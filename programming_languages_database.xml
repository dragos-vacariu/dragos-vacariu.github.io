<?xml version="1.0" encoding="UTF-8"?>

<content>
	<programming_language>
		<name>C</name>
		<description>
			C is a general-purpose computer programming language.<br></br><br></br>
			It was created in the 1970s by Dennis Ritchie, and remains very widely used and 
			influential. <br></br><br></br>
			By design, C's features cleanly reflect the 
			capabilities of the targeted CPUs. It has found lasting use in operating 
			systems, device drivers, and protocol stacks, but its use in application 
			software has been decreasing. <br></br><br></br>
			C is commonly used on computer architectures that range from the largest 
			supercomputers to the smallest microcontrollers 
			and embedded systems.
		</description>
		<generic-programming>
			In C Language generic programming can be achieved using:<br></br><br></br>
			Variable argument lists;<br></br>
			Using <code>void *</code> and function pointers to write generic code;<br></br>
			Using libraries to reuse code without copying and recompiling;<br></br>
			Using plugins to get run-time overriding and more;
		</generic-programming>
		<variable-arguments-lists>
			C allows a function call to have a variable number of
			arguments with the variable argument list mechanism.<br></br>
			Use ellipsis <code>...</code> to denote a variable number of arguments to
			the compiler. the ellipsis can only occur at the end of an
			argument list.<br></br><br></br>
			Here are some standard function calls that use variable
			argument lists:<br></br><br></br>
			<code>int printf(const char *format, ...);</code><br></br>
			<code>int scanf(const char *format, ...);</code><br></br>
			<code>int execlp(const char *file, const char *arg, ...);</code><br></br>
		</variable-arguments-lists>
		<simple-data-types>
			<code>short int</code> - has value range <red>[-32,768 to 32,767]</red> - format specifier <code>%hd</code> - 
			occupies 2 bytes memory
			<br></br><br></br>
			<code>unsigned short int</code> - has value range <red>[-32,768 to 65,535]</red> - format specifier <code>%hu</code> - 
			occupies 2 bytes memory
			<br></br><br></br>
			<code>unsigned int</code> - has value range <red>[0 to 4,294,967,295]</red> - format specifier <code>%u</code> - 
			occupies 4 bytes memory
			<br></br><br></br>
			<code>int</code> - has value range <red>[-2,147,483,648 to 2,147,483,647]</red> - format specifier <code>%d</code> - 
			occupies 4 bytes memory
			<br></br><br></br>
			<code>long int</code> - has value range <red>[-2,147,483,648 to 2,147,483,647]</red> - 
			format specifier <code>%ld</code> - occupies 4 bytes memory
			<br></br><br></br>
			<code>unsigned long int</code> - has value range <red>[0 to 4,294,967,295 ]</red> - format specifier <code>%lu</code> -
			occupies 4 bytes memory
			<br></br><br></br>
			<code>long long int</code> - has value range <red>[-(2^63) to (2^63)-1]</red> - format specifier <code>%lld</code> - 
			occupies 8 bytes memory
			<br></br><br></br>
			<code>unsigned long long int</code> - has value range <red>[-(2^63) to 18,446,744,073,709,551,615 ]</red> - 
			format specifier <code>%llu</code>  - occupies 8 bytes memory
			<br></br><br></br>
			<code>signed char</code> - has value range <red>[-128 to 127]</red> - format specifier <code>%c</code> - occupies 1 
			byte memory
			<br></br><br></br>
			<code>unsigned char</code> - has value range <red>[0 to 255]</red> - format specifier <code>%c</code> - occupies 1 
			byte memory
			<br></br><br></br>
			<code>float</code> - has value range <red>[1.2E-38 to 3.4E+38]</red> - format specifier <code>%f</code> - occupies 
			4 byte memory
			<br></br><br></br>
			<code>double</code> - has value range <red>[1.7E-308 to 1.7E+308]</red> - format specifier <code>%lf</code> - 
			occupies 8 byte memory
			<br></br><br></br>
			<code>long double</code> - has value range <red>[3.4E-4932 to 1.1E+4932]</red> - format specifier <code>%Lf</code>  - 
			occupies 16 byte memory
		</simple-data-types>
		<complex-data-types>
			Data types that are derived from fundamental data types:<br></br><br></br>
			<code>bool type</code><br></br><br></br>
			<code>Enumerated type / Enums</code> - An enum is a special type that represents a group of constants (unchangeable values).<br></br><br></br>
			<code>Complex types</code> - The C programming language, as of C99, supports complex number math with the three built-in types 
			<code>double _Complex</code>, <code>float _Complex</code>, and <code>long double _Complex</code> . When the header <code>complex.h</code> is 
			included, the three complex number types are also accessible as double complex, 
			float complex, long double complex.<br></br><br></br>
			<code>Arrays</code>: A collection of elements of the same data type. Array in C can be defined as a method of 
			clubbing multiple entities of similar type into a larger group. These entities or elements 
			can be of int, float, char, or double data type or can be of user-defined data types too 
			like structures.<br></br><br></br>
			<code>Pointers</code>: A variable that stores the memory address of another variable. The size of a pointer in C 
			programming language varies depending on factors such as the operating system and CPU 
			architecture. Typically, on a 32-bit computer system, the size of pointer is 4 bytes, 
			while on a 64-bit computer system, it is 8 bytes.<br></br><br></br>
			<code>Structures</code>: A collection of variables of different data types grouped 
			together under a single name. <br></br><br></br>
			<code>Unions</code>: A special type of structure that can store only one value at a time.<br></br><br></br>
			<code>Typedefs</code>: A way to create a new name for an existing data type to improve code 
			readability and maintainability.<br></br><br></br>
			<code>void</code> - used to indicate an empty data type, usually used with pointers.<br></br>
		</complex-data-types>
		<loops>
			In computer programming, a loop is a sequence of instruction s that is 
			continually repeated until a certain condition is reached. 
			Typically, a certain process is done, such as getting an item of data 
			and changing it, and then some condition is checked such as whether a 
			counter has reached a prescribed number.<br></br><br></br>
			<br></br><br></br>
			For, while, do-while loops:<br></br><br></br>
			
			<red>While loop does not depend upon the number of iterations. In for loop the number 
			of iterations was previously known to us but in the While loop, the execution 
			is terminated on the basis of the test condition. If the test condition will 
			become false then it will break from the while loop else body will be executed.<br></br><br></br>
			<br></br><br></br></red>	
			
			<green>In for loop, a loop variable is used to control the loop. Firstly we initialize 
			the loop variable with some value, then check its test condition. If the 
			statement is true then control will move to the body and the body of for 
			loop will be executed. Steps will be repeated till the exit condition 
			becomes true. If the test condition will be false then it will stop.
			<br></br><br></br>
			
			Initialization Expression: In this expression, we assign a loop variable 
			or loop counter to some value. for example: <code>int i=1;</code>
			Test Expression: In this expression, test conditions are performed. 
			If the condition evaluates to true then the loop body will be executed and 
			then an update of the loop variable is done. If the test expression becomes 
			false then the control will exit from the loop. for example, <code>counter&lt;5;</code>
			<br></br><br></br>
			
			Update Expression: After execution of the loop body loop variable is updated 
			by some value it could be incremented, decremented, multiplied, or divided by 
			any value.<br></br><br></br></green>
			
			<blue><br></br><br></br>			
			The do-while loop is similar to a while loop but the only difference 
			lies in the do-while loop test condition which is tested at the end of 
			the body. In the do-while loop, the loop body will execute at least once 
			irrespective of the test condition.<br></br><br></br></blue>
<code>
/*While loop syntax: */
int counter = 0;
while(counter &lt; 5)
{
	/*code goes here*/
	 counter++;
}

/*For loop syntax: */
for(int counter = 0; counter &lt; 5; counter++)<br></br>
{
	/*code goes here*/
	 counter++;
}

/*Do while loop syntax: */
do
{
	/*code goes here*/
	 counter++;
}
while(counter &lt; 5)
</code>
		</loops>
		<collections>
			<code>Arrays</code>: Are collections of elements of the same data type with fixed size. 
			Once the array is defined its size cannot be changed.<br></br><br></br>
			
			The <code>linked list</code> is a complex data type, which consists of a structure with at least 2 elements: value and pointer
			to the next element. Memory will be allocated dynamically for each element added to the list. The main benefit of a linked-list
			consists in the possibility of adding a variable number of elements, being able to delete or add an element without making copies
			or exchanges, but only by changing the addresses of the assigned pointers for the next / previous element.
			<br></br><br></br>
			
<code>
/*Declaring arrays and initializing arrays*/

int arr[5];
int array_initialized[7] = [1,2,3,4,5,6,7];
float array_floats[3] = [2.0f, 3.0f, 2.11f];

/*---------------------------------------------*/

//Declaring and initializing a Linked List

//Linked list definition:
struct LinkedList{
	int value; // this will store the value
	struct LinkedList * previous; // this will store the address of the previous block of memory
	struct LinkedList * next; // this will store the address of the next block of memory
};

struct LinkedList* list = NULL; // creating a linked list

int counter = 0;
while(counter &lt; 10)
{
	if(list == NULL) // if this is the first element to be introduced on the linked list
	{
		list = (struct LinkedList* )malloc(sizeof(struct LinkedList)); // allocate memory.
		list->value = counter; // add value
		list->previous = NULL; // there is no previous element.
		list->next = NULL; // we don't know if there will be a next element.
	}

	else //enter here after the first element was added.
	{

		list->next = (struct LinkedList* ) malloc(sizeof(struct LinkedList)); // allocate space for the next element
		list->next->previous = list; // we're still on the previous element, so assign the link to the next element.previous
		list = list->next; // next element become current element
		list->value = counter; // add value
		list->next = NULL;  // we don't know if there will be a next element.
	}
}

//printing the linked list
while(list != NULL) // list is currently pointing to the last element. So we will display it from last to first.
{
	printf("%d ", list->value);
	list = list->previous; // go to the previous
}

</code>
		</collections>
		<collection-methods>There are no built in functions for working with collections.</collection-methods>
		<dynamic-memory-allocation>
		Dynamic memory is allocated from the heap using some standard library functions. 
		The two dynamic memory key functions are malloc() and free(). 
		The malloc() function takes a single parameter, which is the size of the requested memory 
		area in bytes. It returns a pointer to the allocated memory.
		
		C malloc() method<br></br><br></br>
		The “malloc” or “memory allocation” method in C is used to dynamically allocate a single 
		large block of memory with the specified size. It returns a pointer of type void which 
		can be cast into a pointer of any form. It doesn’t Initialize memory at execution time 
		so that it has initialized each block with the default garbage value initially. <br></br><br></br>
<code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;conio.h&gt;

int main()
{
	int *A;
	int i;
	
	/*
	Prototype: void *malloc(size_t size);
	*/

	A=(int *)malloc(20*sizeof(int)); // malloc return a void pointer that needs to be converted
	//into a pointer to however the type of the variable that uses it has. (int *) - is the type of pointer A
	//20 = the number of memory cells allocated;
	
	for (i=0;i&lt;20;i++)
		printf("A[%d]=%d\n", i, A[i]); //the value in each memory cell can be anything
	free(A);
}

</code>
			Calloc function allocates the requested memory and returns a pointer to it similarly to malloc. 
			The Malloc () and calloc() functions differ in how the functions are used when allocating 
			memory at runtime. The Malloc () function only returns the starting address, it doesn't 
			zero it. On the other hand, the calloc() function returns the starting address, zeroing it.
<code>

/*Prototype void *calloc(size_t nitems, size_t size)*/

A=(int *)calloc(20, sizeof(int)); //calloc does the same as malloc while initializing all elements to 0:
	
for (i=0;i&lt;20;i++)
	printf("A[%d]=%d\n", i ,A[i]); //the value in each memory cell is 0
	
free(A); //free is used to free the allocated memory. There is no delete() in C language.
	
</code>
		
		</dynamic-memory-allocation>
		<read-from-file>
		C programming language supports four pre-defined functions to read contents from a file, defined in stdio.h header file:
		<br></br><br></br>
		fgetc()– This function is used to read a single character from the file.<br></br>
		fgets()– This function is used to read strings from files.<br></br>
		fscanf()– This function is used to read formatted input from a file.<br></br>
		fread()– This function is used to read the block of raw bytes from files. This is used 
		to read binary files.
		<br></br><br></br>
		To open a file use: fopen(filename, mode);
		<br></br><br></br>
		Where:<br></br><br></br>
		filename	The name of the actual file you want to open (or create), like filename.txt<br></br>
		mode	A single character, which represents what you want to do with the file 
		(read, write or append):<br></br><br></br>
		w - Writes to a file<br></br>
		a - Appends new data to a file<br></br>
		r - Reads from a file<br></br>
	
<code>

/*Read file char by char*/

FILE* ptr; FILE is basically a data type, and we need to create a pointer variable to work with it 
char ch;

// Opening file in reading mode
ptr = fopen("test.txt", "r");

if (NULL == ptr) {
	printf("file can't be opened \n");
}

printf("content of this file are \n");

// Printing what is written in file
// character by character using loop.
do {
	ch = fgetc(ptr);
	printf("%c", ch);

	// Checking if character is not EOF.
	// If it is EOF stop reading.
} while (ch != EOF); 


//---------------------------------

/*

Alternatively feof function can be used
feof() function takes file pointer as argument and returns true if pointer reaches the end of the file. 

while (!feof(ptr)) {
	ch = fgetc(ptr);
	printf("%c", ch);
}

*/
//---------------------------------

//Reading whole content of the file as string

//fgets() reads one string at a time from the file. fgets() returns a string if it is
//successfully read by function or returns NULL if can not read. 

//Prototype: char * fgets(char *str, int size, FILE * ptr);

while (fgets(str, 50, ptr) != NULL) {
	printf("%s", str);
}

//---------------------------------


/*
fscanf() reads formatted input from a stream.

Approach:

fscanf reads formatted data from the files and stores it in variables.
The data in the buffer is printed on the console till the end of the file is reached.

*/

char buf[100];
while (fscanf(ptr, "%*s %*s %s ", buf) == 1)
	printf("%s\n", buf);

</code>
		
		</read-from-file>
		<write-to-file>
		To create a file, or write to a file you can use the w mode inside the fopen() function.<br></br>
		Function Prototype: fopen(filename, mode);
		<br></br><br></br>
		Where:<br></br><br></br>
		filename	The name of the actual file you want to open (or create), like filename.txt<br></br>
		mode	A single character, which represents what you want to do with the file 
		(read, write or append):<br></br><br></br>
		w - Writes to a file<br></br>
		a - Appends new data to a file<br></br>
		r - Reads from a file<br></br><br></br>
		
		The w mode means that the file is opened for writing. To insert content to it, you can 
		use the fprintf() function and add the pointer variable (fptr in our example) and some text:
		<br></br><br></br>
		If you write to a file that already exists, the old content is deleted, and the new content 
		is inserted. This is important to know, as you might accidentally erase existing content.
<code>

FILE *fptr; //FILE is basically a data type, and we need to create a pointer variable to work with it 

// Open a file in writing mode
fptr = fopen("filename.txt", "w");

// Write some text to the file using fprintf
fprintf(fptr, "Some text");

// Write some other text to the file fputs
fputs("Line wrote with fputs.", fp); 

// Close the file
fclose(fptr); // this will close the file when we are done with it.

</code>		
		Closing the file:
		<br></br><br></br>
		It is considered as good practice, because it makes sure that:
		<br></br><br></br>
		Changes are saved properly. <br></br>
		Other programs can use the file (if you want). <br></br>
		Clean up unnecessary memory space. <br></br><br></br>
		
		If you want to add content to a file without deleting the old content, 
		you can use the a mode. <br></br>
		The a mode appends content at the end of the file:<br></br>
		
<code>
/*Example*/

FILE *fptr;

// Open a file in append mode
fptr = fopen("filename.txt", "a"); 

/*Just like with the w mode; if the file does not exist, the a mode will create a 
new file with the "appended" content.*/

// Append some text to the file
fprintf(fptr, "\nHi everybody!");

// Close the file
fclose(fptr);

</code>
		</write-to-file>
		<serialization>
		Serialization is the process of converting a data object—a combination of code and data 
		represented within a region of data storage—into a series of bytes that saves the state 
		of the object in an easily transmittable form.<br></br><br></br>
		</serialization>
		<deserialization>
		Deserialization is the process of reconstructing a data structure or object from a series 
		of bytes or a string in order to instantiate the object for consumption. This is the 
		reverse process of serialization, i.e., converting a data structure or object into a 
		series of bytes for storage or transmission across devices.<br></br><br></br>
		</deserialization>
		<enums>
		Enumeration (or enum) is a user defined data type in C. It is mainly used to 
		assign names to integral constants, the names make a program easy to read and maintain.
		<br></br><br></br>
		
<code>
/*Examples*/
//Syntax: enum flag{constant1, constant2, constant3, ....... };

// An example program to demonstrate working
// of enum in C
#include &lt;stdio.h&gt;
 
enum week{Mon, Tue, Wed, Thur, Fri, Sat, Sun};
 
int main()
{
    enum week day;
    day = Wed;
    printf("%d",day);
    return 0;
} 

</code>
		</enums>
		<multi-threading>
		A thread is a single sequence stream within a process. Because threads have some of 
		the properties of processes, they are sometimes called lightweight processes. 
		<br></br><br></br>
		Threads are not independent from each other unlike processes. As a result, 
		threads shares with other threads their code section, data section and OS resources 
		like open files and signals. But, like processes, a thread has its own program 
		counter (PC), a register set, and a stack space. 
		<br></br><br></br>
		Why Multithreading? Threads are popular way to improve application through parallelism. 
		For example, in a browser, multiple tabs can be different threads. MS word uses 
		multiple threads, one thread to format the text, other thread to process inputs, etc. 
		<br></br><br></br>
		Threads operate faster than processes due to following reasons: <br></br>
		1) Thread creation is much faster. <br></br>
		2) Context switching between threads is much faster. <br></br>
		3) Threads can be terminated easily <br></br>
		4) Communication between threads is faster.<br></br>
<code>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt; //Header file for sleep(). man 3 sleep for details. 
#include &lt;pthread.h&gt;
  
// A normal C function that is executed as a thread  
// when its name is specified in pthread_create() 

void *myThreadFun(void *vargp) 
{ 
    sleep(1); 
    printf("Printing GeeksQuiz from Thread \n"); 
    return NULL; 
} 
   
int main() 
{ 
    pthread_t thread_id; 
    printf("Before Thread\n"); 
    pthread_create(&#38;thread_id, NULL, myThreadFun, NULL); 
    pthread_join(thread_id, NULL); 
    printf("After Thread\n"); 
    exit(0); 
}

</code>
		</multi-threading>
		<exception-handling>C does not provide direct support to error handling (or exception handling).</exception-handling>
		<bitwise-operators>
		The &#38; (bitwise AND) in C takes two numbers as operands and does AND on every bit 
		of two numbers. The result of AND is 1 only if both bits are 1.  
		<br></br><br></br>
		The | (bitwise OR) in C takes two numbers as operands and does OR on every bit 
		of two numbers. The result of OR is 1 if any of the two bits is 1. 
		<br></br><br></br>
		The ^ (bitwise XOR) in C takes two numbers as operands and does XOR on every 
		bit of two numbers. The result of XOR is 1 if the two bits are different. 
		<br></br><br></br>
		The &lt;&lt; (left shift) in C takes two numbers, the left shifts the bits of the 
		first operand, and the second operand decides the number of places to shift. 
		<br></br><br></br>
		The &gt;&gt; (right shift) in C takes two numbers, right shifts the bits of the 
		first operand, and the second operand decides the number of places to shift.
		<br></br><br></br>
		The ~ (bitwise NOT) in C takes one number and inverts all bits of it.
		
<code>

// C Program to demonstrate use of bitwise operators
#include &lt;stdio.h&gt;
int main()
{
    // a = 5(00000101), b = 9(00001001)
    unsigned char a = 5, b = 9;
 
    // The result is 00000001
    printf("a = %d, b = %d\n", a, b);
    printf("a &#38; b = %d\n", a &#38; b);
 
    // The result is 00001101
    printf("a|b = %d\n", a | b);
 
    // The result is 00001100
    printf("a^b = %d\n", a ^ b);
 
    // The result is 11111010
    printf("~a = %d\n", a = ~a);
 
    // The result is 00010010
    printf("b&lt;&lt;1 = %d\n", b &lt;&lt; 1);
 
    // The result is 00000100
    printf("b&gt;&gt;1 = %d\n", b &gt;&gt; 1);
 
    return 0;
	
	/*
	a = 5, b = 9
	a&#38;b = 1
	a|b = 13
	a^b = 12
	~a = 250
	b&lt;&lt;1 = 18
	b&gt;&gt;1 = 4
	*/
}

</code>
		The left-shift and right-shift operators should not be used for negative numbers.<br></br>
		The left-shift and right-shift operators are equivalent to multiplication and division by 
		2 respectively.<br></br><br></br>
		
		The bitwise OR of two numbers is just the sum of those two numbers if there is no carry involved, otherwise, you just add their bitwise AND.
		<br></br><br></br>
		Let’s say, we have a=5(101) and b=2(010), since there is no carry involved, their sum is 
		just a|b. Now, if we change ‘a’ to 6 which is 110 in binary, their sum would change 
		to a|b + a&#38;b since there is a carry involved. 
		<br></br><br></br>
		The bitwise XOR operator is the most useful operator from a technical interview perspective.
		<br></br><br></br>
		It is used in many problems. A simple example could be “Given a set of numbers where all 
		elements occur an even number of times except one number, find the odd occurring number” 
		This problem can be efficiently solved by doing XOR to all numbers. 
		<br></br><br></br>
		
		The & operator can be used to quickly check if a number is odd or even.<br></br>

		The value of the expression (x & 1) would be non-zero only if x is odd, otherwise, 
		the value would be zero. <br></br><br></br>
		
		The ~ operator should be used carefully.
		<br></br><br></br>
		The result of the ~ operator on a small number can be a big number if the result 
		is stored in an unsigned variable. The result may be a negative number if the result 
		is stored in a signed variable (assuming that the negative numbers are stored in 2’s 
		complement form where the leftmost bit is the sign bit).<br></br>
		</bitwise-operators>
		<default-parameters>Not present</default-parameters>
		<interfaces>
		In C, an interface is a set of function declarations without any implementation 
		details. It defines a contract that concrete implementations must adhere to by providing 
		definitions for all the functions declared in the interface.
<code>

// Declare an interface for a shape
struct shape_interface {
  // Function pointers for the interface functions
  double (*area)(void*);
  double (*perimeter)(void*);
}; 

/*
In OOP there are classes that store to both variables and methods of an object.

In C we can have structs that store variables and structs that hold function pointers to defined behaviours
Both of them are close to forming a class.

*/

</code>
		</interfaces>
		<macros>
		Macros in C are powerful tools that allow developers to define reusable code snippets. 
		They are defined using preprocessor directives and primarily used for code substitution 
		and generation. Macros provide a convenient way to write concise and efficient code, 
		improving the readability and maintainability of C programs.<br></br>
<code>

// C program to illustrate macros
#include &lt;stdio.h&gt;
 
// Macro definition
#define AREA(l, b) (l * b)
 
// Driver Code
int main()
{
    // Given lengths l1 and l2
    int l1 = 10, l2 = 5, area;
 
    // Find the area using macros
    area = AREA(l1, l2);
 
    // Print the area
    printf("Area of rectangle"
           " is: %d",
           area);
 
    return 0;
}
</code>		
		<br></br><br></br>
		Object-Like Macros
		An object-like macro is a simple identifier that will be replaced by a code fragment. 
		It is called object-like because it looks like an object in code that uses it. It is 
		popularly used to replace a symbolic name with a numerical/variable represented 
		as a constant.<br></br>
<code>
//Chain Macros
  
// Macro definition
#define INSTAGRAM FOLLOWERS
#define FOLLOWERS 138 

/*
Both macros INSTAGRAM and FOLLOWERS have same value - 138
*/


Multi-line macros
#include &lt;stdio.h&gt;
 
// Multi-line Macro definition
#define ELE 1, \
            2, \
            3
 
// Driver Code
int main()
{
 
    // Array arr[] with elements
    // defined in macros
    int arr[] = { ELE };
 
    // Print elements
    printf("Elements of Array are:\n");
 
    for (int i = 0; i &lt; 3; i++) {
        printf("%d  ", arr[i]);
    }
    return 0;
}
  
</code>
		</macros>
		<defines>
		In C programming, #define is a preprocessor directive that is used to define macros. 
		The macros are the identifiers defined by #define which are replaced by their value before 
		compilation. We can define constants and functions like macros using #define.
		</defines>
		<random-generators>
		The rand() function returns the random integers whose range from 0 to RAND_MAX. 
		The RAND_MAX is a symbolic constant that defines in stdlib.h header file, whose value 
		is greater but less than 32767 depending on the C libraries.<br></br><br></br>
<code>
#include &lt;stdio.h&gt;    
#include &lt;conio.h&gt;  
#include &lt;stdlib.h&gt;  
void main()  
{     
    // use rand() function to generate the number  
    printf (" The random number is: %d", rand());  
    printf ("\n The random number is: %d", rand());  
      
    printf (" \n The random number is: %d", rand());  
    printf ("\n The random number is: %d", rand());  
    getch();  
}  		

</code>
		The srand() function is a C library function that determines the initial point to generate 
		different series of pseudo-random numbers. A srand() function cannot be used without 
		using a rand() function. The srand() function is required to set the value of the seed 
		only once in a program to generate the different results of random integers before 
		calling the rand() function. <br></br><br></br>
<code>
#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;time.h&gt;  // use time.h header file to use time  
      
int main()  
{  
    int num, i;  
    time_t t1; // declare time variable  
      
    printf(" Enter a number to set the limit for a random number \n");  
    scanf (" %d", &#38;num);  
      
    /* define the random number generator */  
    srand ( (unsigned) time (&#38;t1)); // pass the srand() parameter  
    printf("\n"); // print the space
    /* generate random number between 0 to 50 */  
}  
</code>
		</random-generators>
		<command-line-arguments>Not present</command-line-arguments>
		<ternary-operator>Not present</ternary-operator>
		<modular-programming>Not present</modular-programming>
		<string-methods>Not present</string-methods>
		<datatype-conversions>Not present</datatype-conversions>
		<optional-parameters>Not present</optional-parameters>
		<decorators>Not present</decorators>
		<operators>Not present</operators>
		<pre-post-incrementation>Not present</pre-post-incrementation>
		<regular-expressions>Not present</regular-expressions>
	</programming_language>
	
	<programming_language>
		<name>C++</name>
		<description>
			C++ is a high-level, general-purpose programming language created by 
			Danish computer scientist Bjarne Stroustrup. <br></br><br></br>
			First released in 1985 as an extension of the C programming language, 
			it has since expanded significantly over time; as of 1997, C++ has object-oriented, 
			generic, and functional features, in addition to facilities for low-level memory 
			manipulation for making things like microcomputers or to make operating systems 
			like Linux or Windows. <br></br><br></br>
			
			It is almost always implemented as a compiled language, 
			and many vendors provide C++ compilers, including the Free Software Foundation, 
			LLVM, Microsoft, Intel, Embarcadero, Oracle, and IBM.
		</description>
		<oop>C++ OOP</oop>
		<encapsulation>Not present</encapsulation>
		<polymorphism>Not present</polymorphism>
		<inheritance>Not present</inheritance>
		<abstraction>Not present</abstraction>
		<generic-programming>Not present</generic-programming>
		<variable-arguments-lists>Not present</variable-arguments-lists>
		<simple-data-types>Not present</simple-data-types>
		<complex-data-types>Not present</complex-data-types>
		<loops>Not present</loops>
		<collections>Not present</collections>
		<collection-methods>Not present</collection-methods>
		<dynamic-memory-allocation>Not present</dynamic-memory-allocation>
		<read-from-file>Not present</read-from-file>
		<write-to-file>Not present</write-to-file>
		<serialization>Not present</serialization>
		<deserialization>Not present</deserialization>
		<constructors>Not present</constructors>
		<instantiation>Not present</instantiation>
		<destructors>Not present</destructors>
		<function-overloading>Not present</function-overloading>
		<operator-overloading>Not present</operator-overloading>
		<enums>Not present</enums>
		<multi-threading>Not present</multi-threading>
		<namespaces>
		A namespace is a feature added in C++ and is not present in C. A namespace is a 
		declarative region that provides a scope to the identifiers (names of functions, 
		variables or other user-defined data types) inside it. Multiple namespace blocks 
		with the same name are allowed.
		</namespaces>
		<exception-handling>Not present</exception-handling>
		<bitwise-operators>Not present</bitwise-operators>
		<default-parameters>Not present</default-parameters>
		<interfaces>Not present</interfaces>
		<macros>Not present</macros>
		<defines>Not present</defines>
		<random-generators>Not present</random-generators>
		<command-line-arguments>Not present</command-line-arguments>
		<ternary-operator>Not present</ternary-operator>
		<modular-programming>Not present</modular-programming>
		<string-methods>Not present</string-methods>
		<datatype-conversions>Not present</datatype-conversions>
		<optional-parameters>Not present</optional-parameters>
		<partial-classes>Not present</partial-classes>
		<decorators>Not present</decorators>
		<operators>Not present</operators>
		<pre-post-incrementation>Not present</pre-post-incrementation>
		<datatypes-sizing>Not present</datatypes-sizing>
		<regular-expressions>Not present</regular-expressions>
	</programming_language>
	
	<programming_language>
		<name>C#</name>
		<description>
			C# is a general-purpose high-level programming language supporting multiple 
			paradigms. C# encompasses static typing, strong typing, lexically scoped, 
			imperative, declarative, functional, generic, object-oriented (class-based), 
			and component-oriented programming disciplines. <br></br><br></br>

			The C# programming language was designed by Anders Hejlsberg from Microsoft in 
			2000. <br></br><br></br>

			Microsoft introduced C# along with .NET Framework and Visual Studio, both of 
			which were closed-source. At the time, Microsoft had no open-source products. 
			<br></br><br></br>

			Four years later, in 2004, a free and open-source project called Mono began, 
			providing a cross-platform compiler and runtime environment for the C# 
			programming language. <br></br><br></br>

			A decade later, Microsoft released Visual Studio Code (code editor), 
			Roslyn (compiler), and the unified .NET platform (software framework), 
			all of which support C# and are free, open-source, and cross-platform. 
			Mono also joined Microsoft but was not merged into .NET.<br></br><br></br>
		</description>
		<oop>C# OOP</oop>
		<encapsulation>Not present</encapsulation>
		<polymorphism>Not present</polymorphism>
		<inheritance>Not present</inheritance>
		<abstraction>Not present</abstraction>
		<generic-programming>Not present</generic-programming>
		<variable-arguments-lists>Not present</variable-arguments-lists>
		<simple-data-types>Not present</simple-data-types>
		<complex-data-types>Not present</complex-data-types>
		<loops>Not present</loops>
		<collections>Not present</collections>
		<collection-methods>Not present</collection-methods>
		<dynamic-memory-allocation>Not present</dynamic-memory-allocation>
		<read-from-file>Not present</read-from-file>
		<write-to-file>Not present</write-to-file>
		<serialization>Not present</serialization>
		<deserialization>Not present</deserialization>
		<constructors>Not present</constructors>
		<instantiation>Not present</instantiation>
		<destructors>Not present</destructors>
		<function-overloading>Not present</function-overloading>
		<operator-overloading>Not present</operator-overloading>
		<enums>Not present</enums>
		<multi-threading>Not present</multi-threading>
		<namespaces>Not present</namespaces>
		<exception-handling>Not present</exception-handling>
		<bitwise-operators>Not present</bitwise-operators>
		<default-parameters>Not present</default-parameters>
		<interfaces>Not present</interfaces>
		<macros>Not present</macros>
		<defines>Not present</defines>
		<random-generators>Not present</random-generators>
		<command-line-arguments>Not present</command-line-arguments>
		<ternary-operator>Not present</ternary-operator>
		<modular-programming>Not present</modular-programming>
		<string-methods>Not present</string-methods>
		<datatype-conversions>Not present</datatype-conversions>
		<optional-parameters>Not present</optional-parameters>
		<partial-classes>Not present</partial-classes>
		<decorators>Not present</decorators>
		<operators>Not present</operators>
		<pre-post-incrementation>Not present</pre-post-incrementation>
		<datatypes-sizing>Not present</datatypes-sizing>
		<regular-expressions>Not present</regular-expressions>
	</programming_language>
	
	<programming_language>
		<name>JavaScript</name>
		<description>
			JavaScript often abbreviated as JS, is a programming language and core 
			technology of the Web, alongside HTML and CSS. 99% of websites use JavaScript 
			on the client side for webpage behavior.<br></br><br></br>

			Web browsers have a dedicated JavaScript engine that executes the client code. 
			These engines are also utilized in some servers and a variety of apps. The most 
			popular runtime system for non-browser usage is Node.js.<br></br><br></br>

			JavaScript is a high-level, often just-in-time compiled language that conforms 
			to the ECMAScript standard. It has dynamic typing, prototype-based 
			object-orientation, and first-class functions. It is multi-paradigm, 
			supporting event-driven, functional, and imperative programming styles. 
			It has application programming interfaces (APIs) for working with text, dates, 
			regular expressions, standard data structures, and the Document Object Model (DOM).
		</description>
		<oop>
		</oop>
		<encapsulation>Not present</encapsulation>
		<polymorphism>Not present</polymorphism>
		<inheritance>Not present</inheritance>
		<abstraction>Not present</abstraction>
		<generic-programming>Not present</generic-programming>
		<variable-arguments-lists>Not present</variable-arguments-lists>
		<simple-data-types>Not present</simple-data-types>
		<complex-data-types>Not present</complex-data-types>
		<loops>Not present</loops>
		<collections>Not present</collections>
		<collection-methods>Not present</collection-methods>
		<dynamic-memory-allocation>Not present</dynamic-memory-allocation>
		<read-from-file>Not present</read-from-file>
		<write-to-file>Not present</write-to-file>
		<serialization>Not present</serialization>
		<deserialization>Not present</deserialization>
		<constructors>Not present</constructors>
		<instantiation>Not present</instantiation>
		<destructors>Not present</destructors>
		<function-overloading>Not present</function-overloading>
		<operator-overloading>Not present</operator-overloading>
		<enums>Not present</enums>
		<multi-threading>Not present</multi-threading>
		<namespaces>Not present</namespaces>
		<exception-handling>Not present</exception-handling>
		<bitwise-operators>Not present</bitwise-operators>
		<default-parameters>Not present</default-parameters>
		<interfaces>Not present</interfaces>
		<macros>Not present</macros>
		<defines>Not present</defines>
		<random-generators>Not present</random-generators>
		<command-line-arguments>Not present</command-line-arguments>
		<ternary-operator>Not present</ternary-operator>
		<modular-programming>Not present</modular-programming>
		<string-methods>Not present</string-methods>
		<datatype-conversions>Not present</datatype-conversions>
		<optional-parameters>Not present</optional-parameters>
		<partial-classes>Not present</partial-classes>
		<decorators>Not present</decorators>
		<operators>Not present</operators>
		<pre-post-incrementation>Not present</pre-post-incrementation>
		<datatypes-sizing>Not present</datatypes-sizing>
		<regular-expressions>Not present</regular-expressions>
	</programming_language>
	
	<programming_language>
		<name>Java</name>
		<description>
			Java is a high-level, class-based, object-oriented programming language that is 
			designed to have as few implementation dependencies as possible.<br></br><br></br>
			It is a general-purpose programming language intended to let programmers write once, 
			run anywhere meaning that compiled Java code can run on all platforms that support 
			Java without the need to recompile. <br></br><br></br>
			
			Java applications are typically compiled to bytecode that can run on any 
			Java virtual machine (JVM) regardless of the 
			underlying computer architecture. The syntax of Java is similar to C and C++, 
			but has fewer low-level facilities than either of them. The Java runtime provides 
			dynamic capabilities (such as reflection and runtime code modification) that are 
			typically not available in traditional compiled languages.
		</description>
		<oop>Java OOP</oop>
		<encapsulation>Not present</encapsulation>
		<polymorphism>Not present</polymorphism>
		<inheritance>Not present</inheritance>
		<abstraction>Not present</abstraction>
		<generic-programming>Not present</generic-programming>
		<variable-arguments-lists>Not present</variable-arguments-lists>
		<simple-data-types>Not present</simple-data-types>
		<complex-data-types>Not present</complex-data-types>
		<loops>Not present</loops>
		<collections>Not present</collections>
		<collection-methods>Not present</collection-methods>
		<dynamic-memory-allocation>Not present</dynamic-memory-allocation>
		<read-from-file>Not present</read-from-file>
		<write-to-file>Not present</write-to-file>
		<serialization>Not present</serialization>
		<deserialization>Not present</deserialization>
		<constructors>Not present</constructors>
		<instantiation>Not present</instantiation>
		<destructors>Not present</destructors>
		<function-overloading>Not present</function-overloading>
		<operator-overloading>Not present</operator-overloading>
		<enums>Not present</enums>
		<multi-threading>Not present</multi-threading>
		<namespaces>Not present</namespaces>
		<exception-handling>Not present</exception-handling>
		<bitwise-operators>Not present</bitwise-operators>
		<default-parameters>Not present</default-parameters>
		<interfaces>Not present</interfaces>
		<macros>Not present</macros>
		<defines>Not present</defines>
		<random-generators>Not present</random-generators>
		<command-line-arguments>Not present</command-line-arguments>
		<ternary-operator>Not present</ternary-operator>
		<modular-programming>Not present</modular-programming>
		<string-methods>Not present</string-methods>
		<datatype-conversions>Not present</datatype-conversions>
		<optional-parameters>Not present</optional-parameters>
		<partial-classes>Not present</partial-classes>
		<decorators>Not present</decorators>
		<operators>Not present</operators>
		<pre-post-incrementation>Not present</pre-post-incrementation>
		<datatypes-sizing>Not present</datatypes-sizing>
		<regular-expressions>Not present</regular-expressions>
	</programming_language>
	
	<programming_language>
		<name>Python</name>
		<description>
			Python is a high-level, general-purpose programming language. Its design 
			philosophy emphasizes code readability with the use of significant indentation.
			<br></br><br></br>

			Python is dynamically typed and garbage-collected. It supports multiple 
			programming paradigms, including structured (particularly procedural), 
			object-oriented and functional programming. It is often described as a 
			"batteries included" language due to its comprehensive standard library.
		
		</description>
		<oop>Python OOP</oop>
		<encapsulation>Not present</encapsulation>
		<polymorphism>Not present</polymorphism>
		<inheritance>Not present</inheritance>
		<abstraction>Not present</abstraction>
		<generic-programming>Not present</generic-programming>
		<variable-arguments-lists>Not present</variable-arguments-lists>
		<simple-data-types>Not present</simple-data-types>
		<complex-data-types>Not present</complex-data-types>
		<loops>Not present</loops>
		<collections>Not present</collections>
		<collection-methods>Not present</collection-methods>
		<dynamic-memory-allocation>Not present</dynamic-memory-allocation>
		<read-from-file>Not present</read-from-file>
		<write-to-file>Not present</write-to-file>
		<serialization>Not present</serialization>
		<deserialization>Not present</deserialization>
		<constructors>Not present</constructors>
		<instantiation>Not present</instantiation>
		<destructors>Not present</destructors>
		<function-overloading>Not present</function-overloading>
		<operator-overloading>Not present</operator-overloading>
		<enums>Not present</enums>
		<multi-threading>Not present</multi-threading>
		<namespaces>Not present</namespaces>
		<exception-handling>Not present</exception-handling>
		<bitwise-operators>Not present</bitwise-operators>
		<default-parameters>Not present</default-parameters>
		<interfaces>Not present</interfaces>
		<macros>Not present</macros>
		<defines>Not present</defines>
		<random-generators>Not present</random-generators>
		<command-line-arguments>Not present</command-line-arguments>
		<ternary-operator>Not present</ternary-operator>
		<modular-programming>Not present</modular-programming>
		<string-methods>Not present</string-methods>
		<datatype-conversions>Not present</datatype-conversions>
		<optional-parameters>Not present</optional-parameters>
		<partial-classes>Not present</partial-classes>
		<decorators>Not present</decorators>
		<operators>Not present</operators>
		<pre-post-incrementation>Not present</pre-post-incrementation>
		<datatypes-sizing>Not present</datatypes-sizing>
		<regular-expressions>Not present</regular-expressions>
	</programming_language>
	
</content>
