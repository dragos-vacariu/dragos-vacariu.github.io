<?xml version="1.0" encoding="UTF-8"?>

<content>
    <programming_language>
        <name>General-Programming-Knowledge</name>
        <oop>
            OOP stands for <red>Object-Oriented Programming</red>.
            <br></br><br></br>
            <blue>Procedural programming</blue> is about writing <red>procedures</red> or <red>functions</red> 
            that perform operations on the <red>data</red>, 
            while <blue>object-oriented programming</blue> is about creating objects that contain both 
            <red>data</red> and <red>functions</red>.
            <br></br><br></br>
            <green>
            Object-oriented programming has several advantages over procedural programming:
            </green>
            <br></br><br></br>
            <blue>
            OOP is faster and easier to execute;<br></br>
            OOP provides a clear structure for the programs;<br></br>
            OOP helps to keep the code <red>DRY "Don't Repeat Yourself"</red>, and makes the code 
            easier to maintain, modify and debug;<br></br>
            OOP makes it possible to create full reusable applications with less code and 
            shorter development time;
            </blue>
            <br></br><br></br>
            <red>
            Tip: The "Don't Repeat Yourself" (DRY) principle is about reducing the repetition 
            of code. <br></br>
            You should extract out the codes that are common for the application, 
            and place them at a single place and reuse them instead of repeating it.
            </red>
            <br></br><br></br>
            <green>Terminology:</green>
            <br></br><br></br>
            <brown>Classes:</brown>
            <br></br><br></br>
            A <red>class</red> is a user-defined prototype for an <red>object</red> that defines a set 
            of <blue>attributes</blue> that 
            characterize any <red>object/instance</red> of the <red>class</red>.
            <br></br><br></br>
            <brown>Attributes:</brown>
            <br></br><br></br>
            The attributes are data members (<red>class variables</red> and 
            <blue>instance variables</blue>) and <red>methods</red>, accessed using the <code>.</code> operator.
            The attributes are also reffered to as: <red>fields/variables</red> and <blue>methods/properties</blue>.
            <br></br><br></br>
            <brown>Class variables:</brown>
            <br></br><br></br>
            A <blue>class</blue> variable is a variable that is shared by all <red>instances</red> 
            of a <red>class</red>.
            <br></br>
            <blue>Class</blue> variables are defined within a <red>class</red> but 
            outside any of any <blue>class method</blue>. 
            <br></br>
            Typically in OOP languages <blue>class variables</blue> are 
            defined using the <blue>static</blue> keyword.
            <br></br>
            <blue>Class variables</blue> are not used as frequently as <red>instance variables</red>.
            <br></br><br></br>
            <brown>Instance variables:</brown>
            <br></br><br></br>
            An <red>instance variable</red> is a <blue>non-static</blue> variable that is defined 
            inside a <red>class</red> and belongs only to the current <red>instance</red> of a 
            <red>class</red>. <red>Instance variables</red>
            can be refered to by using <blue>this</blue> keyword in languages such as: C++, C#, Java,
            JavaScript or by using <blue>self</blue> keyword in Python.
            <br></br><br></br>
            <brown>Data member:</brown>
            <br></br><br></br>
            A data member is a <red>class</red> variable or <blue>instance</blue> variable that 
            holds data associated 
            with a <red>class</red> and its <blue>objects</blue>.
            <br></br><br></br>
            <brown>Function overloading:</brown>
            <br></br><br></br>
            <blue>Function overloading</blue> is the assignment of more than one behavior to a 
            particular <red>function</red>.
            The operation performed varies by the types of <blue>objects</blue> or arguments involved.
            <br></br><br></br>
            <brown>Instance:</brown>
            <br></br><br></br>
            An <red>instance</red> is an individual <red>object</red> of a certain <red>class</red>. 
            An <red>instance</red> of an <red>object</red> is created
            by involking the <blue>constructor</blue> of the <red>object</red>. 
            The process of creating an <red>object</red> is 
            called
            <red>instanciation</red> or <red>instancing</red>.
            <br></br><br></br>
            <brown>Method:</brown>
            <br></br><br></br>
            A <red>method</red> is another name given to a <red>function</red> that is defined 
            within a <red>class</red> definition. <red>Methods</red>
            can also belong to the <red>class</red> or to the <red>instance</red>.
            <br></br><br></br>
            <brown>Object:</brown>
            <br></br><br></br>
            An <red>instance</red> of the <red>class</red> is also called as an <red>object</red>.
            An <red>object</red> is a data structure that's defined by its <red>class</red>.
            <br></br>
            An <red>object</red> comprises from both data members (<red>class variables</red> 
            and <blue>instance variables</blue>) and <blue>methods</blue>.
            <br></br><br></br>
            <brown>Operator overloading:</brown>
            <br></br><br></br>
            The assignment of more than one <blue>function</blue> to a particular 
            <red>operator</red> is called <blue>operator 
            overloading</blue>. Via <blue>operator overloading</blue>, an <red>operator</red> can be customized
            so that it produces the desired behaviour on <blue>complex data types</blue> such as 
            <red>objects</red>.
            <br></br><br></br>
            <green>Class members vs. Instance members:</green>
            <br></br><br></br>
            A member is either a <red>variable</red> or a <red>method</red>. 
            A <red>method</red> belonging to the <red>class</red> is
            defined in most OOP languages by using the <red>static</red> keyword.
            <br></br><br></br>
            <blue>Class methods</blue> or <blue>variables</blue>
            cannot be reffered to by using <blue>this</blue> or <blue>self</blue> keywords. 
            <br></br><br></br>
            <blue>Class methods</blue> and <blue>variables</blue> can be accessed without an 
            <red>instance</red>
            of the <red>class</red> by using the name of the <red>class</red> followed by the 
            <blue>.</blue> operator.
            <br></br><br></br>
            <blue>Class members</blue> cannot be combined with <red>instance members</red>. 
            Meaning we cannot have a <blue>class method</blue>
            that would access an <red>instance member</red>. 
            <br></br><br></br>
            <blue>Class methods</blue> cannot directly access <red>instance variables</red> 
            and <red>instance methods</red> but the reversed way is possible: 
            <red>instance methods</red> can access <blue>class variables</blue> and 
            <blue>class methods</blue> directly.
            <br></br><br></br>
            <green>OOP Concepts:</green>
            <br></br><br></br>
            Typically an <blue>object-oriented</blue> programming language 
            has <blue>4 fundamental concepts</blue>:
            <br></br><br></br>
            <blue>
            1. Inheritance<br></br>
            2. Polymorphism<br></br>
            3. Encapsulation<br></br>
            4. Abstraction<br></br>
            </blue>
            <br></br>
        </oop>
        <encapsulation>
            The meaning of <red>Encapsulation</red>, is to make sure that <red>"sensitive"</red> data is hidden from 
            users.<br></br><br></br> 
            To achieve this, you must declare <red>class variables/attributes</red> as <code>private</code> 
            (cannot be accessed from outside the class). <br></br><br></br>
            If you want others to <red>read</red> or <red>modify</red> 
            the value of a <code>private</code> member, you can provide <code>public</code> <red>get</red> and 
            <red>set</red> methods.<br></br>
            <br></br>
            <green>
            Conventions:
            </green>
            <br></br><br></br>
            <blue>
            - good programmer use <red>private fields</red> for a <red>class</red>. 
            (A <red>field</red> is a variable declared in the <red>class</red>)
            <br></br>
            - good programmers use at least a <red>constructor</red> for a <red>class</red>. 
            (And that <red>constructor</red> is used to initialize the
            fields.)
            <br></br>
            - good programmers use <red>encapsulation</red> for controling the value 
            that get in or get out from the <red>fields</red>
            <br></br>
            - a <red>method</red> inside a <red>class</red> is also called 
            <red>property</red> of the <red>class</red>, 
            there can be <red>public</red> or <red>private properties</red>
            </blue>
            <br></br><br></br>
            <red>Encapsulation</red> is one of the <blue>4 OOP fundamental concepts</blue>.
            <br></br>
        </encapsulation>
        <polymorphism>
            Polymorphism means <red>"many forms"</red>, and it occurs when we have many 
            <red>classes</red> that are related to each other by <red>inheritance</red>.
            <br></br><br></br>
            <blue>Polymorphism</blue> is the act of creating a collection of different 
            <red>object types</red> which are <red>inherited</red> from the same 
            <red>base class</red>. 
            <br></br><br></br>
            A <blue>polymorphic type</blue> is one whose <red>operations</red> can also be 
            applied to values of some other <red>type</red>, or <red>types</red>. 
            When calling a <red>virtual</red> function from any 
            <red>derived class</red> the <red>overrided method</red> will be invoked not the 
            <blue>original</blue> one.
            <br></br><br></br>
            <green>There are several fundamentally different kinds of polymorphism:</green>
            <br></br><br></br>
            <blue>Ad hoc polymorphism:</blue> when a function has different implementations 
            depending on a <red>limited range</red> of <blue>individually specified types</blue> 
            and combinations. 
            <br></br><br></br>
            <blue>Ad hoc polymorphism:</blue> is supported in many languages using 
            <red>function overloading</red>.
            <br></br><br></br>
            <blue>Parametric polymorphism:</blue> when the code is written without 
            mention of any <red>specific type</red> and thus can be used transparently with any 
            number of <red>new types</red>. 
            In the <red>object-oriented</red> programming community, this is often known as 
            <red>generics</red> or <blue>generic programming</blue>.
            <br></br>
            In the <blue>functional programming</blue> community, 
            this is often shortened to <blue>polymorphism</blue>. 
            <br></br><br></br>
            <blue>Subtyping</blue> (also called <blue>subtype polymorphism</blue> or 
            <blue>inclusion polymorphism</blue>): when a name <blue>denotes instances</blue> of 
            many different <red>classes</red> related by some common <red>superclass</red>.
            <br></br><br></br>
            <blue>Polymorphism</blue> is one of the <red>4 OOP fundamental concepts</red>.
            <br></br>
        </polymorphism>
        <simple-data-types>
            In programming, <blue>data type</blue> refers to the type of value a <blue>variable</blue> 
            as and what type of mathematical, relational or logical <red>operations</red> can be applied 
            without causing an error.
            <br></br><br></br>
            A <blue>data type</blue> is an attribute associated with a piece of 
            data (<blue>variable</blue>) that tells a computer system how to interpret its value.
            <br></br><br></br>
            <green>Data-types in Programming:</green>
            <br></br><br></br>
            <code>short int</code> - has value range <red>[-32,768 to 32,767]</red> - format specifier <code>%hd</code> - 
            occupies <code>2 bytes</code> memory;
            <br></br><br></br>
            <code>unsigned short int</code> - has value range <red>[-32,768 to 65,535]</red> - format specifier <code>%hu</code> - 
            occupies <code>2 bytes</code> memory;
            <br></br><br></br>
            <code>unsigned int</code> - has value range <red>[0 to 4,294,967,295]</red> - format specifier <code>%u</code> - 
            occupies <code>4 bytes</code> memory;
            <br></br><br></br>
            <code>int</code> - has value range <red>[-2,147,483,648 to 2,147,483,647]</red> - format specifier <code>%d</code> - 
            occupies <code>4 bytes</code> memory;
            <br></br><br></br>
            <code>long int</code> - has value range <red>[-2,147,483,648 to 2,147,483,647]</red> - 
            format specifier <code>%ld</code> - occupies <code>4 bytes</code> memory;
            <br></br><br></br>
            <code>unsigned long int</code> - has value range <red>[0 to 4,294,967,295 ]</red> - format specifier <code>%lu</code> -
            occupies <code>4 bytes</code> memory;
            <br></br><br></br>
            <code>long long int</code> - has value range <red>[-(2^63) to (2^63)-1]</red> - format specifier <code>%lld</code> - 
            occupies <code>8 bytes</code> memory;
            <br></br><br></br>
            <code>unsigned long long int</code> - has value range <red>[-(2^63) to 18,446,744,073,709,551,615 ]</red> - 
            format specifier <code>%llu</code>  - occupies <code>8 bytes</code> memory;
            <br></br><br></br>
            <code>signed char</code> - has value range <red>[-128 to 127]</red> - format specifier <code>%c</code> - occupies 
            <code>1 byte</code> memory;
            <br></br><br></br>
            <code>unsigned char</code> - has value range <red>[0 to 255]</red> - format specifier <code>%c</code> - occupies 
            <code>1 byte</code> memory;
            <br></br><br></br>
            <code>float</code> - has value range <red>[1.2E-38 to 3.4E+38]</red> - format specifier <code>%f</code> - occupies 
            <code>4 bytes</code> memory;
            <br></br><br></br>
            <code>double</code> - has value range <red>[1.7E-308 to 1.7E+308]</red> - format specifier <code>%lf</code> - 
            occupies <code>8 bytes</code> memory;
            <br></br><br></br>
            <code>long double</code> - has value range <red>[3.4E-4932 to 1.1E+4932]</red> - format specifier <code>%Lf</code>  - 
            occupies <code>16 bytes</code> memory;
        </simple-data-types>
        <complex-data-types>
            In Programming, a <red>data type</red> is an attribute associated with a 
            piece of <red>data</red> that tells a computer system how to 
            interpret its <blue>value</blue>. <br></br>
            <br></br>
            <green>
                Data types that are derived from fundamental data types:
            </green>
            <br></br><br></br>
            <code>bool type</code> - The bool type is a <red>byte-sized</red> type that can only hold the value true or false.<br></br><br></br>
            <code>Enumerated type / Enums</code> - An <code>enum</code> is a special type that represents a group of constants 
            (unchangeable values).
            <br></br><br></br>
            <code>Arrays</code> - A collection of elements of the same data type. <br></br>
            These entities or elements can be of <code>int</code>, <code>float</code>, <code>char</code>, or <code>double</code> 
            data type or can be of <code>user-defined</code> data types such as    like <code>structures</code>.
            <br></br><br></br>
            <red>
            The size of an array can be calculated by multiplying the <code>data-type * numberOfElements</code> within the array.
            </red>
            <br></br><br></br>
            <code>Pointers</code> - A variable that stores the memory address of another variable. 
            <br></br>
            The size of a pointer varies depending on factors such as the operating system and CPU 
            architecture.<br></br><br></br>
            <red>
            Typically, on a <code>32-bit</code> computer system, the size of pointer is <code>4 bytes</code>,    
            while on a <code>64-bit</code> computer system, it is <code>8 bytes</code>.
            </red>
            <br></br><br></br>
            <code>Structures</code> - A collection of variables of different data types grouped 
            together under a single name. 
            <br></br><br></br>
            <red>
            The size of a <code>struct</code> can be calculated by summing up the size of all the element data-types.
            </red>
            <br></br><br></br>
            <code>Unions</code> - A special type of structure that can store only one value at a time. <br></br><br></br>
            <red>
            The size of the <code>union</code> is equal to the size of the largest element defined within the union.
            </red>
            <br></br><br></br>
            <code>Typedefs</code> - A way to create a new name for an existing data type to improve code 
            readability and maintainability.<br></br><br></br>
            <code>void</code> - It's used to indicate an empty data type, usually used with pointers.<br></br>
        </complex-data-types>
        <loops>
            In computer programming, a <red>loop</red> is a sequence of instructions that is 
            continually repeated until a certain <red>condition</red> is reached. 
            <br></br><br></br>
            Typically, a certain process is done, such as getting an item of data 
            and changing it, and then some <red>condition</red> is checked such as whether a 
            counter has reached a prescribed number.
            <br></br><br></br>
            <green>
            For, while, do-while loops:<br></br><br></br>
            </green>
            <red>While loop</red> does not depend upon the number of iterations. 
            <br></br>
            If the test condition will 
            become <red>false</red> then it will break from the while loop else body will be executed.
            <br></br><br></br>
<code>
/*While loop syntax: */
int counter = 0;
while(counter &lt; 5)
{
    /*code goes here*/
     counter++;
}
</code>
            <br></br>
            <red>For loop</red> uses a loop variable to control the loop. 
            <br></br><br></br>
            Firstly the <red>loop</red> variable is initialized with some value.<br></br>
            Then its test <red>condition</red> is checked. 
            <br></br><br></br>
            If the 
            statement is <red>true</red> then control will move to the body and the body of for 
            loop will be executed. 
            <br></br>
            Steps will be repeated untill the test <red>condition</red> becomes <red>false</red>. 
            <br></br>
            When the test <red>condition</red> will be <red>false</red> the loop will exit.
            <br></br><br></br>
            
            <blue>Initialization Expression</blue>: In this expression, we assign a loop variable 
            or loop counter to some value. <br></br>
            Example: <code>int counter=1;</code>
            <br></br><br></br>
            
            <blue>Test Expression</blue>: In this expression, test conditions are performed.
            <br></br>            
            If the <red>condition</red> evaluates to <red>true</red> then the loop body will be executed and 
            then an update of the loop variable is done. 
            <br></br>
            If the test expression becomes 
            <red>false</red> then the control will exit from the loop. <br></br>
            Example: <code>counter&lt;5;</code>
            <br></br><br></br>
            
            <blue>Update Expression</blue>: After execution of the loop body loop variable is updated 
            by some value. <br></br>
            It could be incremented, decremented, multiplied, or divided by 
            any value. <br></br>
            Example: <code>counter++;</code><br></br><br></br>

<code>
/*For loop syntax: */
for(int counter = 0; counter &lt; 5; counter++)
{
    /*code goes here*/
}
</code>
            <br></br>        
            The <red>do-while loop</red> is similar to a while loop but the only difference 
            lies in the <red>do-while loop</red> test <red>condition</red> which is tested at the end of 
            the body. <br></br>
            In the <red>do-while loop</red>, the loop body will execute at least once 
            irrespective of the test <red>condition</red>.<br></br><br></br>
<code>
/*Do while loop syntax: */
do
{
    /*code goes here*/
     counter++;
}
while(counter &lt; 5)
</code>
        </loops>
        <dynamic-memory-allocation>
            <red>Dynamic memory</red> is allocated from the <red>heap</red> using some standard library functions. 
            The two <red>dynamic memory</red> key functions are <code>malloc()</code> and <code>free()</code>. 
            <br></br><br></br>
            The <code>malloc()</code> function takes a single parameter, which is the size of the requested memory 
            area in bytes. <br></br>
            It returns a pointer of type <red>void</red> which 
            can be cast into a pointer of any form. 
            <br></br><br></br>
            <red>
            It doesn’t initialize the memory at execution time.<br></br>
            So each block will initially have a default garbage value. 
            </red>
            <br></br><br></br>
<code>
//Example of dynamic memory allocation

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;conio.h&gt;

int main()
{
    int *A;
    int i;
    
    /*
    Prototype: void *malloc(size_t size);
    */

    A=(int *)malloc(20*sizeof(int)); 
    // malloc return a void pointer that needs to be converted
    //into a pointer to however the type of the variable that uses it has. 
    //(int *) - is the type of pointer A
    //20 = the number of memory cells allocated;
    
    for (i=0;i&lt;20;i++)
        printf("A[%d]=%d\n", i, A[i]); //the value in each memory cell can be anything
    free(A);
}
</code>
            <red>Calloc</red> function allocates the requested memory and returns a pointer to it similarly to <red>malloc</red>. 
            <br></br><br></br>
            The <code>malloc()</code> and <code>calloc()</code> do differentiate in how the functions are used when allocating 
            memory at runtime. <br></br><br></br>
            The <code>malloc()</code> function only returns the starting address, <red>it doesn't zero it.</red>
            <br></br>            
            On the other hand, the <code>calloc()</code> function returns the starting address, <red>zeroing it.</red>
            <br></br>    
<code>
/*Prototype void *calloc(size_t nitems, size_t size)*/

A=(int *)calloc(20, sizeof(int)); 
//calloc does the same as malloc while initializing all elements to 0:
    
for (i=0;i&lt;20;i++)
    printf("A[%d]=%d\n", i ,A[i]); //the value in each memory cell is 0
    
free(A); 
//free is used to free the allocated memory. 
//There is no delete() in C language.
    
</code>
        </dynamic-memory-allocation>
        <serialization>
            Serialization is the process of converting a <red>data object</red> <blue>(a combination of code and data 
            represented within a region of data storage)</blue> into a series of bytes that saves the state 
            of the object in an easily transmittable form.<br></br><br></br>
        </serialization>
        <deserialization>
            Deserialization is the process of <red>reconstructing a data structure or object</red> from a series 
            of bytes or a string in order to instantiate the object for consumption. 
            <br></br><br></br>
            This is the 
            reverse process of serialization, i.e., converting a <red>data structure</red> or <red>object</red> into a 
            series of bytes for storage or transmission across devices.<br></br>
        </deserialization>
        <enums>
            <red>Enumeration</red> (or <code>enum</code>) is a user defined data type. <br></br>
            It is mainly used to 
            assign names to integral constants, the names make a program easy to read and maintain.
            <br></br><br></br>
        </enums>
        <concurrent-programming>
            <blue>Concurrent Programming</blue> is a technique in which two or more 
            <red>processes</red> start, run in an interleaved fashion through context switching 
            and complete in an overlapping time period by managing access to 
            shared resources e.g. on a <blue>single core</blue> of <red>CPU</red>.
            <br></br><br></br>
            This doesn’t necessarily mean that multiple <red>processes</red> will be running 
            at the same instant – even if the results might make it seem like it.
            <br></br><br></br>
            <blue>Concurrent Programming</blue> is an essential technique for design applications 
            that can execute <red>tasks</red> simultaneously, in order to increasing overall 
            <red>efficiency</red> and <red>responsiveness</red>.
            <br></br><br></br>
            <green>Principles of Concurent Programming:</green>
            <br></br><br></br>
            The are some basic principles and concepts behind <blue>concurrent programming</blue>: 
            <br></br><br></br>
            <blue>Parallelism</blue>: Concurrent programs can run multiple <red>processes</red> or 
            <red>threads</red> simultaneously, 
            utilizing multiple processing units available in today's computer systems.
            <br></br><br></br>
            <blue>Non-determinism</blue>: Due to the unpredictable order of execution, 
            <blue>concurrent programs</blue> can 
            give different results on different runs, making debugging and testing more complex. 
            This concept arises from the uncertain order in which <red>threads</red> 
            or <red>processes</red> access <blue>shared resources</blue> and interact with each other.
            <br></br><br></br>
            <blue>Synchronization</blue>: Concurrent programs use <blue>synchronization mechanisms</blue> 
            to coordinate access to <blue>shared resources</blue> and ensure mutually exclusive 
            access or <blue>resource protection</blue> to prevent data inconsistency and 
            <blue>race conditions</blue>.
            <br></br><br></br>
            <green>Implementation Techniques:</green>
            <br></br><br></br>
            <blue>Concurrent Programming</blue> can be implemented through the use of 
            <red>multithreading</red> and <blue>multiprocessing</blue>.
            <br></br><br></br>
            A <red>thread</red> is a single <blue>sequence stream</blue> within a <red>process</red>.
            <br></br><br></br>
            A <blue>stream</blue> can be thought of as a <red>path</red> or <red>channel</red>, 
            through which the data is flowing in and out of the program.
            <br></br><br></br>
            Because <red>threads</red> have some of the properties of <red>processes</red>, 
            they are sometimes called <blue>lightweight processes</blue>.
            <br></br><br></br>
            <red>Threads</red> are not independent from each other unlike <red>processes</red>. 
            As a result, 
            <red>threads</red> share with other <red>threads</red> their <blue>code section</blue>, 
            <blue>data section</blue> and <blue>OS resources</blue> such as: opened <blue>files</blue> 
            and <blue>signals</blue>.
            <br></br><br></br>
            <blue>Signals</blue> are software generated interrupts that are sent to a <red>process</red> 
            when an event happens.
            <br></br><br></br>
            Similar to <red>processes</red>, a <red>thread</red> has its own <blue>program 
            counter</blue> (PC), a <blue>register set</blue>, and a <blue>stack space</blue>.
            <br></br><br></br>
            The <blue>program counter</blue> (also called <blue>"instruction pointer"</blue>) is 
            part of the hardware; more specifically, it's a <blue>processor register</blue>. 
            The whole purpose of this <blue>register</blue> is 
            to point to the current <blue>instruction</blue> in the memory that is being executed by 
            the <blue>processor</blue>.
            <br></br><br></br>
            A <red>process</red> is the <red>instance</red> of a computer program that is being 
            executed by 
            one or many <red>threads</red>. By <red>multiprocessing</red> a program can be divided 
            into independent <red>processes</red>, which can run individually as 
            <blue>separate programs</blue>. This would allow the possibility to offload/distribute 
            these <red>processes</red> on separate <red>cores</red> which would increase performance.
            <br></br><br></br>
            <green>Understanding threading and processing:</green>
            <br></br><br></br>
            A <red>CPU</red> ( also called a <blue>central processing unit</blue> , <blue>main processor</blue>, 
            or just <blue>processor</blue>) is essentially the brain that processes and carries 
            out instructions. 
            <br></br>
            <red>CPUs</red> come in many different varieties, such as 
            <blue>single-core</blue>, <blue>dual-core</blue>, 
            <blue>quad-core</blue>, and other <blue>multi-core</blue> processors.
            <br></br><br></br>
            <red>Cores</red> are <blue>physical processing units</blue>. The number of <red>cores</red> 
            in a system will determine how many <red>programs</red> and <red>tasks</red> it can 
            execute simultaneously (in parallel). 
            For instance, a <blue>single-core</blue> processor may be able to handle one <red>task</red> at a time. 
            By contrast, a <blue>quad-core</blue> processor could handle up to four 
            simultaneous <red>tasks</red>.
            <br></br><br></br>
            <red>Threads</red> are <blue>virtual sequences</blue> of instructions given to a <red>CPU</red>. 
            A <red>thread</red> is a sequence of instructions given to the <red>CPU</red> by a program 
            or application. The more <red>threads</red> a <red>CPU</red> can execute at once, the more 
            <red>tasks</red> 
            it can complete.
            <blue>Hyperthreading</blue> allows <blue>multi-core processors</blue> to execute two 
            <red>thread</red> concurrently on each <red>core</red>, meaning a 
            <blue>quad-core processor</blue> could execute up to <blue>8 threads</blue> 
            (<blue>2 threads</blue> on each <red>core</red>).
            <br></br><br></br>
            A <red>thread</red> can be seen as a single-handed person performing one <red>task</red> at 
            a time. 
            Even with one <red>thread</red>
            we can run many programs simultaneos from our perspective, but from <red>CPU</red>'s 
            perspective, these <red>tasks</red> are not simultaneos. The <red>CPU</red> has to switch the 
            <red>thread</red>
            between the <red>tasks</red> on every few microseconds, therefore
            moving its hand from doing one thing to doing the other thing so fast that a real person 
            would not be able to notice any difference. <br></br>
            <red>Example:</red> the music doesn't stop playing when 
            writing the keyboard. 
            <br></br><br></br>
            By <blue>hyperthreading</blue>, the <red>core</red> gets a second hand available, 
            and can perform 
            <blue>2</blue> simultaneos <red>tasks</red> but using the same the shared resources of the 
            <red>core</red>, 
            meaning it's slower than doing simultaneos <red>tasks</red> on different <red>cores</red>, 
            but faster than doing single <red>tasks</red> on one <red>core</red>. 
            <br></br><br></br>
            <blue>Multithreading</blue> refers to using multiple <red>threads</red> 
            (<blue>2 threads</blue>) 
            to one <red>core</red>.
            <blue>Multithreading</blue> allows for better utilization of available system resources by 
            dividing <red>tasks</red> into separate <red>threads</red> and running them in parallel.
            <blue>Hyperthreading</blue> further increases performance by allowing processors to 
            execute two 
            <red>threads</red> concurrently. 
            <br></br><br></br>
            <red>Multiprocessing</red> is the utilization of two or more central processing 
            units (<red>CPUs</red>) in achieving one <red>task</red>, meaning we can have <blue>2 cores</blue> 
            running same program sharing among themselves data. 
            <br></br>
            Similar to <blue>2 workers</blue> working on 
            same <red>task</red>, passing around their tools from one to the other.
            <br></br><br></br>
            <green>Multithreading vs. multiprocessing:</green>
            <br></br><br></br>
            Both <blue>multithreading</blue> and <red>multiprocessing</red> give birth to few challenges 
            when it comes to <blue>concurent programming</blue>.
            <br></br><br></br>
            <brown>The Race Condition:</brown>
            <br></br><br></br>
            A <blue>race condition</blue> occurs when two or more <red>processes/threads</red> 
            can access <blue>shared data</blue> and they try to change it at the same time. 
            As a result, the values of variables 
            may be unpredictable and vary depending on the timings of context switches 
            of the <red>processes/threads</red>.
            <br></br><br></br>
            <brown>Process/Thread Syncronization:</brown>
            <br></br><br></br>
            <red>Process Synchronization</red> and <blue>Thread Synchronization</blue> 
            are two mechanism defined for <blue>concurent programming</blue> in order to ensure 
            that two or more <red>concurrent processes/threads</red> do not simultaneously execute 
            some particular program segment known as <blue>critical section</blue>.
            <br></br><br></br>
            A <blue>critical section</blue> refers to the parts of the 
            program where the <blue>shared resources</blue> are being accessed by different 
            <red>threads/processes</red>. So the <blue>2 workers</blue> or the <red>2 hands</red> 
            working on the same <red>task</red> collide to each other.
            <br></br><br></br>
            By using <red>Process Synchronization</red> and <blue>Thread Synchronization</blue> 
            the <red>race condition</red> can be avoided.
            <br></br><br></br>
            Both <blue>multithreading</blue> and <red>multiprocessing</red> can be used to 
            increase the computing power of a system, but there are some key differences between 
            these two approaches. 
            <br></br><br></br>
            <brown>
            Differences between Multithreading and Multiprocessing:
            </brown>
            <br></br><br></br>
            <red>Multiprocessing</red> uses two or more <red>CPUs</red> to increase computing power, 
            whereas 
            <blue>multithreading</blue> uses a single <red>process</red> with multiple 
            <blue>code segments</blue> to increase computing power.
            <br></br><br></br>
            <blue>Multithreading</blue> focuses on generating computing <red>threads</red> from a 
            single <red>process</red>, 
            whereas <red>multiprocessing</red> increases computing power by adding 
            <red>CPUs</red>. Meaning via <red>multiprocessing</red> we can distribute proccesses on 
            separate <red>CPUs</red>, whereas this is not possible with <blue>multithreading</blue>.
            <br></br><br></br>
            <red>Multiprocessing</red> is used to create a more reliable system, whereas 
            <blue>multithreading</blue> is used to create <red>threads</red> that run parallel to each other.
            <br></br><br></br>
            <blue>Multithreading</blue> is quick to create and requires few resources, 
            whereas <red>multiprocessing</red> 
            requires a significant amount of time and specific resources for its creation.
            <br></br><br></br>
            <red>Multiprocessing</red> executes many <red>processes</red> simultaneously, 
            whereas <blue>multithreading</blue> executes many <red>threads</red> simultaneously.
            <br></br><br></br>
            <blue>Multithreading</blue> uses a common <blue>address space</blue> for all 
            the <blue>threads</blue>, whereas 
            <red>multiprocessing</red> 
            creates a separate address space for each <red>process</red>.
            <br></br><br></br>
            In <red>multiprocessing</red> each <red>process</red> has its own memory 
            <blue>address space</blue> (<blue>stack memory</blue>). So when returning a value
            from a <red>process</red>, the value returned will not be 
            seen by the rest of the program unless it is saved in a <blue>file</blue>, in a 
            <blue>shared memory address</blue>, or in a <blue>message pipe</blue>, 
            whereas <blue>multithreading</blue> is able to return values which can be used 
            later in the main program.
            <br></br>
            A <blue>pipe</blue> is a technique for passing information from one program <red>process</red> 
            to another.
            <br></br><br></br>
            A <red>process</red> is treated as an individual program, (it even creates a 
            <red>process</red> in the Task Manager).
            <red>Processes</red> can be sent through different <red>cores</red>, that would speed 
            up the program even more.
            <br></br><br></br>
            Creating multiple <red>processes</red> is costly compare to <red>threads</red>. 
            Since for each <red>process</red> there is allocated another <blue>stack memory</blue> 
            space.
            <br></br><br></br>
            <blue>Multithreading</blue> is recommended for IO (input/output) operations such as: 
            <blue>file inputting/outputting</blue> and <blue>http requests</blue>, whereas 
            <red>multiprocessing</red> is recommended for CPU intensive operations 
            such as: <blue>calculations</blue>.
            <br></br><br></br>
            <green>Advantages of multithreading:</green>
            <br></br><br></br>
            1. It requires less memory storage.<br></br>
            2. Accessing memory is easier since <blue>threads</blue> share the same 
            parent <red>process</red>.<br></br>
            3. Switching between <blue>threads</blue> is fast and efficient.<br></br>
            4. It's faster to generate new <blue>threads</blue> within an existing <red>process</red> 
            than to create 
            an entirely new <red>process</red>.<br></br>
            5. All <blue>threads</blue> share one <red>process memory pool</red>  and the same 
            <blue>address space</blue>.<br></br>
            6. <blue>Threads</blue> are more lightweight and have lower <blue>overhead</blue>. 
            Any combination of excess or indirect computation time, memory, bandwidth, or other 
            resources that are required to perform a specific <red>task</red> is refered to as 
            <blue>overhead</blue>.
            <br></br> 
            7. The cost of communication between <blue>threads</blue> is relatively low.
            Meaning that <blue>threads</blue> can communicate with each other more easily 
            than <red>processes</red> can.
            <br></br>
            8. Creating responsive user interactions (UIs) is easy.
            <br></br><br></br>
            <green>Disadvantages of multithreading:</green>
            <br></br><br></br>
            1. A <blue>multithreading</blue> system cannot be interrupted/killed. Special attention has to
            be paid to <blue>memory leaks</blue>.
            A <blue>memory leak</blue> occurs when programmers allocate memory on 
            the <red>heap</red> and forget to deallocate it.<br></br>
            2. The code can be more challenging to understand.<br></br>
            3. The <blue>overhead</blue> associated with managing different 
            <blue>threads</blue> may be too costly for basic <red>tasks</red>.<br></br>
            4. Increased potential for <blue>race conditions</blue>. 
            <br></br>
            5. <blue>Debugging</blue> and <blue>troubleshooting</blue> issues may become more 
            challenging because the code can be complex.
            <br></br><br></br><br></br>
            <green>Advantages of multiprocessing:</green>
            <br></br><br></br>
            1. It uses simple coding that's easy to understand.<br></br>
            2. Child <red>processes</red> can be interrupted.<br></br>
            3. It completes <red>tasks</red> faster and analyzes large amounts of data.<br></br>
            4. It uses multiple <red>CPUs</red> to improve a system's overall processing power.<br></br>
            5. It removes synchronization primitives.<br></br>
            6. It's more cost-effective than single processor systems.
            <br></br><br></br>
            <green>Disadvantages of multiprocessing:</green>
            <br></br><br></br>
            1. It requires more memory storage and <blue>overhead</blue> than <blue>threads</blue> 
            in order to move data between the <red>processes</red>.<br></br>
            2. Spawning <red>processes</red> take longer than spawning <blue>threads</blue>.<br></br>
            3. An <red>inter-process communication</red> (<red>IPC</red>) model must be implemented to 
            share objects between the <red>processes</red>.<br></br>
            4. The entire memory is copied into each subprocess, which can also create more 
            <blue>overhead</blue>.
            <br></br><br></br>
            <green>Choosing between multithreading and multiprocessing:</green>
            <br></br><br></br>
            <blue>1. Multithreading can proove optimal for make user interaction (UI) 
            programs responsive.</blue>
            <br></br>
            These programs have to wait for the user to interact with them, so using <red>threads</red> 
            provides enough computing power. 
            <br></br><br></br>
            <red>For instance</red>: <blue>Multithreading</blue> can proove optimal for creating an 
            online writing 
            program in which one <red>thread</red> could track the user's keystrokes, 
            a second <red>thread</red> could display the text for the user to read and a third 
            <red>thread</red> could check the inputted text to identify spelling and grammar errors.
            <br></br><br></br>
            <blue>2. Multithreading can proove optimal for creating I/O-bound or network-bound 
            applications.</blue>
            <br></br>
            <red>Threads</red> can provide all the computing power needed to access web servers 
            and download content from the internet. 
            <br></br><br></br>
            <red>For instance</red>: many data scientists use <blue>multithreading</blue> to create web 
            scraping applications.
            <br></br><br></br>
            <blue>3. Multiprocessing can proove optimal for creating computation-intensive 
            programs.</blue>
            <br></br>
            <red>Multiprocessing</red> can help analyzing large volumes of data quickly.
            <br></br><br></br>
            <blue>4. Multiprocessing can proove optimal for develop programs that 
            are <red>CPU</red> intensive.</blue>
            <br></br>
            <red>Multiprocessing</red> can help to speed up <red>processes</red> and provide 
            reliable solutions for programs that involve several <red>CPU</red> tasks.
            <br></br><br></br>
        </concurrent-programming>
        <bitwise-operators>
            The <code>&#38;</code> (bitwise <red>AND</red>) in C takes two numbers as operands and does <red>AND</red> on every bit 
            of two numbers. <br></br>
            The result of <red>AND</red> is <blue>1</blue> only if both bits are <blue>1</blue>.  
            <br></br><br></br>
            The <code>|</code> (bitwise <red>OR</red>) in C takes two numbers as operands and does 
            <red>OR</red> on every bit 
            of two numbers. <br></br>
            The result of <red>OR</red> is <blue>1</blue> if any of the two bits is <blue>1</blue>. 
            <br></br><br></br>
            The <code>^</code> (bitwise <red>XOR</red>) takes two numbers as operands and does <red>XOR</red> on every 
            bit of two numbers.<br></br> 
            The result of <red>XOR</red> is <blue>1</blue> if the two bits are different. 
            <br></br><br></br>
            The <code>&lt;&lt;</code> (<red>left-shift</red>) takes two numbers, <red>left-shifts</red> the bits of the 
            first operand, and the second operand decides the number of places to shift. 
            <br></br><br></br>
            The <code>&gt;&gt;</code> (<red>right-shift</red>) takes two numbers, <red>right-shifts</red> the bits of the 
            first operand, and the second operand decides the number of places to shift.
            <br></br><br></br>
            The <code>~</code> (bitwise <red>NOT</red>) takes one number and inverts all bits of it.
            <br></br><br></br>
            <blue>
            The <red>left-shift</red> and <red>right-shift</red> operators should not be used for 
            <red>negative numbers</red>.<br></br>
            The <red>left-shift</red> and <red>right-shift</red> operators are equivalent to 
            <red>multiplication</red> and <red>division</red> by 
            <red>2</red> respectively.<br></br><br></br>
            </blue>
            
            The bitwise <red>OR</red> of two numbers is just the sum of those two numbers if there is no carry 
            involved, otherwise, you just add their bitwise <red>AND</red>.
            <br></br><br></br>
            <blue>
            Let’s say, we have <code>a=5(101)</code> and <code>b=2(010)</code>, since there is no carry involved, 
            their sum is just <code>a|b</code>. <br></br>
            Now, if we change <red>'a'</red> to <red>6</red> which is <red>110</red> in binary, their sum would change 
            to <code>a|b + a&#38;b</code> since there is a carry involved.
            <br></br><br></br>
            The bitwise <red>XOR</red> operator is the most useful operator from a technical interview perspective.
            <br></br><br></br>
            It is used in many problems. <br></br>
            <br></br>
            </blue>
            The <code>&#38;</code> operator can be used to quickly check if a number is odd or even.<br></br>

            The value of the expression <code>(x &#38; 1)</code> would be non-zero only if x is odd, otherwise, 
            the value would be zero. <br></br><br></br>
            
            The <code>~</code> operator should be used carefully.
            <br></br><br></br>
            The result of the <code>~</code> operator on a small number can be a big number if the result 
            is stored in an unsigned variable. <br></br><br></br>
            <red>
            The result may be a negative number if the result 
            is stored in a signed variable (assuming that the negative numbers are stored into a
            complement form where the leftmost bit is the sign bit).<br></br>
            </red>
        </bitwise-operators>
        <macros>
            <red>Macros</red> are powerful tools that allow developers to define <blue>reusable code snippets</blue>. 
            <br></br><br></br>
            They are defined using <blue>preprocessor directives</blue> and primarily used for 
            <blue>code substitution</blue> and <blue>generation</blue>. 
            <br></br><br></br>
            <red>Macros</red> provide a convenient way to write <blue>concise</blue> and 
            <blue>efficient code</blue>, 
            <red>improving the readability</red> and <red>maintainability</red> of programs.
            <br></br><br></br>
<code>
// Program to illustrate macros

#include &lt;stdio.h&gt;
 
// Macro definition
#define AREA(l, b) (l * b)
 
int main()
{
    // Given lengths l1 and l2
    int l1 = 10, l2 = 5, area;
 
    // Find the area using macros
    area = AREA(l1, l2);
 
    // Print the area
    printf("Area of rectangle"
           " is: %d",
           area);
 
    return 0;
}
</code>        
            <br></br>
            <green>
            Object-Like Macros:
            </green>
            <br></br><br></br>
            An <red>object-like macro</red> is a simple identifier that will be 
            <blue>replaced by a code fragment</blue>. 
            <br></br>
            It is called <red>object-like</red> because it looks like an <red>object</red> in code that uses it. 
            <br></br><br></br>
            <brown>
            It is popularly used to replace a symbolic name with a numerical/variable represented 
            as a constant.
            </brown>
            <br></br><br></br>
<code>
//Chain Macros
  
// Macro definition
#define INSTAGRAM FOLLOWERS
#define FOLLOWERS 138 

/*
Both macros INSTAGRAM and FOLLOWERS have same value - 138
*/


Multi-line macros
#include &lt;stdio.h&gt;
 
// Multi-line Macro definition
#define ELE 1, \
            2, \
            3
 
int main()
{
 
    // Array arr[] with elements
    // defined in macros
    int arr[] = { ELE };
 
    // Print elements
    printf("Elements of Array are:\n");
 
    for (int i = 0; i &lt; 3; i++) {
        printf("%d  ", arr[i]);
    }
    return 0;
}
  
</code>
        </macros>
        <defines>
            In programming, <code>#define</code> is a preprocessor directive that is used to define <red>macros</red>. 
            <br></br><br></br>
            The <red>macros</red> are the identifiers which are replaced by their <blue>value</blue> before 
            compilation. <br></br><br></br>
            We can define constants and <red>functions like macros</red> using <code>#define</code>.
        </defines>
        <command-line-arguments>
            Command-line <red>arguments</red> are passed to the main function 
            as (<code>argc</code>, <code>argv</code>), or (<code>args</code>). 
            <br></br>
            Command-line <red>arguments</red> are used to control the program from 
            the outside.
            <br></br><br></br>
            <green>For C/C++:</green>
            <br></br><br></br>
            In languages such as C and C++ both <code>argc</code> and <code>argv</code> are being 
            used for this purpose as follows:
            <br></br><br></br>
            The name of the program is 
            stored in <code>argv[0]</code>, the first command-line <red>parameter</red> in <code>argv[1]</code>, 
            and the    last argument in <code>argv[n]</code>.
            <br></br><br></br>
            <code>argc</code> - <red>argument count</red> is an integer variable that stores
            the number of command-line 
            <red>arguments</red> passed by the user including the name of the program. 
            So if we pass a 
            value to a program, the value of <code>argc</code> would be <blue>2</blue> 
            (one for <red>argument</red> and one for 
            <red>program name</red>). 
            <br></br><br></br>
            <red>The value of argc should be non-negative.</red>
            
            <br></br><br></br>
            <code>argv</code> - <red>argument vector</red> is an array of character pointers 
            listing all the <red>arguments</red>.
            If <code>argc</code> is greater than zero, the array elements from <code>argv[0]</code> 
            to <code>argv[argc-1]</code> will 
            contain pointers to strings.<br></br><br></br>
            <code>argv[0]</code> <red>is the name of the program.</red> 
            <br></br><br></br>
            After that until <code>argv[argc-1]</code> every element 
            is a command-line argument.
            <br></br><br></br>
            <brown>Properties of command-line arguments in C/C++:</brown>
            <br></br><br></br>
            <blue>
            <code>argv[argc]</code> is a <red>NULL</red> pointer.<br></br>
            <code>argv[0]</code> holds the name of the program.<br></br>
            <code>argv[1]</code> points to the first command-line argument and <code>argv[argc-1]</code> points to 
                the last argument.
            </blue>
            <br></br><br></br>
            <green>For Java/C#:</green>
            <br></br><br></br>
            In programming languages such as: C# and Java, only one variable is used to 
            store the command-line arguments: <code>args</code>
            <br></br><br></br>
            In these languages <code>args</code> is declared as an <blue>array</blue> of 
            <blue>string</blue> 
            elements. The length of the <code>args</code> can be obtained by using the OOP 
            attributes of the <blue>string</blue>
            class defined in those languages: <code>args.length</code> (in Java) 
            or <code>args.Length</code> (in C#).
            <br></br><br></br>
            <green>Overall properties of Command-Line Arguments:</green>
            <br></br><br></br>
            <blue>
            They are passed to the <code>main()</code> function.<br></br>
            They are parameters/arguments supplied to the program when it is invoked.<br></br>
            They are used to control programs from outside instead of hard coding those values 
            inside the code.
            </blue>
            <br></br><br></br>
        </command-line-arguments>
        <ternary-operator>
            <red>Ternary operator</red> is used for decision making instead of placing longer <red>if and else</red>
            conditional statements.
            <br></br><br></br>
            Syntax:
            <code>condition ? value_if_true : value_if_false</code>
            <br></br>
            The statement evaluates to <code>value_if_true</code> if condition is met, and <code>value_if_false</code> 
            otherwise.<br></br><br></br>
            
            <green>The ternary operator take three arguments:</green>
            <br></br><br></br>
            <blue>
            The first is a comparison argument;<br></br>
            The second is the result upon a <code>true</code> comparison;<br></br>
            The third is the result upon a <code>false</code> comparison;<br></br><br></br>
            </blue>
        </ternary-operator>
        <modular-programming>
            Modular programming consists of <blue>separating implementation</blue> from interface and 
            hiding information in the implementation.
            <br></br><br></br>
            <green>Advantages of modular programming:</green>
            <br></br><br></br>
            
            <blue>Code is easier to read</blue> - Working on modular programming makes <red>code easier 
            to read</red> 
            because functions perform different tasks as compared to <red>monolithic codes</red>. 
            Sometimes modular programming can be a bit messy if we pass arguments and 
            variables in different functions. 
            The use of modules should be done in a 
            <red>sensible manner</red> so as to avoid any problem. <br></br>
            Functions should be <red>neat</red>, <red>clean</red>, 
            and <red>descriptive</red>.<br></br><br></br>
            
            <blue>Code is easier to test</blue> - In software, some functions perform fewer tasks than
            other functions. If the software is easily split 
            using modules, it becomes easier to test. <br></br>
            We can also focus on the <red>riskier 
            functions</red> during testing and use more <red>test cases</red> to make it bug-free.<br></br><br></br>
            
            <blue>Reusability</blue> - There are times where a piece of code is implemented 
            everywhere in 
            our program. Instead of copying and pasting it, again and again, modularity 
            gives us the <red>advantage of reusability</red> so that we can pull our code from 
            anywhere using interfaces or libraries. <br></br>
            The concept of <red>reusability</red> also 
            <red>reduces the size</red> of our program.<br></br><br></br>
            
            <blue>Faster fixes</blue> - Suppose there is an error in the payment options in any 
            application, and the bug needs to be removed. Modularity can be a great help 
            because we know that there will be a separate function that will contain the 
            code of payments, and only that function will only be rectified.<br></br>
            Using modules to find and fix bugs becomes much more 
            <red>smooth</red> and <red>maintainable</red>.<br></br><br></br>
            
            <blue>Low-risk update</blue> - In modular programming, a defined layer of APIs protects 
            things that 
            use it from making changes inside the library. Unless there is a change in the API, 
            there is a <red>low risk</red> for someone's code-breaking. <br></br>
                        For example, if you didn't have 
            explicit APIs and someone changed a function they thought was only used within that 
            same <red>library</red> (but it was used elsewhere), they could <red>accidentally break</red> 
            something.<br></br><br></br>
            
            
            <blue>Easy collaboration</blue> - Different developers work on a single piece of code in the team. 
            There are <red>chances of conflicts</red> when there's a <red>git merge</red>. 
            This <red>conflict</red> can be <red>reduced</red> 
            if the <red>code is split</red> between more <red>functions</red>, <red>files</red>, <red>repos</red>, 
            etc. <br></br>
                        We can also provide 
            ownership to <red>specific code modules</red>, where a team member can break them down into 
            <red>smaller tasks</red>.<br></br><br></br>
            
            <green>Disadvantages of modular programming:</green>
            <br></br><br></br>
            <blue>Requires more resources</blue> - There is a need for extra time and 
            budget for a product in modular programming.
            <br></br><br></br>
            
            <blue>Increases the risk and the difficulty</blue> - It is a <red>challenging task</red> to 
            <red>combine</red> and <red>integrate</red> all the modules into a single program.
            <br></br><br></br>
            
            <blue>Additional efforts needed for the design</blue> - The design should be <red>carefully defined</red> 
            so that the impact for the other program modules is minimum.
            <br></br><br></br>
            
            <blue>The task repetition impacts the software performance</blue> - Some modules may partly 
            <red>repeat the task</red> 
            performed by other modules. Hence, modular programs <red>may need more memory</red>, 
            <red>space</red> and <red>extra time for execution</red>.
            <br></br><br></br>
            
            <blue>The work efficiency might be impacted</blue> - It <red>reduces the program's 
            efficiency</red> because testing and debugging are 
            time-consuming, where each function contains a thousand lines of code.
            <br></br><br></br>
            
            <blue>The code readability might be affected</blue> - Integrating various modules into a 
            single program <red>might prove be a difficult task</red> because 
            different people working on the design of different modules may not have the 
            same style.
            <br></br><br></br>
            
        </modular-programming>
        <datatype-conversions>
            <green>Generally there are two types of conversions:</green>
            <br></br><br></br>
            <blue>
            - implicit conversion (done automatically by the compiler)<br></br>
            - explicit conversion (done manually by the developer)<br></br>
            </blue>
            <br></br>
            <red>Implicit conversion</red> is done automatically by the compiler when you assign a value 
            of one type to another.<br></br><br></br>
            <red>Explicit conversion</red> is done manually by placing the type in parentheses <red>()</red> in front 
            of the value. Also knows as <red>typecasting</red>. 
            <br></br>
        </datatype-conversions>
        <operators>
            An operator is a symbol that tells the compiler to perform specific mathematical or 
            logical functions. 
            <br></br><br></br>
            By definition, an operator performs a certain operation on 
            operands. 
            <br></br>
            An operator needs one or more operands for the operation to be performed.<br></br>
            <br></br>
            Depending on how many operands are required to perform the operation, operands are called as 
            <red>unary</red>, <red>binary</red> or <red>ternary</red> operators.
            They need <blue>one</blue>, <blue>two</blue> or <blue>three</blue> operands respectively.<br></br>
            <br></br>
            <red>Unary operators</red> − <code>++</code> (increment), <code>--</code> (decrement), <code>!</code> (NOT), <code>~</code> (compliment), <code>&#38;</code> (address of), <code>*</code> (dereference)
            <br></br><br></br>
            <red>Binary operators</red> − arithmetic, logical and relational operators except !
            <br></br><br></br>
            <red>Ternary operators</red> − The <code>?</code> operator.
            <br></br><br></br>
            <green>Most programming languages are rich in built-in operators and provides the following types of operators:</green>
            <br></br><br></br>
            <brown>Assume variable <code>A = 10</code> and variable <code>B = 20 </code> then: 
            <br></br><br></br></brown>
            <br></br>
            <green>Arithmetic Operators: <br></br></green>
                <br></br>
                + <red>it adds two operands.</red><br></br>
                <code>A + B = 30</code><br></br>
                <br></br>
                
                − <red>it subtracts second operand from the first.</red><br></br>
                <code>A − B = -10</code><br></br>
                <br></br>
                
                * <red>it multiplies both operands.</red><br></br>
                <code>A * B = 200</code><br></br>
                <br></br>
                
                / <red>it divides numerator by de-numerator.</red><br></br>
                <code>B / A = 2</code><br></br>
                <br></br>
                
                % <red>is the Modulus Operator.</red><br></br>
                <blue>It gives the remainder after an integer division.</blue><br></br>
                <code>B % A = 0</code><br></br>
                <br></br><br></br>
                
                ++ <red>is the Increment operator. </red><br></br>
                <blue>It increases the integer value by one.</blue><br></br>
                <code>A++ = 11</code><br></br>
                <br></br>
                -- <red>is the Decrement operator.</red><br></br>
                <blue>It decreases the integer value by one.</blue><br></br>
                <code>A-- = 9</code><br></br>
                <br></br>
                <green><br></br>Relational Operators:<br></br></green>
                <br></br>
                
                == <red>it checks if the values of two operands are equal or not. </red><br></br>
                <blue>If yes, then the condition becomes true.</blue><br></br>
                <code>(A == B) is not true.</code><br></br>
                <br></br>

                != <red>it checks if the values of two operands are equal or not.</red><br></br>
                <blue>If the values are not equal, then the condition becomes true.</blue><br></br>
                <code>(A != B) is true.</code><br></br>
                <br></br>

                &gt; <red>it checks if the value of left operand is greater than the value of 
                right operand.</red><br></br>
                <blue>If yes, then the condition becomes true.</blue><br></br>
                <code>(A &gt; B) is not true.</code><br></br>
                <br></br>

                &lt; <red>it checks if the value of left operand is less than the value of 
                right operand.</red><br></br>
                <blue>If yes, then the condition becomes true.</blue><br></br>
                <code>(A &lt; B) is true.</code><br></br>
                <br></br>

                &gt;= <red>it checks if the value of left operand is greater than or equal to 
                the value of right operand.</red><br></br>
                <blue>If yes, then the condition becomes true.</blue><br></br>
                <code>(A &gt;= B) is not true.</code><br></br>
                <br></br>

                &lt;= <red>it checks if the value of left operand is less than or equal to the value 
                of right operand.</red><br></br>
                <blue>If yes, then the condition becomes true.</blue><br></br>
                <code>(A &lt;= B) is true.</code><br></br>
                <br></br>
                
                <green><br></br>Logical Operators:<br></br></green>
                <br></br>
    
                &#38;&#38; <red>it's called Logical AND operator.</red><br></br> 
                <blue>Results in TRUE if both the operands are non-zero, 
                then the condition becomes true.</blue><br></br>
                <code>(A &#38;&#38; B) is false.</code><br></br>
                <br></br>

                || <red>it's called Logical OR Operator.</red><br></br>  
                <blue>Results in TRUE if any of the two operands is non-zero, 
                then the condition becomes true.</blue><br></br>
                <code>(A || B) is true.</code><br></br>
                <br></br>

                ! <red>it's called Logical NOT Operator. </red><br></br>
                <blue>It is used to reverse the logical state of 
                its operand. 
                If a condition is true, then Logical NOT operator will make it false.</blue>
                <br></br>
                <code>!(A &#38;&#38; B) is true.</code><br></br>
                <br></br>
                
                <green><br></br>Bitwise Operators:<br></br></green>
                <br></br>
                &#38; <red>binary AND Operator copies a bit to the result if it exists in both operands.</red><br></br>    
                <code>(A &#38; B) = 12, i.e., 0000 1100</code><br></br>
                <br></br>

                | <red>binary OR Operator.</red><br></br>
                <blue>It copies a bit if it exists in either operand.</blue><br></br>
                <code>(A | B) = 61, i.e., 0011 1101</code><br></br>
                <br></br>
                ^ <red>binary XOR Operator.</red><br></br>
                <blue>It copies the bit if it is set in one operand but not both.</blue><br></br>
                <code>(A ^ B) = 49, i.e., 0011 0001</code><br></br>
                <br></br>
                ~ <red>binary One's Complement Operator.</red><br></br>
                <blue>Is unary and has the effect of 'flipping' bits.</blue><br></br>
                <code>(~A ) = ~(60), i.e,. -0111101</code><br></br>
                <br></br>
                &lt;&lt; <red>binary Left Shift Operator.</red><br></br>
                <blue>The left operands value is moved left by the number of bits specified by the 
                right operand.</blue><br></br>
                <code>A &lt;&lt; 2 = 240 i.e., 1111 0000</code><br></br>
                <br></br>
                &gt;&gt; <red>binary Right Shift Operator. </red><br></br>
                <blue>The left operands value is moved right by the number of bits specified 
                by the right operand.</blue><br></br>
                <code>A &gt;&gt; 2 = 15 i.e., 0000 1111</code><br></br>
                <br></br>
                
                <green><br></br>Assignment Operators:<br></br></green>
                <br></br>
                = <red>is the assignment operator. </red><br></br>
                <blue>Assigns values from right side operands to left side operand.</blue><br></br>
                <code>C = A + B will assign the value of A + B to C</code><br></br>
                <br></br>
                += <red>the add AND assign operator. </red><br></br>
                <blue>It adds the right operand to the left operand and assign the result 
                to the left operand.</blue><br></br>
                <code>C += A is equivalent to C = C + A</code><br></br>
                <br></br>
                -= <red>Subtract AND assignment operator. </red><br></br>
                <blue>It subtracts the right operand from the left operand and assigns 
                the result to the left operand.</blue><br></br>
                <code>C -= A is equivalent to C = C - A</code><br></br>
                <br></br>
                *= <red>Multiply AND assignment operator. </red><br></br>
                <blue>It multiplies the right operand with the left operand and assigns 
                the result to the left operand.</blue><br></br>    
                <code>C *= A is equivalent to C = C * A</code><br></br>
                <br></br>
                /= <red>the divide AND assign operator. </red><br></br>
                <blue>It divides the left operand with the right operand and assigns the 
                result to the left operand.</blue><br></br>
                <code>C /= A is equivalent to C = C / A</code><br></br>
                <br></br>
                %= <red>the modulus AND assign operator. </red><br></br>
                <blue>It takes modulus using two operands and assigns the 
                result to the left operand.</blue><br></br>
                <code>C %= A is equivalent to C = C % A</code><br></br>
                <br></br>
                &lt;&lt;= <red>the Left shift AND assign operator.</red><br></br>
                <blue>It takes the value stored in variable C shifts it to the left by 
                the number of bits specified 
                after the equal sign and then assigns the result of the operation back to C variable</blue><br></br>
                <code>C &lt;&lt;= 2 is same as C = C &lt;&lt; 2</code><br></br>
                <br></br>
                &gt;&gt;= <red>the Right shift AND assign operator.</red><br></br>
                <blue>It takes the value stored in variable C shifts it to the right by the 
                number of bits specified after the equal sign and then assigns the result of the 
                operation back to C variable.</blue><br></br>
                <code>C &gt;&gt;= 2 is same as C = C &gt;&gt; 2</code><br></br>
                <br></br>
                &#38;= <red>the bitwise AND assign operator.</red><br></br>
                <blue>It takes the value stored in variable C performs bitwise AND with 
                the value specified after the equal sign and then assigns the result of 
                the operation back to C variable.</blue><br></br>
                <code>C &#38;= 2 is same as C = C &#38; 2</code><br></br>
                <br></br>
                ^= <red>the bitwise exclusive OR and assign operator.</red><br></br>
                <blue>It takes the value stored in variable C performs bitwise XOR with the value 
                specified after the equal sign and then assigns the result of the 
                operation back to C variable.</blue><br></br>
                <code>C ^= 2 is same as C = C ^ 2</code><br></br>
                <br></br>
                |= <red>the bitwise inclusive OR and assign operator.</red><br></br>
                <blue>It takes the value stored in variable C performs bitwise OR with the 
                value specified after the equal sign and then assign the result of the 
                operation back to C variable.</blue><br></br>
                <code>C |= 2 is same as C = C | 2</code><br></br>
                <br></br>
        </operators>
        <pre-post-incrementation>
            <red>Increment operators</red> are used to increase the value of a variable by <blue>1</blue>.<br></br>
            This operator is represented by the <red>++</red> symbol. <br></br><br></br>
            The increment operator can either
            increase the value of the variable by <blue>1</blue> before assigning it to the variable or 
            can increase the value of the variable by <blue>1</blue> after assigning the variable. 
            Thus it can be classified into two types
            <br></br><br></br>
            <green>Classification of the increment operator:</green>
            <br></br><br></br>
            <blue>
            Pre-Increment Operator<br></br>
<code>
a = ++x; // first x will be incremented then value of x is assigned to a;
</code>
            <br></br>
            Post-Increment Operator<br></br>
<code>
a = x++; // first x value is assigned to a, then the value of x gets incremented;
</code>
            </blue>
        </pre-post-incrementation>
        <constructors>
            A <red>constructor</red> is a special method that is automatically called when an object 
            of a <code>class</code> is created.
            <br></br><br></br>
            <red>Constructors</red> can also take <red>parameters</red> (just like 
            <red>regular functions</red>), which can be useful for setting initial 
            values for attributes.<br></br>
        </constructors>
        <instantiation>
            In <red>object-oriented programming</red>, an <red>instance</red> is a concrete realization 
            of a <red>class</red>. 
            <br></br><br></br>
            When you define a <code>class</code>, you're essentially creating a blueprint. 
            <br></br><br></br>
            An <red>instance</red> is an <red>object</red> built from that blueprint. <br></br>
            It has all the characteristics defined in the <code>class</code>, but with specific values.
            <br></br>
        </instantiation>
        <destructors>
            Destructor is an <red>instance member function</red> that is invoked automatically whenever an <red>object</red> is 
            going to be destroyed. <br></br><br></br>
            The destructor is the last <red>function</red> that is going to be called before an 
            <red>object</red> is destroyed.
            <br></br><br></br>
            <green>About destructors:</green>
            <br></br><br></br>
            <blue>
            - A destructor is also a special member function like a constructor. <br></br>
            - Destructor destroys the class objects created by the constructor. <br></br>
            - Destructor has the same name as their <code>class</code> name preceded by a 
            tilde (<code>~</code>) symbol.<br></br>
            - It is <red>not possible</red> to define more than one destructor. <br></br>
            - The destructor is the only one way to destroy the <red>object</red> created by the constructor. 
            <br></br>
            - The destructor <red>can-not be overloaded</red>.
            <br></br>
            - Destructor <red>neither requires</red> any argument <red>nor returns</red> any value.<br></br>
            - It is automatically called when an <red>object</red> goes <red>out of scope</red>. <br></br>
            - Destructor release memory space occupied by the <red>objects</red> created by the constructor.<br></br>
            - In destructor, <red>objects</red> are destroyed in the reverse of an <red>object</red> creation.<br></br>
            </blue>
        </destructors>
        <function-overloading>
            <red>Function overloading</red> is a feature of <red>object-oriented programming</red> 
            where two or more 
            <red>functions</red> can have the <red>same name but different parameters</red>. <br></br><br></br>
            <red>Function overloading</red> can be considered as an example of a <red>polymorphism</red> 
            feature.
            <br></br><br></br>
            Multiple <red>functions</red> having same name but <red>different parameters</red> is 
            known as <red>function overloading</red>.<br></br>
            If we have to perform one operation then having same name for the <red>functions</red> 
            doing it <blue>increases 
            the readability</blue> of the program.
            <br></br><br></br>
            <green>Function Overloading vs. Function Overriding:</green>
            <br></br><br></br>
            <red>Function/Method overloading</red> refers to defining <red>multiple functions/methods</red> 
            with the same name but <blue>different parameters</blue> within the same <red>class</red>, 
            while <blue>function/method overriding</blue> involves 
            creating a <red>function/method</red> in the child class that has the same <blue>name</blue>, 
            <blue>parameters</blue>, and 
            <blue>return type</blue> as a <red>function/method</red> in the <red>parent class</red>.
            <br></br><br></br>
            <brown>
            Overloaded functions can be defined both outside and inside classes.<br></br>
            </brown>
        </function-overloading>
        <operator-overloading>
            <blue>Operator overloading</blue> is a compile-time <red>polymorphism</red>. <br></br><br></br>
            It is an idea of giving special meaning to an existing <red>operator</red> 
            without changing its original meaning. <br></br>
        </operator-overloading>
        <namespaces>
            A <red>namespace</red> is a feature which can be defined as a
            <blue>declarative region</blue> that provides a <red>scope</red> to the 
            identifiers (names of <red>functions</red>, 
            <red>variables</red> or other <red>user-defined data types</red>) inside it. 
            <br></br>
        </namespaces>
        <exception-handling>
            In computer programming <blue>exceptions</blue> are <red>runtime anomalies</red> or <red>abnormal conditions</red> that a program 
            encounters during its execution. 
            <br></br><br></br>
            The process of handling these <blue>exceptions</blue> is 
            called <red>exception handling</red>. <br></br>
            <br></br>
            Using the <red>exception handling</red> mechanism, the control 
            from one part of the program where the <red>exception</red> occurred can be transferred 
            to another part of the code.
            <br></br><br></br>
            By using <red>exception handling</red> we can handle the anomalies so that our 
            program keeps running.<br></br>
        </exception-handling>
        <default-parameters>
            A <red>default parameter/argument</red> is a value provided in a <red>function</red> declaration that is 
            automatically assigned by the compiler if the calling <red>function</red> doesn’t provide 
            a value for the <red>argument</red>. <br></br>
            <br></br>
            In case any value is passed, the <blue>default value</blue> is 
            <red>overridden</red>. <br></br>
        </default-parameters>
        <interfaces>
            In programming: an <red>interface</red> describes the behavior or capabilities of a <red>class</red> without 
            committing to a particular implementation of that <red>class</red>.
            <br></br><br></br>
            The <red>interfaces</red> are implemented using <red>abstract classes</red> and these <red>abstract classes</red>
            should not be confused with <red>data abstraction</red> which is a concept of keeping 
            implementation details separate from associated data.<br></br>
        </interfaces>
        <abstract-classes>
            The purpose of an <red>abstract class</red> (often referred to as an <red>ABC</red>) is to provide an 
            appropriate <red>base class</red> from which other classes can <red>inherit</red>. <br></br>
            <br></br>
            <red>Abstract classes</red> cannot be used to <red>instantiate</red> objects and serves only as an 
            interface. <br></br>
            Attempting to <red>instantiate</red> an object of an <red>abstract class</red> causes a 
            compilation error. <br></br>
            <br></br>
            If a subclass of an <red>ABC</red> needs to be instantiated, it has to implement each of 
            the <red>virtual/abstract functions</red>, which means that it supports the 
            interface declared by the 
            <red>ABC</red>. <br></br><br></br>
            Failing to <red>override</red> a pure <red>virtual/abstract function</red> in a 
            <red>derived class</red>, 
            then attempting to <red>instantiate objects</red> of that <code>class</code>, is a compilation error.
            <br></br><br></br>
            An <red>object-oriented</red> system might use an <red>abstract base class</red> to provide a common and 
            standardized <red>interface</red> appropriate for all the external applications. <br></br>
            Through <red>inheritance</red> from the <red>abstract base class</red>, <blue>derived classes</blue> are 
            formed that operate similarly.
            <br></br><br></br>
            The capabilities (i.e., the <red>public functions</red>) offered by the external applications 
            are provided as pure <red>virtual/abstract functions</red> in the <red>abstract base class</red>. 
            <br></br><br></br>
            The implementations of these pure <red>virtual/abstract functions</red> are provided in 
            the <red>derived 
            classes</red> that correspond to the specific types of the application.<br></br>
        </abstract-classes>
        <optional-parameters>
            A parameter with a default value, is often known as an <blue>"optional parameter"</blue>.
            <br></br><br></br> 
            For more information see the <blue>default-parameters</blue> section.
        </optional-parameters>
        <decorators>
            <red>Decorator</red> is a structural pattern that allows adding new behaviors to <red>objects</red> 
            dynamically by placing them inside special wrapper <red>objects</red> , called <red>decorators</red>. 
            <br></br><br></br>
            Using <red>decorators</red> you can wrap <red>objects</red>  countless number of times since both target 
            <red>objects</red>  and <red>decorators</red> follow the same interface.<br></br>
        </decorators>
        <generic-programming>
            <blue>Generic programming</blue> is a style of computer programming in which 
            algorithms are 
            written in terms of <red>data types to-be-specified-later</red> that are then instantiated 
            when needed for specific types provided as parameters.
            <br></br><br></br>            
            The <red>functions</red> and <red>classes</red> which are <red>data type independent</red> 
            are called <red>generics</red>, 
            and this concept is called <blue>generic programming</blue>. 
            <br></br><br></br>
            <brown>
            Generic Programming provides efficiency by reducing code 
            repetition and in-demand compilation.
            </brown>
            <br></br>
        </generic-programming>
        <abstraction>
            <blue>Abstraction</blue> means displaying only essential information and hiding the 
            details. <br></br><br></br>
            <blue>Abstraction</blue> is a powerful technique that allows for a separation of 
            concerns between the 
            <red>interface</red> and <blue>implementation</blue> of a <code>class</code>. 
            <br></br><br></br>
            It helps to <red>reduce complexity</red> and improve 
            <blue>maintainability</blue> by allowing changes to be made to the 
            <blue>implementation</blue> without affecting 
            the overall behavior of the <code>class</code>.
            <br></br><br></br>
            Can be used to create a <red>base implementation</red> or <blue>contract</blue> for the 
            <blue>actual implementation</blue> from <blue>base classes</blue>.
            <br></br><br></br>
            <green>Types of Abstraction in OOP:</green>
            <br></br><br></br>
            <brown>Data abstraction:</brown>
            <br></br><br></br>
            <blue>Data abstraction</blue> is one of the most essential and important features of 
            <red>object-oriented programming</red>. 
            <br></br><br></br>
            <blue>Data abstraction</blue> refers to providing only <blue>essential information</blue> 
            about the data to the outside world, hiding the background details or implementation. 
            <br></br><br></br>
            Using <blue>data abstraction</blue>, we are not allowed to <red>access</red> the variables directly, however, 
            one can call the <red>setter function</red> to set the values or the 
            <red>getter function</red> to get the values.
            <br></br><br></br>
            
            <red>Advantages of Data Abstraction:</red>
            <br></br><br></br>
            <blue>
            Helps the user to avoid writing the <red>low-level code</red>;<br></br>
            Avoids code duplication and <red>increases reusability</red>.<br></br>
            Can change the internal implementation of the <code>class</code> independently 
            <red>without affecting the user</red>.
            <br></br>
            Helps to <red>increase the security</red> of an application or program as only important 
            details are provided to the user.<br></br>
            It <red>reduces the complexity</red> as well as the <red>redundancy</red> of the code, therefore 
            <red>increasing the readability</red>.
            </blue>
            <br></br><br></br>
            <brown>Process Abstraction:</brown>
            <br></br><br></br>
            <blue>Process abstraction</blue> focuses on abstracting the behavior or 
            processes of an object. 
            <br></br>
            It allows developers to define the methods an object that can perform without 
            specifying how these methods are implemented. 
            <br></br><br></br>
            <blue>Process abstraction</blue> is achieved through <red>interfaces</red>. 
            <br></br>
            <red>Interfaces</red> define a set of method signatures without providing the method 
            implementations, enabling multiple <red>classes</red> to implement the same 
            <red>interface</red> in different ways.
            <br></br><br></br>
            <red>Abstraction</red> vs. <blue>Concrete Implementation:</blue>
            <br></br><br></br>
            <red>Abstraction</red> provides a clear distinction between the <red>interface</red> 
            of an object and its internal implementation. 
            This separation enables developers to focus on 
            high-level design and promotes <red>code reusability</red>.
            <br></br><br></br>
            <blue>Concrete implementation</blue>, 
            on the other hand, involves the actual coding and realization of the abstract 
            concepts. Striking a balance between <red>abstraction</red> and <blue>concrete 
            implementation</blue> is 
            essential in creating <red>maintainable</red>, <red>scalable</red>, and 
            <red>efficient</red> software systems.
            <br></br><br></br>
            <blue>Abstraction</blue> is one of the <red>4 OOP fundamental concepts</red>, 
            and it is regarded to <red>abstract objects</red>, which are the <red>objects</red> 
            that contain fields and methods to be <red>inherited</red> by their children. 
            <br></br><br></br>
            An <red>abstract object</red> is like a <blue>dead parent</blue>
            which has to allow <red>inheritance</red> to their children and nothing more.
            <br></br><br></br>
            <blue>Abstraction</blue> is the quality of dealing with ideas rather than events.
            <br></br><br></br>
            For example, when you consider the case of e-mail, complex details such as what happens 
            as soon as you send an e-mail, the protocol your e-mail, server uses, are hidden from 
            the user. 
            <br></br><br></br>
            Therefore, to send an e-mail you just need to type the content, mention the 
            address of the receiver, and click send.
            <br></br><br></br>
            Similarly, in object-oriented programming, <blue>abstraction</blue> is a process of 
            hiding the implementation details from the user, only the functionality will be 
            provided to the user. 
            <br></br><br></br>
            In other words, the user will have the information on what the <red>object</red> does 
            instead of how it does it.
            <br></br>
        </abstraction>
        <variable-arguments-lists>
            In programming: A <red>function</red> that takes a <red>variable number of arguments</red> 
            is called a 
            <blue>variadic function</blue>. 
            <br></br><br></br>
            A <blue>variadic function</blue> must specify at least one fixed argument 
            with an <blue>explicitly declared</blue> <red>data type</red>. <br></br><br></br>
            Additional <red>arguments</red> can follow, and can vary in 
            both <blue>quantity</blue> and <red>data type</red>.
            <br></br><br></br>
            The variable number of arguments permits a <red>function</red> to 
            accept any number of <red>arguments</red>.
            <br></br>
        </variable-arguments-lists>
        <random-generators>
            A <blue>random number generator</blue> forms the backbone of creating <blue>pseudo-random numbers</blue>.
            <br></br><br></br>
            The idea behind <blue>pseudo-random numbers</blue> is that a computer does not have a thinking 
            process to select a random number. <br></br><br></br>
            So even though an output number produced may seem <red>random</red>, the values are 
            <blue>mathematically computed</blue>.
        </random-generators>
        <preprocessor-directives>
            <red>Preprocessor directives</red> are lines of the source file where the first non-whitespace 
            character is <code>#</code> , which distinguishes them from other lines of text. 
            <br></br><br></br>
            The effect of each <red>preprocessor directives</red> is a change to the text and the 
            result is a 
            transformation of the text that does not contain the <blue>directives</blue> nor comments.
            <br></br><br></br>
            <green>The #define preprocessor as example:</green>
            <br></br><br></br>
            The <code>#define</code> preprocessor directive creates <blue>symbolic constant</blue>. 
            <br></br>
            <br></br>
            The <blue>symbolic constant</blue> is called a <red>macro</red> and the general form of the 
            directive is:<br></br>
<code>
#define macro-name replacement-text
</code>
            <br></br>
        </preprocessor-directives>
        <collections>
            In computer programming: A <red>collection</red> is an <red>object</red> that groups 
            multiple elements into a single unit.
            <br></br><br></br> 
            <red>Collections</red> are used to store, retrieve, manipulate, and communicate 
            aggregate <red>data</red>.
            <br></br>
        </collections>
        <read-from-file>
            <red>File handing</red> is the process in which we <red>create</red>, <red>open</red>, 
            <red>read</red>, <red>write</red>, and <red>close</red> operations on a <red>file</red>.
            <br></br> <br></br> 
            A <red>file</red> is a collection of <red>data</red> stored in the <blue>secondary memory</blue>. 
            <br></br><br></br> 
            The <red>data</red> is entered into the programs through the keyboard. 
            <br></br><br></br> 
            <red>Files</red> are used for storing information that can be processed 
            by the programs. 
            <br></br><br></br> 
            <red>Files</red> are not only used for storing the <red>data</red>, programs are also 
            stored in <red>files</red>.
            <br></br><br></br>
            <green>Features of file handling:</green>
            <br></br><br></br>
            <blue>Reusability:</blue><br></br>
            The data stored in the <blue>file</blue> can be <red>accessed</red>, 
            <red>updated</red>, and <red>deleted</red> anywhere and anytime providing  
            <blue>high reusability.</blue>.
            <br></br><br></br>
            <blue>Portability:</blue><br></br>
            Without losing any data, <blue>files</blue> can be transferred to 
            another in the computer system. The risk of flawed coding is 
            minimized with this feature.
            <br></br><br></br>
            <blue>Efficiency:</blue><br></br>
            A large amount of input may be required for some programs. 
            <blue>File handling</blue> allows you to easily access a part of a <blue>file</blue> using few 
            instructions which saves a lot of time and reduces the chance of errors.
            <br></br><br></br>
            <blue>Storage Capacity:</blue> <br></br>
            <blue>Files</blue> allow you to store a large amount of data 
            without having to worry about storing everything simultaneously in a program.
            <br></br><br></br>
        </read-from-file>
        <write-to-file>
            When a program is terminated, the entire <red>data</red> is lost.
            <br></br><br></br>  
            <red>Storing</red> in a <red>file</red> will preserve your data even if the 
            program terminates.
            <br></br><br></br>  
            A <red>file</red> is a container in computer storage devices used for storing 
            <red>data</red>.
            <br></br> 
        </write-to-file>
        <inheritance>
            <red>Inheritance</red> allows programmers to create <red>classes</red> that are built 
            upon existing 
            <red>classes</red>, to specify a <blue>new implementation</blue>  while maintaining the 
            same behaviors
            (realizing an interface), <blue>to reuse code</blue> and to <blue>independently extend</blue> 
            original software via <code>public classes</code> and <code>interfaces</code>.
            <br></br><br></br>
            <red>Inheritance</red> consist in <red>classes</red> that can inherit other <red>classes</red> 
            behaviour and functionality. 
            <br></br>
            Example: A <red>class</red> that <blue>inherits</blue> from another <red>class</red> 
            can have access to its <red>variables</red> and <red>methods</red> as if it were its own.
            <br></br><br></br>
            <red>Inheritance</red> is one of the <blue>4 OOP fundamental concepts</blue>.
            <br></br>
        </inheritance>
        <recursion>
            <blue>Recursion</blue> is a programming concept available to all programming languages.
            <br></br> <br></br> 
            <blue>Recursion</blue> is achieved by using <red>recursive functions</red>.
            <br></br> <br></br> 
            A <red>recursive function</red> is a function that calls itself.
            <br></br> <br></br> 
            <blue>Recursion</blue> is a concept where the solution to a problem depends on 
            solutions to smaller instances of the same problem (as opposed to iteration).
            <br></br> 
            <red>
            Example: 5! = (4!*5) = (3! * 4 * 5) = (2! *3 *4 *5) etc.
            </red>
            <br></br> <br></br> 
            A <red>recursive function</red> needs to have a <blue>condition</blue> or 
            exit statement in order to stop the recursion and to avoid <blue>infinite looping</blue> 
            and <blue>stack overflow</blue>.
            <br></br> <br></br> 
            <green>Stack overflow:</green>
            <br></br> <br></br> 
            <blue>Stack overflow</blue> is a <red>type of buffer overflow error</red> 
            which occurs when the <blue>stack memory</blue> gets exhausted and the computer program 
            still tries to use more <red>memory space</red>. 
            <br></br> <br></br> 
            All <blue>local variables</blue> are stored in the <blue>stack memory</blue>. 
            Every <blue>function</blue> has it's own stack, once the <blue>function</blue> ends 
            the <blue>stack</blue> is empties and everything stored is lost 
            (<blue>local variables die</blue>).
            <br></br> <br></br> 
            The <blue>overall stack memory</blue> allocated by the program is only few megabytes. 
            That's why in some programming languages we need to make use of 
            <blue>dynamic memory allocation</blue>. 
            <br></br> <br></br> 
            <blue>Dynamic memory-allocation</blue> allows using the rest of the RAM memory, 
            and enables 
            using <blue>global variables</blue>, or <red>variables</red> stored in <red>heap</red> 
            (<red>variables</red> that don't die).
            These <red>variables</red> live through the lifetime of the program or can be 
            <red>deallocated</red>
            when no longer needed. 
            <br></br><br></br>
            <green>
                Recursion vs Loops:
            </green>
            <br></br><br></br>
            <red>Using the loop:</red> the code is <blue>easier to read and understand</blue> 
            (reading code is always a lot harder than writing it), and <red>loops are 
            generally faster</red>.
            <br></br><br></br>
            <blue>Recursion</blue> is useful when it is the natural way of viewing the problem, 
            but you must be sure that there is a <red>manageable number</red> of <blue>stack frames</blue> 
            involved. 
            <br></br><br></br>
            A <blue>stack frame</blue> is a block of memory assigned to the stack 
            when a <red>function</red> is called, if the <blue>stack frames</blue> exceeds the 
            <blue>stack memory capacity</blue>, the <blue>stack overflow</blue> error will occur 
            and will terminate the program.
            <br></br>
       </recursion>
        <string-methods>
            A <red>string</red> is a <blue>variable</blue> that holds a sequence of 
            one or more <blue>alphanumeric characters</blue>.
            <br></br><br></br> 
            It is usually possible to manipulate a <red>string</red> to provide information or 
            to alter the contents of a <red>string</red> using <blue>methods</blue>.
            <br></br>
        </string-methods>
        <reflection>
            <blue>Reflective programming</blue> or <blue>reflection</blue> is a mechanism that 
            enables a <blue>process</blue> perform 
            <blue>introspective operations</blue>, <red>examine</red> and <red>modify</red> its 
            own <red>structure</red> and <red>behavior</red>.
            <br></br>
            The <blue>reflection</blue> APIs built into programming languages allows
            developers to inspect code at runtime.
            <br></br><br></br>
            <blue>Reflection</blue> is used to obtain information about the software implementation 
            (the <red>metadata</red>), while it is in runtime. 
            <br></br><br></br>
            Also <blue>reflection</blue> is the ability of inspecting the code's metadata 
            in runtime.
            The <red>metadata</red> is related to the implementation, contains the 
            information about the <red>fields</red>, <red>methods</red>, <red>properties</red>, 
            <red>variable</red>, etc. used inside the software.
        </reflection>
    </programming_language>
    
    <programming_language>
        <name>C</name>
        <description>
            C is a <blue>general-purpose</blue> computer programming language.<br></br><br></br>
            It was created in the 1970s by Dennis Ritchie, and remains very widely used and 
            influential. <br></br><br></br>
            By design, C's features cleanly reflect the 
            capabilities of the targeted CPUs. It has found lasting use in operating 
            systems, device drivers, and protocol stacks, but its use in application 
            software has been decreasing. <br></br><br></br>
            C is commonly used on computer architectures that range from the largest 
            supercomputers to the smallest microcontrollers 
            and embedded systems.
        </description>
        <generic-programming>
            *General-Programming-Knowledge*
            <br></br>
            <green>
            In C Language generic programming can be achieved using:
            </green>
            <br></br><br></br>
            <blue>
            Variable argument lists;<br></br>
            Using <code>void *</code> and function pointers to write generic code;<br></br>
            Using libraries to reuse code without copying and recompiling;<br></br>
            Using plugins to get run-time overriding and more;
            </blue>
<code>
//Example of generic programming in C:

int min(void v[], int size, int (*compare)(void *, void *))
{
    /* Find min in v[0..size-1], assumes size is > 0 */
    
    int i;
    int min = 0;
    
    for (i = 1; i &lt; size; i++)
    {
        if ((*compare)(v[i], v[min]) &lt; 0)
        {
            min = i;
        }
    }
    
    return min;
}
</code>
        </generic-programming>
        <variable-arguments-lists>
            *General-Programming-Knowledge*
            <br></br>
            C language allows a <red>function</red> call to have a <red>variable</red> number of
            <red>arguments</red> with the <red>variable argument list</red> mechanism.<br></br>
            Use ellipsis <code>...</code> to denote a <red>variable number of arguments</red> to
            the compiler. 
            <br></br><br></br>
            The ellipsis can only occur at the end of an
            <red>argument list</red>.<br></br><br></br>
            <green>
            Here are some standard function calls that use variable
            argument lists:
            </green>
            <br></br><br></br>
            <code>int printf(const char *format, ...);</code><br></br>
            <code>int scanf(const char *format, ...);</code><br></br>
            <code>int execlp(const char *file, const char *arg, ...);</code><br></br>
<code>
//Example of variodic functions in C:

#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;

int AddNumbers(int n, ...)
{
    // Variadic function to add numbers
    
    int Sum = 0;

    //Declaring pointer to the argument list
    //va_list type comes from stdarg.h
    va_list ptr;

    //Initializing argument to the list pointer
    //va_start function comes from stdarg.h
    va_start(ptr, n);

    for (int i = 0; i &lt; n; i++)
    {
        //Accessing current variable and 
        //pointing to next one
        Sum += va_arg(ptr, int);
        //va_arg function comes from stdarg.h
    }
    // Ending argument list traversal
    va_end(ptr);
    //va_end function comes from stdarg.h
    
    return Sum;
}
</code>
        </variable-arguments-lists>
        <simple-data-types>*General-Programming-Knowledge*</simple-data-types>
        <complex-data-types>*General-Programming-Knowledge*
            <br></br><br></br>
            <green>
            The C programming language, as of C99, supports complex number math with the three 
            built-in complex types:
            </green>
            <br></br><br></br>
            <code>double _Complex</code><br></br>
            <code>float _Complex</code><br></br>
            <code>long double _Complex</code><br></br>
            <br></br>
            When the header <code>complex.h</code> is 
            included, the three complex number types are also accessible as <code>double complex</code>, 
            <code>float complex</code>, <code>long double complex</code>.<br></br><br></br>
        </complex-data-types>
        <preprocessor-directives>
            *General-Programming-Knowledge*
        </preprocessor-directives>
        <loops>*General-Programming-Knowledge*</loops>
        <collections>
            *General-Programming-Knowledge*
            <br></br>
            <code>Arrays</code> are collections of elements of the same data type with fixed size. 
            <br></br>
            Once the <red>array</red> is defined, its size cannot be changed.
            <br></br><br></br>

<code>
/*Declaring arrays and initializing arrays*/

int arr[5];
int array_initialized[7] = [1,2,3,4,5,6,7];
float array_floats[3] = [2.0f, 3.0f, 2.11f];
</code>
            <br></br>
            The <code>linked list</code> is a complex data type, which consists of a structure with 
            at least <blue>2 elements</blue>: <red>value</red> and <red>pointer</red>
            to the next element. <br></br>
            The memory can be allocated <blue>dynamically</blue> for each element added to the list. 
            <br></br><br></br>

            The main benefit of a <code>linked list</code>
            consists in the possibility of adding a variable number of elements, being able to 
            <red>delete</red> or <red>add</red> an element 
            without making <red>copies</red>
            or exchanges, but only by changing the addresses of the assigned <red>pointers</red> for 
            the <blue>next</blue> / <blue>previous</blue> element.
            <br></br><br></br>
            
<code>
//Declaring and initializing a Linked List

void createAddElementsOnLinkedList()
{
    //Linked list definition:
    struct LinkedList{
        int value; // this will store the value
        
        // this will store the address of the previous block of memory
        struct LinkedList * previous;
        
        // this will store the address of the next block of memory
        struct LinkedList * next; 
    };

    struct LinkedList* list = NULL; // creating a linked list

    int counter = 0;
    while(counter &lt; 10)
    {
        // if this is the first element to be introduced on the linked list
        if(list == NULL)
        {
            // allocate memory.
            list = (struct LinkedList* )malloc(sizeof(struct LinkedList));
            
            // add value
            list->value = counter;
            
            // there is no previous element.
            list->previous = NULL;
            
            // we don't know if there will be a next element.
            list->next = NULL; 
        }

        else //enter here after the first element was added.
        {
            // allocate space for the next element
            list->next = (struct LinkedList* ) malloc(sizeof(struct LinkedList)); 
            
            // we're still on the previous element, 
            //so assign the link to the next element.previous
            list->next->previous = list;
            
            // next element become current element
            list = list->next;
            
            // add value
            list->value = counter;
            
            // we don't know if there will be a next element.
            list->next = NULL;  
        }
        counter++;
    }

    //printing the linked list

    // list is currently pointing to the last element. 
    //So we will display it from last to first.
    while(list != NULL) 
    {
        printf("%d ", list->value);
        list = list->previous; // go to the previous
    }
}
</code>
        </collections>
        <collection-methods>
            There are no built-in functions for working with collections in C language.
        </collection-methods>
        <dynamic-memory-allocation>*General-Programming-Knowledge*</dynamic-memory-allocation>
        <read-from-file>
            *General-Programming-Knowledge*
            <green>File handling in C:</green>
            <br></br><br></br>
            C programming language supports <red>four</red> pre-defined functions to 
            read contents from a file, defined in <code>stdio.h</code> header file:
            <br></br><br></br>
            <blue>fgetc()</blue><br></br>
            This function is used to read a single character from the file.<br></br><br></br>
            <blue>fgets()</blue><br></br>
            This function is used to read strings from files.
            <br></br><br></br>
            <blue>fscanf()</blue><br></br>
            This function is used to read formatted input from a file.<br></br><br></br>
            <blue>fread()</blue><br></br>
            This function is used to read the block of raw bytes from files. This is used 
            to read binary files.
            <br></br><br></br>
            <green>
            Opening a file:
            </green>
            <br></br><br></br>
            To open a file use: <code>fopen(filename, mode)</code>;
            <br></br><br></br>
            Where:<br></br><br></br>
            <code>filename</code><br></br>    
            The name of the actual file you want to open (or create), like <red>filename.txt</red>.
            <br></br><br></br>
            <code>mode</code><br></br>    
            A single character, which represents what you want to do with the file 
            (<red>read</red>, <red>write</red> or <red>append</red>):<br></br><br></br>
            <blue>w</blue> - Writes to a file<br></br>
            <blue>a</blue> - Appends new data to a file<br></br>
            <blue>r</blue> - Reads from a file<br></br>
    
<code>
/*Read file char by char*/

//FILE is basically a data type, and we need to 
//create a pointer variable to work with it 
FILE* ptr; 
char ch;

// Opening file in reading mode
ptr = fopen("test.txt", "r");

if (NULL == ptr) {
    printf("file can't be opened \n");
}

printf("content of this file are \n");

// Printing what is written in file
// character by character using loop.
do {
    ch = fgetc(ptr);
    printf("%c", ch);

    // Checking if character is not EOF.
    // If it is EOF stop reading.
} while (ch != EOF); 

</code>

<code>
/*
Alternatively feof function can be used:
feof() function takes file pointer as argument 
and returns true if pointer reaches the end of the file. 
*/

while (!feof(ptr)) 
{
    ch = fgetc(ptr);
    printf("%c", ch);
}
</code>

<code>
//Reading whole content of the file as string:

//fgets() reads one string at a time from the file. fgets() returns 
//a string if it is successfully read by function or returns NULL
//if it cannot read. 

//Prototype: char * fgets(char *str, int size, FILE * ptr);

while (fgets(str, 50, ptr) != NULL) {
    printf("%s", str);
}
</code>

<code>
/*
fscanf() reads formatted input from a stream.

Approach:

fscanf reads formatted data from the files and stores it in variables.
The data in the buffer is printed on the console till the end of the 
file is reached.

*/

char buf[100];
while (fscanf(ptr, "%*s %*s %s ", buf) == 1)
    printf("%s\n", buf);
</code>
        
        </read-from-file>
        <write-to-file>
            *General-Programming-Knowledge*
            <br></br>
            To create a file, or write to a file you can use the <red>w</red> mode inside the <code>fopen()</code> function.
            <br></br><br></br>
            <green>
            Opening a file:
            </green>
            <br></br><br></br>
            Function Prototype: <code>fopen(filename, mode)</code>;
            <br></br><br></br>
            Where:<br></br><br></br>
            <code>filename</code><br></br>    
            The name of the actual file you want to open (or create), like <red>filename.txt</red>.
            <br></br><br></br>
            <code>mode</code><br></br>    
            A single character, which represents what you want to do with the file 
            (<red>read</red>, <red>write</red> or <red>append</red>):<br></br><br></br>
            <blue>w</blue> - Writes to a file<br></br>
            <blue>a</blue> - Appends new data to a file<br></br>
            <blue>r</blue> - Reads from a file<br></br>
            <br></br>
            The <red>w</red> mode means that the file is opened for writing. 
            <br></br>
            To insert content to it, you can 
            use the <code>fprintf()</code> function and add the pointer variable (<red>fptr</red> in our example) and some text:
            <br></br><br></br>
            If you write to a file that already exists, the old content is deleted, and the new content 
            is inserted. 
            <br></br>
            This is important to know, as you might accidentally erase existing content.
            <br></br>
<code>
//Example of writing to file in C

//FILE is basically a data type, and we need to 
//create a pointer variable to work with it 
FILE *fptr; 

// Open a file in writing mode
fptr = fopen("filename.txt", "w");

// Write some text to the file using fprintf
fprintf(fptr, "Some text");

// Write some other text to the file fputs
fputs("Line wrote with fputs.", fp); 

// Close the file
fclose(fptr); 
// this will close the file.
</code>    
        <br></br>
        <green>
        Closing the file:
        </green>
        <br></br><br></br>
        It is considered as <red>good practice</red>, because it makes sure that:
        <br></br><br></br>
        <blue>
        Changes are saved properly. <br></br>
        Other programs can use the file (if you want). <br></br>
        Clean up unnecessary memory space. <br></br><br></br>
        </blue>
        If you want to add content to a file without deleting the old content, 
        you can use the <red>a</red> mode. <br></br>
        The <red>a</red> mode appends content at the end of the file:<br></br>
        
<code>
/*Example*/

FILE *fptr;

// Open a file in append mode
fptr = fopen("filename.txt", "a"); 

/*Just like with the w mode; if the file does not exist, 
the a mode will create a new file with the "appended" content.*/

// Append some text to the file
fprintf(fptr, "\nHi everybody!");

// Close the file
fclose(fptr);
</code>
        </write-to-file>
        <serialization>
            *General-Programming-Knowledge*
            C and C++ do not provide <blue>serialization</blue> as any sort of high-level construct, 
            but both languages support writing any of the built-in <blue>data types</blue>, as well as 
            plain old <blue>data structs</blue>, as binary data. 
            <br></br><br></br>
            As such, it is usually trivial to write custom serialization functions.
            <br></br>
        </serialization>
        <deserialization>
            *General-Programming-Knowledge*
            <br></br>
            C and C++ do not provide <blue>serialization</blue> as any sort of high-level construct, 
            but both languages support writing any of the built-in <blue>data types</blue>, as well as 
            plain old <blue>data structs</blue>, as binary data. 
            <br></br><br></br>
            As such, it is usually trivial to write custom serialization functions.
            <br></br>
        </deserialization>
        <enums>
            *General-Programming-Knowledge*
<code>
//Syntax: enum flag{constant1, constant2, constant3, ....... };

// An example program to demonstrate working
// of enum in C

#include &lt;stdio.h&gt;
 
enum week{Mon, Tue, Wed, Thur, Fri, Sat, Sun};
 
int main()
{
    enum week day;
    day = Wed;
    printf("%d",day);
    return 0;
} 
</code>
        </enums>
        <concurrent-programming>
            *General-Programming-Knowledge*
            <br></br>
<code>
/*Example of using multi-threading in C Language*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt; //Header file for sleep(). man 3 sleep for details. 
#include &lt;pthread.h&gt;
  
// A normal C function that is executed as a thread  
// when its name is specified in pthread_create() 

void *myThreadFun(void *vargp) 
{ 
    sleep(1); 
    printf("Printing GeeksQuiz from Thread \n"); 
    return NULL; 
} 
   
int main() 
{ 
    pthread_t thread_id; 
    printf("Before Thread\n"); 
    pthread_create(&#38;thread_id, NULL, myThreadFun, NULL); 
    pthread_join(thread_id, NULL); 
    printf("After Thread\n"); 
    exit(0); 
}
</code>
        <br></br>
        In C/C++: one of the main workhorse functions that makes <blue>multiprocessing</blue> 
        possible is <code>fork()</code>.
        <br></br><br></br>
        <code>fork()</code> is a function that clone a <red>process</red>, spawning an identical 
        copy of it.
        <br></br>
<code>
//Example of multi-processing in C/C++:

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/wait.h&gt;

int main(int argc, char **argv)
{
    pid_t pid = fork ();
    if (pid != 0) 
    {
        waitpid (pid, NULL, 0);
    }
    printf ("Hello, World!\n");
}
</code>
        </concurrent-programming>
        <exception-handling>
            C does not provide direct support to 
            <blue>error handling</blue> (or <red>exception handling</red>).
        </exception-handling>
        <bitwise-operators>
            *General-Programming-Knowledge*
            <br></br>
<code>
// Example on how to use the bitwise operators:

#include &lt;stdio.h&gt;

int main()
{
    // a = 5(00000101), b = 9(00001001)
    unsigned char a = 5, b = 9;
 
    // The result is 00000001
    printf("a = %d, b = %d\n", a, b);
    printf("a &#38; b = %d\n", a &#38; b);
 
    // The result is 00001101
    printf("a|b = %d\n", a | b);
 
    // The result is 00001100
    printf("a^b = %d\n", a ^ b);
 
    // The result is 11111010
    printf("~a = %d\n", a = ~a);
 
    // The result is 00010010
    printf("b&lt;&lt;1 = %d\n", b &lt;&lt; 1);
 
    // The result is 00000100
    printf("b&gt;&gt;1 = %d\n", b &gt;&gt; 1);
 
    return 0;
    
    /*
        OUTPUT: 
        
        a = 5, b = 9
        a&#38;b = 1
        a|b = 13
        a^b = 12
        ~a = 250
        b&lt;&lt;1 = 18
        b&gt;&gt;1 = 4
    */
}
</code>
        </bitwise-operators>
        <default-parameters>
            *General-Programming-Knowledge*
            <br></br>
            There are no default parameters in C. <br></br><br></br>
            But one way to achieve this is by passing <red>NULL</red> pointers and 
            then set the values to the default if <red>NULL</red> is passed.
            <br></br>
<code>
//Example of function with default parameters in C:

void OpenFile(char *path)
{
    FILE *outHandle;

    if (path==NULL)
    {
        outHandle=fopen("DummyFile", "w");
    }
    else
    {
        outHandle=fopen(path, "w");
    }
}

int main()
{
    char* filePath;
    OpenFile(filePath);
}
</code>
        </default-parameters>
        <interfaces>
            *General-Programming-Knowledge*
            <br></br>
            In C - an <red>interface</red> can be implemented as a set of function declarations without 
            any implementation details. <br></br><br></br>
            <brown>
            It defines a contract that concrete implementations must adhere to by providing 
            definitions for all the functions declared in the <red>interface</red>.
            </brown>
<code>
// Declare an interface for a shape
struct shape_interface 
{
  // Function pointers for the interface functions
  double (*area)(void*);
  double (*perimeter)(void*);
}; 

/*
In OOP there are classes that store to both the variables and 
the methods of an object.

In C we can have structs that store variables and function  
pointers initialized with references of functions defined 
outside the struct to hold the implementation for defined 
behaviours.

This is somehow similar to OOP.

*/
</code>
        </interfaces>
        <macros>*General-Programming-Knowledge*</macros>
        <defines>*General-Programming-Knowledge*</defines>
        <random-generators>
            The <code>rand()</code> function returns the random integers whose range from <code>0</code> to 
            <code>RAND_MAX</code>. <br></br><br></br>
            The <code>RAND_MAX</code> is a symbolic constant that defines in <code>stdlib.h</code> header file, whose value 
            is greater but less than <blue>32767</blue> depending on the C libraries.<br></br><br></br>
<code>
//Example of using rand() to generate random numbers

#include &lt;stdio.h&gt;    
#include &lt;conio.h&gt;  
#include &lt;stdlib.h&gt;  

void main()  
{     
    // use rand() function to generate the number  
    printf (" The random number is: %d", rand());  
    printf ("\n The random number is: %d", rand());  
      
    printf (" \n The random number is: %d", rand());  
    printf ("\n The random number is: %d", rand());  
    getch();  
}          
</code>
            <br></br>
            The <code>srand()</code> function is a C library function that determines the initial 
            point to generate 
            different series of <red>pseudo-random numbers</red>. 
            <br></br><br></br>
            A <code>srand()</code> function cannot be used without 
            using a <code>rand()</code> function. 
            <br></br><br></br>
            The <code>srand()</code> function is required to set the value of the <red>seed</red> 
            only once in a program to generate the different results of random integers before 
            calling the <code>rand()</code> function. <br></br><br></br>
<code>
//Example of using srand() to generate pseudo-random numbers

#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;time.h&gt;  // use time.h header file to use time  
      
int main()  
{  
    int num, i;  
    time_t t1; // declare time variable  
      
    printf(" Enter a number to set the limit for a random number \n");  
    scanf (" %d", &#38;num);  
      
    /* define the random number generator */  
    srand ( (unsigned) time (&#38;t1)); // pass the srand() parameter  
    printf("\n"); // print the space
    /* generate random number between 0 to 50 */  
}  
</code>
        </random-generators>
        <command-line-arguments>
            *General-Programming-Knowledge*
<code>
/*Example of command line arguments in C:*/

int main(int argc, char *argv[]) { /* ... */ }

//OR
int main(int argc, char **argv) { /* ... */ }
</code>
        </command-line-arguments>
        <ternary-operator>
            *General-Programming-Knowledge*
<code>
/*Using IF ELSE statements:*/

int a = 10, b = 20, c;

if (a &lt; b) 
{
    c = a;
}
else 
{
    c = b;
}

printf("%d", c);
</code>

<code>
/*Using TERNARY operator:*/

int a = 10, b = 20, c;

c = (a &lt; b) ? a : b;

printf("%d", c);

/*The output of both samples of code from above will result in: c = 3*/
</code>
        </ternary-operator>
        <modular-programming>
            *General-Programming-Knowledge*
            <br></br>
            In C language this is achieved by placing 
            the interface definition in a header file and the implementation in a source 
            file. <br></br>
            The disciplined use of <code>static</code> keyword is practiced in order to hide implementation details.
            <br></br><br></br>
<code>
/*FILE module.h*/
 extern unsigned int Calculate_NoOfChars_In_string(char* str);

/*FILE module.c*/
unsigned int Calculate_NoOfChars_In_string(char* str)
{
    unsigned int counter = 0;
    while(str[counter]!="\0")
    {
        counter++;
    }
    return counter;
}

/*FILE main.c*/
#include &lt;module.h&gt;  
#include &lt;stdio.h&gt;  

int main()
{
    char strA[10] = "Some text.";
    unsigned int length = Calculate_NoOfChars_In_string(strA);
    print("String length is: %d\n", length);
}
</code>
        </modular-programming>
        <string-methods>
            *General-Programming-Knowledge*
            <br></br>
            C has many useful string functions, which can be used to perform certain operations 
            on strings.<br></br><br></br>
            To use them, you must include the <code>&lt;string.h&gt;</code> header file in your program.
            <br></br><br></br>
<code>
/* GET THE SIZE (IN CHARACTERS) OF STRINGS */

char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
printf("%d", strlen(alphabet));

/* Note that sizeof and strlen behaves differently, as sizeof also 
includes the \0 character when counting.*/

/* CONCATENATE STRINGS */

char str1[20] = "Hello ";
char str2[] = "World!";

// Concatenate str2 to str1 (result is stored in str1)
strcat(str1, str2);

// Print str1
printf("%s", str1);

/* COPY STRINGS */
char str1[20] = "Hello World!";
char str2[20];

// Copy str1 to str2
strcpy(str2, str1);

// Print str2
printf("%s", str2);

/* COMPARE STRINGS */

char str1[] = "Hello";
char str2[] = "Hello";
char str3[] = "Hi";

// Compare str1 and str2, and print the result
printf("%d\n", strcmp(str1, str2));  
// Returns 0 (the strings are equal)

// Compare str1 and str3, and print the result
printf("%d\n", strcmp(str1, str3));  
// Returns -4 (the strings are not equal)
</code>
        </string-methods>
        <datatype-conversions>
            *General-Programming-Knowledge*
            <br></br>
            It is one of the important concepts introduced in 'C' 
            programming.<br></br>
<code>
//Automatic conversion: int to float
float myFloat = 9;

printf("%f", myFloat); // 9.000000

//the compiler automatically converts the int value 
//9 to a float value of 9.000000.

//Automatic conversion: float to int
int myInt = 9.99;

printf("%d", myInt); // 9

//the compiler automatically converts the float value of 
//9.99 to int value 9.
</code>

<code>
//Calculate the percentage of a user's score in relation to 
//the maximum score in a game:

//Set the maximum possible score in the game to 500
int maxScore = 500;

//The actual score of the user
int userScore = 420;

/* 
Calculate the percentage of the user's score in relation to the 
maximum available score.
Convert userScore to float to make sure that the division is accurate.
*/
float percentage = (float) userScore / maxScore * 100.0;

//Print the percentage
printf("User's percentage is %.2f", percentage);
</code>
        </datatype-conversions>
        <optional-parameters>*General-Programming-Knowledge*</optional-parameters>
        <operators>
            *General-Programming-Knowledge*
            <green><br></br>Misc Operators:<br></br></green>
                <br></br> 
                <code>sizeof()</code><br></br> 
                <red>It returns the size of a variable. <br></br>
                <code>sizeof(a)</code>, 
                where <code>a</code> is integer, will return <blue>4</blue>.</red>
                <br></br><br></br>
                <code>&#38;</code><br></br>
                <red>It returns the <blue>address</blue> of a variable.<br></br> 
                <code>&#38;a;</code> returns the actual 
                address of the variable.</red>
                <br></br><br></br>
                <code>*</code><br></br>
                <red>Pointer to a variable.<br></br>
                <code>*a;</code> also known as deferefering the pointer <code>a</code></red>
                <br></br><br></br>
                <code>? :</code><br></br>
                <red>Conditional Expression. <br></br>
                If Condition is <code>true</code> <blue>?</blue> 
                then value X <blue>:</blue> otherwise value Y; </red>
                <br></br>
        </operators>
        <pre-post-incrementation>
            *General-Programming-Knowledge*
            <br></br>
<code>
//pre increment operator

#include &lt;stdio.h&gt;  
 
int main()
{
    int x = 10, a;
 
    a = ++x; // x will be incremented to 11 then value of x is assigned to a;
 
    printf("a = %d\n", a);
 
    printf("x = %d\n", x);
    return 0;
    
    /*
        OUTPUT: 
        a = 11
        x = 11
    */
}
</code>

<code>
//post increment operator

#include &lt;stdio.h&gt;  
 
int main()
{
    int x = 10, a;
 
    a = x++; // x value is assigned to a, then x value gets incremented to 11;

    printf("a = %d\n", a);
 
    printf("x = %d\n", x);
    return 0;
    
    /*
        OUTPUT: 
        a = 10
        x = 11
    */
}
</code>
        </pre-post-incrementation>
        <recursion>
            *General-Programming-Knowledge*
<code>
//Example of recursion in C:

#include &lt;stdio.h&gt;  

int fact (int);

int main()  
{  
    int n, f;  
    printf("Enter the number whose factorial you want to calculate?");  
    scanf("%d", &#38;n);  
    
    //Calling the recursive function:
    f = fact(n);
    
    //Printing the result:
    printf("factorial = %d",f);  
}

int fact(int n)  
{
    //Recursive function:
    
    if (n==0)  
    {  
        return 0;  
    }  
    else if ( n == 1)  
    {  
        return 1;  
    }  
    else   
    {  
        return n*fact(n-1);  
    }  
}  
</code>
        </recursion>
        <polymorphism>
            *General-Programming-Knowledge*
            <br></br>
            <green>Polymorphism in C:</green>
            <br></br><br></br>
            Even though C does not support OOP. A type of <blue>polymorphism</blue> can still 
            be achieved
            by using the <blue>generic pointer</blue>.
            <br></br><br></br>
            The type <code>void *</code> is used as a <blue>generic pointer</blue> in 
            C (similar in concept to <red>Object</red> type in OOP). 
            <br></br><br></br>
            <blue>Pointers</blue> to any type can be assigned to a
            variable of type <code>void *</code>, which allows <blue>parametric polymorphism</blue>.
<code>
//Example of parametric polymorphism in C:

void swap(void v[], int i, int j)
{
    //interchange values between index i and j
    void *tmp = v[i]; 
    v[i] = v[j]; 
    v[j] = tmp;
}

void qsort(void v[], int left, int right, int (*compare)(void *, void *))
{
    //sort to increasing order elements between index
    //left and right from array v[]
    
    int i, last;
    
    /* do nothing if array contains */
    /* less than two elements */
    if (left >= right) 
    {
        return; 
    }
    
    swap(v, left, (left + right)/2);
    last = left;
    
    for (i = left+1; i&lt;= right; i++)
    {
        if ((*compare)(v[i], v[left]) &lt; 0)
        {
            swap(v, ++last, i);
        }
    }
    swap(v, left, last);
    
    //Recursion
    qsort(v, left, last-1, compare);
    qsort(v, last+1, right, compare);
}
</code>
        </polymorphism>
    </programming_language>
    
    <programming_language>
        <name>C++</name>
        <description>
            C++ is a <blue>high-level</blue>, <blue>general-purpose</blue> programming language 
            created by Danish computer scientist Bjarne Stroustrup. <br></br><br></br>
            First released in 1985 as an <blue>extension</blue> of the C programming language, 
            it has since expanded significantly over time; as of 1997, C++ has <blue>object-oriented</blue>, 
            <blue>generic</blue>, and <blue>functional</blue> features. <br></br>
            In addition to facilities for low-level memory 
            manipulation for making things like microcomputers or to make operating systems 
            like Linux or Windows. <br></br><br></br>
            
            It is almost always implemented as a <blue>compiled language</blue>, 
            and many vendors provide C++ compilers, including the Free Software Foundation, 
            LLVM, Microsoft, Intel, Embarcadero, Oracle, and IBM.
        </description>
        <oop>*General-Programming-Knowledge*</oop>
        <encapsulation>
            *General-Programming-Knowledge*
<code>
//Example of encapsulation

#include &lt;iostream&gt;  
using namespace std;

class Employee 
{
  private:
    // Private attribute
    int salary;

  public:
    // Setter
    void setSalary(int s) 
    {
      salary = s;
    }
    
    // Getter
    int getSalary() 
    {
      return salary;
    }
};

int main() 
{
    Employee myObj;
    myObj.setSalary(50000);
    cout &lt;&lt; myObj.getSalary();
    return 0;
}
</code>
        </encapsulation>
        <polymorphism>
            *General-Programming-Knowledge*
<code>
//Example of polymorphism

#include &lt;iostream&gt;  

/*

The word polymorphism means having many forms. 

Typically, polymorphism occurs when there is a hierarchy of classes 
and they are related by inheritance.

C++ polymorphism means that a call to a member function will cause a 
different function to be executed depending on the type of object 
that invokes the function. 

Example: if a parent class function is set to be overridable, 
then a parent class pointer can have functionality of the 
child class object.

A pure virtual function is a function that is declared in 
the parent class and it should be defined in every child classes.

Syntax: virtual void DisplayFunction () = 0;

*/

using namespace std;

class Shape
{
    //By default a member without access-specifier is set to private.
    protected:
        int length;
        int height;

    public:
        //Each child class has to provide its own definition of this method.
        virtual void DisplayInfo() 
        {
            cout &lt;&lt; "This is the parent class." &lt;&lt; endl;
        }
};

class Square: public Shape
{
    private:
        int area;
        void CalcArea()
        {
            area=length*height;
        }

    public:
        Square (int len, int hg)
        {
            length=len;
            height=hg;
            CalcArea();
        };
        
        void DisplayArea()
        {
            cout &lt;&lt; "Area: " &lt;&lt; area &lt;&lt; endl;
        }
        
        //This function overrides the parent class function
        void DisplayInfo()
        {
            cout &lt;&lt; "This is the child class." &lt;&lt; endl;
        }
};

class Circle: public Shape
{
    private:
        int radius;
    
    public:
        Circle(int len)
        {
            radius=len/2;
        }
        void DisplayRadius()
        {
            cout &lt;&lt; "Radius: " &lt;&lt; radius &lt;&lt; endl;
        }
};

int main()
{
    Shape *p;
    Circle circle_object(22);
    Square square_object(4,3);
    
    /*
    The pointer of type Shape can reference any of the 
    Shape class children, but having only 
    the functionality of Shape Class.
    */
    
    p=&#38;circle_object;
    p-&gt;DisplayInfo();
    p=&#38;square_object;
    p-&gt;DisplayInfo();
    
    int a;
    cin &gt;&gt; a;
    return 0;
    
    /*
    Using same variable we accessed different behaviour for 
    each child class.
    */
}
</code>    
        </polymorphism>
        <inheritance>
            *General-Programming-Knowledge*
            <br></br>
            In C++, it is possible to <red>inherit</red> attributes and methods from one <code>class</code> 
            to another. <br></br><br></br>
            <green>
            We group the "inheritance concept" into two categories:
            </green>
            <br></br><br></br>
            <blue>
            - derived class (child) - the class that inherits from another class;<br></br>
            - base class (parent) - the class being inherited from;<br></br><br></br>
            </blue>
            To <red>inherit</red> from a <code>class</code>, use the <blue>:</blue> symbol.<br></br>
<code>
#include &lt;iostream&gt;  
#include &lt;conio.h&gt;  

using namespace std;

//BASE CLASS
class Shape{

    protected: 
    //protected variables are visible into this class and the other classes 
    //that are inherited from this.

    string name;
        
    public:
    Shape(string newname)
    {
        name=newname;
    }
    string getName() const
    {
        return name;
    }
};

//CHILD CLASS ONE
class Circle : public Shape 
//making Circle class derive from the Shape class (setting the inheritance).
{
    //inheritance is a way to make 2 classes share the same variables between each other

    double radius; //this variable can be private, or protected or public (anything).

    public:
        Circle(string inheritedName, double newradius) : Shape (inheritedName)
        //this will call the Shape constructor which will set a value into it's string 
        //variable called 'name', in this way, a variable will be used in 2 classes.
        {
            radius=newradius;
        }
        double getCircleRadius() const
        {
            return radius;
        }

};

//CHILD CLASS TWO
class Rectangle : public Shape 
// making the Rectangle class derive from Shape Class, 
//let the Rectangle Class, use the protected variables of the Shape Class.
{
    double length, width;

    public:
        Rectangle (string inheritedName2, double newlength, double newwidth): Shape (inheritedName2)
        {
            length=newlength;
            width=newwidth;
        }
        double getRectangleLength() const
        {
            return length;
        }
        double getRectangleWidth () const
        {
            return width;
        }
};

int main()
{
    Shape object("Shape Class String"); //create object
    cout &lt;&lt; object.getName() &lt;&lt; endl; //calling a function from the class

    cout &lt;&lt; endl &lt;&lt; "CHILD ONE CLASS: " &lt;&lt; endl;
    
    Circle objectchild ("Circle (stored in Shape Class String)", 3.0); //create object
    
    //calling a function from Shape Class using the object from Circle Class.
    cout &lt;&lt; objectchild.getName() &lt;&lt; endl; 
    cout &lt;&lt; objectchild.getCircleRadius() &lt;&lt; endl;

    cout &lt;&lt; endl &lt;&lt; "CHILD TWO CLASS: " &lt;&lt; endl;
    
    Rectangle objectchild2("Rectangle (stored in Shape Class String)", 20.0, 65.0); //create object
    
    //calling a function from Shape Class using the object from Rectangle Class.
    cout &lt;&lt; objectchild2.getName() &lt;&lt; endl; 
    cout &lt;&lt; objectchild2.getRectangleLength() &lt;&lt; endl;
    cout &lt;&lt; objectchild2.getRectangleWidth() &lt;&lt; endl;

    getch();
    return 0;
}
</code>
        </inheritance>
        <abstraction>
            *General-Programming-Knowledge*
<code>
// Example of Data Abstraction in C++

#include &lt;iostream&gt;  
using namespace std;
 
class implementAbstraction 
{
    private:
        int a, b;
     
    public:
        // method to set values of private members
        void set(int x, int y)
        {
            a = x;
            b = y;
        }
     
        void display()
        {
            cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;
            cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;
        }
};
 
int main()
{
    implementAbstraction obj;
    obj.set(10, 20);
    obj.display();
    return 0;
    
    /*
        OUTPUT:
        a = 10
        b = 20
    */
}
</code>
        </abstraction>
        <generic-programming>
            *General-Programming-Knowledge*
            <br></br>    
            In C++ the <red>templates</red> generalize the algorithm to make it <red>data type-independent</red>.
            <br></br><br></br>

<code>
//Example of generic programming in C++

#include &lt;iostream&gt;  

// Template Function with a Type T
// During instantiation, this T will be replaced by the data type of argument.
template &lt;class T&gt;  
T maxNum (T a, T b) {
 return (a &gt;   b ? a : b); //ternary operator
}

int main()
{
    int x = 5, y = 2;
    float a = 4.5, b = 1.3;
    
    std::cout &lt;&lt; maxNum&lt;int&gt;(x, y) &lt;&lt; "\n";
    std::cout &lt;&lt; maxNum&lt;float&gt;(a, b);
    return 0;
}
</code>
        </generic-programming>
        <variable-arguments-lists>
            *General-Programming-Knowledge*
            <br></br>
            Functions with a variable number of arguments in C++ can be easily implemented using 
            a <red>vector</red> or an <red>array</red> if all the arguments are the same type.
            <br></br><br></br>
            If all arguments are of different types, then we need to use the <code>cstdarg</code> header file 
            to implement <red>variadic functions</red>.
            <br></br><br></br>
            <blue><red>Variadic functions</red> do not put restrictions on the types of arguments. <br></br>
            They also do not perform integer and floating-point enhancements.</blue>
            <br></br>
<code>
// Implementation of variable arguments using vector.

#include &lt;iostream&gt; 
#include &lt;vector&gt; 
using namespace std;

// Using vector of string as a parameter to store a variable number of strings.

void printNames(vector&lt;string&gt;  nameVector) {
    for (string &#38;name : nameVector) {
        cout &lt;&lt; name &lt;&lt; " ";
    }
    cout &lt;&lt; '\n';
}

int main() {
    printNames({"Scaler", "Topics"});
    printNames({"Technopedia", "for", "your", "mastermind!"});
    return 0;
}
</code>

<code>
// Implementation of variable arguments using cstdarg variadic functons.

#include &lt;iostream&gt; 
#include &lt;cstdarg&gt; 

using namespace std;

void printDeveloperData(const char* fmt...) {
    va_list args;
    va_start(args, fmt);
 
    while (*fmt != '\0') 
    {
        if (*fmt == 'd') 
        {
            int version = va_arg(args, int);
            std::cout &lt;&lt; "C++ Version: " &lt;&lt; version;
        } 
        else if (*fmt == 'c') 
        {
            int name = va_arg(args, int);
            std::cout &lt;&lt; "Name: " &lt;&lt; static_cast&lt;char&gt; (name);
        } 
        else if (*fmt == 'f') 
        {
            double stability_percentage = va_arg(args, double);
            std::cout &lt;&lt; "Stability Percentage: " &lt;&lt; stability_percentage &lt;&lt; "%";
        }
        ++fmt;
        cout &lt;&lt; '\n';
    }
 
    va_end(args);
}
 
int main() {
    printDeveloperData("cdf", 'B', 20, 94.7);
    
    return 0;

}
</code>

<code>
// Implementation of variable arguments using variadic templates.

#include &lt;iostream&gt; 
using namespace std;

template &lt;typename T&gt; 
void printDeveloperData(T t) {
    cout &lt;&lt; t &lt;&lt; '\n' ;
}

template&lt;typename T, typename... Args&gt; 
void printDeveloperData(T t, Args... args) {
    cout &lt;&lt; t &lt;&lt; '\n';
    printDeveloperData(args...) ;
}

int main() {
    printDeveloperData("Bjarne", 20, 94.7);
}
</code>
        </variable-arguments-lists>
        <simple-data-types>
            All <red>variables</red> use data type during declaration to <blue>restrict</blue> the type of data to 
            be stored. <br></br>
            Therefore, we can say that data types are used to tell the variables 
            the type of data they can store. <br></br><br></br>
            Whenever a <red>variable</red> is defined in C++, 
            the compiler allocates some memory for that <red>variable</red> based on the data type 
            with which it is declared. <br></br><br></br>
            Every data type requires a different amount of memory.
            <br></br><br></br>
            <green>The datatypes presented on C Language are still available in C++:</green>
            <br></br><br></br>
            *General-Programming-Knowledge*
            <br></br><br></br>
            <green>Primitive Datatypes:</green><br></br><br></br>
            <blue>
            Integer<br></br>
            Character<br></br>
            Boolean<br></br>
            Floating Point<br></br>
            Double Floating Point<br></br>
            Valueless or Void<br></br>
            Wide Character<br></br>
            </blue>
            <br></br>
        </simple-data-types>
        <complex-data-types>
            *General-Programming-Knowledge*
            <br></br>
            <brown>Aditional to the C Language, C++ introduced classes as a user-defined datatype. </brown>
            <br></br><br></br>
            <green>Derived Datatypes:</green><br></br>
            <blue>
            Function<br></br>
            Array<br></br>
            Pointer<br></br>
            Reference<br></br>
            </blue>
            <br></br>
            <green>User-defined Datatypes:</green><br></br>
            <blue>
            Class<br></br>
            Structure<br></br>
            Union<br></br>
            Enumeration<br></br>
            Typedef defined Datatype<br></br>
            </blue>
        </complex-data-types>
        <preprocessor-directives>
            *General-Programming-Knowledge*
        </preprocessor-directives>
        <loops>
            *General-Programming-Knowledge*
            <br></br>
            Additional to the loops presented in C language, there is also a <red>"for-each loop"</red> 
            <blue>(introduced in C++ version 11 (2011)</blue>, which is used exclusively to loop through 
            elements in an array (or other data sets):
<code>
/*Example of foreach loop in C++*/

int myNumbers[5] = {10, 20, 30, 40, 50};

for (int i : myNumbers) 
{
  cout &lt;&lt;  i &lt;&lt;  "\n";
}
</code>
        </loops>
        <collections>
            *General-Programming-Knowledge*
            <br></br>
            Additional to C Language: C++ introduced several new <red>collection classes datatypes</red>:
            <br></br><br></br>
            <green>
                Vector: 
            </green>
            <br></br><br></br>
            The C++ Standard Library vector class is a class template for sequence containers.<br></br>
            <br></br>
            <blue>
            Vector is a type of <red>dynamic array</red> which has the ability to <red>resize 
            automatically</red> after insertion or deletion of elements. <br></br>
            The elements in <code>vector</code> 
            are placed in contiguous storage so that they can be accessed and traversed using 
            <red>iterators</red>. <br></br>
            Element is inserted at the end of the <code>vector</code>.<br></br><br></br>
            </blue>
<code>
#include &lt;iostream&gt; 
#include &lt;vector&gt; 
 
int main()
{
    // Create a vector containing integers
    std::vector&lt;int&gt;  v = {8, 4, 5, 9};
 
    // Add two more integers to vector
    v.push_back(6);
    v.push_back(9);
 
    // Overwrite element at position 2
    v[2] = -1;
 
    // Print out the vector
    for (int n : v)
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
</code>    
        <green>
        List: 
        </green>
        <br></br><br></br>
        <blue>
        List is a <red>double linked sequence</red> that supports both forward and backward 
        traversal. <br></br>
        The time taken in the insertion and deletion in the beginning, end 
        and middle is constant.<br></br> 
        It has the <red>non-contiguous memory</red> and there is no 
        pre-allocated memory.<br></br>
        </blue>
<code>
// C++ program to demonstrate the use of list containers

#include &lt;iostream&gt; 
#include &lt;list&gt; 
using namespace std;
 
int main()
{
    // defining list
    list&lt;int&gt;  gqlist{12,45,8,6};
 
    for (auto i : gqlist) {
        cout &lt;&lt; i &lt;&lt; ' ';
    }
    return 0;
}
</code>
        </collections>
        <collection-methods>
            Some of the methods available in C++ for the <blue>Collection Type Classes</blue>: 
            <red>Vector</red> or <red>List</red> are:
            <br></br><br></br>
            <green>Capacity:</green><br></br>
            <code>size()    </code><br></br>Return size<br></br><br></br>
            <code>max_size()</code><br></br>Return maximum size<br></br><br></br>
            <code>resize()    </code><br></br>Change size<br></br><br></br>
            <code>capacity()</code><br></br>Return size of allocated storage capacity<br></br><br></br>
            <code>empty()    </code><br></br>Test whether vector is empty<br></br><br></br>
            <code>reserve()    </code><br></br>Request a change in capacity<br></br><br></br>
            <code>shrink_to_fit()</code><br></br>Shrink to fit<br></br><br></br>
            <br></br>
            <green>Element access:</green><br></br>
            <code>operator[]</code><br></br>Access element<br></br><br></br>
            <code>at()</code><br></br>Access element<br></br><br></br>
            <code>front()</code><br></br>Access first element<br></br><br></br>
            <code>back()</code><br></br>Access last element<br></br><br></br>
            <code>data()</code><br></br>Access data<br></br><br></br>
            <br></br>
            <green>Modifiers:</green><br></br>
            <code>assign()</code><br></br>Assign vector content<br></br><br></br>
            <code>push_back()</code><br></br>Add element at the end<br></br><br></br>
            <code>pop_back()</code><br></br>Delete last element<br></br><br></br>
            <code>insert()</code><br></br>Insert elements<br></br><br></br>
            <code>erase()</code><br></br>Erase elements<br></br><br></br>
            <code>swap()</code><br></br>Swap content<br></br><br></br>
            <code>clear()</code><br></br>Clear content<br></br><br></br>
            <code>emplace()</code><br></br>Construct and insert element<br></br><br></br>
            <code>emplace_back()</code><br></br>Construct and insert element at the end<br></br><br></br>
        </collection-methods>
        <dynamic-memory-allocation>
            *General-Programming-Knowledge*
            <br></br>
            <green>
            Additional to the C language: 
            </green>
            <br></br><br></br>
            C++ integrates the operators <code>new</code> and <code>delete</code> for allocating dynamic memory.
            <br></br><br></br>
            <red>Operators new and new[]: </red>
            <br></br><br></br>
            <red>Dynamic memory</red> is allocated using operator <code>new</code>. <br></br>
            <code>new</code> is followed by a <red>data 
            type</red> specifier and, if a sequence of more than one element is required, 
            the number of these within brackets <code>[]</code>. <br></br>
            It returns a pointer to the beginning of the new block of memory allocated. <br></br>
<code>
//Example:

int * foo;
foo = new int [5];
</code>
        In this case, the system <red>dynamically allocates space</red> for five elements of type <code>int</code> 
        and <red>returns</red> a pointer to the first element of the sequence, which is assigned to 
        <code>foo</code> (a pointer). <br></br><br></br>
        Therefore, <code>foo</code> now points to a valid block of memory with space 
        for five elements of type <code>int</code>.<br></br>
        <br></br>
        <red>Operators delete and delete[]: </red>
        <br></br><br></br>
        In most cases, <red>memory allocated dynamically</red> is only needed during specific periods 
        of time within a program; once it is no longer needed, it can be <red>freed</red> so that 
        the memory becomes available again for other requests of <red>dynamic memory</red>. <br></br>
        <br></br>
        This is the purpose of operator <code>delete</code>, whose syntax is: <br></br>
<code>
// Example of dynamic allocation
// and deallocation of memory using new and delete

#include &lt;iostream&gt; 
using namespace std;

int main()
{
    // Pointer initialization to null
    int* p = NULL;

    // Request memory for the variable
    // using new operator
    p = new (nothrow) int;
    if (!p)
        cout &lt;&lt; "allocation of memory failed\n";
    else {
        // Store value at allocated address
        *p = 29;
        cout &lt;&lt; "Value of p: " &lt;&lt; *p &lt;&lt; endl;
    }

    // Request block of memory
    // using new operator
    float* r = new float(75.25);

    cout &lt;&lt; "Value of r: " &lt;&lt; *r &lt;&lt; endl;

    // Request block of memory of size n
    int n = 5;
    int* q = new (nothrow) int[n];

    if (!q)
        cout &lt;&lt; "allocation of memory failed\n";
    else {
        for (int i = 0; i &lt; n; i++)
            q[i] = i + 1;

        cout &lt;&lt; "Value store in block of memory: ";
        for (int i = 0; i &lt; n; i++)
            cout &lt;&lt; q[i] &lt;&lt; " ";
    }

    // freed the allocated memory
    delete p;
    delete r;

    // freed the block of allocated memory
    delete[] q;

    return 0;
    
    /*
        OUTPUT:
        Value of p: 29
        Value of r: 75.25
        Value store in block of memory: 1 2 3 4 5 
    */
}
</code>
        </dynamic-memory-allocation>
        <read-from-file>
            *General-Programming-Knowledge*
            The <code>fstream</code> library can be used in C++ to work with files.
            <br></br><br></br>
            There are three classes included in the <code>fstream</code> library, 
            which are used to <red>create</red>, <red>write</red> or <red>read</red> files:
            <br></br><br></br>
            <green>Class description:</green><br></br><br></br>
            <red>ofstream</red> - Creates and writes to files.<br></br>
            <red>ifstream</red> - Reads from files.<br></br>
            <red>fstream</red>  - A combination of <code>ofstream</code> and <code>ifstream</code>: 
            <red>creates</red>, <red>reads</red>, and <red>writes</red> to files.
            <br></br><br></br>
            To <red>read</red> from a file, use either the <code>ifstream</code> or <code>fstream class</code>, and the name of the file.
            <br></br><br></br>
            <blue>Note: we also use a <code>while</code> loop together with the <code>getline()</code> function 
            (which belongs to the <code>ifstream</code> class) to read the file line by line, and to print 
            the content of the file:</blue>
            <br></br>
<code>
// Create a text string, which is used to output the text file

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;

int main() 
{
    string myText;

    // Read from the text file
    ifstream MyReadFile("filename.txt");

    // Use a while loop together with the getline() 
    //to read the file line by line
    while (getline (MyReadFile, myText)) 
    {
      // Output the text from the file
      cout &lt;&lt; myText;
    }

    // Close the file
    MyReadFile.close(); 
    //It is considered good practice to close the file, 
    //and it can clean up unnecessary memory space.
}
</code>
        </read-from-file>
        <write-to-file>
            The <code>fstream</code> library can be used in C++ to work with files.
            <br></br><br></br>
            There are three classes included in the <code>fstream</code> library, which are used to 
            <red>create</red>, 
            <red>write</red> or <red>read</red> files:
            <br></br><br></br>
            <green>Class description:</green><br></br><br></br>
            <red>ofstream</red> - Creates and writes to files.<br></br>
            <red>ifstream</red> - Reads from files.<br></br>
            <red>fstream</red> - A combination of <red>ofstream</red> and <red>ifstream</red>: 
            <red>creates</red>, <red>reads</red>, and <red>writes</red> to files.
            <br></br><br></br>
            <red>Create and Write To a File:</red>
            <br></br><br></br>
            To create a file, use either the <red>ofstream</red> or <red>fstream</red> class, and specify 
            the name of the file.
            <br></br><br></br>
            To write to the file, use the insertion operator (<code>&lt;&lt;</code>).<br></br>
<code>
//Example of writing to file using fstream in C++

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;

int main() 
{
    // Create and open a text file
    ofstream MyFile("filename.txt");

    // Write to the file
    MyFile &lt;&lt; "Files can be tricky, but it is fun enough!";

    // Close the file
    MyFile.close(); 
    //It is considered good practice to close the file, 
    //and it can clean up unnecessary memory space.
}
</code>
        </write-to-file>
        <serialization>
            *General-Programming-Knowledge*
            <br></br>
            Storing the state of an object to a file:<br></br>
<code>
/*Example of C++ object.field serialization and deserialization*/

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;

class Student 
{
    public:
    
    string name;
    int rollno;
    string branch;

    Student () // default constructor
    {
    } 
    
    Student (string n, int r, string b) // overloading constructor
    {
        name = n;
        rollno = r;
        branch = b;
    }
    
    //override the insertion operator for object.field serialization
    friend ofstream &#38; operator &lt;&lt; (ofstream &#38; ofs, Student s);
    //now we can write individually every class field member to the file.
    //Example: ofs &lt;&lt; s1.name; 
    
    //override the extraction for object.field deserialization
    friend ifstream &#38; operator &gt;&gt; (ifstream &#38; ifs, Student &#38; s);
    //now we can read individually every class field member from the file. 
    //Example: ifs &gt;&gt; s1.name; 
};

int main() 
{
    Student s1 ("James", 28, "IT");

    //Open the output stream
    ofstream ofs ("Student.txt", ios::trunc);

    //writing to the file
    ofs &lt;&lt; s1.name &lt;&lt; endl;
    ofs &lt;&lt; s1.rollno &lt;&lt; endl;
    ofs &lt;&lt; s1.branch &lt;&lt; endl;
    ofs.close();

    Student s2; //empty object

    //Open the input stream
    ifstream ifs("Student.txt");

    //reading from the file
    ifs &gt;&gt; s2.name;
    ifs &gt;&gt; s2.rollno;
    ifs &gt;&gt; s2.branch;
    ifs.close();

    cout &lt;&lt; s2.name &lt;&lt; endl;
    cout &lt;&lt; s2.rollno &lt;&lt; endl;
    cout &lt;&lt; s2.branch &lt;&lt; endl;

    /*
        OUTPUT: 
        James 
        28 
        IT
    */
}
</code>
        </serialization>
        <deserialization>
            *General-Programming-Knowledge*
            <br></br>
            Deserialization is the reverse process of Serialization, 
            where the <red>byte stream</red> is used to reconstruct the original object.<br></br>
<code>
/*Example of C++ whole-object serialization and deserialization*/

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;
class Student
{
    public:
    
    string name;
    int rollno;
    string branch;
    Student () // default constructor
    {
    }
    
    Student (string n, int r, string b) // overloading constructor
    {
        name = n;
        rollno = r;
        branch = b;
    }

    //override the insertion operator for object.field serialization
    friend ofstream &#38; operator &lt;&lt; (ofstream &#38; ofs, Student s);
    //now we can write individually every class field member to the file. 
    //Example: ofs &lt;&lt; s1.name; 
    
    //override the extraction for object.field deserialization
    friend ifstream &#38; operator &gt;&gt; (ifstream &#38; ifs, Student &#38; s);
    //now we can read individually every class field member from the file. 
    //Example: ifs &gt;&gt; s1.name; 
};

//Overriding the operators for whole-object serialization and deserialization
ofstream &#38;  operator &lt;&lt; (ofstream &#38; ofs, Student s)
{
    ofs &lt;&lt; s.name &lt;&lt; endl;
    ofs &lt;&lt; s.rollno &lt;&lt; endl;
    ofs &lt;&lt; s.branch &lt;&lt; endl;
    return ofs;
}
ifstream &#38; operator &gt;&gt; (ifstream &#38; ifs, Student &#38; s)
{
    ifs &gt;&gt; s.name &gt;&gt; s.rollno &gt;&gt; s.branch;
    return ifs;
}

/*
now we can read/write the whole object to and from the file. 

Example: 
ofs &lt;&lt; s1; 
ifs &gt;&gt; s2; 

*/

int main()
{
    Student s1("James", 28, "IT");

    //Open the output stream
    ofstream ofs("Student.txt", ios::trunc);
    ofs &lt;&lt;  s1;
    ofs.close();

    Student s2; // empty object

    //Open the input stream
    ifstream ifs("Student.txt");
    ifs &gt;&gt; s2;
    ifs.close();
        
    cout &lt;&lt; s2.name &lt;&lt; " " &lt;&lt; s2.rollno &lt;&lt; " " &lt;&lt; s2.branch &lt;&lt; endl;

    /*
        OUTPUT:
        James 28 IT
    */
}
</code>
        </deserialization>
        <constructors>
            *General-Programming-Knowledge*
<code>
/*Example of constructor in C++*/

#include &lt;iostream&gt; 

using namespace std;

class MyClass   // The class
{     
    public:           // Access specifier
        MyClass()     // Constructor
        {     
            /*
            The constructor has the same name as the class, 
            it is always public, 
            and it does not have any return value.
            */

              cout &lt;&lt; "Hello World!";
        }
};

int main() 
{
      MyClass myObj; 
      // Create an object of MyClass (this will call the constructor)
      return 0;
}
</code>
        </constructors>
        <instantiation>
            *General-Programming-Knowledge*
<code>
/*Example of instantiation*/

#include &lt;stdio.h&gt; 

class MyClass{

public:
    MyClass(){}
    void PrintMessage()
    {
        printf("Message from class member.\n");
    }
};

int main()
{
    //Instantiating the class:
    MyClass obj; 
    obj.PrintMessage();

    return 0;
}
</code>
        </instantiation>
        <destructors>
            *General-Programming-Knowledge*
<code>
class Test {
public:
    // User-Defined Constructor
    Test() { cout &lt;&lt; "\n Constructor executed"; }
 
    // User-Defined Destructor
    ~Test() { cout &lt;&lt; "\n Destructor executed"; }
};
</code>
        </destructors>
        <function-overloading>
            *General-Programming-Knowledge*
<code>
/*Example of function overloading*/

#include &lt;iostream&gt; 
using namespace std;
 
 
void add(int a, int b)
{
  cout &lt;&lt; "sum = " &lt;&lt; (a + b);
}
 
void add(double a, double b)
{
    cout &lt;&lt; endl &lt;&lt; "sum = " &lt;&lt; (a + b);
}
 
int main()
{
    add(10, 2); //calling function with ints
    add(5.3, 6.2); //calling function with floats
 
    return 0;
}
</code>
        </function-overloading>
        <operator-overloading>
            *General-Programming-Knowledge*
<code>
// Example of Operator Overloading

#include &lt;iostream&gt; 
using namespace std;
 
class Complex 
{
    private:
        int real, imag;
     
    public:
        Complex(int r = 0, int i = 0)
        {
            real = r;
            imag = i;
        }
     
        // This is automatically called when '+' is used with
        // between two Complex objects
        Complex operator+(Complex const    &#38; obj)
        {
            Complex res;
            res.real = real + obj.real;
            res.imag = imag + obj.imag;
            return res;
        }
        void print() { cout &lt;&lt; real &lt;&lt; " + i" &lt;&lt; imag &lt;&lt; '\n'; }
};
 
int main()
{
    Complex c1(10, 5), c2(2, 4);
    Complex c3 = c1 + c2;
    c3.print();
    
    /*
        OUTPUT:
        12 + i9
    */
}
</code>
        </operator-overloading>
        <enums>
            *General-Programming-Knowledge*
            <green>Comparison to C Language: </green>
            <br></br><br></br>
            In C, an enum is basically a way to <red>alias names</red> to integers. 
            This does not lead to 
            improved type checking. <br></br>
            In C++, an enum defines an actual type, which results in 
            <red>strong type checking</red>.<br></br>
<code>
#include &lt;iostream&gt; 
#include &lt;conio.h&gt; 

using namespace std;

/*
While processing a game loop, there are lots of statements to be checked, 
so in order to use those statements, 
variables that will hold a certain value will be created. 

Example:
int GamePlay =1;
int PauseGame = 2;
int ExitGame = 3;

So in this way the statements can be checked, 
to see when the game should be paused, should run, or should exit. 
As you see above, the variables that are used needs to have different values.

An enum is a way to enclose a bunch of constants, 
An enum guarantees that every variable inside it, will have different values.

Example: an enum with the variables above, can be created as follows:
enum GameStates {GamePlay, PauseGame, ExitGame};

So the synthax is:
enum &lt;name&gt; {states/members};
*/

//Creating a GLOBAL enum:
enum GameStates {GamePlay, PauseGame, ExitGame}; 
//the elements will take as constant value the position inside the enum;
//In this case: GamePlay = 0; PauseGame=1; ExitGame=2;

/*

enum members cannot be initialized with values: 
Example GamePlay = 5, this will give compilation error.

Instead the enum can be initialized only as follows:
GameStates=ExitGame;

In this case the active value of the enum will be ExitGame;
The syntax is : &lt;enum name&gt; = &lt;enum member&gt;;

An enum class is an enum that will use the scope resolution and 
an object of the enum class for assignments as above.

Example:
GameStates gameStates=GameStates::ExitGame;

An enum class will make possible that you can have multiple 
enums with the same members. 

So we could have for example:
enum class GameState {Exit, MainMenu};
enum class SoftwareState (Exit, MainMenu);

Without using an enum class this could not be possible because, 
the 2 members will conflict to each other
(compilation error).

Syntax to create an enum class:

enum class &lt;name&gt; { member1, member2...}
An enum cannot be forward declared, unless it's an enum class. 
So only enum classes can be forward declared.

To change the default value of an ENUM Member which consist in it's position 
on the enum, you can do as follows:

enum GameState {MainMenu=5, GamePlay=7, GameExit, GamePaused}; 
//the two uninitialized members follow gets the value of the
previous member+1; so GameExit will be 8, GamePause will be 9;

*/

int main()
{
    cout &lt;&lt; "GamePlay value: " &lt;&lt; GamePlay &lt;&lt; endl; // this is 0;
    cout &lt;&lt; "PauseGame value: " &lt;&lt; PauseGame &lt;&lt; endl; // this is 1;
    cout &lt;&lt; "ExitGame value: " &lt;&lt; ExitGame &lt;&lt; endl; // this is 2;
    getch();
    return 0;
}
</code>
        </enums>
        <concurrent-programming>
            *General-Programming-Knowledge*
            <br></br>
            C++ <red>multithreading</red> involves creating and using <red>thread</red> objects, seen as <code>std::thread</code> 
            in code, to carry out delegated sub-tasks independently. <br></br>
            New <red>threads</red> are passed a 
            function to complete, and optionally some parameters for that function.
            <br></br>
<code>
#include &lt;iostream&gt; 
#include &lt;cstdlib&gt; 
#include &lt;pthread.h&gt; 

using namespace std;

#define NUM_THREADS 5

void *PrintHello(void *threadid) 
{
   long tid;
   tid = (long)threadid;
   cout &lt;&lt; "Hello World! Thread ID, " &lt;&lt; tid &lt;&lt; endl;
   pthread_exit(NULL);
}

int main () 
{
   pthread_t threads[NUM_THREADS];
   int rc;
   int i;
   
   for( i = 0; i &lt; NUM_THREADS; i++ ) 
   {
      cout &lt;&lt; "main() : creating thread, " &lt;&lt; i &lt;&lt; endl;
      rc = pthread_create(&#38;threads[i], NULL, PrintHello, (void *)i);
      
      if (rc) 
      {
         cout &lt;&lt; "Error:unable to create thread," &lt;&lt; rc &lt;&lt; endl;
         exit(-1);
      }
   }
   pthread_exit(NULL);
}
</code>
        <br></br>
        In C/C++: one of the main workhorse functions that makes <blue>multiprocessing</blue> 
        possible is <code>fork()</code>.
        <br></br><br></br>
        <code>fork()</code> is a function that clone a <red>process</red>, spawning an identical 
        copy of it.
        <br></br>
<code>
//Example of multi-processing in C/C++:

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/wait.h&gt;

int main(int argc, char ** argv)
{
    pid_t pid = fork();
    
    if (pid == 0) 
    { 
        //we are in the child process
        printf("Hello from the child process!\n");
        exit (0); 
        //terminates the child process
    } 
    else 
    {
        //now in the parent process
        waitpid(pid, NULL, 0);
        printf("The child process has exited. Hello from the parent!\n");
    }
    return 0;
}
</code>
        </concurrent-programming>
        <namespaces>
            *General-Programming-Knowledge*
            <br></br>
            <brown>
            In C++ multiple namespace blocks 
            with the same name are allowed.<br></br>
            </brown>
<code>
namespace Data
{
    class ObjectManager
    {
    public:
        void DoSomething() {}
    };
    void Func(ObjectManager) {}
}
</code>
        </namespaces>
        <exception-handling>
            *General-Programming-Knowledge*
            <br></br>
<code>
// C++ example on how to use of try,catch and throw
// for exception handling.
 
#include &lt;iostream&gt; 
#include &lt;stdexcept&gt; 
using namespace std;
 
int main()
{
 
    // try block
    try 
    {
        int numerator = 10;
        int denominator = 0;
        int res;
 
        // check if denominator is 0 then throw runtime
        // error.
        if (denominator == 0) 
        {
            throw runtime_error(
                "Division by zero not allowed!");
        }
 
        // calculate result if no exception occurs
        res = numerator / denominator;
        //[printing result after division
        cout &lt;&lt; "Result after division: " &lt;&lt; res &lt;&lt; endl;
    }
    // catch block to catch the thrown exception
    catch (const exception&#38; e) 
    {
        // print the exception
        cout &lt;&lt; "Exception " &lt;&lt; e.what() &lt;&lt; endl;
    }
 
    return 0;
}
</code>
        </exception-handling>
        <bitwise-operators>
            *General-Programming-Knowledge*
            <br></br>
            Bitwise operators in C/C++ are 
            tools for working with individual <red>bits</red> in data. <br></br>
            <br></br>
            They might not be as famous as other 
            operators, but they’re essential for tasks like making code more <red>efficient</red> or 
            <red>controlling hardware</red>.
        </bitwise-operators>
        <default-parameters>
            *General-Programming-Knowledge*
<code>
// Example of Default Parameters/Arguments in C++.

#include &lt;iostream&gt; 
using namespace std;
 
// A function with default arguments,
// it can be called with
// 2 arguments or 3 arguments or 4 arguments.

//assigning default values to z,w as 0
int sum(int x, int y, int z = 0, int w = 0) 
{
    return (x + y + z + w);
}
 
int main()
{
    // Statement 1
    cout &lt;&lt; sum(10, 15) &lt;&lt; endl;
   
    // Statement 2
    cout &lt;&lt; sum(10, 15, 25) &lt;&lt; endl;
   
    // Statement 3
    cout &lt;&lt; sum(10, 15, 25, 30) &lt;&lt; endl;
    return 0;
}
</code>
        </default-parameters>
        <interfaces>
            *General-Programming-Knowledge*
<code>
/*Example of an interface implementation*/

class Box 
{
   public:
        // pure virtual function
        virtual double getVolume() = 0;
      
   private:
        //Length of a box
        double length;
        
        //Breadth of a box
        double breadth;
        
        //Height of a box
        double height; 
};
</code>
        </interfaces>
        <abstract-classes>
            *General-Programming-Knowledge*
<code>
/*Example of abstract class*/

#include &lt;iostream&gt; 
 
using namespace std;
 
// Base class
class Shape {
   public:
      // pure virtual function providing interface framework.
      virtual int getArea() = 0;
      void setWidth(int w) {
         width = w;
      }
   
      void setHeight(int h) {
         height = h;
      }
   
   protected:
      int width;
      int height;
};
 
// Derived classes
class Rectangle: public Shape {
   public:
      int getArea() { 
         return (width * height); 
      }
};

class Triangle: public Shape {
   public:
      int getArea() { 
         return (width * height)/2; 
      }
};
 
int main(void) {
   Rectangle Rect;
   Triangle  Tri;
 
   Rect.setWidth(5);
   Rect.setHeight(7);
   
   // Print the area of the object.
   cout &lt;&lt; "Total Rectangle area: " &lt;&lt; Rect.getArea() &lt;&lt; endl;

   Tri.setWidth(5);
   Tri.setHeight(7);
   
   // Print the area of the object.
   cout &lt;&lt; "Total Triangle area: " &lt;&lt; Tri.getArea() &lt;&lt; endl; 

   return 0;
}
</code>
        
        </abstract-classes>
        <macros>
            *General-Programming-Knowledge*
            <green>Similar to C Language:</green> 
            <br></br><br></br>
            A C++ <red>macro</red> is defined as a section of code that that particular <red>macro</red> value can 
            replace. <br></br><br></br>
            We can define the <red>macro</red> by using a <code>#define</code> directive.<br></br> 
            When the compiler goes to the <red>macros</red> while program compilation, 
            the <red>macro</red>'s name is replaced by the definition of the <red>macro</red>. 
            <br></br><br></br>
            The termination of the C++ <red>Macros</red> does not need a 
            semi-colon (;).
            <br></br><br></br>
            <blue>Additionally to the C Language:</blue><br></br>
            The header file: <code>&lt;limits.h&gt;</code> 
            is defined to help finding 
            the range of fundamental <red>data-types</red>. <br></br>
             <br></br>
            <red>Unsigned</red> modifiers have minimum value is <blue>zero</blue>. 
            So, no <red>macro</red> constants are defined for the <red>unsigned minimum value</red>.
            <br></br><br></br>
            <green>
            Macro Constants:<br></br><br></br>
            </green>
            <red>
            <blue>CHAR_MIN</blue>  - The minimum value for an object of type char; <br></br><br></br>    
            <blue>CHAR_MAX</blue>  - Maximum value for an object of type char; <br></br><br></br>        
            <blue>SCHAR_MIN</blue>  - The minimum value for an object of type Signed char; <br></br><br></br>    
            <blue>SCHAR_MAX</blue>  - Maximum value for an object of type Signed char; <br></br><br></br>        
            <blue>UCHAR_MAX</blue>  - Maximum value for an object of type Unsigned char; <br></br><br></br>        
            <blue>CHAR_BIT</blue>  - Number of bits in a char object; <br></br><br></br>        
            <blue>MB_LEN_MAX</blue>  - Maximum number of bytes in a multi-byte character; <br></br><br></br>        
            <blue>SHRT_MIN</blue>  - The minimum value for an object of type short int; <br></br><br></br>        
            <blue>SHRT_MAX</blue>  - Maximum value for an object of type short int; <br></br><br></br>        
            <blue>USHRT_MAX</blue>  - Maximum value for an object of type Unsigned short int; <br></br><br></br>        
            <blue>INT_MIN</blue>  - The minimum value for an object of type int; <br></br><br></br>        
            <blue>INT_MAX</blue>  - Maximum value for an object of type int; <br></br><br></br>        
            <blue>UINT_MAX</blue>  - Maximum value for an object of type Unsigned int; <br></br><br></br>    
            <blue>LONG_MIN</blue>  - The minimum value for an object of type long int; <br></br><br></br>        
            <blue>LONG_MAX</blue>  - Maximum value for an object of type long int; <br></br><br></br>        
            <blue>ULONG_MAX</blue>  - Maximum value for an object of type Unsigned long int; <br></br><br></br>        
            <blue>LLONG_MIN</blue>  - The minimum value for an object of type long long int; <br></br><br></br>        
            <blue>LLONG_MAX</blue>  - Maximum value for an object of type long long int; <br></br><br></br>    
            <blue>ULLONG_MAX</blue> - Maximum value for an object of type Unsigned long long int;<br></br>            
            </red>
<code>
/*An example of defining a C++ macro:*/

using namespace std;
 
// Here is the definition of macro.
#define AREA(l, b) (l * b)

int main() {
    // The given lengths are l1 and l2.
    int l1 = 20, l2 = 2, area;
 
    // Here, finding the area using macro.
    area = AREA(l1, l2);
 
    return 0;
}
</code>
        </macros>
        <defines>*General-Programming-Knowledge*</defines>
        <random-generators>
            *General-Programming-Knowledge*
            <br></br><br></br>
            <green>For C++:</green>
            <br></br><br></br>
            <code>rand()</code> function is an inbuilt function in <red>C++ Standard Library</red>, which is defined in 
            header file <code>&lt;cstdlib&gt;</code>. <br></br><br></br>

            The <code>rand()</code> function is 
            used in C++ to generate random numbers in the range <code>[0, RAND_MAX)</code>.
            <br></br><br></br>
            The <red>random number</red> is generated by using an algorithm that gives a series of 
            non-related numbers whenever this function is called.
            <br></br><br></br>
            <red>Syntax of rand():</red><br></br>
            <code>int rand(void);</code><br></br><br></br>
            <red>Parameters of rand():</red><br></br>
            This function does not take any parameters.<br></br><br></br>
            <red>Return Value of rand():</red><br></br>
            <code>rand()</code> returns a pseudo-random number in the range of <code>[0, RAND_MAX)</code>.
            <br></br>
<code>
// C++ program to demonstrate 
//  the use of rand() 

#include &lt;cstdlib&gt; 
#include &lt;iostream&gt;  
using namespace std; 
  
int main() 
{ 
    // This program will create some sequence of 
    // random numbers on every program run 
    for (int i = 0; i &lt; 5; i++) 
        cout &lt;&lt; rand() &lt;&lt; " "; 

    return 0; 
}
</code>
            <code>srand()</code> function is also available in C++.<br></br>
            This function sets the
            <red>seed</red> which is used by <red>rand</red> to generate <red>"random"</red> numbers.
        </random-generators>
        <command-line-arguments>
            *General-Programming-Knowledge*
<code>
//Example of command line arguments in C++:

int main(int argc, char *argv[])
{
     // Suitable Code
     return 0;
}
</code>
        </command-line-arguments>
        <ternary-operator>*General-Programming-Knowledge*</ternary-operator>
        <modular-programming>*General-Programming-Knowledge*
            <br></br>
            <green>Example of modular programming in C++:</green>
<code>
//FILE: vectors_of_objects_mainfile.cpp
//In this file we put everything together

#include "vectors_of_objects_class.h" 
//by this inclusion we get access to: vectors_of_objects_class

//Function prototyping or declaration
void createObjects(vector &lt;vectors_of_objects_class&gt;&#38;);
void printObjectsInfo(const vector &lt;vectors_of_objects_class&gt;&#38;); 

//The main function is the entry point of the program
int main()
{
    //creating a vector of objects;
    vector &lt;vectors_of_objects_class&gt; ObjectVector; 
    
    //Calling the function that populates the vector of objects.
    createObjects(ObjectVector);
    
    //Calling the function that prints out the vector of objects.
    printObjectsInfo(ObjectVector);
    return 0;
}

//Function definition
void createObjects(vector &lt;vectors_of_objects_class&gt;&#38; newObjVec)
{
    int age;
    string name;
    cout &lt;&lt; "How many people do you wish to add? ";
    int people;
    cin &gt;&gt; people;
    for(int i=0;i&lt;people;i++)
    {
        cout &lt;&lt; "People_" &lt;&lt; i &lt;&lt; " Name: ";
        cin &gt;&gt; name; //get the name from the keyboard
        cout &lt;&lt; "People_" &lt;&lt; i &lt;&lt; " Age: ";
        cin &gt;&gt; age; //get the age from the keyboard
        
         //creating the object with self made constructor
        vectors_of_objects_class ObjectInVector(name, age);
        
         //calling the class functions
        ObjectInVector.setAge(age);
        ObjectInVector.setName(name);
        newObjVec.push_back(ObjectInVector);
    }
    cout &lt;&lt; endl;
}

//defining the function
void printObjectsInfo(const vector &lt;vectors_of_objects_class&gt;&#38; newObjVec) 
{
    unsigned int sizeOfVector=newObjVec.size();
    for(int i=0;i&lt;sizeOfVector; i++)
    {
        cout &lt;&lt; "People_" &lt;&lt; i &lt;&lt; " Name: " &lt;&lt; newObjVec[i].getName() &lt;&lt; endl;
        cout &lt;&lt; "People_" &lt;&lt; i &lt;&lt; " Age: " &lt;&lt; newObjVec[i].getAge() &lt;&lt; endl;
    }
}

</code>

<code>
//FILE: vectors_of_objects_class.cpp
//In this file we implement the vectors_of_objects_class interface

#include "vectors_of_objects_class.h"

//Implementing the custom vector class interface

//Adding a default constructor
vectors_of_objects_class::vectors_of_objects_class() //default constructor
{
    //constructor
}

//Adding an overloading constructor that takes 2 arguments
vectors_of_objects_class::vectors_of_objects_class(string name, int age) 
{
    //initializing the variables;
    newage=0;
}

//Adding a default destructor
vectors_of_objects_class::~vectors_of_objects_class()
{
    //destructor
}

//Adding methods

//getter defined to access the private variable of the class
string vectors_of_objects_class::getName() const 
{
    return newname;
}

//getter defined to access the private variables of the class
int vectors_of_objects_class::getAge() const 
{
    return newage;
}

//setter defined to set the private variables of the class
void vectors_of_objects_class::setName(string name) 
{
    newname=name;
}

//setter defined to set the private variables of the class
void vectors_of_objects_class::setAge(int age) 
{
    newage=age;
}

</code>

<code>
//FILE: vectors_of_objects_class.h
//In this file we declare an interface called: vectors_of_objects_class


//this will ensure that the header file is only included once
#ifndef VECTORS_OF_OBJECTS_CLASS_H 
#define VECTORS_OF_OBJECTS_CLASS_H

#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

//Creating a custom vector class interface
class vectors_of_objects_class
{
    public:
        //default constructor
        vectors_of_objects_class(); 
        
        //self made constructor
        vectors_of_objects_class(string, int); 

        //Accessor functions:
        string getName () const;
        int getAge () const;

        //Mutator functions;
        void setName(string);
        void setAge(int);

        virtual ~vectors_of_objects_class();

    protected:

    private: //private variables;
        string newname; 
        int newage;
};

#endif // VECTORS_OF_OBJECTS_CLASS_H

</code>
        </modular-programming>
        <string-methods>
            *General-Programming-Knowledge*
            <br></br>
            The <code>std::string</code> is a <code>class</code> in <red>C++ since C++98</red>. 
            <br></br>
            This <code>class</code> is the standard 
            representation for a text <code>string</code>. 
            <br></br>
            It includes some typical <code>string</code> operations 
            like find, <red>replace</red>, <red>concatenate</red>, <red>compare</red> etc.
            <br></br>
            It is present in <code>&lt;string&gt;</code> 
            header file. <br></br><br></br>
            <green>
            Commonly Used String Functions in C++:<br></br>
            </green>
            <br></br>
            <blue>length() or size()</blue><br></br>
            It will <red>return the length</red> of the string.<br></br>
            <br></br>
            <blue>array[index]</blue><br></br>
            To <red>access</red> individual characters using array indexing.<br></br>
            <br></br>
            <blue>at()</blue><br></br>
            Used to <red>access</red> a character at a specified index.<br></br>
            <br></br>
            <blue>+ Operator</blue><br></br>
            <code>+</code> operator is used to <red>concatenate</red> two strings.<br></br>
            <br></br>
            <blue>append()</blue><br></br>
            The <code>append()</code> function <red>adds one string</red> to the end of another.<br></br>
            <br></br>
            <blue>== Operator</blue><br></br>
            You can <red>compare</red> strings using the <code>==</code> operator.<br></br>
            <br></br>
            <blue>compare()</blue><br></br>
            The <code>compare()</code> function <red>returns an integer</red> value indicating the 
            comparison result.<br></br>
            <br></br>
            <blue>substr()</blue><br></br>
            Use the <code>substr()</code> function to <red>extract a substring</red> from a string.<br></br>
            <br></br>
            <blue>find()</blue><br></br>
            The <code>find()</code> function <red>returns the position</red> of the first occurrence of a substring.<br></br>
            <br></br>
            <blue>replace()</blue><br></br>
            Use the <code>replace()</code> function to <red>modify</red> a part of the string.<br></br>
            <br></br>
            <blue>insert()</blue><br></br>
            The <code>insert()</code> function <red>adds a substring</red> at a specified position.<br></br>
            <br></br>
            <blue>erase()</blue><br></br>
            Use the <code>erase()</code> function to <red>remove</red> a part of the string.<br></br>
            <br></br>
            <blue>c_str()</blue><br></br>
            To obtain a <red>C-style string</red> from a <code>std::string</code>, you can use the 
            <code>c_str()</code> function.<br></br>
        </string-methods>
        <datatype-conversions>*General-Programming-Knowledge*</datatype-conversions>
        <optional-parameters>*General-Programming-Knowledge*</optional-parameters>
        <decorators>
            *General-Programming-Knowledge*
<code>
/*Example of decorators*/

#include &lt;iostream&gt; 
using namespace std;

class Computer
{
    public:
        virtual void display()
        {
            cout &lt;&lt; "I am a computer..." &lt;&lt; endl;
        }
};

class CDDrive : public Computer
{
    private:
        Computer* c;
        
    public:
        CDDrive(Computer* _c)
        {
            c = _c;
        }
        void display()
        {
            c-&gt;display();
            cout &lt;&lt; "with a CD Drive..." &lt;&lt; endl;
        }
};

class Printer : public Computer
{
    private:
        CDDrive* d;
        
    public:
        Printer(CDDrive* _d)
        {
            d = _d;
        }
        void display()
        {
            d-&gt;display();
            cout &lt;&lt; "with a printer..." &lt;&lt; endl;
        }
};

int main()
{
    Computer* c = new Computer();
    CDDrive* d = new CDDrive(c);
    Printer* p = new Printer(d);

    p-&gt;display();
}
</code>
        </decorators>
        <operators>*General-Programming-Knowledge*</operators>
        <pre-post-incrementation>*General-Programming-Knowledge*</pre-post-incrementation>
        <recursion>
            *General-Programming-Knowledge*
        </recursion>
        <reflection>
            *General-Programming-Knowledge*
        </reflection>
    </programming_language>
    
    <programming_language>
        <name>C#</name>
        <description>
            C# is a <blue>general-purpose high-level</blue> programming language supporting multiple 
            paradigms. C# encompasses <blue>static typing</blue>, <blue>strong typing</blue>, 
            <blue>lexically scoped</blue>, <blue>imperative</blue>, <blue>declarative</blue>, 
            <blue>functional</blue>, <blue>generic</blue>, <blue>object-oriented (class-based)</blue>, 
            and <blue>component-oriented programming</blue> disciplines. 
            <br></br><br></br>
            The C# programming language was designed by Anders Hejlsberg from Microsoft in 
            2000. 
            <br></br><br></br>
            Microsoft introduced C# along with .NET Framework and Visual Studio, both of 
            which were closed-source. At the time, Microsoft had no open-source products. 
            <br></br><br></br>
            Four years later, in 2004, a free and open-source project called Mono began, 
            providing a cross-platform compiler and runtime environment for the C# 
            programming language. 
            <br></br><br></br>
            A decade later, Microsoft released Visual Studio Code (code editor), 
            Roslyn (compiler), and the unified .NET platform (software framework), 
            all of which support C# and are free, <blue>open-source</blue>, and 
            <blue>cross-platform</blue>. 
            Mono also joined Microsoft but was not merged into .NET.<br></br><br></br>
        </description>
        <oop>*General-Programming-Knowledge*</oop>
        <encapsulation>
            *General-Programming-Knowledge*
<code>
using System;

/* Members of the class should never be set to public, because public means that anyone 
 * who works at that program is able to change the variable's value, so to avoid that, 
 * all the members (sometimes called proprieties), should be private, 
 * (or protected for inheritance purposes).
 * 
 * Encapsulation: 
 * uses getter functions for getting the value of private members of the class;
 * uses setter function for setting the value of a private members of the class;
 */
 
namespace project27_classes_encaptulation_and_exceptions_throwing
{
    class Program
    {
        public static void Main(string[] args)
        {
            Encapsulation_Example pobject = new Encapsulation_Example();
            pobject.SetAge(15);
            pobject.SetName("Ellias Mustellar");
            Console.WriteLine("Name: {0}\nAge: {1}", pobject.GetName(), pobject.GetAge());
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    class Encapsulation_Example
    {
        //Members: (sometimes called properties)
        
        //as good programming habbit the private variables in a function 
        //should start with underscore.
        private int _age; 

        private string _Name;
        
        //Setters:
        public void SetAge(int NewAge)
        {
            if(NewAge&lt;=0)
            {
                //An exception is an error message, that occures and terminates the 
                //program in case that something goes wrong.

                //Syntax for throwing exception:
                throw new Exception("A person cannot have NULL or NEGATIVE age.");
            }
            _age=NewAge;
        }
        
        public void SetName(string NewName)
        {
            //string.IsNullOrEmpty(string_name); // is a function 
            //that checks if a string is null or empty
            if(string.IsNullOrEmpty(NewName))
            {
                throw new Exception("The name cannot be NULL or EMPTY.");
            }
            _Name = NewName;
        }
        
        //Getters:
        public int GetAge()
        {
            return this._age;
        }
        public string GetName()
        {
            return this._Name;
        }
    }
}
</code>
        </encapsulation>
        <polymorphism>
            *General-Programming-Knowledge*
<code>
using System;

namespace project25_polymorphism
{
    class Program
    {
        public static void Main(string[] args)
        {
            
            Parent [] objarray = new Parent[4];
            objarray[0]=new Parent();
            objarray[1]=new Child1();
            objarray[2]=new Child2();
            objarray[3]=new Child3();
            
            foreach(Parent k in objarray)
            {
                k.DisplayInfo(); //each child has the properties of the parent class
                
                /* To see the information of each child class we could make a function which  
                 * will hide the parent class function, and contain the updated information of
                 * the child class. But a better way doing that is marking the parent class 
                 * you'd wish to hide with virtual keyword, which will allow every child class
                 * overide the method by their own needs.
                 */
            }
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    class Parent
    {
        protected string FirstName, LastName;
       
        public Parent()
        {
            FirstName="FN";
            LastName="LN";
        }
        
        //The virtual keyword will make this function overidable for each child class.
        public virtual void DisplayInfo()  
        {
            Console.WriteLine("This is parent class");
        }
    }
    
    class Child1:Parent
    {
        //This is the syntax: for overriding (overwriting) a function.
        public override void DisplayInfo()
        {
            Console.WriteLine("This is a child 1 class.");
        }
    }
    
    class Child2:Parent
    {
        //This is the syntax: for overriding (overwriting) a function.
        public override void DisplayInfo()
        {
            Console.WriteLine("This is a child 2 class.");
        }
    }
    
    class Child3:Parent
    {
        //This is the syntax: for overriding (overwriting) a function.
        public override void DisplayInfo()
        {
            Console.WriteLine("This is a child 3 class.");
        }
    }
}
</code>
        </polymorphism>
        <inheritance>
            *General-Programming-Knowledge*
            <br></br>
            In C# for an <red>inherited class</red> can be only one <red>parent class</red> 
            (only <red>single class inheritance</red> is allowed).
            <br></br><br></br> 
            In case of inherited classes: the <red>parent class constructor</red> gets automatically 
            executed before the <red>child class constructor</red> if the <red>parent class constructor</red> 
            has no <blue>arguments</blue>.
            <br></br><br></br>
            Otherwise: if the <red>parent class</red> has a <red>constructors</red> with multiple 
            <blue>arguments/parameters</blue> 
            it must be specified at the <red>child class constructor</red> declaration a 
            <blue>syntax<code>:base()</code></blue>
            and specify the <blue>arguments</blue> of the <red>constructor</red> that you want to 
            be executed inside 
            the pharanteses.
            <br></br><br></br>
            <green>Sealing the inheritance:</green> 
            <br></br><br></br>
            To prevent a <code>class</code> of having children (<red>inheritance</red>), you can use the 
            <code>sealed</code> keyword.
            <br></br><br></br>
            A <code>sealed class</code> cannot have children (cannot be <code>base class</code>).
<code>
//FILE: MyClass.cs

using System;
using System.Collections.Generic;

namespace inherited_classes
{
    //These are called XML Comments:
    /// &lt;summary&gt;
    /// Inherited Classes
    /// &lt;/summary&gt;
    //This is the parent class.
    
    public class MyClass
    {
        protected string FirstName;
        protected string LastName;
        protected uint ?age;
        protected MyClass(string FSS)
        {
            Console.WriteLine(FSS);
        }
        public void DisplayInfo()
        {
            Console.WriteLine("Name: {0} {1}",FirstName, LastName);
            if(age==null)
            {
                Console.WriteLine("Age: No Age Provided");
            }
            else
            {
                Console.WriteLine("Age: {0}", age);
            }
        }
    }
    
    //This is the inherited class.
    public class Mates:MyClass
    {
        char Grades;
        
        //THIS IS DEFAULT CONSTRUCTOR
        public Mates(): base("CHILD CLASS CONTROLS THE PARENTS CLASS") //this needs to be public.
            //AS YOU SEE THE :base () sythax appears here too.
        {
            FirstName="No First Name Provided";
            LastName="No Last Name Provided";
            age = null;
        }
        
        //THIS IS OVERLOADED CONSTRUCTOR
        
        //the constructor needs to be public
        //:base () -> it's used to explicitely specify which constructor should be 
        //used for the parent class
        
        //The syntax must be used for each constructor of the child class.
        //if the parent class constructor takes no arguments, then the syntax is optional.
        public Mates(string FS, string LS, uint AGE_m, char GRD) : base("CHILD CLASS CONTROLS THE PARENTS CLASS")
        {
            FirstName=FS;
            LastName=LS;
            age=AGE_m;
            Grades=GRD;
        }
        public void DisplayGrades()
        {
            ///&lt;summary&gt;Displays the grades of the objects in this class.&lt;/summary&gt;
            Console.WriteLine("Grade: {0}", Grades);
        }
    }
}
</code>
        </inheritance>
        <abstraction>
            *General-Programming-Knowledge*
<code>
//Abstraction:

//Animal class provides empty function for eat() 
//and actual implementation for sound()

abstract class animal 
{
    public abstract void eat();
    public void sound() 
    {
        Console.WriteLine("dog can sound");
    }
}

//Class dog inherits animal and can provide its implementation to eat()
//while still be able to access actual implementation sound()

class dog: animal 
{
    public override void eat() 
    {
        Console.WriteLine("dog can eat");
    }
}
</code>
        </abstraction>
        <generic-programming>
            *General-Programming-Knowledge*
<code>
using System;
/* The generic is a specification that allows to a function/method or class to operate without 
 * depending on the data type that's been taking 
 * as parameters, and without losing the strong typed property of the function, and the performance.
 * Generics were introduced in C# 2.0, and they are used especially for class collections.
 * 
 * The conversion from value type to reference type is called boxing. When we talk about performance 
 * provided by generics, we mean that
 * no boxing will be effectuated. Boxing are weak in performance.
 */

namespace project45_generics
{
    class Program
    {
        public static void Main(string[] args)
        {
            Program aProg = new Program();
            
            //Using the generic function:
            bool result = aProg.IsEqual&lt;int&gt; (21,44); //the function works for any data type.
            Console.WriteLine("Result of the comparison: {0}", result);
            
            result = aProg.IsEqual&lt;string&gt; ("Adam", "Exit"); //the function works for any data type.
            Console.WriteLine("Result of the comparison: {0}", result);
            
            result = aProg.IsEqual&lt;char&gt;('a', 'a'); //the function works for any data type.
            Console.WriteLine("Result of the comparison: {0}", result);
            
            //Working with the generic class:
            MyClass&lt;int&gt; GenCls = new MyClass&lt;int&gt;();
            GenCls.printStuff(12,3);
            
            MyClass&lt;string> GenCls2 = new MyClass&lt;string&gt;();
            GenCls2.printStuff("Deady", "Online");
            
            //End of program.
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
        
        //Creating a generic function:
        public bool IsEqual &lt;T&gt; (T value1, T value2) //the parameters are of type T, into 
        //that type could be encapsulated any data type.
        {
            return value1.Equals(value2);
        }
        
        //The syntax to create a generic function is: access_modifier return_type function_name 
        //&lt;variable_type_name&gt; (arguments of variable_type_name).
    }
    
    //Creating a generic class
    #region GenericClass //this is how you can structure your code using regions
    class MyClass &lt;A&gt; //the syntax is class Class_Name &lt;variable_type_name&gt;
    {
        //Creating a function for the generic class.
        public void printStuff(A value1, A value2)
        {
            Console.WriteLine("The stuff sent is: {0} &#38;&#38; {1}", value1, value2);
        }
    }
    #endregion //end of the region
}
</code>
        </generic-programming>
        <variable-arguments-lists>
            *General-Programming-Knowledge*
            <br></br>
            Use the <code>param</code> keyword to get the <red>variable arguments</red> in C#.
<code>
//Example of working with variable arguments in C#

using System;

class Program {
   static void Main() {
      int mulVal1 = Multiply(5);
      int mulVal2 = Multiply(5, 10);

      Console.WriteLine(mulVal1);
      Console.WriteLine(mulVal2);
   }

   static int Multiply(params int[] b) {
      int mul =1;
      foreach (int a in b) {
         mul = mul*a;
      }
      return mul;
   }
}
</code>
        </variable-arguments-lists>
        <simple-data-types>
            *General-Programming-Knowledge*
<code>
//Example of working with different data type variables in C#

using System;

namespace project1_introduction 
{
    class Program
    {
        public static void Main(string[] args)
        {             
            //Data types:
            int numb_one = 5;
            float numb_two = 6.034f;
            double numb_three = 3.0;
            bool istrue = false;
            string name = "Black";
            object ANYTHING = "A variable that can be initialized with anything!";
            char character = 'X';
            
            //Printing the result on the screen;
            Console.Write("The result of addition is: " + (numb_one+numb_two) + "\n");
            Console.WriteLine("An object is: " + "\"" + ANYTHING + "\"");
            
            /*
             Console.WriteLine - automatically puts '\n' at the end of the line,  
             because it is a function designed to be used only for writing a line.
            */
            
            Console.Write(character + "\n");
            Console.WriteLine("Processing data!\n\n");
            while (numb_one>0)
            {
                if(numb_one==1)
                {
                    Console.WriteLine("The program will end.\n\n");
                }
                numb_one--;
            }
            Console.Write("Press any key to continue . . . ");
            
            //function to read keys;
            Console.ReadKey(true);
        }
    }
}
</code>
        </simple-data-types>
        <complex-data-types>
            *General-Programming-Knowledge*
            <br></br><br></br>
            <green>C# brings changes with regards to the datatypes which were available in C/C++:</green>
            <br></br><br></br>
            C# supports <red>pointers</red> in a limited extent. <br></br><br></br>
            A C# <red>pointer</red> is 
            nothing but a variable that 
            holds the <red>memory address</red> of another type. But in C# pointer can only be declared to 
            hold the <red>memory address</red> of value types and arrays. 
            <br></br><br></br>
            Unlike reference types, <red>pointer types</red> are not tracked by the default garbage 
            collection mechanism. For the same reason <red>pointers</red> are not allowed to point to a 
            <blue>reference type</blue> or even to a <blue>structure type</blue> which contains a 
            <blue>reference type</blue>. 
            <br></br><br></br>
            We can say that <red>pointers</red> can point to only <blue>unmanaged types</blue> which includes 
            all basic <red>data types</red>, <red>enum types</red>, other <red>pointer types</red> and 
            <blue>structs</blue> 
            which contain only <blue>unmanaged types</blue>.
            <br></br><br></br>
            <brown>There are no unions available in C#.</brown><br></br>
            <brown>There are no typedefs available in C#.</brown><br></br>
        </complex-data-types>
        <preprocessor-directives>
            *General-Programming-Knowledge*
            C# unlike C and C++ it does not allow the use <red>directives</red> to create <red>macros</red>. 
            <br></br><br></br>
            <brown>
                Although there is no #define in C# - some preprocessor directive are still available:
            </brown>
            <br></br><br></br>
<code>
//Example:

#if DEBUG
    Console.WriteLine("Debug version");
#endif
</code>
            A <red>preprocessor directive</red> must be the only 
            instruction on a line. <br></br>
        </preprocessor-directives>
        <loops>
            *General-Programming-Knowledge*
            <br></br>
            <red>Foreach loop</red> is used especially when trying to iterrate into a 
            list which has dinamic size, or an array with unknown size.
            <br></br><br></br>
            <green>The foreach loop is very similar to a for loop</green>.
            <br></br><br></br>
            <red>Foreach</red> is used only for <red>Collection of data</red>.
            The difference between <red>for loop</red> and <red>foreach loop</red> is that 
            in <red>foreach loop</red> there is no access to the index.
                
<code>
//Example of foreach loop in C#

using System;

namespace project6_foreach_loop
{
    class Program
    {
        public static void Main(string[] args)
        {
            int [] myarray = new int[10];
            for (int i=0;i&lt;10;i++)
            {
                myarray[i]=3*i;
            }
            
            Console.WriteLine("\nDisplaying elements using FOR LOOP: ");
            
            for (int i=0;i&lt;10;i++)
            {
                Console.WriteLine("myarray[" + i + "]=" +myarray[i]);
            }
            
            Console.WriteLine("\nDisplaying elements using FOREACH LOOP: ");
            
            // syntax forech (datatype iterator_name in data_collection)
            foreach(int iter in myarray) 
            {
                    Console.WriteLine("myarray[" + iter/3 + "]=" +iter);
            }
            
            Console.WriteLine("\nSimple task for FOREACH LOOP");
            
            // syntax forech (datatype iterator_name in data_collection)
            foreach(int iter in myarray) 
            {
                if(iter%5==0 &#38;&#38; iter>0)
                {
                    Console.WriteLine (iter + " is divisible with five.");
                }
            }
            
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </loops>
        <collections>
            *General-Programming-Knowledge*
            <br></br>
            <green>C# introduces the following collections:</green>
            <br></br><br></br>
            <code>Queue</code> is a collection type just like a list or dictionary, dispite that 
            once an object is retrieved from <code>Queue</code> (operation called <red>dequeue</red>), 
            that <red>object</red>
            gets automatically <blue>deleted</blue> from the beggining of the <code>Queue</code>.
            <br></br><br></br>
            You can think of a <code>Queue</code> just like a RAR archieve, in order to use an 
            object from the <code>Queue</code>, that object needs to be <red>dequeued</red> into an 
            another object, otherwise it will affect the entire content of the <code>Queue</code>, 
            unless an <code>foreach</code> loop is being used.
            <br></br><br></br>
            To prevent an object be <blue>deleted</blue> from the <code>Queue</code>, you 
            have to use a 
            <code>foreach</code> loop or the <code>.Peak</code> function. 
            <br></br><br></br>
            If you <blue>iterate</blue> through the <code>Queue</code> 
            using <code>foreach</code> loop, 
            and effect changes without affecting the content of the <code>Queue</code>.
            <br></br>
<code>
//Exemple on how to use Queue

using System;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic;

namespace queue_collection_type
{
    class Program
    {
        public static void Main(string[] args)
        {
            people p1 = new people ("Black", 22);
            people p2 = new people ("Mark", 24);
            
            //Creating Queue
            Queue &lt;people&gt; FirstQueue = new Queue &lt;people&gt; ();
            FirstQueue.Enqueue(p1);
            FirstQueue.Enqueue(p2);
            
            //Printing Information:
            Console.WriteLine("Number of objects in Queue: {0}\n", FirstQueue.Count());
            
            //This usage is wrong, unless it is moved into a foreach loop:
            //Console.WriteLine ("Name: {0}, Age: {1}", FirstQueue.Dequeue().name, 
            //                      FirstQueue.Dequeue().Age); 
            
            //A Queue is like an archieve, you need to extract the object from it, 
            //before using that object.
            Queue&lt;people&gt; SecondQueue = new Queue&lt;people&gt; ();
            SecondQueue.Enqueue(p1);
            SecondQueue.Enqueue(p2);
            people deq1 = FirstQueue.Dequeue();
            people deq2 = FirstQueue.Dequeue();
            
            /*
             SecondQueue=FirstQueue 
            
             These two Queues become highly connected one to another in the way that, 
             SecondQueue take all the objects from the FirstQueue, 
             but if in FirstQueue an object is removed so it is in the SecondQueue.
             
            */
            
            Console.WriteLine("Name: {0}, Age: {1}", deq1.name, deq1.Age);
            Console.WriteLine("Name: {0}, Age: {1}", deq2.name, deq2.Age);
            Console.WriteLine();
            
            //Auxiliar way -> Iteration:
            foreach (people p in SecondQueue)
            {
                Console.WriteLine("Name: {0}, Age: {1}", p.name, p.Age);
                Console.WriteLine ("Number of objects in Queue: {0}", FirstQueue.Count());
                Console.WriteLine("In the foreach loop the content of the Queue is it not affected, \n(Dequeue is made without removal).\n");
            }
            
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    class people 
    {
        public int Age {get; set;}
        public string name {get; set;}
        public people (string GivenName, int GivenAge) 
        {
            this.Age = GivenAge; 
            this.name = GivenName;
        }
    }
}
</code>
            
  <code>Stack</code> is a collection that uses the principle <blue>LIFO - Last In First Out</blue>, 
  and which can be accessed and handled similarly to a list.
  <br></br><br></br>
  Once an element gets retrieved from the <code>Stack</code> that object will be <blue>removed</blue>, 
  unless a <code>foreach</code> loop, or the <code>.Peek</code> function it's used.
  <br></br>
 
<code>
//Example on how to use Stack

using System;
using System.Collections.Generic;

namespace project61_stack_collection_type
{
    class Program
    {
        public static void Main(string[] args)
        {
            people p1 = new people ("Dragos", 22);
            people p2 = new people ("Adrian", 21);
            Stack&lt;people&gt; FirstStack = new Stack&lt;people&gt;();
            FirstStack.Push(p1);
            FirstStack.Push(p2);
            
            //The first will be the last:
            foreach (people p in FirstStack)
            {
                Console.WriteLine("Name: {0}    Age: {1}", p.Name, p.Age);
                Console.WriteLine("Number of elements on Stack: {0}", FirstStack.Count);
            }
            
            Console.WriteLine();
            Console.WriteLine("Outside the forech loop:");
            
            Console.WriteLine("Name: {0}", FirstStack.Pop().Name);
            Console.WriteLine("Number of elements on Stack: {0}", FirstStack.Count);
            Console.WriteLine("Name: {0}", FirstStack.Pop().Name);
            Console.WriteLine("Number of elements on Stack: {0}", FirstStack.Count);
            
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    
    class people
    {
        public string Name {get; set;}
        public int Age {get; set;}
        public people (string NewName, int NewAge) {Name=NewName; Age=NewAge;}
    }
}
</code>
        </collections>
        <dynamic-memory-allocation>
            In C#, objects are <red>dynamically allocated</red> on the <red>heap</red> using the 
            <code>new</code> keyword.
            <br></br><br></br>
            When an <red>object</red> is no longer needed, it is the responsibility of the <red>garbage 
            collector</red> to <blue>deallocate the memory</blue> and reclaim it for future use.
        </dynamic-memory-allocation>
        <read-from-file>
            *General-Programming-Knowledge*
<code>
//Example of reading content from a file.

using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;

namespace read_from_file
{
    class Program
    {
        public static void Main(string[] args)
        {
            string textFromFile = System.IO.File.ReadAllText("textfile.txt");
            
            if(textFromFile!=string.Empty)
            {
                Console.WriteLine("Text From File: \n\n{0}", textFromFile);
            }
            
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </read-from-file>
        <write-to-file>
            *General-Programming-Knowledge*
<code>
//Example of writing content to a file.

// Write file using StreamWriter
using (StreamWriter writer = new StreamWriter(fullPath))
{
   writer.WriteLine("Monica Rathbun");
   writer.WriteLine("Vidya Agarwal");
   writer.WriteLine("Mahesh Chand");
   writer.WriteLine("Vijay Anand");
   writer.WriteLine("Jignesh Trivedi");
}

// Read a file
string readText = File.ReadAllText(fullPath);
Console.WriteLine(readText);
</code>
        </write-to-file>
        <serialization>
            *General-Programming-Knowledge*
<code>
//Example of using serialization in C#

using System;  
using System.IO;  
using System.Runtime.Serialization.Formatters.Binary;
  
[Serializable]  //this will ensure that the class is serializable
class Student  
{  
    int rollno;  
    string name;  
    public Student(int rollno, string name)  
    {  
        this.rollno = rollno;  
        this.name = name;  
    }  
}

public class SerializeExample  
{  
    public static void Main(string[] args)  
    {  
        FileStream stream = new FileStream("e:\\sss.txt", FileMode.OpenOrCreate);  
        BinaryFormatter formatter=new BinaryFormatter();  
          
        Student s = new Student(101, "sonoo");  
        formatter.Serialize(stream, s);  
  
        stream.Close();  
    }  
}  
</code>
        </serialization>
        <deserialization>
            *General-Programming-Knowledge*
<code>
//Example of deserializating an object from a file.

using System;  
using System.IO;  
using System.Runtime.Serialization.Formatters.Binary;
  
[Serializable] //this will ensure that the class is serializable 
class Student  
{  
    public int rollno;  
    public string name;  
    public Student(int rollno, string name)  
    {  
        this.rollno = rollno;  
        this.name = name;  
    }  
}  

public class DeserializeExample  
{  
    public static void Main(string[] args)  
    {  
        FileStream stream = new FileStream("e:\\sss.txt", FileMode.OpenOrCreate);  
        BinaryFormatter formatter=new BinaryFormatter();  
  
        Student s=(Student)formatter.Deserialize(stream);  
        Console.WriteLine("Rollno: " + s.rollno);  
        Console.WriteLine("Name: " + s.name);  
  
        stream.Close();  
    }  
}  
</code>
        </deserialization>
        <constructors>
            *General-Programming-Knowledge*
            <br></br>
            In C# constructors can be defined for <code>structs</code> as well as <code>classes</code>.
            <br></br><br></br>
            A <code>struct</code> is a similar data type with a <code>class</code>, but 
            <red>structs</red> works with values, while <red>classes</red> works as 
            <blue>references.</blue>
            <br></br><br></br>
            <green>For a struct:</green>
            <br></br><br></br>
             - if we create <blue>2</blue> <red>struct objects</red> (<red>object1</red> and 
             <blue>object2</blue>):
             <br></br>
 <code>
 object1 = object2;
 
 /*
    - in this case object1 will have all the values that 
    object2 has.
 */
 </code>
             <br></br>
             <green>For a class</green>:
             <br></br><br></br>
             - if we create <blue>2</blue> <red>class objects</red> (<red>object1</red> and 
             <blue>object2</blue>):
             <br></br>
 <code>
 object1 = object2;
 
 /*
  - in this case object1, will be poiting to the object2's values 
    which are stored on the heap.
 */
 </code>
             <br></br>
             <brown>
             The constructors for both structs and classes are declared in the same way:
             </brown>
             <br></br>
<code>
//Example of constructors

using System;

namespace project5_structs_with_constructors
{
    class Program
    {
        struct MyStr
        {
            //Variables of the struct:
            public int posx, posy;
            
            //Constructor of the struct:
            public MyStr (int newposx, int newposy)
            {
                posx = newposx;
                posy = newposy;
            }
        }
        public static void Main(string[] args)
        {
            //Creating the instances/objects of the struct
            MyStr structure1 = new MyStr (4, 5);
            MyStr structure2 = new MyStr (10, 12);
            
            //Printing the values:
            Console.WriteLine("The first structure has: X=" +structure1.posx +" and Y=" +structure1.posy);
            Console.WriteLine("The second structure has: X=" +structure2.posx +" and Y=" +structure2.posy);
            structure1 = structure2;
            
            //Printing the values:
            Console.WriteLine("\nAfter setting structure1 = structure2.\n");
            Console.WriteLine("The first structure has: X=" +structure1.posx +" and Y=" +structure1.posy);
            Console.WriteLine("The second structure has: X=" +structure2.posx +" and Y=" +structure2.posy);
            
            //End of program:
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </constructors>
        <instantiation>
            *General-Programming-Knowledge*
            <br></br>
            When you create a <code>new</code> object in C# for a <code>class</code> using 
            the <code>new</code> 
            keyword, then it is called <blue>instantiation</blue>.
            <br></br>
<code>
Student s1 = new Student();
</code>
        </instantiation>
        <destructors>
            *General-Programming-Knowledge*
<code>
class Example
{ 
    // Rest of the class
    // members and methods.

   // Destructor
   ~Example()
    {
        // Your code
    }

} 
</code>
        </destructors>
        <function-overloading>
            *General-Programming-Knowledge*
<code>
//Example of function overloading in C#:

using System;

namespace project26_methods_and_functions_overloading
{
    class Program
    {
        public static void Main(string[] args)
        {
            int outsider;
            Program p = new Program();
            p.Add(10,12);
            p.Add(1,102,34);
            p.Add(0.2f,3.3f);
            p.Add(1,33, out outsider);
            Console.WriteLine("Func4 Result: {0}", outsider);
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
        
        /*
        A function or method can be overloaded using different number of parameters, 
        different types of parameters or different kind of parameters.
        
        Kinds of parameters are: input parameters, output parameters, reference parameters.
        Types of parameters are: float, int, double, char, etc...
        
        Overloading means that you can have multiple functions with the same name, but 
        respecting at least one of the criteria above (also it can respect all of the 
        criteria above). 
        
        This means that the signature of the overloaded function must be different from 
        the primary function.
        
        Signature consist in number, type and kind of parameters, and also in the code inside 
        the brackets. But a signature does not consist in the return type of the function, 
        the access modifier of the function, or the optional parameters (params) of the function.
        
        So a function CANNOT be overloaded ONLY by using different return types, access modifiers, 
        or optional params, it must be respected the criteria above.
        
        Examples:
        */
        
        public void Add(int numb1, int numb2)
        {
            Console.WriteLine("Func1\nThe Sum: {0}\n", numb1+numb2);
        }
        public void Add(int numb1, int numb2, int numb3) //method overloaded
        {
            Console.WriteLine("Func2\nThe Sum: {0}\n", numb1+numb2+numb3);
        }
        public void Add(float numb1, float numb2) //method overloaded
        {
            Console.WriteLine("Func3\nThe Sum: {0}\n", numb1+numb2);
        }
        public void Add (int numb1, int numb2, out int sum) //method overloaded
        {
            sum=numb1+numb2;
        }
    }
}
</code>
        </function-overloading>
        <operator-overloading>
            *General-Programming-Knowledge*
<code>
// Example of operator overloading in C#:

using System;

namespace Calculator 
{
     
    class Calculator 
    {
         
        public int number1 , number2;
        public Calculator(int num1 , int num2)
        {
            number1 = num1;
            number2 = num2;
        }
         
        // Function to perform operation
        // By changing sign of integers
        public static Calculator operator -(Calculator c1)
        {
            c1.number1 = -c1.number1;
            c1.number2 = -c1.number2;
            return c1;
        }
         
        // Function to print the numbers
        public void Print()
        {
            Console.WriteLine ("Number1 = " + number1);
            Console.WriteLine ("Number2 = " + number2);
        }
    }
     
    class EntryPoint
    {
         
        static void Main(String []args)
        { 
             
            // using overloaded - operator 
            // with the class object
            Calculator calc = new Calculator(15, -25);
             
            calc = -calc;
             
            // To display the result
            calc.Print();
        }
    }
}
</code>
        </operator-overloading>
        <enums>
            *General-Programming-Knowledge*
             The <code>enum</code> is like an <code>array</code> of <code>boolean</code> <red>values</red>, 
             in which only one can be <code>true</code> at a time.
             <br></br> <br></br> 
             This is useful while creating <blue>game engines</blue>, or <blue>software engines</blue>, 
             to know when a certain option is available. 
             <br></br><br></br> 
             Also this is used to control and interract the states in a certain application.
             <br></br> 
<code>
//Example of using enums in C#

using System;
using System.Threading.Tasks;
using System.Text;
using System.Linq;
using System.Collections.Generic;

namespace Software
{
    class Software
    {
         /*
          * NOTE: 
          * Enums cannot be declared inside a function, or method. 
          * NOT even within the Main function.
          */
        
        enum Gamestate {Playing, Menu, Pause=6}; //from now on, Gamestate is like a datatype.
        
        /*
         * From the moment of declaration the enum is initializing to true the first state. 
         * In this case:
         * Playing = true, until the programmer sets it otherwise.
         * The elements of the enum can also hold values, 
         * as it sets above, Pause = 6, Playing = 0, Menu = 1 
         * (by default the    value set for each element is its index).
         */
        
        public static int Main()
        {
            //Creating an object/instance for the enum;
            Gamestate gamestate;
            Console.WriteLine("Gamestate: " + Convert.ToInt32(Gamestate.Pause));
            Console.WriteLine("Gamestate: " + Convert.ToInt32(Gamestate.Playing));
            
            //Changing the state of the Gamestate enum;
            gamestate=Gamestate.Menu;
            
            /* Equivalence for this case:
             * bool Playing = false;
             * bool Menu = true;
             * bool Pause = false;
             */
             
            Console.WriteLine("Gamestate: " + gamestate);        
            gamestate=Gamestate.Playing;
            
            /* Equivalence:
             * bool Playing = true;
             * bool Menu = false;
             * bool Pause = false;
             */
             
            Console.WriteLine("Gamestate: " + gamestate);
            
            //Interraction of the user:
            int input=9;
            while(input>0 &#38;&#38; input&lt;10)
            {
                Console.WriteLine("Enter the option: ");
                input = Convert.ToInt16 (Console.ReadLine());
                switch(input)
                {
                        case 1:
                        {
                            gamestate = Gamestate.Menu;
                            Console.WriteLine("The active state: " + gamestate);
                            break;
                        }
                        case 2:
                        {
                            gamestate = Gamestate.Pause;
                            Console.WriteLine("The active state: " + gamestate);
                            break;
                        }
                        case 3:
                        {
                            gamestate = Gamestate.Playing;
                            Console.WriteLine("The active state: " + gamestate);
                            break;
                        }
                        default:
                        {
                            Console.WriteLine("This is not a gamestate");
                            break;
                        }
                }
            }
            Console.WriteLine("Out of the loop!");
            Console.ReadLine();
            return 0;
        }
    }
}
</code>
        </enums>
        <concurrent-programming>
            *General-Programming-Knowledge*
<code>
//Example of using multi-threading in C#

using System;
using System.Threading;

namespace MultithreadingApplication 
{
   class ThreadCreationProgram 
   {
      public static void CallToChildThread() 
      {
         try 
         {
            Console.WriteLine("Child thread starts");
            
            // do some work, like counting to 10
            for (int counter = 0; counter &lt;= 10; counter++) 
            {
               Thread.Sleep(500);
               Console.WriteLine(counter);
            }
            
            Console.WriteLine("Child Thread Completed");
         } 
         catch (ThreadAbortException e) 
         {
            Console.WriteLine("Thread Abort Exception");
         } 
         finally 
         {
            Console.WriteLine("Couldn't catch the Thread Exception");
         }
      }
      
      static void Main(string[] args) 
      {
         ThreadStart childref = new ThreadStart(CallToChildThread);
         Console.WriteLine("In Main: Creating the Child thread");
         
         Thread childThread = new Thread(childref);
         childThread.Start();
         
         //stop the main thread for some time
         Thread.Sleep(2000);
         
         //now abort the child
         Console.WriteLine("In Main: Aborting the Child thread");
         
         childThread.Abort();
         Console.ReadKey();
      }
   }
}
</code>
        </concurrent-programming>
        <namespaces>
            *General-Programming-Knowledge*
            <br></br>
            C# allows using <code>namespace</code> <red>alliases</red> to avoid 
            <blue>ambiguity errors</blue>. 
            <br></br><br></br>
            An <blue>ambiguity errors</blue> is when declaring <blue>2 namespaces</blue> 
            which may contains some <blue>classes</blue> or <blue>functions</blue> with 
            the same name, so when trying to call one of such <blue>function</blue>, the compiler
            will not know to which one are you are refering to.
            <br></br>
<code>
//Example of using namespaces in C#

//FILE: MyClass.cs

using System;

//The namespace need to be declared in here

using Project20.DeadyOnline; //declaration of the namespace.
using PATA = Project20.DeadyOnline; //Creating a namespace alias called PATA.


//THIS IS AN EXTERNAL CLASS PROJECT
//in order to use this you need to right click on this project and add the ProjectA.TeamB
//as reference to the main project (in this case this is the main project).
using ProjectA.TeamB; 

namespace project20_namespaces
{
    class Program
    {
        public static void Main(string[] args)
        {
            //Creating an instance for the Class that's inside the namespace Project20.DeadyOnline
            //A namespace is using much like a path to a file, or a directory(folder).
            
            Project20.DeadyOnline.FirstClass p = new Project20.DeadyOnline.FirstClass();
            
            //If the namespace is declared above, an object of the class can be created as follows:
            FirstClass p2 = new FirstClass();
            
            //Calling the function that's inside the namespace below.
            
            //calling the STATIC function which has to be done using the qualify name of the class
            Project20.DeadyOnline.FirstClass.PrintingMethod();
            
            //calling the function using the namespace alias PATA.
            PATA.FirstClass.PrintingMethod();
            
            //Also the function can be called like this if the namespace is declared above.
            FirstClass.PrintingMethod();
            
            //calling the INSTANCE (non-static) function.
            p.AnotherMessage();
            
            //calling the INSTANCE (non-static function) using the object 2.
            p2.AnotherMessage(); 
            
            //Calling a function from external namespace and class.
            
            //creating an instance of the class.
            MyClass ms = new MyClass(); 
            
            //the function is INSTANCE function (so it needs to be called with and instance of
            //the class that it belongs to).
            ms.PrintName();

            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}

//Namespaces are used to organize the code/programs, and to avoid name clashes.
//Creating a namespace: (this is internal namespace because it's written into the same file.)
namespace Project20
{
    namespace DeadyOnline
    {
        class FirstClass
        {
            public static void PrintingMethod()
            {
                Console.WriteLine("This is a function from a SELF-CREATED namespace.");
            }
            public void AnotherMessage()
            {
                Console.WriteLine("This function is INSTANCE function.");
            }
        }
    }
}
</code>

<code>
//This is an external namespace

//FILE: Program.cs

using System;
using System.Collections.Generic;

namespace ProjectA.TeamB
{
    //This are called XML Comments, and are used to create descriptions.
    /// &lt;summary&gt;
    /// This is an Outside Class Project that contains a PrintName Function.
    /// &lt;/summary&gt;
    
    public class MyClass
    {
        public void PrintName()
        {
            Console.WriteLine("This is an external Class Project called ProjectA.TeamA");
        }
    }
}

/* 
//The code above is equivalent to this:

namespace ProjectA
{
    namespace TeamB
    {
        public class MyClass
        {
            public void PrintName()
            {
                Console.WriteLine("This is an external Class Project called ProjectA.TeamA");
            }
        }
    }
}

//THIS IS CALLED NASTED NAMESPACE (or a namespace inside of another).
 */
</code>
        </namespaces>
        <exception-handling>
            *General-Programming-Knowledge*
            <br></br> 
            <green>
                Disadvantages of unhandling exceptions:
            </green>
            <br></br> <br></br> 
            <blue>
             An <red>unhandled exception</red> would provide annoying error message to a user, 
             which could make the program be devoid using.
             <br></br> 
             An <red>unhandled exception</red> could also provide important information to a hacker.
             <br></br><br></br> 
             </blue>
             While handling the <red>exceptions</red> the <code>catch</code> block containing the <red>specific 
             classes</red> must be placed above the <red>general class</red> which should be the last one 
             at the bottom.
             <br></br> <br></br> 
             In this way specific <red>exceptions</red> will be handled first and in case the 
             <code>exception</code> was not handled
             specifically then it can be handled generically with the general <code>Exception Class</code>.
             <br></br> 
<code>
//Example on how to handle exceptions in C#

using System;
using System.IO; //namespace for files.

namespace project37_read_write_to_files_handling_exceptions
{
    class Program
    {
        public static void Main(string[] args)
        {
            
            //Creating a file read streamer:
            StreamReader readFromFile = new StreamReader(@"D:\error.txt"); // @ -> using the escape sequence
            
            //EXCEPTION HANDLING:
            
            //try to do this without exception
            try 
            {
                Console.WriteLine(readFromFile.ReadToEnd()); 
                //ReadToEnd will read all the content of the file (until the end).
            }
            
            /*
             * If there was an exception come to this catch statement
             * THIS IS A SPECIFIC CATCH, this is the child of EXCEPTION CLASS
             * try to handle the exception with this object.
             * This object is mostly for FileNotFoundException.
             */
            
            catch(FileNotFoundException fNotFound) 
            {
                //An object of type FileNotFoundException contain more information about 
                //the file that could not be found then an object of type 
                //Exception (as we use in our case).
                
                Console.WriteLine(fNotFound.Message);
                Console.WriteLine("Check for the file: {0}", fNotFound.FileName);
            }
            
            //If the catch above was not able to handle the exception try this one:
            //The Exception class is the parent of all the other classes above.
            //So this will catch any kind of exception that might have occurred.
            
            catch(Exception ex) //this can handle also the DirectoryNotFoundException.
            {
                Console.WriteLine(ex.Message);
            }
            
            //The finally is always executed regardless of the result whereas 
            //the execution of catch blocks execution is not a certainty.
            
            finally 
            //the finally block contain the code that should be executed by all means necessary
            {
                if(readFromFile!=null) //if the file is null then it cannot be closed.
                {
                    readFromFile.Close();
                }
            }
            
            //END OF EXCEPTION HANDLING.
            
            StreamWriter writeToFile = new StreamWriter(@"D:\writeToFile.txt");
            writeToFile.WriteLine("Project37 Read write to files, exception handling Finally!");
            writeToFile.Close(); //the filestream needs to be closed for the writing to work.
            
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </exception-handling>
        <bitwise-operators>*General-Programming-Knowledge*</bitwise-operators>
        <default-parameters>
            *General-Programming-Knowledge*
<code>
//Example of functions default-parameters:

static void MyMethod(string country = "Norway") 
{
  Console.WriteLine(country);
}

static void Main(string[] args)
{
  MyMethod("Sweden");
  MyMethod("India");
  MyMethod();
  MyMethod("USA");
}

// OUTPUT:
// Sweden
// India
// Norway
// USA
</code>
        </default-parameters>
        <interfaces>
            *General-Programming-Knowledge*
            <br></br>
            <green>
            An interface in C# is mostly like a class but with some differences:
            </green>
            <br></br><br></br>
            <blue>
             1. An <code>interface</code> cannot have field <red>members/variable</red> members (can have only 
             <red>functions/methods</red>, <red>delegates</red>, <red>events</red> or <red>proprieties</red>).
             <br></br><br></br>
             2. An <code>interface</code> cannot contain implementations for the <red>functions/methods</red>
             (an implementation of a <red>function/method</red> is the code between the brackets).
             <br></br><br></br>
             3. An <code>interface</code> has <code>public</code> fields set by default, so inside an 
             <code>interface</code> you 
             cannot use the <code>public</code> acces-modifier for its members.
             <br></br><br></br>
             4. A class can inherit from an <code>interface</code>. But with the condition of providing 
             the implementation for all the <code>interface</code> <red>function/method</red> members.
             <br></br><br></br>
             5. When a class provides implementation of an <code>interface</code> function member, 
             it also needs to make the member function <code>public</code>. 
             (The <code>public</code> access modifier must be used.)
             <br></br><br></br>
             6. A <code>class</code> or <code>struct</code> can <red>inherit</red> from MORE interfaces 
             at the same time. 
             Whereas a <code>class</code> or <code>struct</code> cannot <red>inherit</red> from
             more then one <code>class</code>.
             <br></br><br></br>
             7. An <code>interface</code> cannot be <red>instanciated</red> (an <red>instance</red>, 
             object of the <code>interface</code> 
             cannot be created), because doing this it would mean that you would be able to call 
             a function from the <code>interface</code>, and the <code>interface</code> cannot contain
             implemented members.
             </blue>
             <br></br><br></br>
<code>
//Example of using creating/using interfaces

using System;

namespace project30_interfaces
{
    //Creating an interface:
    public interface Ifirst_interface //an interface name usually starts with I (capital i).
    {
        //int age; -> an interface cannot have such fields (variable fields).
        //public void Print(); -> an interface cannot contain public access modifier.
        
        void Print(); //this is a function of the interface.
    }
    public interface Isecond_interface : Ithird_interface
    {
        void Print2();
    }
    public interface Ithird_interface
    {
        void Print3();
    }
    
    class Program
    {
        public static void Main(string[] args)
        {
            Inherited_from_interface Iobject = new Inherited_from_interface();
            Iobject.Print();
            Iobject.Print3(); //calling the grandpa's function.
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    
    class Inherited_from_interface : Ifirst_interface, Isecond_interface
    {
        /* A class that inherits from an interface HAS to provide implementations for all 
         * the interface methods members.
         */
         
        public void Print() //providing implementation for the interface function.
        {
            /*
             * IMPORTANT: 
             * when providing implementation for an interface function/method member you have
             * to specify it to be public. (YOU need to use the public access modifier.)
             * 
             * IF A CLASS inherits from multiple interfaces, then the class has to provide 
             * members.implementation for all the interface members.
             * 
             * IF A CLASS inherits from an interface which inherits from another interface, 
             * then the class has to provide implementation for both the parent
             * interface and grandparent interface as well.
             */
            
            Console.WriteLine("Class inherited from an interface.");
        }
        
        //A method can be implemented like this. (The brackets can be empty.)
        public void Print2() 
        {
            //By implementing a function inherited from an interface, 
            //you have to assure that the functionis public, and there 
            //exists the brackets (where the implementation should be made).
        }
        
        //this function is inherited from an interface which inherits from another interface.
        public void Print3() 
        {
            Console.WriteLine("This is the grandpa's function!");
        }
    }
}
</code>
        </interfaces>
        <random-generators>
            *General-Programming-Knowledge*
<code>
//Example of generating random numbers in C#

using System;

namespace project68_random_numbers
{
    class Program
    {
        public static void Main(string[] args)
        {
            Random i = new Random();
            int nr;
            nr=i.Next(1,5);
            Console.WriteLine("Value: {0}",nr);
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </random-generators>
        <command-line-arguments>
            *General-Programming-Knowledge*
<code>
//Example of command line arguments in C#:

using System; 

namespace ComLineArg   
{   
    class Program 
    {   
          
        // Main Method which accepts the 
        // command line arguments as  
        // string type parameters   
        static void Main(string[] args)  
        {   
              
            //Check the length of  
            //Command line arguments array
            if(args.Length > 0) 
            { 
                Console.WriteLine("Arguments Passed by the Programmer:");   
              
                //Print the command line  
                //arguments using foreach loop 
                foreach(Object obj in args)   
                {   
                    Console.WriteLine(obj);        
                }   
            }   
            else
            { 
                Console.WriteLine("No command line arguments found."); 
            } 
        }   
    } 
} 
</code>
        </command-line-arguments>
        <ternary-operator>
            *General-Programming-Knowledge*
<code>
//Example of using ternary operator in C#

using System;

namespace project11_ternary_operator
{
    class Program
    {
        public static void Main(string[] args)
        {
            bool istrue;
            int simpletest;
            int number = 10;
            
            //Ternary Operator "?":
            istrue = number==10 ? true : false;
            //Syntax: boolean variable = condition ? value for true : value for false
            
            /* Equivalence of that:
             * if(number==10)
             * {
             *         istrue=true;
             * }
             * else
             * {
             *         istrue=false;
             * }
             */
            
            Console.WriteLine("The value of istrue is: {0}", istrue);
            
            //Other example:
            simpletest = number==10 ? 10+2 : 10-2;
            Console.WriteLine("The value of simpletest is: {0}", simpletest);
            
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </ternary-operator>
        <modular-programming>
            *General-Programming-Knowledge*
<code>
//Example of modular programming in C#:

//FILE: project20_namespaces.cs

using System;


//THIS IS AN EXTERNAL CLASS PROJECT
//in order to use this you need to right click on this project and add the ProjectA.TeamB
//as reference to the main project (in this case this is the main project).

using ProjectA.TeamB; 

namespace project20_namespaces
{
    class Program
    {
        public static void Main(string[] args)
        {
            MyClass ms = new MyClass(); 
            
            ms.PrintName();

            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>

<code>
//This is an external namespace

//FILE: Program2.cs

using System;
using System.Collections.Generic;

namespace ProjectA.TeamB
{
    //This are called XML Comments, and are used to create descriptions.
    /// &lt;summary&gt;
    /// This is an Outside Class Project that contains a PrintName Function.
    /// &lt;/summary&gt;
    
    public class MyClass
    {
        public void PrintName()
        {
            Console.WriteLine("This is an external Class Project called ProjectA.TeamA");
        }
    }
}
</code>
        </modular-programming>
        <string-methods>
            *General-Programming-Knowledge*
            <br></br>
             A <code>stringbuilder</code> is a <red>data type</red> just like <code>string</code>. 
             <br></br><br></br>
             The main difference between them is that the <code>stringbuilder</code> is 
             <red>mutable</red>.
             <red>Mutable</red> means that once that is created the <code>string</code> can be 
             changed, whereas 
             <code>System.string</code> is not <red>mutable</red>, once created cannot be change. 
             <br></br><br></br>
             If you try to change a <code>string</code> after it was been initialized, the system will 
             create another <red>object</red> of the <code>string</code> in
             memory and pass the new <blue>value</blue> of the <code>string</code> to that <red>object</red>, 
             but the old <red>object</red> 
             which holds the old <blue>value</blue> of the <code>string</code> will not be cleaned
             until the end of the program, when the <red>garbage collector</red> does its work.
             <br></br><br></br>
             A <code>stringbuilder</code> should be used everytime when a <code>string</code> 
             that's created 
             tends to 
             change its <blue>value</blue>, in this way, only a single <red>object</red> will
             be created in memory no matter how many times its <blue>value</blue> will change, 
             because it's <red>mutable</red>.
             <br></br>
<code>
//Example of using StringBuilder and StringBuilder methods:

using System;
using System.Text; // using this for StringBuilder.

namespace project46_working_with_string_builder
{
    class Program
    {
        public static void Main(string[] args)
        {
            //Creating a stringbuilder:
            StringBuilder stringbuiler = new StringBuilder("Adam"); 
            //this is how a stringbuilder gets created and initialized
            
            //To concatenate string builders, there is a function called .Append();
            stringbuiler.Append(" has");
            stringbuiler.Append(" C#");
            stringbuiler.Append(" skills!");
            
            //Printing the stringbuilder:
            Console.WriteLine("{0}", stringbuiler);
            Console.WriteLine("{0}", stringbuiler.ToString()); 
            //this is a better way to print the stringbuilder
            
            //Other stringbuilder operations:
            stringbuiler.Clear(); //clear the stringbuiler's content
            Console.WriteLine("{0}", stringbuiler);
            
            //stringbuilder.Capacity returns the capacity of the stringbuilder
            Console.WriteLine("Stringbuilder Capacity: {0}", stringbuiler.Capacity); 
            
            Console.WriteLine("Stingbuilder Max Capacity: {0}",stringbuiler.MaxCapacity);
            
            //End of program:
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </string-methods>
        <datatype-conversions>
            *General-Programming-Knowledge*
<code>
//Example of datatype conversions:

using System;

namespace project13_implicit__explicit__data_type_conversions
{
    class Program
    {
        public static void Main(string[] args)
        {
            /* An implicit conversion is done by the compiler when there are no loss of information. 
             * Also there is no possibility of throwing exceptions during the conversion.
             * 
             * Example:
             */
             
            int numb1 = 100;
            float numb2 = numb1; //implicit conversion (done by the compiler).
            Console.WriteLine("The value of numb2 is: {0}", numb2);
            
            /* An explicit conversion is done by the programmer using type cast operators  
             * or predefined classes, data-conversion classes.
             * 
             * Example:
             */
            
            float numb3=123.543f;
            numb1 = (int) numb3; //explicit conversion using type cast.
            Console.WriteLine("The value of numb1 is: {0}", numb1);
            
            numb1 = Convert.ToInt32(numb3); //explicit conversion using Conversion Class.
            Console.WriteLine("The value of numb1 is: {0}", numb1);
            
            /* Conversion Class - will throw an exception/message when the conversion fails 
             * because one variable can't hold the value of the converted one.
             * Type Cast - will not throw any exception, will just print the minimum value that 
             * the variable can hold. 
             */
            
            //Parse Methods of converting string to int.
            string valueN = "199";
            numb1 = int.Parse(valueN); //parsing sinthax
            
            //in case if the string does not contain a valid number, an exception will be thrown. 
            //So the program will be terminated.
            Console.WriteLine("The value of numb1 after parsing is: {0}", numb1);
            
            //TryParse Methods of converting string to int.
            string valueB = "221a";
            int Result = 0;
            bool Success = int.TryParse(valueB, out Result); //sinthax of TryParse.    
            
            //if int.TryParsing is succesfull the bool Success will become true, 
            //else it will become false.
            
            //TryParse takes 2 arguments: the string to be converted 
            //and the variable that will stored the converted result (if it is successful). 
            
            //If the TryParse is not successful the Result will not be changed.
            
            if(Success)
            {
                Console.WriteLine("The value of numb1 after tryparsing is: {0}", Result );
            }
            else
            {
                Console.WriteLine("The number is invalid. The conversion was unsuccesful!");
            }
            
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>

<code>
//Example of explicit vs implicit conversions

using System;

namespace project30_explicit_vs_implicit_implementation
{
    interface I1
    {
        void Print(); 
        
        //when there are 2 interfaces with identical function, which inherits into the same child
        //the explicit implementation must be used to avoid ambiguity.
    }
    interface I2
    {
        void Print();
    }
    interface I3
    {
        void MessageShow();
    }
    interface I4
    {
        void MessageShow();
    }
    
    class Program: I1,I2,I3,I4 //this class inherits from all 4 interfaces
    {
        public static void Main(string[] args)
        {
            Program soft = new Program(); 
            //soft is reference variable for an object type Program stored in heap.
            
            soft.Print(); //calling the implicit implemented function
            
            //By TYPE CASTING - calling the explicit implemented functions.
            ((I3)soft).MessageShow(); //calling the explicit implemented function
            ((I4)soft).MessageShow(); //calling the explicit implemented function
            
            //By OBJECT REFERENCE - calling the explicit implemented functions.
            I3 explicit1 = new Program();
            I4 explicit2 = new Program();
            explicit1.MessageShow();
            explicit2.MessageShow();
            
            //END OF PROGRAM;
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
        
        //This is implicit implementation, the compilation and the runtime is fine, 
        //dispite that there is a simple implementation for the both functions.
        
        public void Print()
        {
            Console.WriteLine("Implicit Implemetation!");
        }
        
        //Explicit Implementation:
        
        //when explicitly implementing a function the access modifiers are not allowed
        void I3.MessageShow() 
        {
            Console.WriteLine("This is I3 function!");
        }
        
        //when explicitly implementing a function the access modifiers are not allowed
        void I4.MessageShow() 
        {
            Console.WriteLine("This is I4 function!");
        }
    }
}
</code>
        </datatype-conversions>
        <optional-parameters>
            *General-Programming-Knowledge*
            <br></br><br></br>
            <green>
                Ways of adding optional parameters in C#:
            </green>
            <br></br><br></br>
            <blue>
            1. Using <code>params</code> <red>arrays</red> (optional <red>arrays</red> created 
            using <code>params</code> keyword as prefix).<br></br>
            2. Methods <red>overloading</red> (<red>overloading</red> a method/function to 
            provide many <red>versions</red> with different number of <red>parameters</red>);<br></br>
            3. Methods with <red>default parameter values</red>.<br></br>
            4. Methods that are using <red>optional attribute</red>.<br></br>
            </blue>
            
<code>
//Example of using optional parameters:

using System;

//using this for the [Optional] or [OptionalAttribute] attribute
using System.Runtime.InteropServices; 

namespace project50_optional_parameters
{
    class Program
    {
        public static void Main(string[] args)
        {
            Program pr = new Program();
            Console.WriteLine("The result of adding 10, 3, 4, 6 is: {0}", pr.AddNumbers(10,3, new int[]{4,6}));
            Console.WriteLine("The result of adding 2 and 5 is: {0}", pr.AddNumbers(2,5));
            
            //Calling the second function:
            pr.PrintNrs(12);
            
            //To use the default value only for b (the second argument):
            pr.PrintNrs(1,c:22); //the value of b will be the default value (10);
            
            //To use default value only for c:
            pr.PrintNrs(1,2); //the value of c will be the default value (2);
            
            //CALLING THE OPTIONAL ATTRIBUTE FUNCTIONS:
            pr.DisplayArgs(1,3);
            pr.DisplayArgs(12,3,11);
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
        
        //Creating functions with default values:
        public int AddNumbers(int num1, int num2, int [] array = null) //syntax is just like in C++;
        {
            int result=num1+num2;
            if(array!=null)
            {
                foreach (int i in array)
                {
                    result+=i;
                }
            }
            return result;
        }
        
        
        //for a function with default parameters, the parameters initialized with
        //default values must be the last in the list of parameters 
        //(just like in case of params arrays).
        public void PrintNrs(int a, int b=10, int c=2) 
        {
            Console.WriteLine("Nr1= {0}\nNr2= {1}\nNr3= {2}", a, b, c);
        }
        
        //Creating functions with [Optional] attributes
        public void DisplayArgs(int num1, int num2, [Optional] int num3) 
        //this can also be done with [OptionalAttribute].
        {
            //In case that num3 is not specified by the user, it's value will be 0.
            Console.WriteLine("The numbers are: {0}, {1}, {2}", num1,num2,num3);
        }
    }
}
</code>
        </optional-parameters>
        <partial-classes>
            A <red>partial class</red> is a <blue>unique feature</blue> of C#. 
            <br></br><br></br>
            It can break the functionality of a single 
            <code>class</code> into many files. 
            <br></br><br></br>
            When the application is compiled, these files are then 
            reassembled into a single <code>class</code> file. 
            <br></br><br></br>
            The <code>partial</code> keyword is 
            used to build a <code>partial class</code>.
            <br></br><br></br>
            <brown>
            A partial class its used to separate/split a class into two or more parts, 
            across different files.
            </brown>
            <br></br><br></br>
            If the part of the <red>class</red> are in different files, those files must be 
            contained in the same assembly (directory of project), otherwise
            the compilation will fail. 
            <br></br><br></br>
            A <red>partial class</red> can also be used in techniques of splitting an 
            <red>interface</red> into more parts successfully.
             <br></br><br></br>
             <green>
             Important rules of partial classes:
             </green>
             <br></br><br></br>
             <blue>
             1. Without the <red>partial</red> keyword into the <red>class declaration</red>, 
             the compiler will not 
             know the intention of creating a <red>partial class</red>.
             <br></br><br></br>
             2. All the parts of a <red>partial class</red> needs to be contained by 
             the <red>same namespace</red> 
             and assembly.<br></br><br></br>
             3. All the parts must use the <red>partial</red> keyword in their declaration.
             <br></br><br></br>
             4. All the parts must use the same <red>access modifier</red> in their declaration.
             <br></br><br></br>
             5. If any of the parts is declared as <red>abstract</red>, the entire class will be 
             <red>abstract</red> (even if only a part was declared <red>abstract</red>).
             <br></br><br></br>
             6. If any of the parts is declared as <red>sealed</red>, the entire <red>class</red> will 
             be <red>sealed</red>.
             <br></br><br></br>
             7. If any of the parts is declared to be <red>inherited</red> from a a <red>class</red>, 
             the entire <red>class</red> will be <red>inherited</red> from that <red>class</red>. 
             <br></br><br></br>
             8. Different parts of the <red>partial class</red> cannot specify that they are 
             <red>inherited</red> from 
             different <red>classes</red>.
             <br></br>
             <red>Multiple class inheritance is not allowed</red> in C#.
             <br></br><br></br>
             9. Different parts of the <red>partial class</red> can specify that they <red>inherits</red> 
             from different <red>interfaces</red>, so after the compilation the <red>partial class</red>
             will be <red>inherited</red> from all the specified <red>interfaces</red> (even if they were 
             specified in different parts of the <red>class</red>).
             <br></br><br></br>
             10. The members declared to a part of the <red>partial class</red> are available to all 
             the part of the <red>partial class</red> (available in the <red>entire class</red>).
             </blue>
             
<code>
//Example of partial class in C#:

FILE: project47_partial_classes.cs

using System;

namespace project47_partial_classes
{
    class Program
    {
        public static void Main(string[] args)
        {
            //A partial class its used like a normal class.
            MyClass obj = new MyClass();
            obj.Age = 16;
            obj.Name = "Ellias";
            obj.PrintInfo();
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    
    //Example of partial class:
    //the partial keyword must be used for all the parts of the class
    partial class MyClass .
    {
        private string _Name;
        private int _Age;
        
        public int Age
        {
            get {
                return _Age;
            }
            set
            {
                _Age=value;
            }
        }
        
        public string Name
        {
            get {
                return _Name;
            }
            set
            {
                _Name=value;
            }
        }
        
        //THE SECOND PART OF THE CLASS IS IN THE ASSEMBLY DIRECTORY (PROJECT DIRECTORY), 
        //WITH THE NAME PartialClassPartTwo, AND CONTAINS A METHOD CALLED PrintInfo().
    }
    
}
</code>

<code>
//FILE: PartialClassPartTwo.cs

using System;

//IMPORTANT: the class parts must be in the same namespace.
namespace project47_partial_classes 
{
        /// &lt;summary&gt;
        /// Description of PartialClassPartTwo.
        /// &lt;/summary&gt;
        partial class MyClass //the partial keyword must be used for all the parts of the class.
        {
                public void PrintInfo()
                {
                        Console.WriteLine("Name: {0}         Age: {1}", _Name, _Age);
                }
        }
}
</code>
        </partial-classes>
        <decorators>*General-Programming-Knowledge*</decorators>
        <operators>
            *General-Programming-Knowledge*
<code>
//Example of using operators in C#

using System;

namespace project12_new_types_null_coalescing_operator
{
    class Program
    {
        public static void Main(string[] args)
        {
            /* Non-Nullable type: Are Value TYPES: 
             * integers, boolean, double, float, long, long long, char...etc
             * 
             * Nullable type: Are Reference TYPES: 
             * classes, interface, delegates, arrays... etc
             * 
             * A Non-Nullable type can become Nullable type by using ? in their declaration.
             * 
             * Examples:
             */
            
            bool major = false; //non-nullable value type.
            bool ?minor = null; //nullable value type. 
            
            /* A nullable boolean type can hold on to 3 values: true, false or null. */
            Console.WriteLine("Are you a minor? Press Y/N to answear or anything else to skip.");
            char answear = Convert.ToChar(Console.ReadLine());
            switch(answear)
            {
                case 'y':  minor = true; break;
                case 'Y': minor = true; break;
                case 'n':  minor = false; break;
                case 'N': minor = false; break;
                default: minor = null; break;
            }
            
            if(minor == true)
            {
                Console.WriteLine("You are minor!");
            }
            else if(minor == false)
            {
                Console.WriteLine("You are not minor!");
            }
            else
            {    
                Console.WriteLine("You did not answear the question!");
            }
            
            //NULL COALESCING OPERATOR:
            int? TicketsOnSale = 100;
            
            //if TicketsOnSale is null, availableTickets will be 0, otherwise
            //availableTickets = (int)TicketsOnSale.
            int availableTickets=TicketsOnSale??0; 

            /*Equivalent method:
             * if(TicketsOnSale == null)
             * {
             *         availableTickets=0;
             * }
             * else
             * {
             *         availableTickets = (int)TicketsOnSale; 
             *         //TicketsOnSale is a nullable int, so it must be
             *         //casted to normal int.
             *         
             *         //Other method of casting:
             *         //available Tickets = TicketsOnSale.value;
             * }
             */
            
            Console.WriteLine("Available Tickets: {0}", availableTickets);
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </operators>
        <pre-post-incrementation>*General-Programming-Knowledge*</pre-post-incrementation>
        <abstract-classes>
            *General-Programming-Knowledge*
            <br></br>
            <green>In C#:</green> 
            <br></br><br></br>
             An <red>abstract class</red> is similar to an <red>interface</red>, 
             dispite that it can contain 
             <blue>variable_members(field members)</blue> , and that
             an <red>abstract class</red> it's acting like a <red>class</red> when it comes to 
             <blue>inheritance</blue>.
             <br></br><br></br>
             An <red>abstract class</red> can have implementation
             for some or even for all its <blue>members/field</blue>, while the <red>interface</red> 
             cannot.
             <br></br><br></br>
             An <red>abstract class</red> can use the (<red>public</red>) 
            <blue>access modifiers</blue> whereas an <red>interface</red> cannot. 
            <br></br><br></br>
            An <red>interface</red> can be <red>inherited</red> only from another <red>interface</red>, 
            while an <red>abstract class</red>
            can be <blue>inherited</blue> either from an <red>interface</red> or <red>abstract class</red>. 
            <br></br><br></br>
            A <red>class</red> can <blue>inherit</blue> from multiple <red>interfaces</red> at the
            same time whereas a <red>class</red> cannot inherit from <blue>multiple classes</blue>.
            <br></br><br></br>
            <green>Rules for abstract classes in C#:</green>
            <br></br><br></br>
            <blue>
             1. An <red>abstract class</red> cannot be <red>instanciated</red> (an <red>instance</red> 
             of the <red>class</red> cannot be created).<br></br>
             <br></br>
             2. An <red>abstract class</red> can contain <red>abstract members</red>, and the 
             <red>abstract members</red>
             are not allowed to be implemented in
             that <red>class</red>.<br></br>
             <br></br>
             3. An <red>abstract class</red> can inherit (can have <red>children classes</red>), and every child 
             of the <red>class</red> must provide its
             own implementations for the <red>abstract members</red> of the <red>parent class</red>.<br></br>
             <br></br>
             4. Any <red>class</red> provides <red>single inheritance</red> (the child of the <red>class</red> can have 
             only one <red>parent/base class</red>).<br></br>
             <br></br>
             5. An <red>abstract class</red> can only be used as a <red>base class</red>. 
             So an <red>abstract class</red> cannot be <red>sealed</red>.<br></br>
             <br></br>
             6. If a <red>class</red> that's inherited from an <red>abstract class</red> 
             doesn't wish to provide implementation for the <red>parent class</red>
             <red>abstract members</red>, then that <red>class</red> can be also 
             set as <red>abstract</red>.<br></br>
             </blue>
<code>
//Example of abstract class in C#:

using System;

namespace project32_abstract_classes
{
    //A class can inherit only from a single class. 
    //(multiple class inheritance is not allowed)
    
    class Program: AbsClass 
    {
        public static void Main(string[] args)
        {
            Program p1 = new Program();
            p1.MessageShow();
            p1.Print();
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
        
        //In order to provide implementation for an abstract member of the parent 
        //class the override keyword must be used.
        protected override void Print()
        {
            Console.WriteLine("Providing implementation for the parent abstract class member.");
        }
    }
    
    //Creating an abstract class:
    public abstract class AbsClass
    {
        //this function is abstract
        protected abstract void Print(); 
        
        //this is a normal function
        public void MessageShow()
        {
            Console.WriteLine("This is not an abstract member.");
        }
    }
}
</code>
        </abstract-classes>
        <recursion>
            *General-Programming-Knowledge*
        </recursion>
        <reflection>
            *General-Programming-Knowledge*
<code>
//Example of reflection in C#:

using System;
using System.Reflection; //using this namespace for reflection

/*
In C# every object is directly or indirectly inherited from System.Object class, 
so every type and object will have access to functionalities like:
 getType(), ToString(), etc
*/

namespace project43_reflection
{
    class Program
    {
        public static void Main(string[] args)
        {
            //Getting the type:
            //T gets the type of the project43_reflection.ExampleClass.
            Type T = Type.GetType("project43_reflection.ExampleClass");
                
            //Equivalent methods to get the type: 
            //Type T = typeof (ExampleClass);
            //ExampleClass ec = new ExampleClass();
            //Type T = ec.GetType();
                
            //Getting the properties:
            //T.GetProprieties returns an array of type PropertyInfo, containing all
            //the information about the proprieties of the class.
            PropertyInfo [] proprietiesFound = T.GetProperties(); 
            
            foreach(PropertyInfo k in proprietiesFound)
            {
                Console.WriteLine("Property Name: {0}   Property type: {1}", k.Name, k.PropertyType); 
                //printing the proprieties of the class ExampleClass.
            }
                
            Console.WriteLine();        
                
            //Getting the methods:
            MethodInfo[] methodsFound = T.GetMethods();
            foreach(MethodInfo k in methodsFound)
            {
                Console.WriteLine("Method Name: {0} Method return type: {1}", k.Name, k.ReturnType);
            }
            Console.WriteLine();
                
            //Getting members:
            MemberInfo [] membersFound = T.GetMembers();
            foreach(MemberInfo k in membersFound)
            {
                Console.WriteLine("Member Name: {0} Member type: {1}", k.Name,  k.MemberType);
            }
                
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    
    class ExampleClass
    {
        //Variables:
        private int _age;
        private string _name;
            
        //Properties:
        public string Name 
        {
            get{
                    return this._name;
            }
            set{
                    this._name=value;
            }
        }
        public int Age
        {
            get{
                    return this._age;
            }
            set{
                    this._age=value;
            }
        }
            
        //Methods:
        public void Print()
        {
                Console.WriteLine("Name: {0}        Age: {1}", this._name, this._age);
        }
    }
}
</code>
        </reflection>
    </programming_language>
    
    <programming_language>
        <name>JavaScript</name>
        <description>
            JavaScript often abbreviated as JS, is a programming language and core 
            technology of the Web, alongside HTML and CSS. <blue>99%</blue> of websites use JavaScript 
            on the <blue>client side</blue> for webpage behavior.
            <br></br><br></br>
            Web browsers have a dedicated JavaScript engine that executes the client code. 
            These engines are also utilized in some servers and a variety of apps. The most 
            popular runtime system for non-browser usage is Node.js.
            <br></br><br></br>
            JavaScript is a <blue>high-level</blue>, often <blue>just-in-time</blue> 
            compiled language that conforms 
            to the ECMAScript standard. It has <blue>dynamic typing</blue>, <blue>prototype-based</blue>
            <blue>object-orientation</blue>, and <blue>first-class functions</blue>. It is 
            <blue>multi-paradigm</blue>, 
            supporting <blue>event-driven</blue>, <blue>functional</blue>, and <blue>imperative</blue> 
            programming styles. 
            It has application programming interfaces (APIs) for working with text, dates, 
            regular expressions, standard data structures, and the Document Object Model (DOM).
            <br></br><br></br>
            
            Difference between <blue>JavaScript</blue> and <red>PHP</red> is that 
            <blue>JavaScript</blue> is <blue>running in the client 
            computer's browser</blue>, and its performance depends only on the client 
            computer's specifications. 
            Whereas <red>PHP</red> is a programming language that <red>runs on a server</red> so when 
            the client is using a <red>PHP script</red> its computer will make a <red>request to 
            the server</red> with the purpose of getting the <red>compilation result</red> and 
            <red>transfer</red> that information back to the client computer. 
            <br></br><br></br>
            
            This action is significantly slower than the javascript because in case that 
            the server is busy, that action might take place in a matter of seconds, or minutes. 
            While in case of JavaScript the action completes almost instantaneos.
            <br></br><br></br>
            
            PHP is a <red>back-end</red> development language (related to the server), JavaScript is a 
            <blue>front-end</blue> development language related to the client computer/machine.
        </description>
        <oop>
            *General-Programming-Knowledge*
            <br></br>
            <green>
            OOP in JavaScript:
            </green>
            <br></br><br></br>
            The objects can be classifed in <blue>2</blue> categories:<br></br>
            <blue>
            - standard built-in objects;<br></br>
            - custom objects;<br></br>
            </blue>
            <br></br>
            In Javascript the concept called of <blue>"class"</blue> is different, so objects are 
            not built based on <blue>classes</blue> alone, but also based on <red>functions</red> or 
            <red>literal notations</red> (or <red>singletons</red>).
            <br></br>
<code>
//Example of creating objects in JavaScript:

//Creating an object using an function as Object Constructor:

function Employee (firstName, lastName) //This will be the constructor;
{
    this.firstName = firstName;
    this.LastName = lastName;
    
    //This is an object method:
    this.getFullName = function () {
        return this.firstName + " " + this.LastName;
    }
}

//Creating an instance of the object:

var emp = new Employee("Alan", "Walker");
document.write("First Name: " + emp.firstName + "&lt;br&gt;");
document.write("Last Name: " + emp.LastName + "&lt;br&gt;");
document.write("Full Name: " + emp.getFullName() + "&lt;br&gt;");

//Creating a class with Object Constructor:
class Student
{

    constructor(firstName, lastName)
    {
        this.firstName = firstName;
        this.LastName = lastName;
    }
    getFullName() 
    {
        return this.firstName + " " + this.LastName;
    }
}

var stud = new Student("Alan", "Walker");
document.write("First Name: " + stud.firstName + "&lt;br&gt;");
document.write("Last Name: " + stud.LastName + "&lt;br&gt;");
document.write("Full Name: " + stud.getFullName() + "&lt;br&gt;");

//Creating an object using a Variable/Literal Notation or Singleton:

var objct = { //in this case we already create an object/instance.

    //Here we are now describing the functionality of the object:

    // In this case instead of equal sign for assignment 
    //we use colon operator and coma afterwards;
    
    firstName: "Alan", 
    lastName: "Walker",
    
    getFullName: function ()
    {
        return this.firstName + " " + this.lastName;
    }
} 

//Displaying the information about this objct:

document.write("&lt;br&gt;First Name: " + objct.firstName + "&lt;br&gt;");
document.write("Last Name: " + objct.lastName + "&lt;br&gt;");
document.write("Full Name: " + objct.getFullName() + "&lt;br&gt;");

</code>
            <br></br>
            <green>Differences between the Object Constructor and Object Literal/Singleton:
            </green>
            <br></br><br></br>
            In the <blue>constructor</blue> case the properties are separed by their values 
            using <red>=</red> operator, whereas in case of <blue>literal notation</blue> 
            we use <red>:</red> operator;
            <br></br><br></br>
            In case of <blue>contructor</blue> we use <red>;</red> to separate the properties, in 
            <blue>literal notation</blue> we use <red>,</red> 
            instead.
            <br></br><br></br>
            With the <blue>constructor method</blue>, you first need to create an <red>instance</red> 
            in order to access its properties, but with <blue>literal notation</blue> the 
            <red>instance</red> is already created, so you can just access it. 
            <br></br><br></br>
            <red>Objects</red> created using <blue>literal notation</blue> are <blue>singletons</blue>, 
            this mean that when a value is 
            changed for an <red>instance</red>, it affects all the <red>instances</red> created. 
            <br></br><br></br>
            This is happening because all the <red>instances</red> created from <blue>literal notation</blue> 
            will reference the same set of values, so if any of them make a change, that change will 
            affect the whole set of <red>instances</red>.
            <br></br>
            Whereas this is not the case using <blue>constructor objects</blue>.
            <br></br><br></br>
            <green>
            When to use Object Constructor or Object Literal/Singleton:
            </green>
            <br></br><br></br>
            When multiple <red>instances</red> of an <red>object</red> are needed the <blue>object contructor</blue> will be used.
            <br></br>
            When single <red>instance</red> of an <red>object</red> is needed the <blue>object literal</blue> can be used.
            <br></br><br></br>
            <blue>Singleton</blue> means that the <red>object</red> cannot have multiple <red>instances</red> 
            without affecting one another. <br></br>
            That's why the <red>object literal</red> is a <blue>singleton</blue>.
            <br></br><br></br>
            The common way used for creating <red>objects</red> in all the <blue>OOP languages</blue> is by using 
            <blue>Object Constructor</blue>.
            <br></br>
        </oop>
        <reflection>
            *General-Programming-Knowledge*
            <br></br>
            <blue>Reflection</blue> allows the <blue>inspection</blue> of <blue>meta data</blue>, 
            <blue>assemblies</blue>, <blue>modules</blue> and <blue>type</blue>.
            <br></br><br></br>
            If the <red>object</red> is <red>derived</red> from a <red>base class</red> than
            <blue>reflection</blue> can also <blue>inspect</blue> the <red>parent/base class</red> data.
<code>
//Example of reflection in JavaScript

var Class = function (objName, objID, objType) {
    //These are public fields:
    this.ObjectName = objName;
    this.ObjectID= objID;
    this.ObjectType = objType;
}

//These are public methods:
Class.prototype.getObjectName = function () {
    return this.ObjectName + "&lt;br&gt;";
}

Class.prototype.getObjectID = function () {
    return this.ObjectID + "&lt;br&gt;";
}

Class.prototype.getObjectType = function () {
    return this.ObjectType + "&lt;br&gt;";
}

var Class = new Class ("Car", "2", "Base Class");

//Creating a foreach loop:
for (var property in Class)
{
    //Checking if the property is a variable:
    if(typeof Class[property] != "function")
    {
        document.write(property + " : " + Class[property] + "&lt;br&gt;");
        //A property of class can be accessed using ClassName[foreach_variable].
    }
}

document.write("&lt;br&gt;");
//Another foreach loop:
for (var p in Class)
{
    //Checking if a property is not inherited:
    if( Class.hasOwnProperty(p) )
    {
        document.write(p + " : " + Class[p] + "&lt;br&gt;");
    }
    
    //Checking if a property is inherited:
    if( !Class.hasOwnProperty(p) )
    {
        document.write(p + " : " + Class[p] + "&lt;br&gt;");
    }
}
</code>
        </reflection>
        <encapsulation>
            *General-Programming-Knowledge*
<code>
//Example of encapsulation in JavaScript:

function Car ()
{
    //Creating private fields using the naming convention.
    var _speed;
    var _acceleration;
    
    //Creating properties: getters and setters
    Object.defineProperty(this, "speed", 
    {
        get: function () 
        {
            return _speed;
        } 
        , //using the coma operator to separate between get and set properties:
        set: function (value)
        {
        
            _speed = value;
        }
    })
    
    //The second way of creating getters and setters
    
    //Private methods:
    function getAccel()
    {
        return _acceleration;
    }
    function setAccel(value)
    {
        _acceleration = value;
    }
    
    //The third way of achieving encapsulation
    
    //Privileged methods;
    this.getAcceleration = function() //this is a get function
    {
        return getAccel();
    }
    this.setAcceleration = function (value) //this is a set function
    {
        setAccel(value);
    }
    
    /*
    Privileged methods can be accessed from anywhere, and apart of public methods. 
    
    Privileged methods are the only methods that can access directly private 
    fields and functions. 
    
    In the case of public methods this is not possible.
    */
    
}

var c = new Car();

//Now we can use this syntax for initializing the private fields:
c.speed = 12; //using the set:

document.write ("The car speed is " + c.speed + "&lt;br&gt;"); //using the get;

//Using the second way of encapsulation:

c.setAcceleration(22); //using the setter
document.write ("The car acceleration is " + c.getAcceleration() + "&lt;br&gt;"); //using the getter;
</code>
        </encapsulation>
        <polymorphism>
            *General-Programming-Knowledge*
<code>
//Creating polymorphism in Javascript:

//Creating a base class;
var Shape = function() { }

//Adding a function to the class:
Shape.prototype.draw = function () 
{
    return "I am a generic shape.";
}

//Creating another class
var Circle = function () {}

//Doing the inheritance:
Circle.prototype = Object.create(Shape.prototype);

//Overriding the base class function:
Circle.prototype.draw = function ()
{
    return "I am a circle shape.";
}

//Creating another class
var Square = function () {}

//Doing the inheritance:
Square.prototype = Object.create(Shape.prototype);

//Overriding the base class function:
Square.prototype.draw = function () 
{
    return "I am a square shape.";
}

//Creating a collection of objects:
var collection = [new Shape(), new Circle(), new Square()];

//Iterating through the collection using foreach loop:
collection.forEach(function (shape) {

    document.write(shape.draw() + "&lt;br&gt;");
    
    //Expected result every object calls it's own implementation of .draw() function.
    //OUTPUT:
    //
    //I am a generic shape.
    //I am a circle shape.
    //I am a square shape.
})
</code>
        </polymorphism>
        <inheritance>
            *General-Programming-Knowledge*
            <br></br>
            In other programming languages a <red>class</red> <blue>inherits</blue> from 
            another <red>class</red>, 
            but in Javascript an <red>object</red> will only <blue>inherits</blue> from another 
            <red>object</red> (this is called <blue>prototype based inheritance</blue>).
            <br></br><br></br>
            Also it's not possible for a <red>constructor</red> to
            <blue>inherit</blue> from another <red>constructor</red>.
            <br></br><br></br>
            A <red>constructor</red> can <blue>inherit</blue> only from an <red>instance</red> 
            of another (also called <red>object</red>).
            <br></br>
<code>
//Example of inheritance in JavaScript:

//Creating a singleton object constructor:

var Vehicle = function (Name, Traction)
{
    this.name = Name;
    this.traction = Traction;
}

/*
Creating a function object constructor will work as well:

function Vehicle(Name, Traction)
{
    this.name = Name;
    this.traction = Traction;
}
*/

//Creating a function using the prototype object:
Vehicle.prototype.getName = function ()
{
    return this.name;
}
Vehicle.prototype.getTraction = function()
{
    return this.traction;
}

//Creating another singleton object:

//Inheritance can also be made using the first singleton object(var Vehicle), 
//as well, but the main fields should be initialized first. 
//Example:

var car = function (speed, acceleration)
{
    //this keyword refers to the current instance's field.
    this.speed = speed;
    this.acceleration = acceleration;
}

//Creating an object from the singleton constructor:
var vehicle = new Vehicle("Bike", "2 wheels");

//Creating the inheritance:
car.prototype = vehicle; 
//Now the any object of the car constructor is a child of the "vehicle" object.

//Creating an object of the constructor "car".
var c = new car(22, 109); 

document.write("The following fields are inherited: &lt;br&gt;");

//calling the functions inherited from parent object.
document.write("Name: " + c.getName() + "&lt;br&gt;"); 
document.write("Traction: " + c.getTraction() + "&lt;br&gt;"); 

/*
Adding a new method to the parent object will automatically 
make it available to the child object.

.hasOwnProperty() - this method will check whether a property/field/variable 
is defined on the actual object or prototype. 

By that it can be found all the inherited properties.
*/

document.write("Is Name a Property of c Object: " + c.hasOwnProperty("name") + "&lt;br&gt;");
document.write("Is Speed a Property of c Object: " + c.hasOwnProperty("speed") + "&lt;br&gt;");


/* Another Example: Inheritance from the first object of the singleton: */

document.write("Singleton Nume: " + Vehicle.name + "&lt;br&gt;");
Vehicle.name = "Something";
Vehicle.traction = "4 wheels";

document.write("Singleton Nume: " + Vehicle.name + "&lt;br&gt;");

function Class (num)
{
    this.number = num;
}

Class.prototype = Vehicle;
var clas = new Class(4)

document.write("Inherited From Singleton: " + clas.name + "&lt;br&gt;");

/*
Inheritance can be realized without singletons as well:

function Class (num)
{
    this.number = num;
}

var cl = new Class(7);

function B (name)
{
    this.name = name;
}
B.prototype = cl;

var bb = new B("Alan");

document.write(bb.number + " is perfectly valid" + "&lt;br&gt;");
*/
</code>
        </inheritance>
        <abstraction>
            *General-Programming-Knowledge*
            <br></br>
            <red>Abstract object constructors</red> are those <red>constructors</red> that 
            cannot be <blue>instantiated</blue>. That means that no <red>object</red> can be 
            created out of them. 
            The purpose of using such <red>constructors</red> is to provide <red>inheritance</red> 
            to other prototypes. 
            <br></br><br></br>
            In this way the functionality can be shared amongst the <red>objects</red> without 
            needing any <blue>instances</blue>.
            <br></br><br></br>
            Blocking a constructor from being <blue>instantiated</blue> will result in error.
<code>
//Example of abstraction

function House ()
{
    this.personName = "";
    
    //This will block anyone from creating an instance with this constructor.
    throw Error ("Cannot instantiate an abstract object.");
    
}

//This is a public-static method of House object;
House.prototype.printMsg = function()
{
    document.write("Printing a message!" + "&lt;br&gt;");
}

function Home(pn)
{
    //Using the base object (Home) field named personName;
    personName = pn;
    
    this.getHomeOwnerName = function ()
    {
        return personName;
    }
}

//Creating the inheritance:

//House is gonna be the base class for Home constructor

Home.prototype = Object.create(House.prototype); 

/*
Object.create - will create an object without using the constructor.
*/

//Creating an instance of the child object:
var h = new Home("Adrian");

//Using the child object method and parent object field:
document.write("Owner's name: " + h.getHomeOwnerName() + "&lt;br&gt;");
document.write("Is name owned by this class: " + h.hasOwnProperty("personName") + "&lt;br&gt;");
document.write("Is h instance of House: " + (h instanceof House) + "&lt;br&gt;")
document.write("Is h instance of Home: " + (h instanceof Home) + "&lt;br&gt;")

//Calling the base object method;
h.printMsg();
</code>
        </abstraction>
        <generic-programming>
            *General-Programming-Knowledge*
            <br></br>
            TypeScript is a syntactic superset of JavaScript which adds <blue>static typing</blue> which
            also facilitates the use of <blue>generic-programming</blue>.
            <br></br><br></br>
            This basically means that TypeScript adds syntax on top of JavaScript, 
            allowing developers to add <blue>data types</blue>.
            <br></br><br></br>
            <green>
            Why should I use TypeScript?
            </green>
            <br></br><br></br>
            JavaScript is a <blue>loosely typed language</blue>. It can be difficult to understand 
            what <blue>types of data</blue> are being passed around within the script.
            <br></br><br></br>
            In JavaScript, <blue>function parameters</blue> and <blue>variables</blue> don't have 
            any information! 
            So developers need to look at documentation, or guess based on the implementation.
            <br></br><br></br>
            TypeScript allows specifying the <blue>types of data</blue> being passed around within 
            the code, and has the ability to report errors when the <blue>types</blue> don't match.
            <br></br><br></br>
            For example, TypeScript will report an error when passing a <code>string</code> into a 
            function that expects a <blue>number</blue>. JavaScript will not do that.
            <br></br><br></br>
            TypeScript uses compile time <blue>type checking</blue>. Which means it checks if the 
            specified <blue>types match</blue> 
            <red>before</red> running the code, <red>not while</red> running the code.
            <br></br><br></br>
            <blue>Generics</blue> allow creating 'type variables' which can be used to 
            create <blue>classes</blue>, <blue>functions</blue> and 
            <blue>type aliases</blue> that don't need to explicitly define the types that they use.
            <br></br>
<code>
//Example of generic programming in JavaScript using TypeScript:

function createPair&lt;S, T&gt;(v1: S, v2: T): [S, T] 
{
  return [v1, v2];
}
console.log(createPair&lt;string, number&gt;('hello', 42)); 

//OUTPUT: ['hello', 42]
</code>

<code>
//Example of generic class implementation

class NamedValue&lt;T&gt; 
{
  private _value: T | undefined;

  constructor(private name: string) {}

  public setValue(value: T) 
  {
    this._value = value;
  }

  public getValue(): T | undefined 
  {
    return this._value;
  }

  public toString(): string 
  {
    return `${this.name}: ${this._value}`;
  }
}

let value = new NamedValue&lt;number&gt;('myNumber');
value.setValue(10);
console.log(value.toString()); // myNumber: 10
</code>
        </generic-programming>
        <variable-arguments-lists>
            *General-Programming-Knowledge*
<code>
//Example of using variable number of arguments in JavaScript:

/*
The argument object is used to store the value of arguments of a function.
Accessing the argument object outside a function will result in undefined error.
The argument object is not an array, but it only has one property of the array, 
and that is .length
*/

function Myfct(a,b,c)
{
    document.write("The function has: " + arguments.length + " arguments.&lt;br&gt;");
    
    //arguments.length will return the number of arguments that was passed to the function. 
    //Not the number of parameters that the function has. 
    
    document.write("&lt;br&gt;The arguments are: &lt;br&gt;");
    for (var i =0; i&lt;arguments.length; i++)
    {
        document.write(" " + arguments[i] + " ");
    }
    document.write("&lt;br&gt;");
    
};

/*
The Myfct(a,b,c) function has 3 parameters: a,b,c 
but it is called below using 5 arguments: 0,1,3,4,5
*/

Myfct(0,1,3,4,5); 

//In JavaScript a function can be called using any number of arguments. 
//The unnecessary ones will be ignored.

//Creating a function with various number of arguments;

function getSum() 
{
    var sum=0;
    for (var i=0; i&lt;arguments.length; i++)
    {
        sum+=arguments[i];
    }
    return sum;
    
};

//See how the getSum() function is declared without any parameters 
//but it is called with various number of arguments each time.

document.write("&lt;br&gt;The sum of all the arguments is: " + getSum(1,12,3,22,1,3,4,22) + "&lt;br&gt;");
document.write("The sum of all the arguments is: " + getSum(-2,10,4,21) + "&lt;br&gt;");

//the function was called with different number of arguments each time and 
//it worked fine every time.
</code>
        </variable-arguments-lists>
        <simple-data-types>
            Javascript is a <blue>dynamical type</blue> language this means that any variable 
            can store any <blue>data type</blue>.
            <br></br><br></br>
            <green>
            Data Values:
            </green>
            <br></br><br></br>
            Numbers: <blue>22</blue>, <blue>22.4</blue>, <blue>44</blue>;<br></br>
            Strings: <blue>"me"</blue>, <blue>"you"</blue>; <br></br>
            boolean: <blue>true</blue>, <blue>false</blue>; <br></br>
            <red><br></br>
            Strings can also be initialized using single quotes such as: 'me', 'you'
            </red>
            <br></br><br></br>
            All the variables are declared using the <code>var</code> keyword.
<code>
//Example of using JavaScript dynamical typed variables:

var A = 22;
A="My string";
//This is perfectly valid, because the var size and type 
//will be automatically converted as needed.

/*
Variables and function as in other programming languages they are case sensitive 
this means that var A is different from var a; 
and function A () {} is different from function a() {};
*/
</code>
            In order to add <blue>static typing</blue> so that JavaScript can work with 
            <blue>data types</blue>, the TypeScript was introduced. 
            <br></br><br></br>
            TypeScript is a free and open-source <blue>high-level</blue> programming language developed by 
            Microsoft that adds <blue>static typing</blue> with optional type annotations to JavaScript.
            <br></br><br></br>
            Example of using TypeScript data-types:
<code>
//String data-type:
var name:string = "John";

//Number data-type:
var score1:number = 50;
var score2:number = 42.50

//Array data-type
var alphas:string[]; 
alphas = ["1","2","3","4"] 

//Tuple data-type
var mytuple = []; 
mytuple[0] = 120 
mytuple[1] = 234

//Union data-type
var val:string|number 
val = 12 

//Interface data-type:
interface IPerson { 
   firstName:string, 
   lastName:string, 
   sayHi: ()=>string 
} 

//Classes
class Shape { 
   Area:number 
   
   constructor(a:number) { 
      this.Area = a 
   } 
} 
</code>
        </simple-data-types>
        <loops>
            *General-Programming-Knowledge*
            <br></br>
            <green>
            JavaScript also provides a forEach() function.
            </green>
            <br></br><br></br>
            The <code>forEach()</code> method of Array instances executes a provided function once 
            for each array element.
            <br></br>
<code>
//Example of foreach loop in JavaScript
const array1 = ['a', 'b', 'c'];

array1.forEach((element) => console.log(element));

// Expected output: "a"
// Expected output: "b"
// Expected output: "c"

</code>
        </loops>
        <collections>
            *General-Programming-Knowledge*
            <br></br>
            <green>In JavaScript:</green>
            <br></br><br></br>
            An <red>array</red> is a collection of variables which can take 
            any type of values. A JavaScript <red>Array</red> is much like a 
            <blue>Vector</blue> or a <blue>List</blue>, 
            being <red>dynamic in length</red> (resizeable).
            <br></br><br></br>
            For example: an <red>array</red> could store both <blue>strings</blue> and 
            <blue>integer</blue> values in it.
            <br></br>
<code>
//Example of creating an array in JavaScript:

//Creating an array without a constructor:
var arr = ["James", 10, 2];

//Another ways to create an array without a constructor:
var arr2 = []; //Creating an array (without constructor), the size is not specified.

/*
Dispite the other C-like languages, creating an array using this syntax make it resizeable.
*/

arr2[0]= 22; //the array length is now 1.
arr2[1]= 44; //the array length is now 2.

//Creating an array using the constructor

var arr3 = new Array(5); // the 5 between the parenthesis specifies the length.
//The elements of arr3 are not initialized.

//Creating an array using constructor, the elements are specified.
var arr4 = new Array(26,8,1994); 

/*
The elements can be specified while creating an array using a constructor, 
by using multiple arguments when calling it. 
So, you cannot create and initialize an array with a single element, using this syntax. 
*/

</code>
        </collections>
        <collection-methods>
            *General-Programming-Knowledge*
            The collection methods in Javascript can be divided in 2 categories:
            <br></br>
            <blue>
             - mutator methods;<br></br>
             - non-mutator methods;<br></br>
            </blue>
            <br></br>
            A <blue>mutator method</blue> is a method that change or modify the <red>array object</red>
            (in size or content).
            <br></br><br></br>
            The <blue>non-mutator methods</blue> are the methods that don't perform 
            any change on the <red>array object</red>.
<code>

//Creating an array using constructor.
var arr4 = new Array(26,8,1994); 

//.length property contains the current number of elements within the array
document.write("The length of arr4 is: " + arr4.length + "&lt;br&gt;");

//.pop() - This method removes and returns the last item from the array.
document.write("This element was returned using pop method: " + arr4.pop() + "&lt;br&gt;");

//.shift() - This method removes and returns the first element of the array.
document.write("This element was returned using shift method: " + arr4.shift() + "&lt;br&gt;");

/*
MORE METHODS:

These are Mutator methods:
.push() - This method adds a new item at the end of the array.
.pop() - This method removes and returns the last item from the array.
.unshift() - This method adds a new item at the beginning of the array.
.shift() - This method removes and returns the first element of the array.

.reverse() - This method reverse the element order of an Array Object 
(the last element becomes the first, etc).

.sort() - This method sorts the items of an array (alphabetical, descending or ascending, etc).

.slice() - This method returns a shallow copy of a portion of an array into a new array object 
selected from begin to end (end not included). 
The original array will not be modified. 
It can be used for adding or removing a group of item after the specified index. 

Non-mutator methods:
.contains() - This method returns a boolean value specifying whether the searched value 
is present in the array or not.

.lastIndexOf() - This method returns the position of the last occurrence of a specified value.
.indexOf() - This method returns the position of the first occurrence of a specified value.

*/
</code>
        </collection-methods>
        <serialization>*General-Programming-Knowledge*</serialization>
        <deserialization>*General-Programming-Knowledge*</deserialization>
        <enums>
            *General-Programming-Knowledge*
            In JavaScript <blue>enums</blue> are made available only with by the means of TypeScript.
<code>
//Example of using enums in TypeScript:

enum CardinalDirections 
{
  North,
  East,
  South,
  West
}

let currentDirection = CardinalDirections.North;
// logs 0
console.log(currentDirection);

// throws error as 'North' is not a valid enum
currentDirection = 'North'; // Error: "North" is not assignable to type 'CardinalDirections'.
</code>
        </enums>
        <constructors>
            *General-Programming-Knowledge*
            <br></br>
            A <blue>constructor</blue> is a special function that creates and initializes an 
            <blue>object instance</blue> of a class. 
            <br></br><br></br>
            In JavaScript, a <blue>constructor</blue> gets called when an <blue>object</blue> 
            is created using the <code>new</code> keyword.
<code>
//Example of constructor in JavaScript:

function User (name, age) {
    this.name = name;
    this.age = age;
}

var user1 = new User('Bob', 25);
var user2 = new User('Alice', 27);
</code>
        </constructors>
        <instantiation>
            *General-Programming-Knowledge*
<code>
//Instantiation in Javascript:

var user1 = new User('Bob', 25);
</code>
        </instantiation>
        <destructors>
            *General-Programming-Knowledge*
            <br></br>
            <brown>
            JavaScript doesn't have a concept of destructors like many OOP languages.
            </brown>
        </destructors>
        <function-overloading>
            *General-Programming-Knowledge*
            <br></br>
            <green>
                JavaScript does not support function overloading.
            </green>
            <br></br><br></br>
             When creating <blue>2 functions</blue> with the <blue>same name</blue> and different
             number of arguments in JavaScript, the <blue>function</blue> declared <red>later</red> 
             will <red>replace</red> the <blue>function</blue> 
             declared <red>sooner</red>, in the <blue>global namespace</blue>. 
             <br></br><br></br>
             This process is called <blue>namespace pollution</blue> (or <blue>name collision</blue>). 
             <br></br><br></br>
             Also if the scripts are written in different <blue>files</blue>, the <blue>file</blue> 
             which is <red>loaded last</red> will <red>replace</red> the <blue>function</blue> 
             declared into the <blue>file</blue> which was <red>loaded first</red>.
             <br></br>
<code>
//Example of namespace pollution

function PrintSomething()
{
    alert("This is the first function.");
}

function PrintSomething(a) //this function will replace the first function declared above;
{
    alert("This is the second function.");
}

PrintSomething(5);

//OUTPUT:
//This is the second function.
</code>
        </function-overloading>
        <operator-overloading>
            *General-Programming-Knowledge*
            <br></br>
            <green>
                JavaScript doesn't support operator overloading.
            </green>
        </operator-overloading>
        <concurrent-programming>
            *General-Programming-Knowledge*
            <br></br><br></br>
            <green>Multithreading in JavaScript:</green>
            <br></br><br></br>
            JavaScript is a <blue>single-threaded language</blue> which means it <red>does 
            not support multithreading</red>. <br></br>
            <br></br>
            All the operations in JavaScript are non-blocking and are executed in the event loop. 
            <br></br>
            This <blue>single-threaded</blue> nature along with <red>event loop</red> allows 
            JavaScript to handle <red>concurrent</red> operations at once.
            <br></br>
        </concurrent-programming>
        <namespaces>
            *General-Programming-Knowledge*
            <br></br>
            In JavaScript: it is possible to declare <blue>2 functions</blue> with the same name, 
            but not in the <blue>same namespace</blue>.
            <br></br><br></br>
            Similarly with creating <blue>2 variables</blue> with the same <blue>name</blue> but in 
            different <red>scope</red> (<red>global</red> and <red>local</red>).
            <br></br><br></br>
            The <blue>global namespace</blue> in JavaScript can be accessed using <code>window.Object</code> 
            - where <red>Object</red> is an item in the <blue>global namespace</blue> <red>"window"</red>.
<code>
//Example of creating a namespace in JavaScript:

//Create a variable named NameSpace 
//if such an object already exists, than my variable will take its value,
//otherwise my variable will be an empty object {};
var NameSpace = NameSpace || {} 

//Creating a nested namespace/object;
NameSpace.a = NameSpace.a || {} 

//Creating an object into the nested namespace:
NameSpace.a.print = function () 
{
    this.PrintMessage = function ()
    {
        alert("Message from the nested object.");
    }
}

//Creating an instance of the nested namespace object.
var a = new NameSpace.a.print;

//Setting the object method for the onclick button.
document.getElementById("but2").onclick = a.PrintMessage;

/*
Another example of creating a namespace:
    var yourNamespace = {

        foo: function() {
        },

        bar: function() {
        }
    };

    yourNamespace.foo();
*/
</code>
        </namespaces>
        <exception-handling>
            *General-Programming-Knowledge*
<code>
//Example of exception handling in JavaScript:

try
{
    //The code that can produce exception will be put here:
    document.write(sayHello()); //calling undefined function will cause an exception;
    
    document.write("This line will be skipped, once the exception was caught.&lt;br&gt;");
}
catch(e) //e is the type of exception to be caught;
{
    document.write("Error. Calling undefined function.&lt;br&gt;&lt;br&gt;");
    document.write(e.description+"&lt;br&gt;");
    document.write(e.message+"&lt;br&gt;");
    document.write(e.stack+"&lt;br&gt;");
}
finally //this will be executed no matter what.
{
    /*
    The code in this block will be executed regardless 
    if there was an exception or not.
    */
    
    document.write("&lt;br&gt;Finished. &lt;br&gt;");
}

//Throwing customized exceptions:

function Fraction(a,b)
{
    try
    {
        if (b==0)
        {
            throw 
            { 
                //creating a custom exception.
                //Completing the exception properties:
                
                error: "Divide by zero error." ,  //here is coma not semicolon
                message: "Denominator cannot be ZERO."
            }
        }
        else
        {
            return a/b;
        }
    }
    catch(e) //catching the custom exception
    {
        document.write("Exception caught. " + e.error + "&lt;br&gt;");
        document.write(e.message + "&lt;br&gt;");
    }
};

var a = parseInt(prompt("Enter a number for nominator: "));
var b = parseInt(prompt("Enter a number for denominator: "));

document.write("&lt;br&gt;The result a/b is: " + Fraction(a,b) + "&lt;br&gt;");


//Using window.onerror for handling errors:

/*
Once the window.onerror is initialized with a function which takes 3 arguments: 
msg, url, line. 

Any error that will occur will execute that code.
*/

window.onerror = function (msg, url, line)
{
    //This code will be executed each time an error occur
    //without the need of try/catch blocks.
    
    alert("Message: " + msg + "\nURL: " + url + "\nLine: " + line);
    return true;
}

//Raising window.onerror by calling undefined function:
UndefinedFunction();

/*
window.onerror is not displayed if it's places in a try/catch block, 
instead the try/catch will handle the exception it by itself.

window.onerror is raised only when there is an unhandled exception.
*/

//Handling an html element error:
function ImageErrorHandler() 
{
    //this function will be executed when the html image will have an error.
    
    alert("The image is not present.");
}
</code>
        </exception-handling>
        <bitwise-operators>
            *General-Programming-Knowledge*
<code>
//Example of working with bitwise operators in JavaScript:
let x = 5 | 1;
let x = 5 ^ 1;
let x = ~5;
let x = 5 &lt;&lt; 1;
let x = -5 &gt;&gt; 1;
</code>
        </bitwise-operators>
        <default-parameters>
            *General-Programming-Knowledge*
<code>
//Example of default arguments/parameters in JavaScript:

function myFunction(x, y) 
{
    //check whether second argument was passed to the function
    if (y === undefined) 
    {
        y = 2;
    }
}

//In JavaScript a function can be called with any number of arguments:
myFunction(2);
myFunction(2,3,4,5);
</code>
        </default-parameters>
        <interfaces>
            *General-Programming-Knowledge*
            <br></br>
            In JavaScript, an <red>interface</red> can be thought of as a set of 
            <blue>method signatures</blue> that a <red>class</red> must implement.
            <br></br><br></br>
            You can define an <red>interface</red> as an empty object 
            containing method names and their associated function signatures.
<code>
//Example of implementation of an interface in JavaScript:

const MyInterface = {
    method1: function () { },
    method2: function (param1, param2) { },
};

class MyClass {
    method1() {
        console.log("Method 1 called");
    }
 
    method2(param1, param2) {
        console.log(
            `Method 2 called with ${param1} and ${param2}`);
    }
}
 
function implementsInterface(obj, interfaceObj) {
    for (const method in interfaceObj) {
        if (!(method in obj) || 
            typeof obj[method] !== "function") {
            return false;
        }
    }
    return true;
}
 
const myObject = new MyClass();
 
if (implementsInterface(myObject, MyInterface)) {
    console.log(
        "myObject implements MyInterface");
} else {
    console.log(
        "myObject does not implement MyInterface");
}
</code>
        </interfaces>
        <random-generators>
            *General-Programming-Knowledge*<br></br>
            <br></br>
            Generate a random whole number between <blue>1</blue> and <blue>10</blue> (inclusive):
            <br></br><br></br>
<code>
//Example of generating random numbers in JavaScript:

let x = Math.floor((Math.random() * 10) + 1);
</code>
        </random-generators>
        <ternary-operator>
            *General-Programming-Knowledge*
<code>
//Example of working with ternary operator in JavaScript:

function Funct()
{
    var a = document.getElementById('textBox').value;
    
    //if statement is used to execute code when a particular condition is true
    if(isNaN(a))
    {
        document.getElementById('textBox').value+= " 'is not a number.'";
    }
    else //if the condition above is not true, then it will execute this code.
    {
        document.getElementById('textBox').value+= " is a number.";
    }

    //using ternary operator to change the color of the textbox:
    
    (isNaN(a)==true) ? alert("Entered ternary if.")  //this part is if condition is true
                    : alert("Entered ternary else.") //this part is executed otherwise.
                    
    /*
    Ternary operator is also called the short if, and has the same functionality 
    as an if statement, the only difference is that ternary operator sythax is shorter, 
    and yet harder to be read, in that regard it's better to use if else statements.
    */

    //using switch()
    if(isNaN(a) == false)
    {
        a = parseInt(a);
        
        //switch works only with constant values: 
        //integer, long, chars values. 
        //switch cannot be used with floats, doubles or strings
        
        switch(a)
        {
            case 1: {alert("you have entered 1."); break} 
            case 2: {alert("you have entered 2."); break}
            case 3: {alert("you have entered 3."); break}
            default : {alert("you have entered a number above 3 or below 1."); break}
            
            // the break statement will break out of the switch.
            //the default case is equivalent to else statement, 
            //it will be executed only of the cases above do not match.
        }    
    }
    
    /*
        switch is very similar to an if, else if, else block, 
        generally a switch statement it's faster in execution.
    */
}
</code>
        </ternary-operator>
        <modular-programming>*General-Programming-Knowledge*</modular-programming>
        <optional-parameters>*General-Programming-Knowledge*</optional-parameters>
        <string-methods>
            *General-Programming-Knowledge*
            <br></br>
            JavaScript provides several function that facilitate <blue>string manipulation</blue>:
            <br></br>
<code>
//Some string methods in JavaScript:

var string1 = "Blue bottle on a blue table."

var result = string1.replace(/blue/g , "green") 
//.replace() This function replaces a substring within a string and 
//returns the result.
//Result will be: Blue bottle on a green table.

result = string1.replace(/blue/gi, "green") 
//result will be: green bottle on a green table.

result = string1.substring(1, 4); 
//.substring() This function returns the part of this string from the start 
//index up to and excluding the end index

result = string1.substring(4, 1); 
//string1.substring(4, 1) will produce the same result as above, 
//because the function will swap the values 4 with 1, because the start 
//value needs to be smaller than the end value. 
//The value at the second parameter is not included in the returned result.

result = string1.substring(4); 
//will return a string containing all the character from 4th character 
//until the end of the string. 
//Result will be: "e bottle on a blue table."

result = string1.substr(1,4);
//.substr() has the same functionality .substring(), 
//But it doesn't swap the parameters, and the second parameter 
//specifies the last caracter to be returned.

result = string1.slice(1,4); 
//has the same functionality as the .substr()
//if the start is greater than the end - empty string is returned

result = string1.indexOf("B"); 
//this function will return the index of "B" which is 0;

result = string1.lastIndexOf(b); 
//this will return the last index of specified value "b" which is: 17

</code>
        </string-methods>
        <datatype-conversions>
            *General-Programming-Knowledge*
            <br></br>
            JavaScript variables can be converted to different <blue>data types</blue> by using the 
            following functions: <br></br><br></br>
            <code>Number()</code> - Returns a number, converted from its argument<br></br>
            <code>parseFloat()</code> - Parses a string and returns a floating point number<br></br>
            <code>parseInt()</code> - Parses a string and returns an integer<br></br>
            <code>String()</code>  - Converts to string<br></br>
        </datatype-conversions>
        <operators>
            *General-Programming-Knowledge*
<code>
//In JavaScript operator + can also be used for concatenation:
//In JavaScript variables are converted implicitly to facilitate the operation:

//Plus operator:
var a = 10;
var b = 20;
//a + b will result 30;

a = "10";
b = 20;
//a + b will result 1020;  
//'b' will be converted to string and then concatenated with 'a'.

//Minus operator:
a = "10";
b = 20;
//a-b will result -10; 
//because the string 'a' will be automatically converted to a number.
</code>
        </operators>
        <pre-post-incrementation>*General-Programming-Knowledge*</pre-post-incrementation>
        <minification>
            Minification of Javascript consists in <red>reducing the amount</red> of JavaScript 
            <blue>files</blue> used in a webpage as well as <red>reducing the size</red> of 
            each <blue>files</blue>, in order to optimize the server amount of requests from 
            the client machine.
            <br></br><br></br>
            Example: Instead of using 4 JavaScript files, it will be used a single file, 
            and instead of arranging the code in that file to be readable, it will be arranged in
            such a way that the <red>size will be reduced</red> by removing unnecessary 
            characters such used spaces, newline characters and comments.
        </minification>
        <recursion>
            *General-Programming-Knowledge*
<code>
//Example of using recursion in JavaScript

function RecursiveFunc(num)
{
    if (num &lt;= 1)
    {
        return 1;
    }
    else
    {
        return num * RecursiveFunc(num-1);
        //This will be equivalent to n* n-1* n-2* n-3* ...... *1; when it reaches 
        //1 all the functions will end
        
    }
    
    /*
        Using the loop the whole code above can be implemented as :
        var result=1;
        while(num > 1)
        {
            result*=num;
            num-=1;
        }
    */
};

document.write("This was a recursive function: " + RecursiveFunc(5) + "&lt;br&gt;");

//Comparison to loops:

document.write("&lt;br&gt;With Loops&lt;br&gt;");
var i;
for(i=0;i&lt;10;i++)
{
    document.write(i+" ");
}

//The equivalent recursive function of the for loop above is:

document.write("&lt;br&gt;With Recursion&lt;br&gt;");

function Rec(a)
{
    if(a&lt;10)
    {
        document.write(a + " ");
        Rec(a+1);
    }
};

Rec(0);
</code>
        </recursion>
        <abstract-classes>
            *General-Programming-Knowledge*
            <br></br>
            <brown>
                In Javascript, the concept of an abstract class is not natively 
                supported as it is in other languages but it is however 
                available in TypeScript.
            </brown>
<code>
//Abstract classes in TypeScript

abstract class Shape {
  name: string;
  constructor(name: string) {
     this.name = name;
  }
}

class Circle extends Shape {
  radius: number;
  constructor(name: string, radius:number){
     super(name);
     this.radius = radius;
  }
    
}

const myShape = new Shape('My shape'); // This will throw an Error 
const shortCircle = new Circle("Short Circle", 0.5); // This will work fine.
</code>
        </abstract-classes>
        <decorators>
            *General-Programming-Knowledge*
<code>
// Working with decorators in Javascript
 
// "add" function takes the function as
// a parameter for wrapping function 
// "print" is wrapped 

function add(fn) 
{
    return function(s) 
    {
        var gg = s + ' is Best';

        // By concatenating we extend
        // the function "add"
        fn(gg);
    }
}
 
// Decorated function
function print(s) 
{
    document.write(s);
}
 
// Calling "add"
var g = add(print);
g('GFG'); 
</code>
        </decorators>
    </programming_language>
    
    <programming_language>
        <name>Java</name>
        <description>
            Java is a <blue>high-level</blue>, <blue>class-based</blue>, <blue>object-oriented</blue> 
            programming language that is 
            designed to have as few implementation <blue>dependencies</blue> as possible.
            <br></br><br></br>
            It is a <blue>general-purpose</blue> programming language intended to let 
            programmers write once, 
            run anywhere meaning that compiled Java code can run on all platforms that support 
            Java without the need to recompile. <br></br><br></br>
            
            Java applications are typically compiled to <blue>bytecode</blue> that can run on any 
            Java virtual machine (JVM) regardless of the 
            underlying computer architecture. The syntax of Java is similar to C and C++, 
            but has fewer <blue>low-level facilities</blue> than either of them. 
            The Java runtime provides 
            <blue>dynamic capabilities</blue> (such as <blue>reflection</blue> and runtime code 
            modification) that are typically not available in traditional compiled languages.
        </description>
        <oop>
            *General-Programming-Knowledge*
            In Java each <blue>class</blue> must have its own .java file. 
            There cannot be multiple <blue>classes</blue> in the same file,
            unless some of them are inner <blue>classes</blue> 
            (<blue>class</blue> inside another <blue>class</blue>).
<code>
//Example of class definition in Java
 
class Student 
{
    // data member (also instance variable)
    int id;
    // data member (also instance variable)
    String name;

    public static void main(String args[])
    {
        // creating an object of
        // Student - process called instantiation
        Student s1 = new Student();
        System.out.println(s1.id);
        System.out.println(s1.name);
    }
}
</code>
        </oop>
        <encapsulation>
            *General-Programming-Knowledge*
            <br></br>
            <green>
            Encapsulation in Java:
            </green>
            <br></br><br></br>
            <blue>Encapsulation</blue> in Java is a mechanism of <blue>wrapping</blue> 
            the <red>data</red> (variables) 
            and <red>code</red> acting on the <red>data</red> (<blue>methods</blue>) 
            together as a single unit. 
            <br></br><br></br>
            In <blue>encapsulation</blue>, the variables of a <blue>class</blue> will be 
            hidden from other <blue>classes</blue>, and can be accessed only through 
            the <blue>methods</blue> of their current <blue>classes</blue>.
            <br></br><br></br>
            Therefore, it is also known as <blue>data hiding</blue>.
            <br></br>
<code>
//Example of using Encapsulation in Java
 
// Person Class
class Person 
{
    // Encapsulating the name and age
    // only approachable and used using
    // methods defined
    
    private String name;
    private int age;
 
    public String getName() { return name; }
 
    public void setName(String name) { this.name = name; }
 
    public int getAge() { return age; }
 
    public void setAge(int age) { this.age = age; }
}
 
public class Main 
{
    public static void main(String[] args)
    {
        // person object created
        Person person = new Person();
        person.setName("John");
        person.setAge(30);
 
        // Using methods to get the values from the
        // variables
        System.out.println("Name: " + person.getName());
        System.out.println("Age: " + person.getAge());
    }
}
</code>
        </encapsulation>
        <polymorphism>
            *General-Programming-Knowledge*
<code>
//Example of polymorphism in Java:

class Bike
{  
    void run(){System.out.println("running");}  
}  

class Splendor extends Bike
{  
    void run(){System.out.println("running safely with 60km");}  

    public static void main(String args[])
    {  
        //Parent datatype instantiated with child object
        Bike b = new Splendor();//upcasting  
        b.run(); 
        //even though b is Bike it's gonna act like Splendor
    }
    /*
        OUTPUT:
        running safely with 60km.
    */
}  
</code>
        </polymorphism>
        <inheritance>
            *General-Programming-Knowledge*
            <br></br>
            <green>Inheritance in Java:</green>
            <br></br><br></br>
            Java does not support <blue>multiple inheritances</blue> with <red>classes</red>. 
            But <blue>multiple 
            inheritances</blue> is still possible through the use of <red>interfaces</red>.
            <br></br>
            Any Java <red>class</red> can <red>inherit</red> from a single <red>class</red> 
            and/or <blue>multiple interfaces</blue>.
            <br></br><br></br>
            By <red>inheritance</red> the child <red>class</red> (class which inherits) <red>extends</red> 
            the functionality of the parent <red>class</red>.
            <br></br><br></br>
            <green>Implements vs Extends:</green>
            <br></br><br></br>
            - <red>extends</red> is for extending a class (<red>class inheritance</red>);<br></br>
            - <red>extends</red> can also be used for <red>interface inheritance</red>. 
            An <red>interface</red> can <red>extend</red> another <red>interface</red>.
            <br></br>
            - <blue>implements</blue> is for implementing an interface 
            (<blue>interface to class inheritance</blue>);<br></br>
            <br></br>
            Through <blue>implements</blue> the <red>interfaces</red> exhibit the same characteristics 
            to the <red>classes</red> which are implementing them.
            <br></br><br></br>
            The main difference between an <red>interface</red> and a <red>class</red> is that 
            in an <red>interface</red> cannot <red>implement</red> any 
            of the declared <red>methods</red>. 
            <br></br>
            Only the <red>class</red> that <blue>"implements"</blue> 
            the <red>interface</red> can <red>implement</red> the <red>methods</red>. 
            <br></br><br></br>
            Also
            an <red>interface</red> cannot contain instance <blue>fields/variables</blue>. 
            The only fields that can appear in an 
            <red>interface</red> must be declared both <red>static</red> and <red>final</red>.
            <br></br>
            A <red>final</red> variable, also called a <blue>“constant”</blue>, is a variable 
            whose value it cannot be
            change after it's been initialized. 
            <br></br>
            A <red>static</red> variable is a variable 
            shared among all the <red>instances</red> of a <red>class</red> and which can be accessed
            from the <red>class</red> even with no <red>instances</red> by using: 
            <code>ClassName.variable;</code>
            <br></br><br></br>
            An <red>interface</red> is not <red>extended</red> by a <red>class</red>; 
            it is <red>implemented</red> by a <red>class</red>.
            <br></br><br></br>
            <green>Class to class inheritance:</green>
            <br></br>

<code>
//Example of class to class inheritance in Java:

//FILE: Product.java

package project25;

public class Product 
{
    private String name;
    private double Price;
    
    public Product(String NewName, double NewPrice)
    {
        this.name = NewName;
        this.Price = NewPrice;
    }
    
    //Getters:
    public String GetName()
    {
        return this.name;
    }
    public double GetPrice()
    {
        return this.Price;
    }
    public String GetType()
    {
        return "Product";
    }
}

</code>

<code>
//FILE: Books.java

package project25;

public class Books extends Product 
{
    private String Author;
    private int NrOfPages;
    
    public Books(String NewAuthor, int NewNrOfPages, String NewName, double NewPrice)
    {
        super(NewName, NewPrice); 
        //super refers to the parent class, so it will call the constructor of the  
        //parent class, and it will initialize the two fields Price and Name.
        this.Author = NewAuthor;
        this.NrOfPages = NewNrOfPages;
    }
    
    //Getters:
    public String GetAuthor()
    {
        return this.Author;
    }
    public int GetNrOfPages()
    {
        return this.NrOfPages;
    }
    
    //Overriding the function of the parent class
    @Override
    public String GetType()
    {
        return "Book";
    }
}
</code>
        <br></br>
        <green>Interface to class inheritance:</green>
        <br></br>
<code>
//Example of class implementing an interface in Java:
//Example of defining a nested interface in Java:

//FILE: ToDoListInterface.java

package project13;

//this is the outer interface
public interface ToDoListInterface 
{ 
    
    //this is the inner interface
    public interface Numbers
    { 
        int findMax(int a, int b, int c);
    }
    void PrintMessage(String message);
}
</code>

<code>
//FILE: Project13.java

package project13;

import java.util.Scanner;

//This class is obliged to provide implementations for: 
//ToDoListInterface and ToDoListInterface.Numbers

public class Project13 implements ToDoListInterface, ToDoListInterface.Numbers 
{
    /*
     * @param args the command line arguments
     */
     
    public static void main(String[] args) 
    {
        //Creating an object of the class:
        Project13 InstanceOfClass = new Project13();
        
        //Calling functions inherited from interface:
        InstanceOfClass.PrintMessage("This is a function that came from an interface!");
        System.out.printf("Max number is: %d\n", InstanceOfClass.findMax(12, 33, 21));
        
        Scanner myscanner = new Scanner (System.in);
        myscanner.next();
    }
    
    //If Project13 class will not provide implementations for these methods
    //the program will not compile.
    public void PrintMessage(String Message){
        System.out.println(Message);
    }
    public int findMax(int a, int b, int c)
    {
        //Using ternary operator:
        return a>b? a>c? a : c : b>c? b : c;
    }
}
</code>
        <br></br>
        <green>Interface to interface inheritance:</green>
        <br></br>
<code>
//FILE: Sports.java
public interface Sports 
{
    public void setHomeTeam(String name);
    public void setVisitingTeam(String name);
}

//FILE: Football.java
public interface Football extends Sports 
{
    public void homeTeamScored(int points);
    public void visitingTeamScored(int points);
    public void endOfQuarter(int quarter);
}

//FILE: Hockey.java
public interface Hockey extends Sports 
{
    public void homeGoalScored();
    public void visitingGoalScored();
    public void endOfPeriod(int period);
    public void overtimePeriod(int ot);
}
</code>
            <br></br>
            Whatever <red>class</red> will <red>implement</red> <red>interface</red> Hockey will have to 
            provide implementation to all its methods + the <red>extended</red> methods from Sports 
            <red>interface</red>.
            <br></br>
            Same goes for whatever <red>class</red> will implement Football.
        </inheritance>
        <abstraction>
            *General-Programming-Knowledge*
            <br></br>
            <green>Abstraction in Java:</green>
            <br></br><br></br>
            In Java, <blue>abstraction</blue> is achieved using <blue>abstract classes</blue> and 
            <red>interfaces</red>.
            <br></br><br></br>
            A <red>class</red> which contains the <red>abstract</red> keyword in its declaration is 
            known as <blue>abstract class</blue>.
            <br></br><br></br>
            <blue>Abstract classes</blue> may or may not contain <blue>abstract methods</blue>, 
            i.e., methods without a body.
            <br></br>
            Example: ( <code>public void get();</code> )
            <br></br><br></br>
            But, if a <red>class</red> has at least one abstract method, then the <red>class</red> 
            must be declared <red>abstract</red>.
            <br></br><br></br>
            If a <red>class</red> is declared <red>abstract</red>, it cannot be <red>instantiated</red>.
            <br></br><br></br>
            To use an <blue>abstract class</blue>, you have to <red>inherit</red> it from another 
            <red>class</red>, provide implementations to the <blue>abstract methods</blue> in it.
            <br></br><br></br>
            If you <red>inherit</red> an <blue>abstract class</blue>, you have to provide implementations 
            to all the <blue>abstract methods</blue> in it.
<code>
//Example of abstraction using interfaces:

//Defining an interface
interface Animal 
{
    public void animalSound(); // interface method (does not have a body)
    public void sleep(); // interface method (does not have a body)
}

// Pig "implements" the Animal interface
class Pig implements Animal 
{
    public void animalSound() 
    {
        // The body of animalSound() is provided here
        System.out.println("The pig says: wee wee");
    }
    
    public void sleep() 
    {
        // The body of sleep() is provided here
        System.out.println("Zzz");
    }
}

class Main 
{
    public static void main(String[] args) 
    {
        Pig myPig = new Pig();  // Create a Pig object
        myPig.animalSound();
        myPig.sleep();
    }
}
</code>
        </abstraction>
        <generic-programming>
            *General-Programming-Knowledge*
            <br></br>
            <green>Generic Programming in Java:</green>
            <br></br><br></br>
            <brown>Generic Classes:</brown>
            <br></br><br></br>
            In Java a <blue>generic class</blue> declaration is similar to a 
            regular non-generic <blue>class</blue> declaration, 
            except that the <blue>class</blue> name is followed by a 
            <red>&lt;type parameter&gt;</red> section.
            <br></br><br></br>
            For all generics the <red>&lt;type parameter&gt;</red> section can 
            contain one or more <red>&lt;type parameters&gt;</red> separated by commas.
            <br></br><br></br>
            Such <red>generics</red> are called <blue>parameterized types</blue> because they 
            accept one or more <blue>parameters</blue>.
<code>
//Example of generic class declaration in Java:

package project29;

public class GenericClass &lt;T&gt; 
{
   private T t;

   public void set(T t) 
   {
      this.t = t;
   }

   public T get() 
   {
      return t;
   }
}

</code>

        In Java each <blue>data type</blue> has an <red>object</red> correspondant: 
        <br></br>
        <blue>int</blue> (primitive) -> <red>Integer</red> (object)<br></br>
        <blue>double</blue> (primitive) -> <red>Double</red> (object)<br></br>
        etc...
        <br></br><br></br>
        We could use <blue>generics</blue> to wrap <blue>primitive types</blue> 
        into <red>objects</red>.
        <br></br><br></br>
        Example: <blue>java.lang.Integer class</blue>  wraps a value of the 
        <blue>primitive type int</blue> into an <red>object</red>. 
        <br></br>
        The <red>object</red> of type <blue>Integer</blue> contains a single <blue>field</blue> 
        whose <blue>type</blue> is <blue>int</blue>
        <br></br><br></br>
        <brown>Generic Methods:</brown>
        <br></br><br></br>
        <blue>Generic methods</blue> are methods that can be called with arguments of 
        different types.
        Based on the <blue>types</blue> of the <blue>arguments</blue> passed to the 
        <blue>generic method</blue>, the compiler handles each <blue>method</blue> 
        call appropriately.
<code>
//Example of generic class instantiation in Java:
//Example of generic method/function definition in Java:

package project29;

import java.util.Scanner;
 
public class Project29 
{
    public static void main(String[] args) 
    {
        //Instantiating the GenericClass from previous example:
        GenericClass &lt;Integer&gt; FirstGeneric_Class = new GenericClass&lt;Integer&gt;();
        FirstGeneric_Class.set(2);
        System.out.printf("Value of GenericClass object: %d\n", FirstGeneric_Class.get());
        
        //Creating some arrays:
        Integer [] myArray = new Integer[] {1,42,13,24,5};
        Character [] myCharArray = new Character[] {'D', 'N', 'C', 'A'};
        
        //Calling the generic method printArray() on 2 different arrays:
        printArray(myArray);
        printArray(myCharArray);
        
        //Keep the window opened until a key is pressed:
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
    //Creating a generic method/function:
    public static &lt; E &gt; void printArray( E[] inputArray ) 
    {
        // Display array elements
        for(E element : inputArray) 
        {
         System.out.printf("%s ", element);
        }
        System.out.println();
    }
}
/*
Another example of using generics:
public final class Integer extends Number implements Comparable&lt;Integer&gt;
*/
</code>
        </generic-programming>
        <variable-arguments-lists>
            *General-Programming-Knowledge*
<code>
// Example of variable arguments in Java
 
class Test1 
{
    // A method that takes variable 
    // number of integer arguments.
    static void fun(int... a)
    {
        System.out.println("Number of arguments: "
                           + a.length);
 
        // using for each loop to display contents of a
        for (int i : a)
            System.out.print(i + " ");
        System.out.println();
    }
 
    public static void main(String args[])
    {
        // Calling the varargs method with 
        // different number of parameters

        // one parameter
        fun(100); 

        // four parameters
        fun(1, 2, 3, 4); 

        // no parameter
        fun(); 
    }
}
</code>
        </variable-arguments-lists>
        <simple-data-types>
            *General-Programming-Knowledge*
<code>
package project2;

import java.util.Scanner;

//In Java: function definitions outside classes is not allowed
//The main function also needs to be places inside a function.

public class Project2 
{ 
    public static void main(String[] args) 
    {
        //Creating a scanner in order to take the input;
        Scanner myscanner = new Scanner(System.in);
        
        //In Java strings needs to be declared using String keyword (with capital S);
        String Name; 
        int Age;
        double height=11.1;
        
        //In Java the bool type got renamed to boolean.
        boolean IsFemale;
        
        //In Java a variable cannot be displayed if it doesn't get initialized.
        String gender;
        System.out.printf("Enter you name: ");
        
        //Creating a scanner for inputting;
        Name = myscanner.nextLine();
        
        System.out.printf("Enter you age: ");
        Age = myscanner.nextInt(); 
        //if any other data it's entered that cannot be converted into a integer
        //an exception will be thrown.
        
        System.out.printf("Enter your height: ");
        height = myscanner.nextDouble();
        //if any other type it's entered that cannot be converted into a float, 
        //an exception will be thrown.
        
        //Printing the stored information:
        System.out.printf("Are you a female? (True or False)\n");
        IsFemale = myscanner.nextBoolean();
        
        //Using the ternary operator:
        gender = IsFemale? "Female" : "Male";
        
        //Printing the information:
        System.out.printf("Hello %s. Your age is %d, and you're %f tall. \n", Name, Age, height);
        System.out.printf("%s, you are a %s!\n", Name, gender);
        
        //System.out.print(MyByte); => this code is not valid, because the 
        //variable MyByte is never initialized so it cannot be displayed.
        
        System.out.printf("Press any key to terminate!\n");
        myscanner.next();
    }   
}
</code>
        <br></br>
        <green>DEFAULT INITIALIZATIONS IN JAVA</green>
        <br></br><br></br>
            <code>Data Type            Default Value (for fields)</code><br></br>
            <code>byte                     0</code><br></br>
            <code>short                    0</code><br></br>
            <code>int                      0</code><br></br>
            <code>long                     0L</code><br></br>
            <code>float                    0.0f</code><br></br>
            <code>double                   0.0d</code><br></br>
            <code>char                    '\u0000'</code><br></br>
            <code>String (or any object)   null</code><br></br>
            <code>boolean                  false</code><br></br>
        </simple-data-types>
        <complex-data-types>*General-Programming-Knowledge*</complex-data-types>
        <loops>
            *General-Programming-Knowledge*
            <green>
            Foreach loop:
            </green>
            <br></br><br></br>  
            Java also contains a <blue>foreach loop</blue>:
            <br></br><br></br>
            The <blue>foreach loop</blue> is used exclusively for collections such as: 
            <red>arrays</red>, <red>vectors</red>, <red>lists</red>, etc. 
            <br></br>
            By using a <blue>foreach loop</blue> you can iterate through all the items in that 
            <blue>collection</blue> and access their values without using indexes.
            <br></br>
<code>
//Example of foreach loop in Java:

package project7;

import java.util.Scanner;

public class Project7 
{
    public static void main(String[] args) 
    {
        int [] arrayC = {1,2,3,4,5,6,7,8,9,10};
        //Using foreach loop in Java:
        System.out.printf("Multiplication Table with 10:\n");
        for (int k : arrayC)
        {
            System.out.printf("10 * %d = %d\n", k, 10*k);
        }
        
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
}
</code>
        </loops>
        <collections>
            *General-Programming-Knowledge*
            <br></br>
            <green>Collections in Java:</green>
            <br></br><br></br>
            <brown>Arrays</brown>
            <br></br><br></br>
            An <red>array</red> is a collection of data of the same type, with 
            <blue>fixed</blue> <red>size/capacity</red>.
            <br></br>
<code>
//Example of arrays in Java:

String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
cars[0] = "Opel";
System.out.println(cars[0]);
// Now outputs Opel instead of Volvo

int[] myNum = {10, 20, 30, 40};
System.out.println(myNum[1]);
// Now outputs 20
</code>
            <br></br>
            <brown>Vectors</brown>
            <br></br><br></br>
            A <red>Vector</red> is a <blue>dynamic array</blue> that can change it's 
            <red>size/capacity</red> and is 
            capable of storing any type of <red>data/object</red>. Meaning that a <red>Vector</red> 
            of objects 
            can <blue>mix</blue> different <blue>types</blue> together such as: 
            <red>integers</red> and <red>strings</red>.
            <br></br>
            
<code>
//Example of working with Vectors in Java:

package project11;
import java.util.Scanner;
import java.util.Vector; //using this for Vector class.

public class Project11 
{
    /*
     * the parameter args will store command line arguments
     */
    
    public static void main(String[] args) 
    {
        //creating a vector (of objects by default) of size 3;
        Vector myVector = new Vector(3); 
        
        //Creating a vector of integers:
        Vector &lt;Integer&gt; Vector2 = new Vector(); 
        //using the default constructor, this vector will have the size 10

        System.out.printf("The capacity of the myVector before adding elements: %d\n", myVector.capacity());
        System.out.printf("The size of myVector before adding elements: %d\n", myVector.size());
        
        //A Vector of object can mix different types of data together.
        myVector.add(21);
        myVector.add(55);
        myVector.add(77);
        myVector.add(192);
        myVector.add("Name");
        
        System.out.printf("The capacity of the myVector after adding 5 elements: %d\n", myVector.capacity());
        System.out.printf("The size of myVector after adding 5 elements: %d\n", myVector.size());
        System.out.printf("The capacity of the Vector2 is: %d\n", Vector2.capacity());
        
        /*
        The capacity increases automatically when it exceeds its initial value.
        */
        
        System.out.printf("The index of NAME is: %d\n", myVector.indexOf("Name"));
        
        //Displaying elements:
        int i = 0;
        
        //Using foreach loop to iterate through the vector:
        for(Object k : myVector)
        {
           if(i&lt;myVector.indexOf("Name"))
           {
               System.out.printf("vector [%d] = %d\n", i, Integer.parseInt(k.toString()));
           }
           else
           {
               System.out.printf("vector [%d] = %s\n", i, k.toString());
           }
           i++;
        }
        
        //Some vector functions:
        Object [] array = myVector.toArray(); //converting vector into array;
        
        //Iterate through array:
        for(i=0;i&lt;array.length; i++)
        {
            System.out.printf("array[%d] = %s\n", i, array[i].toString());
        }
        myVector.insertElementAt("NAME2", 3); //insert element at index 3;
        myVector.removeElementAt(4); // remove element at index 4;
        i=0;
        
        //Using while to iterate through vector:
        while(i&lt;myVector.size())
        {
            System.out.printf("myVector[%d] = %s\n", i, myVector.elementAt(i).toString());
            i++;
        }
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
}
</code>
            <br></br>
            <brown>ArrayLists</brown>
            <br></br><br></br>
            The <blue>ArrayList</blue> <red>class</red> extends <blue>AbstractList</blue> and 
            <red>implements</red> the <red>List interface</red> . 
            <blue>ArrayList</blue> supports <blue>dynamic arrays</blue> that can grow as needed. 
            This gives us a new collection <blue>data type</blue> that can be used exactly as 
            <red>Vectors</red>, <red>Lists</red>, <red>Stacks</red>, <red>Dictionaries</red>.
            <br></br><br></br>
            <blue>ArrayLists</blue> are created with an initial size of <blue>10</blue> elements. 
            When this size is exceeded, the collection is automatically enlarged. 
            <br></br>
            When <red>objects</red> are removed, the <blue>ArrayList</blue> may be shrunk.
            <br></br><br></br>
            NOTE: <blue>ArrayLists</blue> cannot hold primitive data types such as <red>int</red>, 
            <red>double</red>, <red>char</red>, and <red>long</red>.
            <br></br><br></br>
            To create an <blue>ArrayList</blue> that store primitive values such as those mentioned
            above, the <blue>ArrayList</blue> must be created using the corresponding <red>object</red> 
            of these primitives.
            <br></br>
            Example: <br></br>
            - for <red>int</red> the corresponding class is <red>Integer</red>;
            <br></br>
            - for <red>double</red> the corresponding class is <red>Double</red>;
            <br></br><br></br>
            These <red>classes</red> wrap the <blue>primitive types</blue> into an <red>object</red>.
            <br></br><br></br>
            The methods available for the <blue>ArrayLists</blue> are similar to those of 
            <red>Vector</red>, <red>List</red>, <red>Stack</red>, <red>Dictionary</red>. 
            <br></br><br></br>
            So you can call methods such as: <blue>Add()</blue>, <blue>Remove()</blue>, 
            <blue>RemoveAt()</blue>, etc.
<code>
//Example of working with ArrayLists in Java:

package project20;

import java.util.ArrayList; //used for ArrayList Collection type.
import java.util.Scanner;

public class Project20 {
    public static void main(String[] args) 
    {
        ArrayList&lt;Integer&gt; al = new ArrayList();
        al.add(22);
        al.add(44);
        al.add(59);
        
        //Accessing the elements:
        for(int i: al)
        {
            System.out.printf("%d ", i);
        }
        
        System.out.println();
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
}
</code>
             <br></br>
            <brown>Stacks</brown>
            <br></br><br></br>
            <red>Stack</red> is a subclass of <red>Vector</red> that implements the <blue>LIFO</blue> standard 
            (<blue>last-in first-out</blue>).
            <br></br><br></br>
            <red>Stack</red> only defines the <blue>default constructor</blue>, which creates an 
            empty <red>stack</red>.
            <br></br><br></br>
            <red>Stack</red> includes all the methods defined by <red>Vector</red>, and adds several of 
            its own.
            <br></br><br></br>
            A <red>stack</red> has the same properties as a <red>vector</red>, it's 
            <blue>dynamic in size</blue>, and
            can store <red>objects</red> of any type.
            <br></br><br></br>
            <blue>Stacks</blue> get automatically resized to fit the <red>objects</red> pushed in.
            <br></br>
<code>
//Example of working with Stack.

package project16;

import java.util.Scanner; //used for Scanner class;
import java.util.Stack; //used for stack collection;

public class Project16 {

    public static void main(String[] args) 
    {
        Stack newStack = new Stack(); //Stack of objects
        Stack&lt;Integer&gt; intStack; //Stack of integers;
        
        //Adding objects to the Stack:
        newStack.add(5);
        newStack.add(5);
        newStack.add(33);
        newStack.add(135);
        newStack.add(25);
        
        //Accessing elements in the Stack:
        System.out.printf("The element on top of stack is: %d\n", newStack.peek());
        System.out.printf("The element on bottom of the stack is: %d\n", newStack.firstElement());
        //Stacks have the same methods, fields and functionalities as vectors.
        
        Scanner myscanner = new Scanner (System.in);
        myscanner.next();
    }
}
</code>
             <br></br>
            <brown>Dictionaries</brown>
            <br></br><br></br>

                The <blue>Dictionary class</blue> is an <blue>abstract class</blue> that 
                defines a <blue>data structure</blue> for mapping <red>keys</red> to <red>values</red>.
                <br></br>
                This is useful in cases where you want to be able to access data via a particular 
                <red>key</red> rather than an integer index.
                <br></br><br></br>
                Since the <blue>Dictionary class</blue> is abstract, it provides only the 
                framework for a 
                <red>key-mapped</red> <blue>data structure</blue> rather than a specific implementation.
                <br></br><br></br>
                Given a <red>key</red> and <red>value</red>, you can store the <red>value</red> in a 
                <blue>Dictionary object</blue>. 
                Once the <red>value</red> is stored, you can retrieve it by using its <red>key</red>. 
                Thus, like a map, a <blue>dictionary</blue> can be thought of as a 
                <red>list</red> of <red>key/value</red> pairs.
                <br></br>
                The <blue>Dictionary class</blue> is <blue>obsolete</blue>. 
                You should implement the <blue>Map interface</blue> to 
                obtain <red>key/value</red> storage functionality.
                <br></br>
<code>
//Example of working with dictionaries:

package project17;

import java.util.Dictionary; //used for dictionary;
import java.util.Scanner; //used for Scanner class;
import java.util.Hashtable; //used for the hashtable;
import java.util.Enumeration; //used for enumeration;

public class Project17 {

    /*
     * @param args the command line arguments
     */
     
    public static void main(String[] args) 
    {
        //It can be constructed like this also: Dictionary myDict = new Hashtable();
        Dictionary &lt;Integer, String&gt; myDict = new Hashtable(); 
        //creating a dictionary with Integer Keys, and String Content.

        myDict.put(1, "Alan Walker");
        myDict.put(2, "Adam Lambert");
        myDict.put(3, "Tokio Hotel");
        myDict.put(4, "Deryck Whibley");
        myDict.put(5, "Avril Lavigne");
        Enumeration&lt;Integer&gt; MyKeys = myDict.keys();
        Enumeration&lt;String&gt; MyNames = myDict.elements();
        System.out.printf("Size of Dictionary: %d\n", myDict.size());
        
        //Using for loop to access dictionary:
        for(int i=0; i&lt;myDict.size(); i++)
        {
            System.out.printf("Name: %s     Key: %s\n", MyNames.nextElement(), MyKeys.nextElement());
        }
        
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
}
</code>
        <br></br>
        <brown>Lists</brown>
        <br></br><br></br>
        The <red>List</red> interface extends <red>Collection</red> and declares the 
        behavior of a collection that stores a sequence of elements.
        <br></br><br></br>
        Elements can be inserted or accessed by their <blue>position</blue> in the <red>List</red> 
        by using a zero-based index.
        <br></br><br></br>
        A <red>List</red> may contain duplicate elements.
        <br></br><br></br>
        In addition to the methods defined by <red>Collection</red>, the <red>List</red> defines 
        some of its own.
        <br></br><br></br>
        Several of the <red>List</red> methods will throw an <blue>UnsupportedOperationException</blue> 
        if the collection cannot be modified, and a <blue>ClassCastException</blue> is generated 
        when one object is <blue>incompatible</blue> with the other.
        <br></br>
<code>
//Example of working with Lists/LinkedLists

package project31;
import java.util.*; //import everything in java.util; 

public class Project31 
{

    /**
     * @param args the command line arguments
     */
    
    public static void main(String[] args) 
    {
      List a1 = new ArrayList();
      //List is an interface so it cannot be instanciated, but it can be 
      //initialized with an object of type ArrayList() or LinkedList;

      a1.add("Zara");
      a1.add("Mahnaz");
      a1.add("Ayan");      
      System.out.println("ArrayList Elements:");
      System.out.print("\t" + a1);
      System.out.println();
      
      //Creating and printing a linked list.
      List l1 = new LinkedList();
      
      /*
        The LinkedList class extends AbstractSequentialList and implements
        the List interface and provides a linked-list data structure.
      */
      
      l1.add("Zara");
      l1.add("Mahnaz");
      l1.add("Ayan");
      System.out.println();
      System.out.println("LinkedList Elements:");
      System.out.print("\t" + l1);
      System.out.println();
      
      //Keep the window opened until the next button press.
      Scanner myscanner = new Scanner(System.in);
      myscanner.next();
   }
    
}
</code>
        </collections>
        <collection-methods>
            The <blue>Collection</blue> in Java is a framework that provides an architecture to 
            store and manipulate the group of <red>objects</red>.
            <br></br><br></br>
            There are many <red>methods</red> declared in the <blue>Collection</blue> interface:
            <br></br><br></br>
            <code>public boolean add(E e)</code><br></br>
            It is used to <red>insert</red> an element in this collection.
            <br></br><br></br>
            <code>public boolean addAll(Collection&lt;? extends E&gt; c)</code><br></br>
            It is used to <red>insert</red> the specified <blue>collection</blue> 
            elements in the invoking <blue>collection</blue>.
            <br></br><br></br>
            <code>public boolean remove(Object element)</code><br></br>
            It is used to <red>delete</red> an element from the <blue>collection</blue>.
            <br></br><br></br>
            <code>public boolean removeAll(Collection&lt;?&gt; c)</code><br></br>
            It is used to <red>delete</red> all the elements of the specified <blue>collection</blue> 
            from the invoking <blue>collection</blue>.
            <br></br><br></br>
            <code>default boolean removeIf(Predicate&lt;? super E&gt; filter)</code><br></br>
            It is used to <red>delete</red> all the elements of the <blue>collection</blue> 
            that satisfy the specified predicate.
            <br></br><br></br>
            <code>public boolean retainAll(Collection&lt;?&gt; c)</code><br></br>
            It is used to <red>delete</red> all the elements of invoking <blue>collection</blue> 
            except the specified <blue>collection</blue>.
            <br></br><br></br>
            <code>public int size()</code><br></br>
            It returns the <blue>total number</blue> of elements in the <blue>collection</blue>.
            <br></br><br></br>
            <code>public void clear()</code><br></br>
            It <red>removes</red> the total number of elements from the <blue>collection</blue>.
            <br></br><br></br>
            <code>public boolean contains(Object element)</code><br></br>
            It is used to <red>search</red> an element.
            <br></br><br></br>
            <code>public boolean containsAll(Collection&lt;?&gt; c)</code><br></br>
            It is used to <red>search</red> the specified <blue>collection</blue> in the 
            <blue>collection</blue>.
            <br></br><br></br>
            <code>public Iterator iterator()</code><br></br>
            It returns an <red>iterator</red>.
            <br></br><br></br>
            <code>public Object[] toArray()</code><br></br>
            It converts <blue>collection</blue> into <red>array</red>.
            <br></br><br></br>
            <code>public &lt;T&gt; T[] toArray(T[] a)</code><br></br>
            It converts <blue>collection</blue> into <red>array</red>. Here, the runtime type of the 
            returned <red>array</red> 
            is that of the specified <red>array</red>.
            <br></br><br></br>
            <code>public boolean isEmpty()</code><br></br>
            It checks if <blue>collection</blue> is empty.
            <br></br><br></br>
            <code>default Stream&lt;E&gt; parallelStream()</code><br></br>
            It returns a possibly parallel <red>Stream</red> with the <blue>collection</blue> as 
            its source.
            <br></br><br></br>
            <code>default Stream&lt;E&gt; stream()</code><br></br>
            It returns a sequential <red>Stream</red> with the <blue>collection</blue> as its source.
            <br></br><br></br>
            <code>default Spliterator&lt;E&gt; spliterator()</code><br></br>
            It generates a <red>Spliterator</red> over the specified elements in the 
            <blue>collection</blue>.
            <br></br><br></br>
            <code>public boolean equals(Object element)</code>
            It matches two <blue>collections</blue>.
            <br></br><br></br>
            <code>public int hashCode()</code><br></br>
            It returns the <red>hash</red> code number of the <blue>collection</blue>.
            <br></br><br></br>
        </collection-methods>
        <dynamic-memory-allocation>
            <red>Heap space</red> is used for the <blue>dynamic memory allocation</blue> of 
            Java <red>objects</red> and JRE (Java Runtime Environment) <red>classes</red> 
            at runtime. 
            <br></br><br></br>
            New <red>objects</red> are always created in <red>heap space</red>, and the 
            <blue>references</blue> to these <red>objects</red> are stored in <red>stack memory</red>. 
            <br></br>
            These <red>objects</red> have <blue>global</blue> access and we can access them from 
            anywhere in the application.
            <br></br><br></br>
            <green>Dynamic memory allocation in Java:</green>
            <br></br><br></br>
            All Java <red>objects</red> are <blue>dynamically</blue> allocated. 
            The variables used in the application are stored in stack but these variables 
            only store <blue>references</blue> to <red>objects</red>. 
            <br></br>
            If the variable dies the object still exists as 
            long as <blue>referenced</blue> by other variables.
            <br></br><br></br>
            This means is we always pass <red>objects</red> to other functions by 
            <blue>reference</blue> 
            (no copies are performed behind the scenes).
            <br></br>
        </dynamic-memory-allocation>
        <read-from-file>
            *General-Programming-Knowledge*
<code>
//Example of reading content from file in JAVA:

// Import the File class
import java.io.File;

// Import this class to handle errors
import java.io.FileNotFoundException;

// Import the Scanner class to read text files  
import java.util.Scanner; 

public class ReadFile 
{
    public static void main(String[] args) 
    {
        try 
        {
            File myObj = new File("filename.txt");
            Scanner myReader = new Scanner(myObj);
            while (myReader.hasNextLine()) 
            {
                String data = myReader.nextLine();
                System.out.println(data);
            }
            myReader.close();
        } 
        catch (FileNotFoundException e) 
        {
            System.out.println("An error occurred.");
            e.printStackTrace();
        }
    }
}
</code>
        </read-from-file>
        <write-to-file>
            *General-Programming-Knowledge*
            <br></br>
            <green>Writing to files in Java:</green>
            <br></br><br></br>
            <red>Creating a file:</red>
            <br></br>
<code>
//Example of creating a file in Java: 

// Import the File class
import java.io.File;

// Import the IOException class to handle errors
import java.io.IOException;

public class CreateFile 
{
    public static void main(String[] args) 
    {
        try 
        {
            File myObj = new File("filename.txt");
            if (myObj.createNewFile()) 
            {
                System.out.println("File created: " + myObj.getName());
            } 
            else 
            {
                System.out.println("File already exists.");
            }
        }
        catch (IOException e) 
        {
            System.out.println("An error occurred.");
            e.printStackTrace();
        }
    }
}
</code>
            <br></br>
            <red>Write to a file:</red>
            <br></br>
<code>
//Example of writing content to a file in Java:

// Import the FileWriter class
import java.io.FileWriter;

// Import the IOException class to handle errors
import java.io.IOException;  

public class WriteToFile 
{
    public static void main(String[] args) 
    {
        try 
        {
            FileWriter myWriter = new FileWriter("filename.txt");
            myWriter.write("Files in Java might be tricky, but it is fun enough!");
            myWriter.close();
            System.out.println("Successfully wrote to the file.");
        } 
        catch (IOException e)
        {
            System.out.println("An error occurred.");
            e.printStackTrace();
        }
    }
}
</code>
        </write-to-file>
        <serialization>
            *General-Programming-Knowledge*
<code>
//Example of serialization in Java:

package project23;

import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Scanner;

public class Project23 {

    /**
     * @param args the command line arguments
     */
    
    //Making main function able to throw IOException, 
    //so that we don't need to use try catch blocks.
    public static void main(String[] args) throws IOException 
    {
        //Creating a collection of HumanClass objects:
        ArrayList&lt;HumanClass&gt; myList = new ArrayList();
        myList.add(new HumanClass(22, "Adam Lambert"));
        myList.add(new HumanClass(44, "Jackie Chan"));
        
        //Creating a file to store these objects:
        File myObjectsFile = new File ("objectFile.txt");
        
        //Serializing an object:
        try
        {
            FileOutputStream fo = new FileOutputStream(myObjectsFile);
            ObjectOutputStream os = new ObjectOutputStream(fo);
            for(HumanClass s:myList)
            {
                //Writing objects to a file can be made only using binary mode. 
                //So that file will not contain readable text
                //and cannot be altered using text editors.
                os.writeObject(s);
            }
        }
        catch(FileNotFoundException e)
        {
            System.out.printf("File not found: %s", e);
        }
        
        //Keep the console opened until a key is pressed.
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
}
</code>
        </serialization>
        <deserialization>
            *General-Programming-Knowledge*
            <br></br>
<code>
//Example of deserialization in Java:

package project23;

import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Scanner;

public class Project23 
{

    /**
     * @param args the command line arguments
     */
    
    //Making main function able to throw IOException, 
    //so that we don't need to use try catch blocks.
    public static void main(String[] args) throws IOException 
    {
        //Deserializing an object from the file:
        ArrayList&lt;HumanClass&gt; ObjectRead = new ArrayList();
        FileInputStream fi = new FileInputStream(myObjectsFile);
        ObjectInputStream oi = new ObjectInputStream(fi);
        try
        {
            //the following loop will terminate when the catch block will terminate, 
            //and when the catch block will terminate then EOFException will be thrown.
            while(true) 
            {
                //this will read until the file ends.
                HumanClass e = (HumanClass) oi.readObject();  
                
                //When it cannot read any more objects from the file 
                //it will throw an EOFException that needs to be catched, and handled,
                //otherwise the program will terminate.
                ObjectRead.add(e);
            }
        }
        catch(ClassNotFoundException e)
        {
             System.out.printf("File not found: %s", e);
        }
        //Once the file was done reading, it will throw EOFException
        catch(EOFException b) 
        {
            System.out.println("\nDone reading the objects:\n");
            
            //Print the objects:
            for(HumanClass s:ObjectRead)
            {
                System.out.printf("Name: %s, Age: %d\n", s.GetName(), s.GetAge());
            }
        }
        
        //Keep the console opened until a key is pressed.
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
}
</code>
        </deserialization>
        <constructors>
            *General-Programming-Knowledge*
<code>
//Example of constructors in Java:

//Create a Main class
public class Main 
{
    //Create a class attribute
    int x;  

    //Create a class constructor for the Main class
    public Main() 
    {
        x = 5;  
        //Set the initial value for the class attribute x
    }

    public static void main(String[] args) 
    {
        Main myObj = new Main(); 
        // Create an object of class Main 
        //(This will call the constructor)
        
        System.out.println(myObj.x); 
        //Print the value of x
    }
}

// Outputs 5
</code>
        </constructors>
        <instantiation>
            *General-Programming-Knowledge*
<code>
//Example of instanciation in Java:

ClassName objName = new ClassName();  
</code>
        </instantiation>
        <destructors>
            *General-Programming-Knowledge*
            <br></br>
            <green>Destructors in Java:</green><br></br>
            <br></br>
            In Java: <red>destructors</red> are also known as <blue>finalizers</blue> that are 
            non-deterministic. <br></br>
            The allocation and deallocation of <red>objects</red> is handled by the 
            <blue>garbage collector</blue>. <br></br>
            The invocation of <blue>finalizers</blue> is not guaranteed because it 
            invokes implicitly.
            <br></br><br></br>
            <brown>Advantages of Destructor:</brown><br></br>
            <blue>
            1. It releases the resources occupied by the <red>object</red>.<br></br>
            2. No explicit call is required, it is automatically <red>invoked</red> at the end of the 
            program execution.<br></br>
            3. It does not accept any parameter and cannot be <red>overloaded</red>.<br></br>
            </blue>
            <br></br>
            Java <blue>finalize()</blue> method works the same as the <red>destructor</red>. 
            It is not a 
            <red>destructor</red> however, but it provides extra security.
            <br></br>            
            For example: It ensures the use of 
            external resources like closing the <red>file</red>, etc. before shutting down the 
            program.
            <br></br>
<code>
//Example of destructor in Java:

public class DestructorExample  
{  
    public static void main(String[] args)  
    {  
        DestructorExample de = new DestructorExample ();  
        de.finalize();  
        de = null;  
        System.gc();  
        System.out.println("Inside the main() method");  
    }
    
    protected void finalize()  
    {  
        System.out.println("Object is destroyed by the Garbage Collector");  
    }  
}   
</code>
        </destructors>
        <function-overloading>
            *General-Programming-Knowledge*
<code>
// Example of Method overloading in Java
// By using Different Types of Arguments
 
// Class 1
// Helper class
class Helper {
 
    // Method with 2 integer parameters
    static int Multiply(int a, int b)
    {
        // Returns product of integer numbers
        return a * b;
    }
 
    // Method 2
    // With same name but with 2 double parameters
    static double Multiply(double a, double b)
    {
        // Returns product of double numbers
        return a * b;
    }
}
 
// Class 2
// Main class
class GFG 
{
    public static void main(String[] args)
    {
        // Calling method by passing
        // input as in arguments
        System.out.println(Helper.Multiply(2, 4));
        System.out.println(Helper.Multiply(5.5, 6.3));
    }
}
</code>
        </function-overloading>
        <operator-overloading>
            *General-Programming-Knowledge*
<code>
public class Vec {
   private float x, y, z;

   public Vec(float x, float y, float z) {
       this.x = x;
       this.y = y;
       this.z = z;
   }
   //Overloading the operator +
   public Vec plus(Vec other) {
       return new Vec(x + other.x, y + other.y, z + other.z);
   }
}
</code>
        </operator-overloading>
        <enums>
            *General-Programming-Knowledge*
            <green>Enums in Java:</green>
            <br></br><br></br>
            In Java: <red>enums</red> can have <red>constructors</red>, and it needs to have 
            <red>constructors</red> 
            if they are provided with values. 
            <br></br><br></br>
            <red>Enums</red> provides both <red>string</red> values and 
            <red>int</red> values in the same patch.
            <br></br>
<code>
//Example of enums in Java:

package project18;

public enum Directions 
{
    //Defining the fields:
    South(0), West(180), North(90), East(260);
    private final int Degrees; 
    // a place to store the value for each field.
    
    //This constructor has the role of initializing 
    //the above fields with their values:
    Directions(int degreesNew)
    {
        this.Degrees = degreesNew;
    }
    public int GetDegrees()
    {
        return this.Degrees;
    }
}
</code>
            <br></br>
            <green>Enumerations in Java:</green>
            <br></br><br></br>
            The <blue>Enumeration interface</blue> defines the <red>methods</red> by which you can 
            enumerate 
            (obtain one at a time) the elements in a <blue>collection</blue> of <red>objects</red>.
            <br></br><br></br>
            <blue>Enumerations</blue> must not be confused with <red>enums</red>.
             They are different <red>types</red>, different <red>objects</red>, 
            with different utility.
            <br></br><br></br>
<code>
//Example of working with Enumerations in Java:

package project15;

import java.util.Enumeration; //used for enumerations;
import java.util.Scanner; // used for scanner class;
import java.util.Vector; //used for vectors;

public class Project15 {

    /**
     * @param args the command line arguments
     */
    
    public static void main(String[] args) 
    {
        //Creating an enumeration of objects;
        Enumeration Days; 
        //enumerations cannot be initialized with an object ;
        //of type enumeration because enumeration is abstract interface.
        
        Enumeration &lt;Integer&gt; intEnumeration; //enumeration of integers;
        
        //vector of objects
        Vector myVect = new Vector (3);
        myVect.add("Sunday");
        myVect.add("Monday");
        myVect.add("Friday");
        
        //the elements from vector gets transfered to enumeration.
        Days = myVect.elements(); 
        while(Days.hasMoreElements())
        {
            System.out.println(Days.nextElement());
        }
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
}
</code>
        </enums>
        <concurrent-programming>
            *General-Programming-Knowledge*
            <br></br>
            <green>Multithreading in Java:</green>
            <br></br><br></br>
            In Java: <blue>Threads</blue> can be created by using two mechanisms : 
            <br></br><br></br>
            <blue>
            1. Extending the Thread class; <br></br>
            2. Implementing the Runnable Interface;
            </blue>
            <br></br><br></br>
            <brown>Thread creation by extending the Thread class:</brown>
            <br></br><br></br>
            We create a <red>class</red> that <red>extends</red> the <blue>java.lang.Thread</blue> <red>class</red>. 
            This <red>class</red> <blue>overrides</blue> the <red>run()</red> method available in 
            the Thread <red>class</red>.
            <br></br><br></br>
            A <red>thread</red> begins its life inside <red>run()</red> method. 
            We create an <red>object</red> of our 
            new <red>class</red> and call <blue>start()</blue> method to start the 
            execution of a <red>thread</red>. 
            <blue>Start()</blue> invokes the <red>run()</red> method on the <blue>Thread</blue> object.
            <br></br>
<code>
//Example of multithreading in Java 
//by extending the Thread class:

class MultithreadingDemo extends Thread 
{
    public void run()
    {
        try 
        {
            // Displaying the thread that is running
            System.out.println(
                "Thread " + Thread.currentThread().getId()
                + " is running");
        }
        catch (Exception e) 
        {
            // Throwing an exception
            System.out.println("Exception is caught");
        }
    }
}
 
// Main Class
public class Multithread {
    public static void main(String[] args)
    {
        int n = 8; // Number of threads
        for (int i = 0; i &lt; n; i++) 
        {
            MultithreadingDemo object
                = new MultithreadingDemo();
            object.start();
        }
    }
}
</code>
        <br></br>
        <brown>Thread creation by implementing the Runnable Interface</brown>
        <br></br><br></br>
        We create a new <red>class</red> which <red>implements</red> <blue>java.lang.Runnable</blue> 
        <red>interface</red> and <red>override</red> <blue>run()</blue> 
        method. 
        <br></br>
        Then we <red>instantiate</red> a <blue>Thread object</blue> and call 
        <blue>start()</blue> method on this object. 
        <br></br>
<code>
//Example of multithreading in Java 
//by implementing the Runnable interface:

class MultithreadingDemo implements Runnable 
{
    public void run()
    {
        try 
        {
            // Displaying the thread that is running
            System.out.println(
                "Thread " + Thread.currentThread().getId()
                + " is running");
        }
        catch (Exception e) 
        {
            // Throwing an exception
            System.out.println("Exception is caught");
        }
    }
}
 
// Main Class
class Multithread 
{
    public static void main(String[] args)
    {
        int n = 8; // Number of threads
        for (int i = 0; i &lt; n; i++) 
        {
            Thread object
                = new Thread(new MultithreadingDemo());
            object.start();
        }
    }
}
</code>
        </concurrent-programming>
        <exception-handling>
            *General-Programming-Knowledge*
<code>
//Example of exception handling in Java:
//Example of throwing custom exceptions;

package project22;
import java.util.InputMismatchException;
import java.util.Scanner;

public class Project22 
{
    public static void main(String[] args) 
    {
        Scanner myscanner = new Scanner(System.in);
        try
        {
            //try block should contain the code that 
            //might throw an exception:
            System.out.println("Enter an integer: ");
            int number = myscanner.nextInt();
            
            //This code will run only if the line above doesn't 
            //produce an exception.
            System.out.printf("You entered: %d\n\n", number);
            
            //Throwing a Custom Exception:
            if(number>10||number&lt;0)
            {
                throw new CustomExceptionOutRange();
            }
        }
        //Handle the input mismatch exception:
        catch(InputMismatchException e)
        {
            System.out.println("You didn't entered an integer!\n");
        }
        //Handle the custom exception:
        catch(CustomExceptionOutRange r)
        {
            System.out.println("Your number is out of range!\n");
        }
        //This code gets executed anyhow.
        finally
        {
            //the finally block is not mandatory
            //It is possible to have only try and catch blocks
            
            System.out.println("Finally block reached.");
        }
        myscanner.next();
    }
}

</code>
            <br></br>
            <green>Creating Custom Exceptions classes in Java:</green>
            <br></br><br></br>
            In order to create <blue>Custom Exception</blue> <red>classes</red> in Java, 
            you to create a <red>class</red> of 
            <red>extends</red> the <red>Exception</red> class.
            <br></br>
<code>
package project22;

/*
 * Making this class inherits from Exception class.
 */

public class CustomExceptionOutRange extends Exception
{
    //custom code can be added here
}
</code>
        </exception-handling>
        <bitwise-operators>*General-Programming-Knowledge*</bitwise-operators>
        <default-parameters>
            *General-Programming-Knowledge*
<code>
public void doSomething(String name, int age, String city = "New York") {  
  // code to perform some action  
}  
</code>
        </default-parameters>
        <interfaces>
            *General-Programming-Knowledge*
            <br></br>
            <green>Interfaces in Java:</green>
            <br></br><br></br>
            An <red>interface</red> is a <blue>reference type</blue> in Java that 
            is similar to <red>class</red>.
            <br></br><br></br>
            A <red>class</red> <blue>implements</blue> an <red>interface</red>, 
            thereby <blue>inheriting</blue> the 
            <red>abstract methods</red> of the <red>interface</red>.
            <br></br><br></br>
            An <red>interface</red> is basically a collection of <blue>abstract methods</blue>. 
            <br></br><br></br>
            Along with the <red>abstract methods</red>, an <red>interface</red> may 
            also contain <red>constants</red>
            (<red>final variables</red>), <red>static variables</red>,  
            <blue>default methods</blue>, <red>static methods</red>, and <blue>nested types</blue>.
            <br></br><br></br>
            A <blue>nested type</blue> is a <blue>type</blue> defined within a <blue>type</blue> 
            such as: 
            a <red>class</red> defined within a <red>class</red> or an <red>interface</red> defined
            within an <red>interface</red>.
            <br></br><br></br>
            A <red>final</red> variable is also called a <blue>“constant”</blue>. It is a variable 
            whose value cannot be
            change after it's been initialized. 
            <br></br><br></br>
            The method bodies may exist only for the <blue>default methods</blue> and/or 
            <red>static methods</red>.
<code>
//Example of interface with constants, 
//default and static methods:

public interface Electronic 
{

    // Constant variable
    String LED = "LED";

    // Abstract method
    int getElectricityUse();

    // Static method
    static boolean isEnergyEfficient(String electtronicType) 
    {
        if (electtronicType.equals(LED)) 
        {
            return true;
        }
        return false;
    }

    //Default method
    default void printDescription() 
    {
        System.out.println("Electronic Description");
    }
}
</code>
            <br></br>
            A <red>static variable</red>  or <blue>method</blue> is one which is shared 
            among all the 
            <red>instances</red> of a <red>class</red> and which can be accessed directly
            from the <red>class</red> even with no <red>instances</red> by using: 
            <code>ClassName.variable;</code>
            <br></br><br></br>
            The <blue>default methods</blue> can be defined inside the <red>interface</red> by using the 
            <red>default</red>
            keyword. These methods are <blue>non-abstract methods</blue> meaning they have an 
            implementation.
            <br></br><br></br>
            The concept of <blue>default method</blue> is used to define a method with <red>default</red>
            implementation. 
            The <red>class</red> implementing the <red>interface</red> can override the 
            <blue>default method</blue> also, in order
            to provide a more specific implementation for the method.
            <br></br><br></br>
            Defining an <red>interface</red> is similar to defining a <red>class</red>. 
            But a <red>class</red> 
            describes the attributes and behaviors of an <red>object</red>,
            whereas an <red>interface</red> contains the declaration of the behaviors 
            that a <red>class</red> needs to <red>implement</red>.
            <br></br><br></br>
            Just like <red>classes</red>, there can be only one <red>interface</red> in a .java file. 
            <br></br><br></br>
            Java does not allow that multiple <red>interfaces</red> and/or <red>classes</red> be 
            defined in the same file, unless they are <blue>nested</blue>.
            <br></br><br></br>
            The only way to have multiple <red>classes</red>/<red>interfaces</red> defined in 
            one file is by having them defined as <blue>nested types</blue>.
            <br></br><br></br>
            Once that a <red>class</red> implements an <red>interface</red> that <red>class</red> is 
            obliged to 
            provide implementations for all the <blue>abstract methods</blue> within 
            the <red>interface</red>:
            <br></br><br></br>
            <green>
            Properties of Interfaces:
            </green>
            <br></br><br></br>
            An interface is implicitly <red>abstract</red>. You do not need to use the <red>abstract</red> 
            keyword while declaring an <red>interface</red>.
            <br></br><br></br>
            Each method within the <red>interface</red> is implicitly <red>abstract</red>, so the 
            <red>abstract</red> keyword is also not needed for declaring the methods.
            <br></br><br></br>
            The methods declared within the <red>interface</red> are implicitly <red>public</red>.
            <br></br><br></br>
            <green>
            Similarities between interfaces and classes:
            </green>
            <br></br><br></br>
            An <red>interface</red> can contain any number of methods.
            <br></br><br></br>
            An <red>interface</red> is written in a file with a .java extension, with the name of 
            the 
            <red>interface</red> matching the name of the file.
            <br></br><br></br>
            The bytecode of an <red>interface</red> appears in a .class file.
            <br></br><br></br>
            The <red>interfaces</red> appear in packages, and their corresponding bytecode 
            file must be in a directory structure that matches the package name.
            <br></br><br></br>
            <green>
            Differences between interfaces and classes:
            </green>
            <br></br><br></br>
            You cannot <blue>instantiate</blue> an <red>interface</red>.
            <br></br><br></br>
            An <red>interface</red> does not contain any <red>constructors</red>.
            <br></br><br></br>
            All of the <red>methods</red> in an <red>interface</red> are <red>abstract</red>.
            <br></br><br></br>
            An <red>interface</red> cannot contain <red>instance</red> fields. 
            The only fields that can appear in an interface must be declared 
            both <red>static</red> and <red>final</red>.
            <br></br><br></br>
            An <red>interface</red> is not extended by a <red>class</red>, it is implemented by a 
            <red>class</red>.
            <br></br><br></br>
            An <red>interface</red> can <red>extend</red> multiple other <red>interfaces</red>.
            <br></br><br></br>
            Through <blue>implements</blue> the <red>interfaces</red> exhibit the same characteristics 
            to the <red>classes</red> which are implementing them.
            <br></br>
<code>
//Example of defining an interface in Java:
//Example of nested interfaces

package project13;

public interface ToDoListInterface 
{ 
    //this is the outer interface
    public interface Numbers
    { 
        //this is the inner interface
        int findMax(int a, int b, int c);
    }
    void PrintMessage(String message);
}
</code>

<code>
//Example of a class implementing an interface in Java:
//FILE: Project13.java

package project13;

import java.util.Scanner;

//This class is obliged to provide implementations for: 
//ToDoListInterface and ToDoListInterface.Numbers

public class Project13 implements ToDoListInterface, ToDoListInterface.Numbers 
{
    /*
     * @param args the command line arguments
     */
     
    public static void main(String[] args) 
    {
        //Creating an object of the class:
        Project13 InstanceOfClass = new Project13();
        
        //Calling functions inherited from interface:
        InstanceOfClass.PrintMessage("This is a function that came from an interface!");
        System.out.printf("Max number is: %d\n", InstanceOfClass.findMax(12, 33, 21));
        
        Scanner myscanner = new Scanner (System.in);
        myscanner.next();
    }
    
    //If Project13 class will not provide implementations for these methods
    //the program will not compile.
    public void PrintMessage(String Message){
        System.out.println(Message);
    }
    public int findMax(int a, int b, int c)
    {
        //Using ternary operator:
        return a>b? a>c? a : c : b>c? b : c;
    }
}
</code>
        </interfaces>
        <random-generators>
            *General-Programming-Knowledge*
<code>
//Example of generating random numbers in Java:

package project37;

import java.util.Random;
import java.util.Scanner;

public class Project37 {

    /**
     * @param args the command line arguments
     */
     
    public static void main(String[] args) 
    {
        Scanner myscanner = new Scanner(System.in);
        System.out.printf("Thinking of a number between 0 and 100:\n\n");
        
        //Create a random generator
        Random rand = new Random();
        
        //Generate a random number between 0-100
        int Number = rand.nextInt(101);
        
        //This variable will store user input;
        int choice = 101;
        
        //this will count how many times 
        //the user guessed wrong
        int NrOfTries=0;
        
        //Enter the loop by default:
        while(Number!=choice)
        {
            System.out.printf("What is the number?\n");
            do
            {
                System.out.printf("Number = ");
                choice = myscanner.nextInt();
                //get input from the user;
                
            }while(choice&lt;0 || choice>100);
            
            //Compare the user input with the random number;
            if(Number==choice)
            {
                System.out.printf("Congratulations, the number was: %d\n", Number);
            }
            
            else if(Number&lt;choice)
            {
               System.out.printf("Your number is too high, try a lower one!\n");
            }
            
            else
            {
                System.out.printf("Your number is too low, try a higher one!\n");
            }
            
            System.out.println();
            NrOfTries++;
        }
        
        System.out.printf("You required %d tries to guess the number!\n", NrOfTries);
        
        //Keep the console opened.
        myscanner.next();
    }
}
</code>
        </random-generators>
        <command-line-arguments>
            *General-Programming-Knowledge*
<code>
//Working with command-line arguments in Java:

package Args_main;

import java.util.Scanner;

public class Args_main
{
    //args will store the command prompt arguments - if any
    public static void main(String[] args) 
    { 
        //Supposingly we have some arguments in args[]
        
        int [] lenNrs = Args_main.NumberOrNo(args); 
        //convert them to numbers or get their string length
        
        Sorting(lenNrs, args); 
        //sort the numbers or lengths
        
        System.out.printf("Sorting by length or value: \n\n");
        for (int i=0; i&lt;args.length; i++)
        {
            //print results
            System.out.printf("%d &lt;--&gt; %s\n", lenNrs[i], args[i]); 
        }
        
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
        //cursor to the next line.
    }
    
    //We shall return an array
    public static int[] NumberOrNo(String[] arguments) 
    {
        //Build an array of the same length as arguments array
        int[] someArray = new int[arguments.length]; 
        for (int i=0; i&lt;arguments.length; i++)
        {
            try
            {
                //try to convert to int
                someArray[i] = Integer.parseInt(arguments[i]); 
            }
            catch (Exception e)
            {
                //if not successful then we are having a letter string / word
                someArray[i] = arguments[i].length(); 
                //take out it's length
            }
        }
        return someArray;
    }
    
    //no need to return anything, lists/arrays are always passed by reference
    public static void Sorting (int[] nrsOrNo, String[] arguments) 
    {
        //Do the sorting
        for (int i=0; i &lt; nrsOrNo.length; i++)
        {
            for (int j=0; j&lt;nrsOrNo.length; j++ )
            {
                if (nrsOrNo[j] &lt; nrsOrNo[i])
                {
                    int temp = nrsOrNo[i];
                    nrsOrNo[i] = nrsOrNo[j];
                    nrsOrNo[j] = temp;
                    String argTmp = arguments[i];
                    arguments[i] = arguments [j];
                    arguments [j] = argTmp;
                }
            }
        }
    }
}

</code>
        </command-line-arguments>
        <ternary-operator>
            *General-Programming-Knowledge*
<code>
//Example of using ternary operator in Java:

import java.io.*;

class Ternary 
{
    public static void main(String[] args)
    {
        // variable declaration
        int n1 = 5, n2 = 10, max;

        System.out.println("First num: " + n1);
        System.out.println("Second num: " + n2);

        // Largest among n1 and n2
        max = (n1 > n2) ? n1 : n2;

        // Print the largest number
        System.out.println("Maximum is = " + max);
    }
}
</code>
        </ternary-operator>
        <modular-programming>
            *General-Programming-Knowledge*
            <green>Modular Programming in Java:</green>
            <br></br><br></br>
            A <blue>module</blue> in Java is typically just a .jar file that has a <blue>module-info.java</blue> 
            file at the root. 
            <br></br><br></br>
            A <blue>module</blue> is a directory containing other directories 
            called <blue>packages</blue>, 
            where every <blue>package</blue> contains <red>classes</red> stored in individual 
            .java files.
            <br></br><br></br>
            Java modules help encapsulating <blue>packages</blue> and managing dependencies:<br></br>
            - a <red>class</red> is a container of <red>fields</red> and <red>methods</red>;<br></br>
            - a <blue>package</blue> is a container of <red>classes</red> and <red>interfaces</red>;<br></br>
            - a <blue>module</blue> is a container of <blue>packages</blue>;<br></br>
            <br></br>
            In Java a <blue>module</blue> is somehow different than in C/C++.
            <br></br>            
            Since Java only allow one <red>class/interface</red>
            be defined per file, a <blue>module</blue> is more like a collection of files, 
            than a pair of <blue>2 files</blue> (.c and .h) as it is in C/C++.
            <br></br><br></br>
            In Java there cannot be any <red>functions</red>, <red>variable declarations</red> or
            implementations of any sort, outside
            the <red>class</red>. <br></br>
            Everything has to be <red>encapsulated</red> within the <red>class</red>.
            <br></br><br></br>
            <brown>Example of modular project in Java:</brown>
            <br></br><br></br>
            <red>1. The module <blue>exporting</blue> the implementation:</red>
            <br></br>
<code>
//Example of modular project in Java:

//FILEPATH: Implementation_Module/classes/module-info.java

module Implementation_Module 
{
    //this module exports the package:
    exports Implementation_Package;
}
</code>

<code>
//FILEPATH: 
//Implementation_Module/classes/Implementation_Package/Implementation_Class.java

//A package is like a folder/directory
package Implementation_Package;
//This package contains the class with the implementation

public class Implementation_Class 
{
    public void PrintMessage() 
    {
        //This class contains the implementation:
        System.out.println("Hello from Implementation_Module");
    }
    
}
</code>
            <br></br>
            <red>2. The module <blue>importing</blue> the implementation:</red>
<code>
//FILEPATH: Main_Module/classes/module-info.java

module Main_Module 
{
    //this module requires Implementation_Module:
    requires Implementation_Module;
}
</code>

<code>
//FILEPATH: Main_Module/classes/Main_Package/Main_Class.java

//A package is like a folder/directory
package Main_Package;
//Main_Package requires the implementation

import Implementation_Package.Implementation_Class;
//Implementation is in this package.class

public class Main_Class 
{
    public static void main(String[] args) 
    {
        //Accessing the implementation:
        Implementation_Class obj = new Implementation_Class();
        obj.PrintMessage();
        
        /*
        OUTPUT:
        Hello from Implementation_Module
        */
    }
}
</code>
        </modular-programming>
        <string-methods>
            The <red>String class</red> in Java has a set of built-in methods that 
            can used on strings:
            <br></br><br></br>
            <code>charAt()</code><br></br>
            Returns the character at the specified <red>index</red> (position).
            <br></br><br></br>
            <code>compareTo()</code><br></br>
            <red>Compares</red> two strings lexicographically.
            <br></br><br></br>
            <code>compareToIgnoreCase()</code><br></br>
            <red>Compares</red> two strings lexicographically, ignoring case differences.
            <br></br><br></br>
            <code>concat()</code><br></br>
            <red>Appends</red> a string to the end of another string.
            <br></br><br></br>
            <code>contains()</code><br></br>
            <red>Checks</red> whether a string contains a sequence of characters.
            <br></br><br></br>
            <code>contentEquals()</code><br></br>
            <red>Checks</red> whether a string contains the exact same sequence of characters of the specified 
            CharSequence or StringBuffer.
            <br></br><br></br>
            <code>copyValueOf()</code><br></br>
            Returns a String that represents the characters of the <red>character array</red>.
            <br></br><br></br>
            <code>endsWith()</code><br></br>
            <red>Checks</red> whether a string ends with the specified character(s).
            <br></br><br></br>
            <code>equals()</code><br></br>
            <red>Compares</red> two strings. Returns true if the strings are equal, and false if not.
            <br></br><br></br>
            <code>equalsIgnoreCase()</code><br></br>
            <red>Compares</red> two strings, ignoring case considerations.
            <br></br><br></br>
            <code>format()</code><br></br>
            Returns a <red>formatted string</red> using the specified locale, format string, and arguments.
            <br></br><br></br>
            <code>indexOf()</code><br></br>
            Returns the <red>position</red> of the first found occurrence of specified characters in a string.
            <br></br><br></br>
            <code>isEmpty()</code><br></br>
            <red>Checks</red> whether a string is empty or not.
            <br></br><br></br>
            <code>join()</code><br></br>
            <red>Joins</red> one or more strings with a specified separator.
            <br></br><br></br>
            <code>lastIndexOf()</code><br></br>
            Returns the <red>position</red> of the last found occurrence of specified characters in a string.
            <br></br><br></br>
            <code>length()</code><br></br>
            Returns the <red>length</red> of a specified string.
            <br></br><br></br>
            <code>matches()</code><br></br>
            <red>Searches</red> a string for a match against a regular expression, and returns the matches.
            <br></br><br></br>
            <code>replace()</code><br></br>
            <red>Searches</red> a string for a specified value, and returns a new string where the 
            specified values are replaced.
            <br></br><br></br>
            <code>replaceAll()</code><br></br>
            <red>Replaces</red> each substring of this string that matches the given regular expression 
            with the given replacement.
            <br></br><br></br>
            <code>replaceFirst()</code><br></br>
            <red>Replaces</red> the first occurrence of a substring that matches the given regular expression 
            with the given replacement.
            <br></br><br></br>
            <code>split()</code><br></br>
            <red>Splits</red> a string into an array of substrings.
            <br></br><br></br>
            <code>startsWith()</code><br></br>
            <red>Checks</red> whether a string starts with specified characters.
            <br></br><br></br>
            <code>subSequence()</code><br></br>
            Returns a new <red>character sequence</red> that is a subsequence of this sequence.
            <br></br><br></br>
            <code>substring()</code><br></br>
            Returns a new <red>string</red> which is the substring of a specified string.
            <br></br><br></br>
            <code>toCharArray()</code><br></br>
            <red>Converts</red> this string to a new character array.
            <br></br><br></br>
            <code>toLowerCase()</code><br></br>
            <red>Converts</red> a string to lower case letters.
            <br></br><br></br>
            <code>toString()</code><br></br>
            Returns the <red>value</red> of a String object.
            <br></br><br></br>
            <code>toUpperCase()</code><br></br>
            <red>Converts</red> a string to upper case letters.
            <br></br><br></br>
            <code>trim()</code><br></br>
            <red>Removes</red> whitespace from both ends of a string.
            <br></br><br></br>
            <code>valueOf()</code><br></br>
            Returns the <red>string representation</red> of the specified value.
        </string-methods>
        <datatype-conversions>
            *General-Programming-Knowledge*
<code>
//Example of datatype conversion in Java:

package project3;
import java.util.Scanner;

public class Project3 
{
    public static void main (String[] args) 
    {
        String ValueOne = "1";
        String ValueTwo = "2";
        System.out.printf("ValueOne + ValueTwo = %s\n", ValueOne+ValueTwo);
        
        //Converting Strings to int:
        int a = Integer.parseInt(ValueOne);
        int b = Integer.parseInt(ValueTwo);
        System.out.printf("a + b = %d\n", a+b);
        float val1 = 22.1f, val2 = 25.4f;

        //TypeCasting:
        a = (int)val1; 
        //a gets the integer part of the floating number val1;

        b = (int)val2; 
        //b gets the integer part of the floating number val2;

        System.out.printf("The value of a is: %d\nThe value of b is: %d\n", a, b);

        //The implicit casting is the casting made automatically by the compiler:
        val2 = 15; 
        //so in this case the integer value 15 will be casted into a floating  
        //point value 15.00, this is done automatically by the compiler, 
        //so it's implicit casting.

        //Explicitly casting is the casting that is done by the programmer, 
        //because it cannot be done, automatically by the compiler.
        a = (int) 22.5; 
        //in this case 22.5 will became 22, only the integer part of 
        //the floating value will get stored into int a;

        //Interesting fact:
        val2 = 20 / 15; 
        //integer / integer will result an integer.

        System.out.printf("The value of division is: %f\n", val2); 
        //this will output the value: 1, 
        //even if 20/15 is 1.33333333, and even if it is stored in a float.

        //for the result of the operation to be a float at least one 
        //of those operands need to be casted to float:

        val2 = 20 / (1.0f * 15); 
        //solution one for casting (1.0 * 15 will be converted to 
        //float implicitly).

        System.out.printf("The value of division after casting is: %f\n", val2);

        val2 = 25 / (float) a; 
        //a is explicitly casted to float, so int divided by float will 
        //result in float.

        System.out.printf("The value after explicitly casting is: %f\n", val2);
        System.out.printf("Press any key to terminate!\n");

        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
}

</code>
        </datatype-conversions>
        <decorators>
            *General-Programming-Knowledge*
            <br></br>
            <green>Decorators in Java:</green>
            <br></br><br></br>
            In order to implement a decorator in Java, the following steps
            needs to be followed:
            <br></br><br></br>
            <red>1. Component Interface:</red>
            <br></br><br></br>
            Defining the <red>interface</red> or the <blue>abstract class</blue> 
            declaring the methods that will be 
            implemented. 
            <br></br>
            In this case Car will be the component interface.
            <br></br>
<code>
//the interface defining the methods 
//that will be implemented.

package com.journaldev.design.decorator;

public interface Car 
{
    public void assemble();
}
</code>
        <br></br>
        <red>2. Component Implementation:</red>
        <br></br><br></br>
        The basic implementation of the component interface. 
        We can have BasicCar class as our component implementation.
        <br></br>
<code>
//the basic implementation of 
//the Car interface

package com.journaldev.design.decorator;

public class BasicCar implements Car 
{
    @Override
    public void assemble() 
    {
        System.out.print("Basic Car.");
    }
}
</code>
        <br></br>
        <red>3. Decorator:</red> 
        <br></br><br></br>
        Defining the <blue>decorator class</blue> that <red>implements</red> the component 
        <red>interface.</red> <br></br>
        The component variable needs to be accessible to the child <blue>decorator classes</blue>, 
        so it should be defined as <red>protected</red> variable .
<code>
//the decorator class implementing
//Car interface

package com.journaldev.design.decorator;

public class CarDecorator implements Car 
{

    protected Car car;

    public CarDecorator(Car c)
    {
        this.car=c;
    }

    @Override
    public void assemble() 
    {
        this.car.assemble();
    }

}
</code>
        <br></br>
        <red>4. Concrete Decorators:</red>
        <br></br><br></br>
        <red>Extending</red> the <blue>base decorator</blue> functionality and modifying the 
        component behavior accordingly. We can have <red>concrete decorator classes</red> 
        as LuxuryCar and SportsCar.
        <br></br>
<code>
//a second decorator extending the
//functionality of the first decorator

package com.journaldev.design.decorator;

public class SportsCar extends CarDecorator 
{
    public SportsCar(Car c) 
    {
        super(c);
    }

    @Override
    public void assemble()
    {
        super.assemble();
        System.out.print(" Adding features of Sports Car.");
    }
}
</code>

<code>
//using the decorator to modify the 
//component behaviour

package com.journaldev.design.decorator;

public class LuxuryCar extends CarDecorator 
{
    public LuxuryCar(Car c) 
    {
        super(c);
    }

    @Override
    public void assemble()
    {
        super.assemble();
        System.out.print(" Adding features of Luxury Car.");
    }
}
</code>
        </decorators>
        <operators>*General-Programming-Knowledge*</operators>
        <pre-post-incrementation>*General-Programming-Knowledge*</pre-post-incrementation>
        <recursion>
            *General-Programming-Knowledge*
<code>
//Example of using recursion in Java:

public class Main 
{
    public static void main(String[] args) 
    {
        int result = sum(10);
        System.out.println(result);
    }
    
    //Use recursion to add all numbers up to 10:
    public static int sum(int k) 
    {
        if (k > 0) 
        {
            return k + sum(k - 1);
        } 
        else 
        {
            return 0;
        }
    }
}
</code>
        </recursion>
        <reflection>
            *General-Programming-Knowledge*
<code>
//Example of reflection in Java:

import java.lang.Class;
import java.lang.reflect.*;

class Animal {
}

//put this class in different Dog.java file
public class Dog extends Animal 
{
    public void display() 
    {
        System.out.println("I am a dog.");
    }
}

//put this in Main.java file
class Main 
{
    public static void main(String[] args) 
    {
        try 
        {
            // create an object of Dog
            Dog d1 = new Dog();

            // create an object of Class
            // using getClass()
            Class obj = d1.getClass();

            //get name of the class
            String name = obj.getName();
            System.out.println("Name: " + name);

            //get the access modifier of the class
            int modifier = obj.getModifiers();

            //convert the access modifier to string
            String mod = Modifier.toString(modifier);
            System.out.println("Modifier: " + mod);

            //get the superclass of Dog
            Class superClass = obj.getSuperclass();
            System.out.println("Superclass: " + superClass.getName());
        }

        catch (Exception e) 
        {
            e.printStackTrace();
        }
    }
}
</code>
        </reflection>
        <abstract-classes>
            *General-Programming-Knowledge*
            <br></br>
            <green>Abstract classes in Java:</green>
            <br></br><br></br>
            In Java the pure <blue>virtual functions/methods</blue> are called <blue>abstract 
            functions/methods</blue>
            due to the keyword <code>abstract</code> used for their definition.
            <br></br><br></br>
            <brown>
            Important rules for abstract methods/classes in Java:
            </brown>
            <br></br><br></br>
            <blue>
            Any <red>class</red> that contains one or more <red>abstract methods</red>
            must also be declared <red>abstract</red>.<br></br>
            If a <red>class</red> contains an <red>abstract method</red> it needs to be 
            <red>abstract</red> and vice versa is not true.<br></br>
            If a <red>non-abstract class</red> extends an <red>abstract class</red>, then the 
            <red>class</red> must implement all the abstract methods of the <red>abstract</red> 
            <red>class</red> else the <red>concrete class</red> has to be declared as 
            <red>abstract</red> as well.<br></br><br></br>
            </blue>
            The following combinations of <blue>modifiers</blue> used on <blue>abstract methods</blue> 
            declaration are <red>invalid</red>: <br></br>
            <code>final</code><br></br>
            <code>abstract native</code><br></br>
            <code>abstract synchronized</code><br></br>
            <code>abstract static</code><br></br>
            <code>abstract private</code><br></br>
            <code>abstract strictfp</code>
            <br></br>
<code>
//Example of abstract class definition:

abstract class Shape 
{
    int color;
    // An abstract function
    abstract void draw();
}
</code>

<code>
//Example of abstract class definition
//and implementation:

//Abstract class
abstract class Sunstar 
{
    abstract void printInfo();
}
 
//Abstraction performed using extends
class Employee extends Sunstar 
{
    void printInfo()
    {
        String name = "avinash";
        int age = 21;
        float salary = 222.2F;

        System.out.println(name);
        System.out.println(age);
        System.out.println(salary);
    }
}
</code>
        </abstract-classes>
        <optional-parameters>
            *General-Programming-Knowledge*
        </optional-parameters>
    </programming_language>
    
    <programming_language>
        <name>Python</name>
        <description>
            Python is a <blue>high-level</blue>, <blue>general-purpose</blue> programming language. 
            Its design 
            philosophy emphasizes <blue>code readability</blue> with the use of 
            <blue>significant indentation</blue>.
            <br></br><br></br>

            Python is <blue>dynamically typed</blue> and <blue>garbage-collected</blue>. 
            It supports multiple 
            <blue>programming paradigms</blue>, including <blue>structured</blue> 
            (particularly <blue>procedural</blue>), 
            <blue>object-oriented</blue> and <blue>functional</blue> programming. 
            It is often described as a 
            "batteries included" language due to its <blue>comprehensive standard library</blue>.
        </description>
        <oop>
            *General-Programming-Knowledge*
            <green>Object Oriented Programming in Python:</green>
            <br></br><br></br>
            <red>Python</red> uses the <blue>self</blue> keyword to refer to 
            <blue>instance</blue> variables.
            <br></br><br></br>
            In Python the <blue>variables/fields</blue> declared within a <red>class</red> but outside of 
            any <red>method</red>red
            will become <red>class variables/fields</red> and will be shared amongst all <red>instances</red>.
            The <blue>variables/fields</blue>
            declared within the <blue>constructor</blue> will become
            <blue>instance variables/fields</blue>.
            <br></br>
<code>
#Example of class definition in Python 3:

#Creating a class:
class Employee:
    #This works like documentation of the class.
    'Common base class for all employees' 

    #This member is a class variable whose value 
    #is shared among all instances of a this class.
    empCount = 0 
    #this is similar to a static variable

    #Creating a constructor for the class:
    def __init__(self, name, salary):    
        #the name of the constructor is 
        #always the same: "__init__"
    
        #Here is the place where the members of the 
        #class gets created and initialized.
        self.name = name
        self.salary = salary
        Employee.empCount += 1
   
    #The first parameter of any function
    #in the class is always "self"
    def displayCount(self):  
        #That means that the function will display 
        #information about that instance that calls it.
        print ("Total Employee {0}" .format(Employee.empCount))

    def displayEmployee(self):
        print ("Name : {0}, Salary: {1}" .format(self.name,self.salary))

    #Implementing a destructor for the class.
    def __del__(self):
        #This code will be executed when calling 'del instance'
        class_name = self.__class__.__name__
        print ("Employee destroyed")


#Creating the instances:
"This would create first object of Employee class"
emp1 = Employee("Zara", 2000)
"This would create second object of Employee class"
emp2 = Employee("Manni", 5000)

#Calling the functions;
emp1.displayEmployee()
emp2.displayEmployee()
emp1.displayCount()

Employee.displayCount(emp2) 
#This can work like this as well. 
#But it needs to be specified an instance

Employee.displayEmployee(emp1)

#Instead of using the normal statements to access  
#attributes, you can use the following functions
#similar to getters and setters:

hasattr(emp1, 'name')
#Returns true if 'name' attribute exists

getattr(emp1, 'name')    
#Returns value of 'name' attribute

setattr(emp1, 'name', "Mark") 
#Set attribute 'name' at 8

delattr(emp1, 'name')    
# Delete attribute 'name'

#calling this method will now throw an exception
#emp1.displayEmployee()
#as emp1 has no name attribute anymore.

#Accesing build-in class attributes:
print ("Employee.__doc__: {0}" .format(Employee.__doc__))
#__doc__ is the class documentation string or none, if undefined.

print ("Employee.__name__: {0}" .format( Employee.__name__))
#__name__ is the class name

print ("Employee.__module__: {0}" .format( Employee.__module__))
#__module__ is the module name in which the class is defined.

print ("Employee.__bases__: {0}" .format( Employee.__bases__))
#__bases__ a possibly empty tuple containing the base classes
#in the order of their occurrence in the base class list.

print ("Employee.__dict__: {0}" .format( Employee.__dict__))
#__dict__ is a dictionary containing the class's namespace.

#Example:
del emp1 
#this will delete the instance callded emp1.

emp2.displayEmployee()

#emp1.displayEmployee()
#using emp1 will throw an exception
#as it doesn't exist anymore

input("\nPress any key to exit: ")
#this statement will keep the command prompt open 
#until the next button press:
</code>        
            
            Python <blue>deletes</blue> unneeded <red>objects</red> (built-in <red>types</red> or 
            <red>class instances</red>) automatically to <blue>free</blue> the memory space.
            <br></br><br></br>
            Python's <blue>garbage collector</blue> runs during program execution 
            and is triggered when an <blue>object's reference count</blue> reaches zero. 
            An <blue>object's reference count</blue> changes as the number of <blue>aliases</blue> 
            that point to it changes.
            <br></br><br></br>
            You normally will not notice when the <blue>garbage collector</blue> 
            destroys an <blue>orphaned instance</blue> and reclaims its space.
            <br></br><br></br>
            A <red>class</red> can implement the special method <code>__del__()</code>, 
            called a <blue>destructor</blue>, that is invoked when the 
            <red>instance</red> is about to be destroyed.
            <br></br><br></br>
            <green>Built-In Class Attributes:</green>
            <br></br><br></br>
            These built-in attributes can be accessed using dot operator(<code>.</code>) just 
            like any other class attribute.
            <br></br><br></br>
            <brown>The atttributes used in the example above are:</brown>
            <br></br><br></br>
            <code>__dict__</code> 
            The attribute contains a <blue>dictionary</blue> containing the class's namespace.
            <br></br><br></br>
            <code>__doc__</code>   
            The attribute contains the class <blue>documentation string</blue> or none, if undefined.
            <br></br><br></br>
            <code>__name__</code>  
            The attribute contains the class name.
            <br></br><br></br>
            <code>__bases__</code>  
            The attribute contains a possibly empty <blue>tuple</blue> containing the base classes, 
            in the order of their occurrence in the base class list.
            <br></br><br></br>
            <code>__module__</code>  
            The attribute contains the <blue>name</blue> of the <blue>module</blue> in which 
            the class is defined. 
            If the <blue>module</blue> is the one that is currently running then the module name will 
            be <code>__main__</code>.
            <br></br><br></br>
            <red>This is used for modular programming:</red>
<code>
//Check whether the python script is ran standalone
//or was imported from a different file.

if __name__ == "__main__": 
    print ("Executed when invoked directly")
else: 
    print ("Executed when imported")
</code>

            
        </oop>
        <encapsulation>
            *General-Programming-Knowledge*
<code>
#Example of encapsulation in Python 3:

class Person:

    #Static fields are declared here
    name = "name"
    __age = 0 #this is a public field
    width = 0 #this is a private
    
    #static field can become non-static field for a particular instance 
    #at a particular time when specified
    
    #Constructor:
    def __init__(self):
        #This is the constructor: Only one constructor 
        #function is allowed in Python.
        
        #Function overriding is forbidden.
        self.width = 104
        #Non-Static field get declared in the constructor
    
    #Encapsulation getters and setters:
    
    #Setters:
    def setName(self, Name): # this is a setter
        self.name = Name
    
    def setAge(self, Age):
        self.__age = Age
    
    #Getters:
    def getAge(self):
        return self.__age

class Employee(Person):
    def __init__(self):
        super().__init__()
        self.name = "Employee"

#Creating a class
person = Person ()
#seting the field of the class

person.setName("Alin Popescu")

#Accesing the public field of the class
print (person.name)

#setting the value of private field
person.setAge(22)

#getting the value of a private field
print(person.getAge())

#accessing field modified by the constructor
print(person.width)

emp = Employee()
print(emp.name)

input("\nPress ENTER to exit.")
</code>        
        </encapsulation>
        <polymorphism>
            *General-Programming-Knowledge*
            <br></br><br></br>
            <green>Polymorphism in Python:</green>
            <br></br><br></br>
            <red>Polymorphism with built-in functions:</red>
            <br></br>
<code>
#Example of polymorphism in Python 3
#using built-in functions:
 
# len() being used for a string
print(len("geeks"))
 
# len() being used for a list
print(len([10, 20, 30]))
</code>
            <br></br>
            <red>Polymorphism with user-defined functions:</red>
            <br></br>
<code>
#Example of polymorphism in Python 3
#using user-defined functions:
 
def add(x, y, z = 0): 
    return x + y+z
 
print(add(2, 3))
print(add(2, 3, 4))
</code>
            <br></br>
            <red>Polymorphism with class methods:</red>
            <br></br>
<code>
#Example of polymorphism in Python 3
#using class methods:

class India():
    def capital(self):
        print("New Delhi is the capital of India.")
 
    def language(self):
        print("Hindi is the most widely spoken language of India.")
 
    def type(self):
        print("India is a developing country.")
 
class USA():
    def capital(self):
        print("Washington, D.C. is the capital of USA.")
 
    def language(self):
        print("English is the primary language of USA.")
 
    def type(self):
        print("USA is a developed country.")
 
obj_ind = India()
obj_usa = USA()

for country in (obj_ind, obj_usa):
    country.capital()
    country.language()
    country.type()
</code>
        </polymorphism>
        <inheritance>
            *General-Programming-Knowledge*
            <br></br>
            <green>Inheritance in Python:</green>
            <br></br><br></br>
            Instead of starting from scratch, you can create a <blue>class</blue> by deriving 
            it from a preexisting <blue>class</blue> by listing the <red>parent class</red>
            between <code>()</code> parentheses, after the <blue>class</blue> name.
            <br></br><br></br>
            By <red>inheritance</red>: the <red>child class</red> inherits the attributes of 
            its <blue>parent class</blue>, 
            and those attributes can be used as if they were defined in the <red>child class</red>. 
            <br></br><br></br>
            A <red>child class</red> can also override data members and methods from the 
            <blue>parent</blue>.
            <br></br><br></br>
            In Python a <red>child class</red> is often reffered to as <red>subclass</red> whereas a 
            <blue>parent class</blue>
            is reffered to as <blue>superclass</blue>.
            <br></br>
<code>
#Example of inheritance in Python 3:

#Defining a parent class
class Parent:        
    #Variables declared here will be 
    shared through all the instances
    
    #Creating a public member
    parentAttr = 100 
    #This is a public member which could 
    #be accessed from anywhere.

    #Creating hidden (private) member:
   __secretCount = 0 
    #this member is only visible for this class. 
    #So child classes won't be able to access or inherit it.
    
    #To create hidden members (private members), 
    #you just need to put __ as prefix.
    
    #Private members are only visible inside the class, 
    #and can be accessed only by class instances.
    #It's not inheritable

    #Defining a constructor:
    def __init__(self):

        #Members declared here will be 
        #individually created for each instance:
        print ("Calling parent constructor")
        
        #Creating protected member(variable):
        self._protectedVar = 2 
        
        #protected variables can be accessed by parent class 
        #and child class, they are not public.
        
        #Creating hidden (private) member:
        self.__privateVar = 1

    def parentMethod(self):
        print ("Calling parent method")
      
    #Defining a setter:
    def setAttr(self, attr):
        Parent.parentAttr = attr
      
    #Defining a getter:
    def getAttr(self):
        print ("Parent attribute : {0}" .format(Parent.parentAttr))

    def myMethod(self):
        print ("Calling parent method")
    
    def printPrivate(self):
        print("Private Variable: {0}" .format(self.__privateVar))

#Defining a child class
#Child(Parent) means Child inherits Parent
class Child(Parent): 
    #Defining a contructor:
    def __init__(self):
        print ("Calling child constructor")
        
        #Calling parent constructor:
        Parent.__init__(self)
   
    def childMethod(self):
        print ("Calling child method")

    #This is an overrided function:
    def myMethod(self):
        print ("Calling the overrided method.")


c = Child()          # creating an instance of Child class
c.childMethod()      # child calls its method
c.parentMethod()     # calls parent's method
c.setAttr(200)       # again call parent's method
c.getAttr()          # again call parent's method

#You can always override your parent class methods. One reason 
#for overriding parent's methods is because you may want
#special or different functionality in your subclass.
c.myMethod()

#Trying to print a private members:
#print("Private value: {0}" .format(c.__secretCount)) 
#will result in compilation error, child has no member named like that.

#print("Private value: {0}" .format(Parent.__secretCount))
#will result incompilation error, parent has no member like that.

print("The public member: {0}" .format(Parent.parentAttr))

#Trying to print protected members:
#print("The protected member: {0}" .format(Parent._protectedVar)) 
#will result in compilation error, parent class has no member name like that.

print("The protected member: {0}" .format(c._protectedVar))
p1 = Parent()

#Accesing the private variable can only be made 
#with public accessors (Getters and Setters)
p1.printPrivate()

#print("The private member: {0}" .format(p1.__privateVar))
#this won't work.

input("\nPress any key to exit: ")
</code>
        <br></br>
        <green>Python built-in functions for classes/instances:</green>
        <br></br><br></br>
        <code>issubclass(sub, sup)</code><br></br>
        It's a <blue>boolean function</blue> that returns <blue>true</blue> 
        if the given <blue>subclass</blue> sub is indeed a <blue>subclass</blue> of the 
        <blue>superclass sup</blue>.
        <br></br><br></br>
        <code>isinstance(obj, Class)</code><br></br>
        Its a <blue>boolean function</blue> that returns <blue>true</blue> if 
        the <code>obj</code> is an <red>instance</red> of <blue>class Class</blue> or is an 
        instance of a <blue>subclass</blue> of Class.
        <br></br>
        </inheritance>
        <abstraction>
            *General-Programming-Knowledge*
            <br></br>
            <green>Abstraction in Python:</green>
            <br></br><br></br>
            <blue>Abstraction</blue> in Python refers to the process of creating 
            <blue>abstract 
            classes</blue> and <blue>methods</blue> that provide a blueprint for other 
            <blue>classes</blue> to <red>inherit</red> from.
            <br></br><br></br>
            It allows us to define common attributes and behaviors that can be shared among 
            multiple <blue>classes</blue>.
            <br></br>
<code>
#Example of abstraction in Python:

from abc import ABC, abstractmethod

#Defining abstract class:
class democlass(ABC):
    #Defining abstract method:
    @abstractmethod
    def method1(self):
        print ("abstract method")
        return
    
    #Defining concrete method:
    def method2(self):
        print ("concrete method")

#Defining concrete class:
class concreteclass(democlass):
    def method1(self):
        #Calling parent class method:
        super().method1()
        return
      
obj = concreteclass()
obj.method1()
obj.method2()
</code>
        </abstraction>
        <generic-programming>
            *General-Programming-Knowledge*
            <br></br>
            <green>Generic-Programming in Python:</green>
            <br></br><br></br>
            Python <blue>generics</blue> are like hints in Python. They came out in Python 3.5
            and newer versions. 
            <br></br>
            They let you say what <red>type</red> of things your variables, 
            functions, and results are. 
            <br></br>
            It helps you write down what kind of things your 
            code is dealing with, but it doesn't make the computer check it 
            while running the code.
            <br></br>
<code>
#Example of Python 3 generics with functions:

from typing import TypeVar, List

T = TypeVar('T')

def element(items: List[T]) -> T:
    return items[0]

# Usage
print(element([1, 2, 3])) 
print(element(['a', 'b', 'c']))  

# OUTPUT:
# 1
# a
</code>

<code>
#Example of Python 3 generics with classes:

from typing import TypeVar, Iterable

#Declare type variable
T = TypeVar('T')  

def process_data(data: Iterable[T]) -> None:
    for item in data:
        # Check if the object has a quack method, then call it
        if hasattr(item, 'quack') and callable(item.quack):
            item.quack()
        else:
            print(f"This object of type {type(item).__name__} doesn't quack like a duck!")

#Example class
class Duck:
    def quack(self):
        print("Quack!")

#Another class with similar behavior
class AnotherBird:
    def quack(self):
        print("Quack!")

#Using duck typing with process_data function
duck_obj = Duck()
another_bird_obj = AnotherBird()

#Both objects "quack" like a duck
duck_list = [duck_obj, another_bird_obj]  

#We can pass duck_list to process_data because 
#both objects have a quack method
process_data(duck_list)   

# OUTPUT: 
# Quack!
# Quack!
</code>
        </generic-programming>
        <variable-arguments-lists>
            *General-Programming-Knowledge*
<code>
#Example of variable arguments in Python:

def Print(*argv):
    for arg in argv:
        print(arg)

Print('Hello', 'Welcome')
</code>        
        </variable-arguments-lists>
        <simple-data-types>
            In programming, data type is an important concept.
            <br></br><br></br>
            Variables can store data of different <blue>types</blue>, and different 
            <blue>types</blue> can do different things.
            <br></br><br></br>
            <green>Data types in Python:</green>
            <br></br><br></br>
            Python has the following built-in data types:<br></br>
            <code>Text Type:        str</code><br></br>
            <code>Numeric Types:    int, float, complex</code><br></br>
            <code>Sequence Types:   list, tuple, range</code><br></br>
            <code>Mapping Type:     dict</code><br></br>
            <code>Set Types:        set, frozenset</code><br></br>
            <code>Boolean Type:     bool</code><br></br>
            <code>Binary Types:     bytes, bytearray, memoryview</code><br></br>
            <code>None Type:        NoneType</code><br></br>
            <br></br>
<code>
#Example of data-types in Python:

#str
x = "Hello World"
print(type(x))

#int
x = 20
print(type(x))

#float
x = 20.5
print(type(x))

#complex
x = 1j
print(type(x))

#list
x = ["apple", "banana", "cherry"]
print(type(x))

#tuple
x = ("apple", "banana", "cherry")
print(type(x))

#range
x = range(6)
print(type(x))

#dict
x = {"name" : "John", "age" : 36}
print(type(x))

#set
x = {"apple", "banana", "cherry"}
print(type(x))

#frozenset
x = frozenset({"apple", "banana", "cherry"})
print(type(x))

#bool
x = True
print(type(x))

#bytes
x = b"Hello"
print(type(x))

#bytearray
x = bytearray(5)
print(type(x))

#memoryview
x = memoryview(bytes(5))
print(type(x))

#NoneType
x = None
print(type(x))
</code>        
        </simple-data-types>
        <complex-data-types>
            The <blue>complex data type</blue> in Python is used to represent numbers with both 
            <red>real</red> and <red>imaginary</red> parts. It is written in the 
            form of <blue>a + bj</blue>, where <blue>a</blue> 
            represents the real part and <blue>b</blue> represents the imaginary part.
        </complex-data-types>
        <loops>
            Python programming language provides two types of loops: <red>For loop</red> and 
            <blue>While loop</blue>
            <br></br><br></br>
            Loops in Python provides multiple ways for the execution:
            <br></br><br></br>
            <red>While Loop:</red>
<code>
#Example of while loop execution:

count = 0
while (count &lt; 3):
    count = count + 1
    print("Hello")
</code>

<code>
#Example of while-else loop execution:

count = 0
while (count &lt; 3):
    count = count + 1
    print("Hello")
else:
    print("Goodbye")
</code>

<code>
#Example of infinite while loop execution 
#using try-except blocks:

fruits = ["apple", "orange", "kiwi"]
iter_obj = iter(fruits)
while True:
    try:
        fruit = next(iter_obj)
        print(fruit)
    except StopIteration:
        break
</code>
             <br></br>
            <red>For Loop:</red>
            <br></br>
<code>
#Example of for loop execution using range:

n = 4
for i in range(0, n):
    print(i)
</code>

<code>
#Example of for loop execution using range:

list = ["items", "inside", "the", "list"]
for index in range(len(list)):
    print(list[index])
</code>

<code>
#Example of for-else loop execution using range:

list = ["items", "inside", "the", "list"]
for index in range(len(list)):
    print(list[index])
else:
    print("List ended.")
</code>

<code>
#Example of for loop execution as foreach:

fruits = ["apple", "orange", "kiwi"]

for fruit in fruits:
    print(fruit)
</code>
        </loops>
        <collections>
            *General-Programming-Knowledge*
            <br></br>
            <green>Collections in Python:</green>
            <br></br><br></br>
            <brown>Lists:</brown>
            <br></br><br></br>
            <blue>Lists</blue> are <red>ordered</red> and <red>changeable collections</red> which 
            allow <red>duplicate</red> values. 
            <red>Ordered</red> means that the items within a <blue>list</blue> have a 
            defined order, and that order will 
            not change. <red>Changeable</red> means that we can change, <red>add</red>, 
            and <red>remove</red> 
            items in a <blue>list</blue> after it has been created.
            <br></br><br></br>
            A <blue>list</blue> is like a vector (<red>dynamic</red> in length) and it can be accessed 
            in the same way, by <red>index</red>. The <blue>list</blue> collections are indexed 
            starting from 
            <blue>0</blue>, similar to any other <red>collection</red> from other programming languages.
            <br></br><br></br>
            In Python a <blue>list</blue> can be created using any type of data.
            The <red>dynamic</red> length of a <blue>list</blue>, allows appending new elements 
            at the end of the 
            <blue>list</blue>, so that the <red>size</red> would change automatically.
            <br></br>
<code>
#Example of working with lists in Python 3:

#Defining a list:
CharList = ['M','e','s','s','a','g','e']

print('The list is: {0}' .format(CharList))

#Accessing an element of the list:
print('This is the 4th element {0}' .format(CharList[4]))

#Changing an element of the list:
CharList[4] = 'O'
print("The new 4th element is: {0}" .format(CharList[4]))

#Appending elements at the end of the list.
CharList+= ['1', '2'] 
#this is used for temporarily change.
print("The list now, looks like this: {0}" .format(CharList))

CharList.append('3') 
#this is used for permanent change. 
print("The list now, looks like this: {0}" .format(CharList))

#Slicing lists:
print("The sliced list is: {0}" .format(CharList[:5])) 
#slicing a list can be done just like in case of strings.

#Changing multiple items of the list:
CharList[2:] = ['2', '3'] 
#this synthax can only be used on lists, to add multiple
#elements after a given index (will automatically erase 
#the rest of the elements after that index)

print(CharList)

#Emptying the list:
CharList[:] = []
print(CharList)

input("\nPress any key to exit: ")
</code>

<code>
#Example of unpacking lists in Python:

#Unpacking is the process in which every
#list element gets assigned to individual variable

item, name, price = ["Car", "Mustang Gt", "14000"]
#This is an unpacked list, where each element is actually a variable.

print("item: ", item, " name: ", name, " price: ", price);

#The lists that have many more elements:
print("\nThis is the second method: ")
start, *middle, end = ["element1", "element2", "element3", "element4"]

print(start) 
#this will print the first element

print(*middle) 
#this will print all the middle elements

print(end) 
#this will print the last element
</code>

<code>
#Example of zipping/combining lists together:

Lst1 = ["Dragos", "Alan", "Robin"]
Lst2 = ["Blake", "Walker", "Williams"]

names = zip(Lst1, Lst2)

#names will be a new list, a 2-dimensional list 
#containing all the elements in Lst1 and Lst2 combined.

#Iterating names:
for a,b in names:
    print("Name = ", a, b)

</code>
            <brown>Dictionaries:</brown>
            <br></br><br></br>
            <blue>Dictionaries</blue> are used to store data values in <code>key:value</code> pairs.
            A <blue>dictionary</blue> is a <red>collection</red> which is <red>ordered</red>, 
            <red>changeable</red> and do not allow duplicates.
            <br></br><br></br>
            Each <blue>key</blue> is separated from its <red>value</red> by a colon (<code>:</code>), 
            the items are separated by
            commas (<code>,</code>) and the whole thing is enclosed in curly braces <code>{}</code>. 
            <br></br>
            An empty <blue>dictionary</blue>
            without any items is declared using only two curly braces such as: <code>{}</code>.
            <br></br><br></br>
            <blue>Keys</blue> are <red>unique</red> within a <blue>dictionary</blue> while 
            <red>values</red> may not be. The <red>values</red> of a
            <blue>dictionary</blue> can be of any type, but the <blue>keys</blue> must be of 
            an <blue>immutable</blue> data type such as <red>strings</red>, <red>numbers</red>, 
            or <red>tuples</red>.
            <br></br><br></br>
            An item can be accessed only with a valid <red>key</red> or <red>index</red>, 
            trying to access an item with invalid <red>key</red> or <red>index</red> will 
            result in an error.
            <br></br><br></br>
            <blue>Dictionary</blue> <red>values</red> have no restrictions. 
            They can be any arbitrary Python <red>objects</red>,
            either standard <red>objects</red> or user-defined <red>objects</red>. 
            However, the same is not true for the <blue>keys</blue>
            <br></br><br></br>
            <red>IMPORTANT:</red> More than one entry per <blue>key</blue> is not allowed. 
            Which means no duplicate <blue>key</blue> is allowed. 
            When duplicate <blue>keys</blue> are encountered during assignment, the last
            assignment wins.
            <br></br><br></br>
            <blue>Keys</blue> must be <red>immutable</red>. Which means you can use 
            <red>strings</red>, <red>numbers</red> or <red>tuples</red> as dictionary  
            <blue>keys</blue> but something like <code>['key']</code> is not allowed.
            <br></br><br></br>
            Example: <code>dict = {['Name']: 'Zara'}</code>
            <br></br>
            This case is not allowed as the <blue>key</blue> provided is of type <blue>list</blue>.
            <br></br>
<code>
#Example of working with dictionaries in Python 3:

dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}

print ("dict['Name']: {0}" .format(dict['Name']))
print ("dict['Age']: {0}" .format(dict['Age']))

#Updating the dictionary:
print("\nAfter the update:")
dict['Age'] = 8; # update existing entry
dict['Name'] = "DPS School"; # Add new entry
print ("dict['Name']: {0}" .format(dict['Name']))
print ("dict['Age']: {0}" .format(dict['Age']))

#Looping through the dictionary:
for name,key in dict.items(): 
    #treat 'name' as the Name(from dictionary)
    #and key as the Key(value from the dictionary)
    
    print("Key: ", key, "\t Name:", name)

#Deleting dictionary items:
del dict['Name']; 
#remove entry with key 'Name'
#After the deletion the item with key 'Name'
#accessing it will result and error.

dict.clear();     
#remove all entries in dict, the dictionary 
#will be empty.

del dict ;        
#delete entire dictionary, it won't exist anymore.

input("\nPress any key to exit: ")
</code>

<code>
#Example of iterating through dictionaries:
#Accessing elements of dictionary using indexes:

i=0
dict = {"name1": "John", "name2": "Allan", "name3": "Mark"}

#Iterating through dictionary using while loop (for values):
while(i&lt;len(dict)):
    print("While-loop Key: ", list(dict.keys())[i], \
                  " While-loop Value: ", list(dict.values())[i])
    i+=1
print()

#Iterating through dictionary using while loop (for values):
i=0
while(i&lt;len(dict)):
    print("While-loop Value: ", list(dict.values())[i])
    i+=1
print()

#Iterating through dictionary using while loop (for values):
i=0
while(i&lt;len(dict)):
    print("While-loop Key: ", list(dict.keys())[i])
    i+=1
print()

#Iterating through dictionary using for loop (for keys and values):
for n,k in dict.items():
    print("For-Loop key = ", n, " For-Loop Value = ", k)
print()

#Iterating through dictionary using for loop (for keys):
for k in dict:
    print("For-Loop key = ", k)
print()

#Iterating through dictionary using for loop (for values):
for k in dict.values():
    print("For-Loop Value = ", k)

#Keep the console opened until the next button pressed:
input("Enter anything to quit.")
</code>
            <br></br>
            <blue>Dictionaries</blue> can also be converted to <blue>lists</blue> as the following 
            example demonstrates:
            <br></br>
<code>
//Example of splitting dictionaries to lists:

Dict = { "GOOGLE": 53.22, "FACEBOOK": 77.22, "TUMBLR": 33.2}

#Splitting dictionary to lists:
#Dict.values() => this will return a list with all the values in dictionary
#Dict.keys() => this will return a list with all the keys in the dictionary

#Zipping a dictionary:
name = zip(Dict.values(), Dict.keys())

#The zipped dictionary will look like this:
#(33.2, 'TUMBLR'), (53.22, 'GOOGLE'), (77.22, 'FACEBOOK')
#The same would be in case of lists, 1->1, 2->2
#first element combined with first, second to second... etc

print("The original dictionary is: ", Dict)
#Sorting a zipped dictionary:
print("The sorted(by value) zipped dictionary is: ", sorted(name))

name = name = zip(Dict.keys(), Dict.values())
print("The sorted (by keys) zipped dictionary is: ", sorted(name))
</code>
            <br></br>
            <brown>Sets:</brown>
            <br></br><br></br>
            <blue>Sets</blue> are like <blue>lists</blue> that cannot contain duplicate elements.
            <br></br>
            A <blue>set</blue> is one of 4 built-in <red>data types</red> in Python used 
            to store <blue>collections</blue> of data, 
            the other 3 are <blue>List</blue>, <blue>Tuple</blue>, and <blue>Dictionary</blue>, 
            all with different qualities and usage.
            <br></br>
<code>
#Example of working with sets in Python 3:

SetO = {"Fruits", "Vegetables", "Meal", "Drinks"}
print("This is the set: ", SetO)

#Printing item by item:
print("\nThese are the items in the set: ")
for item in SetO:
    print(item)

print("The size of Set is: " + str(len(SetO)))

input("\nPress any key to exit: ")
</code>
            <br></br>
            <brown>Tuples:</brown>
            <br></br><br></br>
            A <blue>tuple</blue> is a sequence of <red>immutable</red> Python objects. 
            <blue>Tuples</blue> are 
            sequences, just like <red>lists</red>. 
            <br></br><br></br>
            The differences between <blue>tuples</blue> 
            and <red>lists</red> are:<br></br>
            - <blue>tuples</blue> cannot be changed whereas <red>lists</red> can be changed;<br></br>
            - <blue>tuples</blue> use parenthesis <code>()</code>, whereas <red>lists</red> use 
            square brackets <code>[]</code>.<br></br>
            <red>Immutable</red> means constant once initialized it cannot be changed, meaning
            no item can be changed, <red>added</red> or <red>removed</red> from it.
            <br></br><br></br>
            <blue>Tuples</blue> can however be reinitialized with different values.
            <br></br><br></br>
            <blue>Tuples</blue> can be sliced meaning you are able to take portions of
            existing <blue>tuples</blue> to create new <blue>tuples</blue>.
            <br></br><br></br>
            New <blue>tuples</blue> can be created by adding <blue>2</blue> 
            existing <blue>tuples</blue> together.
            <br></br><br></br>
            Any set of multiple <red>objects</red>, comma-separated, declared without identifying 
            symbols are by default set to <blue>tuples</blue>.
            <br></br>
            <blue>Tuples</blue> can be accessed using indexes. 
            <br></br>
<code>
#Example of working with tuples in Python 3:

tup1 = ('physics', 'chemistry', 1997, 2000);
tup2 = (1, 2, 3, 4, 5 );
tup3 = "a", "b", "c", "d";

#An empty tuple is declared like this:
tup1 = ();

#To write a tuple containing a single value you have to 
include a comma, even though there is only one value.
tup1 = (50,); 
print("The tuple contain {0} elements: {1} " .format(len(tup1), tup1[0]))

#Tuples can be reinitialized with other values.
tup1 = (12, 34.56); 
tup2 = ('abc', 'xyz');

#Following action is not valid for tuples
#tup1[0] = 100;

#So let's create a new tuple as follows:
tup3 = tup1 + tup2;
print (tup3)

#Tuples can be DELETED as follows:
del tup3
#print(tup3) -> this will result an error, 
#tup3 won't exist anymore after its deletion

tup3 = tup1 + tup2;
#Tuples can use the same operation just as lists:
print ("\nExample: tup3[2] = {0}, tup3[-2] = {1}" .format(tup3[2], tup3[-2]))

print("Slicing tuples: {0}" .format(tup3[:2]))
print("Slicing tuples: {0}" .format(tup3[2:]))

#Any set of multiple objects, comma-separated, 
#declared without identifying symbols are by 
#default set to tuples.
#Examples:
x, y = 1, 2;

input("\nPress any key to exit: ")
</code>
        </collections>
        <collection-methods>
            <green>Collection Methods in Python:</green>
            <br></br><br></br>
            Python has a set of built-in <blue>methods</blue> that can be used on collections.
            <br></br><br></br>
            <green>List methods:</green>
            <br></br><br></br>
            <code>append()</code><br></br>
            Used for <red>adding</red> elements to the end of the List. 
            <br></br><br></br>
            <code>copy()</code><br></br>
            It <red>returns</red> a shallow copy of a list
            <br></br><br></br>
            <code>clear()</code><br></br>
            This method is used for <red>removing</red> all items from the list. 
            <br></br><br></br>
            <code>count()</code><br></br>
            These methods <red>count</red> the elements.
            <br></br><br></br>
            <code>extend()</code><br></br>
            <red>Adds</red> each element of an iterable to the end of the List
            <br></br><br></br>
            <code>index()</code><br></br>
            <red>Returns</red> the lowest index where the element appears. 
            <br></br><br></br>
            <code>insert()</code><br></br>
            Inserts a given element at a given index in a list. 
            <br></br><br></br>
            <code>pop()</code><br></br>
            <red>Removes</red> and returns the last value from the List or the given index value.
            <br></br><br></br>
            <code>remove()</code><br></br>
            <red>Removes</red> a given object from the List. 
            <br></br><br></br>
            <code>reverse()</code><br></br>
            <red>Reverses</red> objects of the List in place.
            <br></br><br></br>
            <code>sort()</code><br></br>
            <red>Sort</red> a List in ascending, descending, or user-defined order
            <br></br><br></br>
            <code>min()</code><br></br>
            <red>Calculates</red> the minimum of all the elements of the List
            <br></br><br></br>
            <code>max()</code><br></br>
            <red>Calculates</red> the maximum of all the elements of the List
            <br></br><br></br>
            <green>Dictionary methods:</green>
            <br></br><br></br>
            <code>clear()</code><br></br>
            <red>Removes</red> all the elements from the dictionary
            <br></br><br></br>
            <code>copy()</code><br></br>
            <red>Returns</red> a copy of the dictionary
            <br></br><br></br>
            <code>fromkeys()</code><br></br>
            <red>Returns</red> a dictionary with the specified keys and value
            <br></br><br></br>
            <code>get()</code><br></br>
            <red>Returns</red> the value of the specified key
            <br></br><br></br>
            <code>items()</code><br></br>
            <red>Returns</red> a list containing a tuple for each key value pair
            <br></br><br></br>
            <code>keys()</code><br></br>
            <red>Returns</red> a list containing the dictionary's keys
            <br></br><br></br>
            <code>pop()</code><br></br>
            <red>Removes</red> the element with the specified key
            <br></br><br></br>
            <code>popitem()</code><br></br>
            <red>Removes</red> the last inserted key-value pair
            <br></br><br></br>
            <code>setdefault()</code><br></br>
            <red>Returns</red> the value of the specified key. If the key does not exist: 
            insert the key, with the specified value
            <br></br><br></br>
            <code>update()</code><br></br>
            <red>Updates</red> the dictionary with the specified key-value pairs
            <br></br><br></br>
            <code>values()</code><br></br>
            <red>Returns</red> a list of all the values in the dictionary
            <br></br><br></br>
            <green>Set methods:</green>
            <br></br><br></br>
            <code>add()</code><br></br>
            <red>Adds</red> an element to the set
            <br></br><br></br>
            <code>clear()</code><br></br>
            <red>Removes</red> all the elements from the set
            <br></br><br></br>
            <code>copy()</code><br></br>
            <red>Returns</red> a copy of the set
            <br></br><br></br>
            <code>difference()</code><br></br>
            <red>Returns</red> a set containing the difference between two or more sets
            <br></br><br></br>
            <code>difference_update()</code><br></br>
            <red>Removes</red> the items in this set that are also included in another, specified set
            <br></br><br></br>
            <code>discard()</code><br></br>
            <red>Remove</red> the specified item
            <br></br><br></br>
            <code>intersection()</code><br></br>
            <red>Returns</red> a set, that is the intersection of two other sets
            <br></br><br></br>
            <code>intersection_update()</code><br></br>
            <red>Removes</red> the items in this set that are not present in other, 
            specified set(s)
            <br></br><br></br>
            <code>isdisjoint()</code><br></br>
            <red>Returns</red> whether two sets have a intersection or not
            <br></br><br></br>
            <code>issubset()</code><br></br>
            <red>Returns</red> whether another set contains this set or not
            <br></br><br></br>
            <code>issuperset(()</code><br></br>
            <red>Returns</red> whether this set contains another set or not
            <br></br><br></br>
            <code>pop()</code><br></br>
            <red>Removes</red> an element from the set
            <br></br><br></br>
            <code>remove()</code><br></br>
            <red>Removes</red> the specified element
            <br></br><br></br>
            <code>symmetric_difference()</code><br></br>
            <red>Returns</red> a set with the symmetric differences of two sets
            <br></br><br></br>
            <code>symmetric_difference_update()</code><br></br>
            <red>Inserts</red> the symmetric differences from this set and another
            <br></br><br></br>
            <code>union()</code><br></br>
            <red>Return</red> a set containing the union of sets
            <br></br><br></br>
            <code>update()</code><br></br>
            <red>Update</red> the set with the union of this set and others
            <br></br><br></br>
            <green>Tuple methods:</green>
            <br></br><br></br>
            <code>count()</code><br></br>
            <red>Returns</red> the number of times a specified value occurs in a tuple
            <br></br><br></br>
            <code>index()</code><br></br>
            <red>Searches</red> the tuple for a specified value and returns the 
            position of where it was found
            <br></br>
        </collection-methods>
        <dynamic-memory-allocation>
            <green>Dynamic memory allocation in Python:</green>
            <br></br><br></br>
            The memory is allocated to the <red>objects</red> at the run time. <br></br>
            The <blue>heap</blue> is used to implement <blue>dynamic memory management</blue>. 
            <br></br><br></br>
            Everything in Python is an <red>object</red> which means the memory is
            allocated <blue>dynamically</blue> and is managed by the 
            <blue>Python Memory Management</blue>.
            <br></br><br></br>
            Python <blue>deletes</blue> unneeded <red>objects</red> (built-in <red>types</red> or 
            <red>class instances</red>) automatically to <blue>free</blue> the memory space.
            <br></br><br></br>
            Python's <blue>garbage collector</blue> runs during program execution 
            and is triggered when an <blue>object's reference count</blue> reaches zero. 
            An <blue>object's reference count</blue> changes as the number of <blue>aliases</blue> 
            that point to it changes.
            <br></br>
        </dynamic-memory-allocation>
        <read-from-file>
            *General-Programming-Knowledge*
            <green>Read files in Python:</green>
            <br></br><br></br>
            The <blue>read()</blue> method reads a <red>string</red> from an opened <blue>file</blue>. 
            <br></br>
            It is important to note that Python <red>strings</red> can contain <red>binary data</red>, 
            apart from <red>text data</red>.
            <br></br><br></br>
            When reading/writing characters from a <blue>file</blue> the <blue>pointer/cursor</blue> 
            will move across the
            content of a <blue>file</blue>, and if it reaches the end, it will need to be reseted 
            using <blue>seek()</blue> function, before being able to read/write again.
            <br></br><br></br>
            The method <blue>tell()</blue> returns the current position of the 
            <blue>pointer/cursor</blue> within the <blue>file</blue>.
            <br></br><br></br>
            Passing an argument to the <blue>read()</blue> method will ensure that everything is 
            read until to the given position within the <blue>file</blue> content.
            <br></br><br></br>
            <red>Example:</red> <code>MyFile.read(11)</code> 
            <br></br>
            Only the first <blue>11</blue> characters will be extracted from the <blue>file</blue>.
            <br></br><br></br>
            The <blue>close()</blue> method of a <blue>file object</blue>, <red>flushes</red> 
            any unwritten information and closes the <red>file object</red>, 
            after which no more reading or writing can be done. 
            <br></br><br></br>
            Python automatically closes a <blue>file</blue> when the <red>reference object</red> of 
            a <blue>file</blue> is reassigned to another <blue>file</blue>.
            <br></br><br></br>
            It is a good practice to use the <blue>close()</blue> method to close a <blue>file</blue> 
            after finishing operating on the <blue>file</blue>.
            <br></br><br></br>
            In order to open a <blue>file</blue> the <blue>open()</blue> method it is used. 
            <br></br><br></br>
            The <blue>open()</blue> method takes <blue>2</blue> arguments:<br></br>
            - the <blue>filepath</blue> of the <blue>file</blue> to be opened;<br></br>
            - the <blue>mode</blue> for opening;<br></br>
            <br></br>
            <red>Example:</red> <code>open("file.txt", "w")</code><br></br>
            This will open a <blue>file</blue> named <blue>file.txt</blue> placed in the same 
            directory as the .py script.
            <br></br><br></br>
            <green>Modes for opening a file:</green>
            <br></br><br></br>
            The other available <red>modes</red> for opening a <blue>file</blue> are:
            <br></br><br></br>
            <blue>"r"</blue> - Opens a <blue>file</blue> for reading only. 
            <br></br>
            The <blue>file pointer/cursor</blue> is placed at the beginning of the <blue>file</blue>. 
            This is the <red>default mode</red>. It throws an <red>error</red> if 
            the <blue>file</blue> does not exist.
            <br></br><br></br>
            <blue>"w"</blue> - Opens a <blue>file</blue> for writing only. 
            <br></br>
            Overwrites the <blue>file</blue> if the <blue>file</blue> exists.
            If the <blue>file</blue> does not exist, creates a new <blue>file</blue> for writing.
            <br></br><br></br>
            <blue>"rb"</blue> - Opens a <blue>file</blue> for reading only in <red>binary format</red>. 
            <br></br>
            The <blue>file pointer/cursor</blue> is placed
            at the beginning of the <blue>file</blue>. 
            This is the <red>default mode</red>.
            <br></br><br></br>
            <blue>"rb+"</blue> - Opens a <blue>file</blue> for both reading and writing in 
            <red>binary format</red>. 
            <br></br>
            The <blue>file pointers</blue> placed at the beginning of the <blue>file</blue>.
            <br></br><br></br>
            <blue>"wb"</blue> - Opens a <blue>file</blue> for writing only in <red>binary format</red>. 
            <br></br>
            Overwrites the file if the <blue>file</blue> exists. 
            If the <blue>file</blue> does not exist, 
            creates a new <blue>file</blue> for writing.
            <br></br><br></br>
            <blue>"w+"</blue> - Opens a <blue>file</blue> for both writing and reading.
            <br></br>
            Overwrites the existing <blue>file</blue> if
            the <blue>file</blue> exists. 
            If the <blue>file</blue> does not exist, creates a new <blue>file</blue> for reading
            and writing.
            <br></br><br></br>
            <blue>"wb+"</blue> - Opens a <blue>file</blue> for both writing and reading in 
            <red>binary format</red>. 
            <br></br>
            Overwrites the existing <blue>file</blue> if 
            the <blue>file</blue> exists. 
            If the <blue>file</blue> does not exist, creates a
            new <blue>file</blue> for reading and writing.
            <br></br><br></br>
            <blue>"a"</blue> - Opens a <blue>file</blue> for appending. <br></br>
            The <blue>file pointer/cursor</blue> is at the end of the <blue>file</blue>
            if the <blue>file</blue> exists. 
            The <blue>file</blue> is opened in 
            the <red>append mode</red>. If the <blue>file</blue> does
            not exist, it creates a new <blue>file</blue> for writing.
            <br></br><br></br>
            <blue>"ab"</blue> - Opens a <blue>file</blue> for appending in <red>binary format</red>. 
            <br></br>
            The <blue>file pointer/cursor</blue> is at the
            end of the <blue>file</blue> if the <blue>file</blue> exists.
            The <blue>file</blue> is opened in the <red>append mode</red>.
            If the <blue>file</blue> does not exist, 
            it creates a new <blue>file</blue> for writing.
            <br></br><br></br>
            <blue>"a+"</blue> - Opens a <blue>file</blue> for both appending and reading.
            <br></br>
            The <blue>file pointer/cursor</blue> is at the
            end of the <blue>file</blue> if the <blue>file</blue> exists.
            The <blue>file</blue> opens in the <red>append mode</red>. If the
            <blue>file</blue> does not exist, it creates a new <blue>file</blue> 
            for reading and writing.
            <br></br><br></br>
            <blue>"ab+"</blue> - Opens a <blue>file</blue> for both <red>appending</red> and <red>reading</red> 
            in <red>binary format</red>. 
            <br></br>
            The <blue>pointer/cursor</blue> within the <red>file</red> is poiting to the end of the 
            <blue>file</blue> if the <blue>file</blue> exists. 
            If the <blue>file</blue> does not exist, it creates 
            a new <blue>file</blue> for reading and writing.
            <br></br><br></br>
            <green>File object attributes:</green>
            <br></br><br></br>
            The <blue>file object</blue> contains several <red>attributes</red>:
            <br></br><br></br>
            <code>file.closed</code><br></br>
            <blue>Returns</blue> <code>true</code> if <blue>file</blue> is closed, <code>false</code> 
            otherwise.
            <br></br><br></br>
            <code>file.mode</code><br></br>
            <blue>Returns</blue> the <red>access mode</red> with which the <blue>file</blue> was 
            opened.
            <br></br><br></br>
            <code>file.name</code><br></br> 
            <blue>Returns</blue> name of the <blue>file</blue>.
            <br></br><br></br>
            <code>file.softspace</code><br></br>
            <blue>Returns</blue> a <red>boolean</red> that indicates whether a space character 
            needs to be printed before another value when using the <red>print</red> statement.
            <br></br><br></br>
<code>
#Example of reading content from files
#in Python:

MyFile.write("This program is written in Python language.")
#The string above will be written after the files gets closed (in the next line)
MyFile.close();

MyFile = open("file.txt", "r")

Msg = MyFile.read(11) 
#Only the first 11 character will be extracted from the file.
print(Msg)

Msg = MyFile.read(11) 
#This will print the next 11 character in the file
#since the cursor wasn't restarted.

print(Msg)

#Check current position
position = MyFile.tell();
print ("Current file position : {0}"  .format(position))
position = MyFile.seek(0, 0); 
#this will restart the cursor to the beginning of the file.

Msg = MyFile.read(11)
print(Msg)

import os 
#needed for the os functions.

#Syntax: os.rename(current_file_name, new_file_name)
#This function will rename a file:

#Getting the current file name:
print("The current file name is: {0}" .format(MyFile.name))
#The attribute .name shows the name of the current file loaded.

MyFile.close() 
#closing the file

#Check if a file exists
if os.path.isfile("file1.txt"): 
    os.remove("file1.txt") 
    #remove the file

os.rename("file.txt", "file1.txt")
#renaming the file

#Renaming the file with the name of an 
#existing file (at the same path) will
#throw an exception.

MyFile = open("file1.txt", "r")
print("The current file name is: {0}" .format(MyFile.name))
#Changing the name of the file will work only 
#if the file is closed, and not being
#processed by another programs.

#Removing a directory:
os.chdir(r"C:\Users\Black2\Desktop\python") 
#Changing the current directory

#Check if a directory exists
if os.path.exists(r"C:\Users\Black2\Desktop\python\file dir"):
    os.rmdir(r"C:\Users\Black2\Desktop\python\file dir") 
    #removing the directory

#Creating a directory:
os.mkdir("file dir")

#The os.getcwd() method displays the current working directory.
print("The current working directory is: {0}" .format(os.getcwd()))

#Renaming directories:
#Check if a directory exists:
if os.path.exists(r"C:\Users\Black2\Desktop\python\directory dir2"):
    os.rmdir(r"C:\Users\Black2\Desktop\python\directory dir2") 
    #removing the directory

os.rename(r"C:\Users\Black2\Desktop\python\directory dir",
             r"C:\Users\Black2\Desktop\python\directory dir2")
#renaming the file

MyFile.close()
#closing the file

os.rmdir(r"C:\Users\Black2\Desktop\python\directory dir2")
#removing the directory

input("\nPress any key to exit: ")
</code>
        </read-from-file>
        <write-to-file>
            *General-Programming-Knowledge*
            <br></br>
            <green>Writing to files in Python:</green>
            <br></br><br></br>
            The <blue>write()</blue> method writes any string to an open file.
            The <blue>write()</blue> method does not add a newline character ('\n')
            <br></br><br></br>
            It is important to note that
            Python <red>strings</red> can have <blue>binary data</blue> and not just text.
            <br></br><br></br>
            When reading/writing characters from a <blue>file</blue> the <blue>pointer/cursor</blue> 
            will move across the
            content of a <blue>file</blue>, and if it reaches the end, it will need to be reseted 
            using <blue>seek()</blue> function, before being able to read/write again.
            <br></br><br></br>
            The <blue>close()</blue> method of a <blue>file object</blue>, <red>flushes</red> 
            any unwritten information and closes the <red>file object</red>, 
            after which no more reading or writing can be done. 
            <br></br><br></br>
            Python automatically closes a <blue>file</blue> when the <red>reference object</red> of 
            a <blue>file</blue> is reassigned to another <blue>file</blue>.
            <br></br><br></br>
            It is a good practice to use the <blue>close()</blue> method to close a <blue>file</blue> 
            after finishing operating on the <blue>file</blue>.
            <br></br><br></br>
            In order to open a <blue>file</blue> the <blue>open()</blue> method it is used. 
            <br></br><br></br>
            The <blue>open()</blue> method takes <blue>2</blue> arguments:<br></br>
            <br></br>
            - the <blue>filepath</blue> of the <blue>file</blue> to be opened;<br></br>
            - the <blue>mode</blue> for opening;
             <br></br><br></br>
            <red>Example:</red> <code>open("file.txt", "w")</code><br></br>
            This will open a <blue>file</blue> named <blue>file.txt</blue> placed in the same 
            directory as the .py script.
            <br></br><br></br>
            <brown>Writing to a file using TXT format:</brown>
            <br></br>
<code>
#Example of writing to a file in Python:
 
#Opening a file
file1 = open('myfile.txt', 'w')
L = ["This is Delhi \n", "This is Paris \n", "This is London \n"]
s = "Hello\n"
 
#Writing a string to file
file1.write(s)
 
#Writing multiple strings
#at a time
file1.writelines(L)
 
#Closing file
file1.close()
 
#Checking if the data is
#written to file or not
file1 = open('myfile.txt', 'r')
print(file1.read())
file1.close()
</code>
            <br></br>
            <brown>Writing to a file using XML format:</brown>
            <br></br>
<code>
#Example of writing to XML file
#in Python 3:

import os

import sys
import xml.etree.ElementTree
#import used for XML formatting

#Defining a person class:
class Person:
    def __init__(self, surname:str, firstname:str, age: int):
        self.surname = surname
        self.age = age
        self.firstname = firstname

    def __repr__(self):
        return self.surname+ " " + self.firstname + " " + str(self.age)

#Creating a list of persons:
people = [
                Person("Geere", "Richard", 64),
                Person("Walker", "Alan", 24),
                Person("Manson", "Mary", 34),
                Person("Manson", "Deny", 36),
                Person("Menance", "Denise", 54),
                Person("Reyes", "Antonio", 22),
            ]

#Define a function to write to an xml file:
def write_xml(list, filename):
    #Format the content of the list to XML format
    root  = xml.etree.ElementTree.Element("people")
    for pers in list:
        node = xml.etree.ElementTree.Element("people", age = str(pers.age))
        surname = xml.etree.ElementTree.SubElement(node, 'surname')
        firstname = xml.etree.ElementTree.SubElement(node, 'firstname')
        surname.text = pers.surname
        firstname.text = pers.firstname
        root.append(node)
    
    tree = xml.etree.ElementTree.ElementTree(root)
    
    #Writing to the file:
    try:
        tree.write(filename, "UTF-8")
    
    except EnvironmentError as err:
        print("{0}: import error: {1}".format(
            os.path.basename(sys.argv[0]), err))
        return False
    
    return True

#Calling write_xml function:
write_xml(people, "file.xml")
</code>        
        </write-to-file>
        <serialization>
            *General-Programming-Knowledge*
<code>
#Example of serialization in Python:

import pickle

#Object to serialize  
data = [1, 2, 3, 4, 5]

#Serialize object to a file  
with open('data.pkl', 'wb') as file:  
pickle.dump(data, file) 
</code>        
        </serialization>
        <deserialization>
            *General-Programming-Knowledge*
<code>
#Example of deserialization in Python:

import pickle

#Deserialize object from the file  
with open('data.pkl', 'rb') as file:  
loaded_data = pickle.load(file)

print(loaded_data)    
</code>        
        </deserialization>
        <enums>
            *General-Programming-Knowledge*
            <green>Enums in Python:</green>
            <br></br><br></br>
            <red>Enumerations</red> in Python are implemented by using the module named 
            <red>“enum“</red>.
            <br></br><br></br>
            <red>Enumerations</red> are created using classes. 
            <red>Enums</red> have names and values 
            associated with them.
            <br></br><br></br>
            <red>Enums</red> can be displayed as <red>string</red> or <red>repr</red>.<br></br>
            <red>Enums</red> can be checked for their types using <red>type()</red>.<br></br>
            The <blue>“name”</blue> keyword is used to display the name of the <red>enum</red>
            member.
            <br></br>
<code>
#Example of enums in Python:

from enum import Enum
 
class Season(Enum):
    SPRING = 1
    SUMMER = 2
    AUTUMN = 3
    WINTER = 4

print(Season.SPRING)
print(Season.SPRING.name)
print(Season.SPRING.value)
print(type(Season.SPRING))
print(repr(Season.SPRING))
print(list(Season))
</code>
        </enums>
        <constructors>
            *General-Programming-Knowledge*
<code>
#Example of constructor in Python:

class Employee:
 
    #Constructor definition:
    def __init__(self):
        print('Employee created.')

#Instantiation:
obj = Employee()
del obj
</code>        
        </constructors>
        <instantiation>
            *General-Programming-Knowledge*
<code>
#Example of instantiation in Python: 

class Person:
    #Defining a constructor:
    def __init__(self, name, age):
        self.name = name
        self.age = age

#Instantiation:
person1 = Person("John", 25)

print(person1.name)
print(person1.age)
</code>        
        </instantiation>
        <destructors>
            *General-Programming-Knowledge*
<code>
#Example of destructor in Python:

class Employee:
 
    #Constructor definition:
    def __init__(self):
        print('Employee created.')
 
    #Destructor definition:
    def __del__(self):
        print('Destructor called, Employee deleted.')

#Instantiation:
obj = Employee()
del obj
</code>        
        </destructors>
        <function-overloading>
            *General-Programming-Knowledge*
            <br></br>
            <green>Function overloading in Python:</green>
            <br></br><br></br>
            In Python <blue>function overloading</blue> works different as compared to other 
            OOP programming
            languages: the <red>methods</red> can be <red>overloaded</red> but only the 
            latest defined <red>method</red> can be used.
            <br></br>
<code>
#Example of function overloading in Python:

#First product takes 2 arguments:
def product(a, b):
    p = a * b
    print(p)
 
#Second product method 3 arguments:
def product(a, b, c):
    p = a * b*c
    print(p)
 
#Uncommenting the below line shows an error
#product(4, 5)
 
 
#This line will call the second product method
product(4, 5, 5)
</code>
            <br></br>
            <green>Overloading behaviour in a single function:</green>
            <br></br><br></br>
            A <red>method</red> can be implemented in such a way that it responds differently
            based on the arguments passed to it. This will result in a behaviour
            which is similarly obtained via <red>method overloading</red> in other programming
            languages.
            <br></br>
<code>
#Example of efficient overloading
#behavior:

#Function to take multiple arguments
def add(datatype, *args):
 
    #if datatype is int
    #initialize answer as 0
    if datatype == 'int':
        answer = 0
 
    #if datatype is str
    #initialize answer as ''
    if datatype == 'str':
        answer = ''
 
    #Traverse through the arguments
    for x in args:
 
        #This will do addition if the
        #arguments are int. Or concatenation
        #if the arguments are str
        answer = answer + x
 
    print(answer)
 
 
#Integer
add('int', 5, 6)
 
#String
add('str', 'Hello ', 'Python')
</code>
            <br></br>
            <green>Overloading via decorator:</green>
            <br></br><br></br>
            <blue>Method overloading</blue> can also be achieved by using a <red>decorator</red>. 
            The <blue>method everloading</blue> via <red>decorator</red> allows using all the 
            defined versions of the <red>method</red>.
            <br></br>
<code>
#Overloading via decorator:

from multipledispatch import dispatch
#import dispatch

@dispatch(int, int)
def product(first, second):
    result = first*second
    print(result)
 
@dispatch(int, int, int)
def product(first, second, third):
    result = first * second * third
    print(result)
 
@dispatch(float, float, float)
def product(first, second, third):
    result = first * second * third
    print(result)
 
 
#calling product method with 2 arguments
product(2, 3)  
#the output will be 6
 
#calling product method with 3 arguments but all int
product(2, 3, 2)  
#the output will be 12
 
#calling product method with 3 arguments but all float
product(2.2, 3.4, 2.3)  
#the output will be 17.985999999999997
</code>
        </function-overloading>
        <operator-overloading>
            *General-Programming-Knowledge*
            <br></br>
<code>
#Example of operator overloading in Python:
 
class complex:
    def __init__(self, a, b):
        self.a = a
        self.b = b
 
     #overloading the + operator for addition:
    def __add__(self, other):
        return self.a + other.a, self.b + other.b
 
Ob1 = complex(1, 2)
Ob2 = complex(2, 3)

#Using the overloaded operator we can now
#perform addition on complex objects:
Ob3 = Ob1 + Ob2
print(Ob3)
</code>
        <br></br>
        <green>Python Operators for Overloading:</green>
        <br></br><br></br>
        <red>Operator:</red><code>      </code><red>Magic Method:</red><br></br>
        <code>+             __add__(self, other)</code><br></br>
        <code>–             __sub__(self, other)</code><br></br>
        <code>*             __mul__(self, other)</code><br></br>
        <code>/             __truediv__(self, other)</code><br></br>
        <code>/</code><code>/            __floordiv__(self, other)</code><br></br>
        <code>%             __mod__(self, other)</code><br></br>
        <code>**            __pow__(self, other)</code><br></br>
        <code>&gt;&gt;            __rshift__(self, other)</code><br></br>
        <code>&lt;&lt;            __lshift__(self, other)</code><br></br>
        <code>&#38;             __and__(self, other)</code><br></br>
        <code>|             __or__(self, other)</code><br></br>
        <code>^             __xor__(self, other)</code><br></br>
        </operator-overloading>
        <concurrent-programming>
            *General-Programming-Knowledge*
            <br></br>
            <green>Multithreading in Python:</green>
            <br></br><br></br>
            In Python: <blue>multithreading</blue> is the action of executing <red>tasks</red> simultaneosly 
            (in parallel) in order to increase the speed of execution.
            <br></br><br></br>
            <green>GIL or Global Interpreter Lock:</green>
            <br></br><br></br>
            <blue>Python Global Interpreter Lock</blue> or <blue>GIL</blue> is an important 
            part of <blue>multithreading programming</blue>. 
            <br></br><br></br>
            <blue>Python Global Interpreter Lock</blue> it's a <blue>mutex</blue> or a type 
            of <blue>process lock</blue> used when working with multiple <red>processes</red>. 
            It allows only one <blue>thread</blue> to hold the <blue>control</blue> of 
            the <blue>Python interpreter</blue>. 
            This means that only one <blue>thread</blue> can be in a state of 
            execution at any point in time. 
            <br></br><br></br>
            The impact of the GIL isn’t visible to developers who execute 
            <blue>single-threaded</blue> programs but it can be a performance bottleneck in 
            <blue>CPU-bound</blue> and <blue>multi-threaded</blue> code.
            <br></br><br></br>
            Python uses <blue>reference counting</blue> for <blue>memory management</blue>. 
            It means that 
            <red>objects</red> created in Python have a <blue>reference count</blue> variable that 
            keeps track of the number of <blue>references</blue> that point to the <red>object</red>. 
            <br></br>
            When this count reaches <blue>zero</blue> and no variable is referencing the 
            <red>object</red> stored in the <blue>heap memory</blue>, 
            the <blue>heap memory</blue> occupied by the <red>object</red> is released 
            (<blue>deallocated</blue>).
            <br></br><br></br>
            The problem was that this <blue>reference count</blue> variable needed protection 
            from <blue>race conditions</blue> where two <blue>threads</blue> increase or decrease 
            its value 
            simultaneously. If this happens, it can cause either <blue>leaked memory</blue> that 
            is never released or, even worse, <blue>incorrectly release</blue> of the
            the memory while a <blue>reference</blue> to that <red>object</red> still exists. 
            This can cause <red>crashes</red> or other “weird” <red>bugs</red> within the 
            Python programs.
            <br></br><br></br>
            <brown>GIL was introduced in order to fix these issues.</brown>
            <br></br><br></br>
            Generally, Python uses a <blue>single thread</blue> to run a <blue>single process</blue>.
            We get the same performance result of the <blue>single-threaded</blue> and 
            <blue>multithreading</blue> processes using the <blue>GIL</blue>. 
            It restricts achieving <blue>multithreading</blue> in Python because it prevents 
            the <blue>threads</blue> and works as a <blue>single thread</blue>.
            <br></br><br></br>
            <green>Python-related Multithreading Drawbacks:</green>
            <br></br><br></br>
            1. One GIL is used for all <blue>threads</blue>, and <blue>threads</blue> are limited by 
            GIL;
            <br></br><br></br>
            2. <blue>Multithreading</blue> has no effect for CPU-bound <red>tasks</red> due to 
            the <blue>GIL</blue>, 
            meaning we'll notice no improvements in the performance when it comes to these sort 
            of <red>tasks</red>;
            <br></br>
            CPU-bound <red>tasks</red> are those that require a significant amount of computational 
            resource.
            <br></br>
<code>
#Example of multithreading in Python 3:

import threading 
#used for threading

import time 
#used for time

def calculateSquare(numberList):
    for n in numberList:
        print(str(n) + " * " + str(n) + " = " + str(n*n))
        time.sleep(0.2) #this will add a 0.2 seconds delay

def calculateCube(numberList):
    for n in numberList:
        print(str(n) + " * " + str(n) + " * " + str(n) + " = " + str(n*n*n))
        time.sleep(0.2) #this will add a 0.2 seconds delay

#Creating a list:
numberList = [2,4,5,6,12,34]

#Creating threads:
thread1 = threading.Thread(target=calculateSquare, args =(numberList,))
thread2 = threading.Thread(target=calculateCube, args =(numberList,))

t_before = time.time() 
#this will get the time before starting the threads

calculateSquare(numberList)
calculateCube(numberList)
t_after = time.time()

print("Example 1: No threading - time for execution: " 
    + str(t_after-t_before) + " seconds.\n")

#The following thread example works as calling 
#the 2 functions without threading (similar to the example above),
#because the second thread needs to wait until the first thread 
#finishes its execution just like the functions in the example 
#above do.

#Get current time:
t1_before = time.time() # this will get the time before starting the threads
thread1.start()
thread1.join() 
#wait for the thread1 to finish its work.

thread2.start()
thread2.join() 
#wait for the thread2 to finish its work.
t1_after = time.time()

print("Example 2: Inefficient threading - time for execution: " 
        + str(t1_after-t1_before) + " seconds.\n")

#The following way is faster but printing is a mess 
#(because the 2 functions are executed in parallel).

#After finishing, the thread needs to be reinitialized.
#Reinintializing threads:
thread1 = threading.Thread(target=calculateSquare, args =(numberList,))
thread2 = threading.Thread(target=calculateCube, args =(numberList,))
t2_before = time.time() 
#this will get the time before starting the threads.

thread1.start()
thread2.start()
thread1.join() 
#wait for the thread1 to finish its work.

thread2.join() 
#wait for the thread2 to finish its work.

t2_after = time.time()
print("Example 3: Good threading - time for execution: " 
    + str(t2_after-t2_before) + " seconds.")

input("\nPress any key to exit: ")
</code>
            <br></br>
            <green>Multiprocessing in Python:</green>
            <br></br><br></br>
            By using <blue>multiprocessing</blue> in Python the 
            <blue>Global Interpreter Lock</blue> limitations can be overcome.
            <br></br><br></br>
            <blue>Multiprocessing</blue> refers to the ability of a system to support more than 
            one processor at the same time. Applications in a <blue>multiprocessing</blue> system 
            are broken to smaller routines that run independently. The operating system 
            allocates these <red>threads</red> to the processor cores improving the performance 
            of the system.
            <br></br><br></br>
            The <blue>Pool class</blue> in Python's <blue>multiprocessing</blue> module provides 
            convenient means of managing a pool of worker <red>processes</red>. It comes with 
            built-in <red>methods</red> that offer structured ways to distribute <red>tasks</red> 
            among these <red>processes</red>.
            <br></br><br></br>
            The <blue>Pool class</blue> represents a pool of worker <red>processes</red>. It has 
            methods which allows 
            <red>tasks</red> to be offloaded/distributed to the worker <red>cores/processes</red> 
            in few different ways. 
            <br></br>
<code>
#Example of multiprocessing in Python 3:

import multiprocessing 
#used for multiprocessing

import time 
#used for time

def PrintHello():
    i=0
    while(i&lt;50):
        print("Hello " + str(i))
        time.sleep(0.2)
        i+=1

def PrintHi():
    i=0
    while(i&lt;50):
        print("Hi " + str(i))
        time.sleep(0.2)
        i+=1

#Functions used with ".pool and .map" needs 
#to take an extra argument

#The Python Multiprocessing Pool provides 
#reusable worker processes in Python.

def Funct(n):
    i=0
    while(i&lt;50):
        print("Hello " + str(i))
        time.sleep(0.2)
        i+=1

#If the script is being ran standalone:
if __name__ == "__main__":
    t_before = time.time()
    p1 = multiprocessing.Process(target=PrintHello, args=())
    p2 = multiprocessing.Process(target=PrintHi, args=())
    p1.start()
    p2.start()
    p1.join() 
    #wait for the process to finish
    
    p2.join() 
    #Wait for the process to finish
    t_after = time.time()
    print("Example 1. Time for execution: " + str(t_after - t_before))
    
    #Executing single process:
    t_before = time.time()
    p1 = multiprocessing.Process(target=PrintHello, args=())
    p1.start()
    p1.join() 
    #wait for the process to finish
    
    t_after = time.time()
    print("Example 2: Without Pooling and Mapping - time for execution: " 
            + str(t_after - t_before))
    
    #Pooling and mapping processes:
    #Functions used for "pooling and mapping" needs to 
    #take an extra argument for
    #iteration (how many times to run the same function).
    
    t_before = time.time()
    p1 = multiprocessing.Pool()
    p1.map(Funct, range(1)) 
    #run this function for 1 time.
    
    #The extra argument specifies how many times the 
    #function should be runned.
    t_after = time.time()
    print("Example 2: With Pooling and Mapping - time for execution: " 
        + str(t_after - t_before))
    
    input("Press any key to quit.")
</code>        
        </concurrent-programming>
        <namespaces>
            *General-Programming-Knowledge*
            <br></br>
            <green>Namespaces in Python:</green>
            <br></br><br></br>
            Python <blue>namespaces</blue> are <red>collections</red> of different 
            <red>objects</red> that are associated with 
            unique names whose lifespan depends on the <red>scope</red> of a variable.
            <br></br>
            A variable is only available from inside the region it is created. 
            This is called <red>scope</red>.
            <br></br><br></br>
            The <red>scope</red> is a 
            region from where we can access a particular <red>object</red>.
            <br></br><br></br>
            There are three levels 
            of <red>scopes</red>: <blue>built-in</blue> (<blue>outermost</blue>), 
            <blue>global</blue>, and <blue>local</blue>.
            <br></br><br></br>
            <brown>Built-in scope:</brown>
            <br></br><br></br>
            The built-in <red>scope</red> is automatically loaded by Python when you run a 
            program or script. 
            It contains names that are built into Python, such as 
            <blue>keywords</blue>, <blue>functions</blue>, <blue>exceptions</blue>, 
            and other <red>attributes</red>. 
            <br></br><br></br>
            <brown>Global scope:</brown>
            <br></br><br></br>
            A variable created in the main body of the Python 
            code is a <red>global variable</red> and belongs to the <red>global scope</red>.
            <red>Global variables</red> are available from within any <red>scope</red>, 
            <red>global</red> and <red>local</red>.
            The <red>global</red> keyword makes the variable <red>global</red>.
            <br></br><br></br>
            <brown>Local scope:</brown>
            <br></br><br></br>
            A variable created inside a function belongs to the <red>local scope</red> 
            of that function, and can only be used inside that function.
            The <blue>nonlocal</blue> keyword is used to work with variables 
            inside nested functions. A nested function is a function defined within a function.
            <br></br><br></br>
            The <blue>nonlocal</blue> keyword makes the variable belong to the outer function.
            <br></br><br></br>
            Within Python <red>namespaces</red> and <red>scopes</red> are in a tight relationship. 
            For example: 
            the <red>global namespace</red> can be seen as a collection of <red>global variables</red> 
            which have 
            <red>global scope</red>, meaning they can be accessed from anywhere in the program. 
            The <red>global
            namespace</red> contains <red>local namespaces</red> for each function/method/loop an 
            other entities
            defining <red>local scopes</red>.
            <br></br><br></br>
            <red>Scope</red> refers to the coding region from which a particular Python object 
            is accessible. 
            <br></br>
<code>
#Example of namespace and scopes in Python:

#var1 is in the global namespace
#meaning var1 has global scope:
var1 = 5

def some_func():
 
    #var2 is in the local namespace 
    #meaning var1 has local scope:
    var2 = 6
    
    def some_inner_func():
 
        #var3 is in the nested local namespace
        #meaning var3 has nested local scope:
        var3 = 7
</code>
        </namespaces>
        <exception-handling>
            *General-Programming-Knowledge*
<code>
#Exceptions handling:




#An exception is an event, which occurs during the execution of a program that disrupts the normal flow of the program's
#instructions. In general, when a Python script encounters a situation that it cannot cope with, it raises an exception.
#An exception is a Python object that represents an error.

#Handling exceptions:
try:
   fh = open("dragos1.txt", "a")
   fh.write("This was added by 'handling exceptions' Program.")
except IOError:
   print ("Error: can't find file or read data from {0}" .format(fh.name))
else:
   print ("Written content in the file successfully!")
   fh.close()

#Example 2:
try:
    fh = open("file.txt", "r")
    fh.read(12)
except IOError:
    print ("Error: can\'t find file or read data from {0}" .format(fh.name))
finally:
    print ("Not working!")

#When an exception is thrown in the try block, the execution immediately passes to the finally block. After all the statements
#in the finally block are executed, the exception is raised again and is handled in the except statements if present in the
#next higher layer of the try-except statement.

#You can raise exceptions in several ways by using the raise statement. The general syntax for the raise statement is as follows.

level=1
if level &lt; 1:
      raise Exception('level &lt; 1')

#Creating user-defined exception:
class MyError(Exception):
     def __init__(self, value):
         self.value = value
     def __str__(self):
         return repr(self.value)

#Catching user-defined exceptions:
try:
    raise MyError(2*2)
except MyError as e:
     print ("My exception occurred, value: {0}" .format (e.value))


#THIS STATEMENT WILL THE COMMAND PROMPT OPEN UNTIL THE NEXT BUTTON PRESS:
input("\nPress any key to exit: ")
</code>        

<code>
try:
    lis = ['a', 'b']
    print(str(lis[4]))
except Exception as exp: # equivalent to except:
    print("Exception class: " + str(type(exp)) + "\nMessage: " + str(exp))
    #an exception created in the except block or finally will not be treated or caught.
else:
    print("No exception caught!")
finally:
    print("Operation done.")

#raise Exception ("Custom error") # this will throw an exception

assert 5&lt;8, "Nothing to do" #this is fine since condition is true
#assert 5&gt;8, "Condition is false" # this will raise an exception because the condition is false.

#assert can be used for debugging. can be turned off when running python script with -O

#LAMBDA functions:

DoubleValue = lambda value: value*2

print(DoubleValue(2)) #calling the lambda function

input("\nPress ENTER to exit.")
</code>
            <br></br>
            <green>Python Exceptions:</green>
            <br></br><br></br>
            <code>Exception</code><br></br>
            <red>Base class</red> for all exceptions.
            <br></br><br></br>
            <code>StopIteration</code><br></br>
            <red>Raised</red> when the <blue>next()</blue> method of an <red>iterator</red> does not 
            point to any <red>object</red>.
            <br></br><br></br>
            <code>SystemExit</code><br></br>
            <red>Raised</red> by the <blue>sys.exit()</blue> function.
            <br></br><br></br>
            <code>StandardError</code><br></br>
            <red>Base class</red> for all built-in exceptions except <blue>StopIteration</blue> 
            and <blue>SystemExit</blue>.
            <br></br><br></br>
            <code>ArithmeticError</code><br></br>
            <red>Base class</red> for all errors that occur for numeric calculation.
            <br></br><br></br>
            <code>OverflowError</code><br></br>
            <red>Raised</red> when a calculation exceeds maximum limit for a numeric type.
            <br></br><br></br>
            <code>FloatingPointError</code><br></br>
            <red>Raised</red> when a floating point calculation fails.
            <br></br><br></br>
            <code>ZeroDivisionError</code><br></br>
            <red>Raised</red> when division or modulo by zero takes place for all numeric types.
            <br></br><br></br>
            <code>AssertionError</code><br></br>
            <red>Raised</red> in case of failure of the <blue>Assert</blue> statement.
            <br></br><br></br>
            <code>AttributeError</code><br></br>
            <red>Raised</red> in case of failure of attribute reference or assignment.
            <br></br><br></br>
            <code>EOFError</code><br></br>
            <red>Raised</red> when there is no input from either the <blue>raw_input()</blue> or 
            <blue>input()</blue> function and the end of file is reached.
            <br></br><br></br>
            <code>ImportError</code><br></br>
            <red>Raised</red> when an import statement fails.
            <br></br><br></br>
            <code>KeyboardInterrupt</code><br></br>
            <red>Raised</red> when the user interrupts program execution, usually by pressing 
            <blue>Ctrl+C</blue>.
            <br></br><br></br>
            <code>LookupError</code><br></br>
            <red>Base class</red> for all lookup errors.
            <br></br><br></br>
            <code>IndexError</code><br></br>
            <red>Raised</red> when an <red>index</red> is not found in a <red>sequence</red>.
            <br></br><br></br>
            <code>KeyError</code><br></br>
            <red>Raised</red> when the specified <red>key</red> is not found in the <red>dictionary</red>.
            <br></br><br></br>
            <code>NameError</code><br></br>
            <red>Raised</red> when an identifier is not found in the local or global namespace.
            <br></br><br></br>
            <code>UnboundLocalError</code><br></br>
            <red>Raised</red> when trying to access a local variable in a function or method but 
            no value has been assigned to it.
            <br></br><br></br>
            <code>EnvironmentError</code><br></br>
            Same as above
            <br></br><br></br>
            <code>IOError</code><br></br>
            <red>Raised</red> when an input/output operation fails, such as the <blue>print</blue> 
            statement or the <blue>open()</blue> function when trying to <red>open</red>
            a <red>file</red> that does not exist.
            <br></br><br></br>
            <code>IOError</code><br></br>
            Same as above.
            <br></br><br></br>
            <code>SyntaxError</code><br></br>
            <red>Raised</red> when there is an error in Python syntax.
            <br></br><br></br>
            <code>IndentationError</code><br></br>
            <red>Raised</red> when <red>indentation</red> is not specified properly.
            <br></br><br></br>
            <code>SystemError</code><br></br>
            <red>Raised</red> when the interpreter finds an internal problem, but when 
            this error is encountered the Python interpreter does not exit.
            <br></br><br></br>
            <code>SystemExit</code><br></br>
            <red>Raised</red> when Python interpreter is quit by using the <blue>sys.exit()</blue> 
            function. If not handled in the code, causes the interpreter to exit.
            <br></br><br></br>
            <code>TypeError</code><br></br>
            <red>Raised</red> when an operation or function is attempted that is invalid 
            for the specified data type.
            <br></br><br></br>
            <code>ValueError</code><br></br>
            <red>Raised</red> when the built-in function for a data type has the valid 
            type of arguments, but the arguments have invalid values specified.
            <br></br><br></br>
            <code>RuntimeError</code><br></br>
            <red>Raised</red> when a generated error does not fall into any category.
            <br></br><br></br>
            <code>NotImplementedError</code><br></br>
            <red>Raised</red> when an abstract method that needs to be implemented in an 
            <red>inherited class</red> is not actually implemented.
            <br></br>
        </exception-handling>
        <bitwise-operators>
            *General-Programming-Knowledge*
            <br></br>
            <brown>Python bitwise operators work only on integers.</brown>
            <br></br>
<code>
#Example of using bitwise 
#operators in Python:

a=60
b=13

print ("a:",a, "b:",b, "a&#38;b:",a&#38;b)
print ("a:",a, "b:",b, "a|b:",a|b)
print ("a:", bin(a))
print ("b:", bin(b))

#OUTPUT:
#a: 60 b: 13 a&#38;b: 12
#a: 60 b: 13 a|b: 61
#a: 0b111100
#b: 0b1101
</code>
        </bitwise-operators>
        <default-parameters>
            *General-Programming-Knowledge*
<code>
#Functions in Python:

#A function is a block of organized, reusable code that is used to perform a
#single, related action. Functions provide better modularity for your
#application and a high degree of code reusing.

#IMPORTANT: All parameters (arguments) in the Python language are passed by
#reference. 

def AddingNumbers(a,b):
    return a+b

print("The sum of {0} and {1} is: {2}\n" . format(5,4,AddingNumbers(5,4)))

#ABOVE in the print() function call the AddingNumbers() function is called using
#required arguments

#BELOW the function AddingNumbers() is called using keyword arguments:
print("The sum of {0} and {1} is: {2}" . format(5,4,AddingNumbers(a=5,b=4)))
#Keyword arguments are used to specify for which arguments you are giving a value
#when it comes to default arguments.

#A function can have default arguments:
def PrintFunct (str="Default argument"):
    print(str)
    return

print("This is PrintFunct: {0}" .format(PrintFunct()))

#If you have a function with 2 default arguments, you can use keyword to specify
#for which of them you are setting a value.

def PrintFunct2 (str="Default argument", str2="Default argument2"):
    print("{0} + {1}" .format(str, str2))
    return
print("This is PrintFunct2: ")
PrintFunct2(str="First String")

#The function PrintFunct() above is called using default argument (no value is
#passed).

#Variable-length arguments - > can be implemented using tuples as arguments:
def VarArgFct(arg1, *ArgTuple):
    print("\n")
    print(arg1)
    for item in ArgTuple:
        print("{0}" .format(item))
    return

#Calling function:
VarArgFct(22, 44,33,55)
VarArgFct(22, [44,33,55])


#Anonymous Functions - are called anonymous because they are not declared in
#the standard manner by using the def keyword. You can use the lambda keyword
#to create small anonymous functions.

#Example:
sum = lambda arg1, arg2: arg1 + arg2; #Anonymous functions are small single line functions

#Anonymous functions don't need a 'return' statement, they will return whoever the
#value after the ':' is. (return values similarily as ternary operator)

#Calling the function:
print ("Value of total: {0}" .format(sum(10,20)))

#Variables: local and global.
#Local variables - are those that are declared inside a function.
#Global variables - are those declared outside of any function.

#THIS STATEMENT WILL THE COMMAND PROMPT OPEN UNTIL THE NEXT BUTTON PRESS:
input("\nPress any key to exit: ")

</code>        
        </default-parameters>
        <interfaces>
            *General-Programming-Knowledge*
<code>
#Example of interface in Python:

class PdfParser(TextExtractor):  
      
    #This PdfParser will act as an interface
    def load_data_source(self, path: str, file_name: str) -> str:  
        #pass keyword specified that the  
        #implementation will be added at later stage 
        pass  
  
    def extract_text(self, file_path):  
        #pass keyword specified that the  
        #implementation will be added at later stage
        pass  
  
class EmlParser(TextExtractor):  
     
    #This EmlParser will also act as an interface
    def load_data_source(self, path: str, file_name: str) -> str:  
        #pass keyword specified that the  
        #implementation will be added at later stage
        pass  
    
    def extract_email_text(self, file_path):  
        #pass keyword specified that the  
        #implementation will be added at later stage
        pass  

#the implementation in both interfaces will be added
#at a later stage.
</code>
        </interfaces>
        <random-generators>
            *General-Programming-Knowledge*
<code>
#Example of random generator in Python:

#This program will print a random quotes from 
#the .txt quotation file opened below. 

from random import randint

def ReadFromFile():
    MyFile = open(r"D:\my files\quotations.txt", "r")
    Line=MyFile.read(1000000)
    i=0
    numberOfQuotes=0
    MyList=[]
    buff=""
    while(i&lt;len(Line)):
        if(Line[i]=="\n"):
            MyList.append(buff)
            buff=""
            numberOfQuotes+=1
        else:
            buff+=Line[i]
        i+=1
    #Getting a random number between 0 and numberOfQuotes
    choice = randint(0,numberOfQuotes)
    #Printing the choice:
    print(MyList[choice])

#Calling the function:
while(input("Press C to continue, or Q to quit: ")=="C"):
    print()
    ReadFromFile()
    print()

#Keep the console opened until the next button pressed:
input("Press any key to quit.")

</code>
        </random-generators>
        <command-line-arguments>
            *General-Programming-Knowledge*
<code>
import sys

if __name__ == "__main__": #if script is run from this file do this, otherwise it means file imported by other module and you will ignore this.
    if len(sys.argv) > 1: #there is always gonna be at least one element in this... at index 0 the name of the file is stored.
        print ("The script has the name "  + str(sys.argv[0]))
        print ("The arguments which were passed are: " + str(sys.argv[1:]))
</code>        
        </command-line-arguments>
        <ternary-operator>
            *General-Programming-Knowledge*
            <green>Ternary operator in Python:</green>
            <br></br><br></br>
            Python modifies the syntax for using <red>ternary operator</red> by adding 
            <blue>keywords</blue> instead
            of <blue>operators</blue>. This increases readability:<br></br>
            <code>?</code> operator is replaced by <code>if</code> keyword;<br></br>
            <code>:</code> operator is replaced by <code>else</code> keyword;<br></br>
<code>
#Example of ternary operator in Python:

a = 10
b = 20

#ternary operator
min = "a is minimum" if a &lt; b else "b is minimum"

print(min)
</code>
        </ternary-operator>
        <modular-programming>
            *General-Programming-Knowledge*
<code>
#Example of modular programming in Python:
#FILE: module_with_functions.py

#This is a module (a module can be any .py file).

#These are the functions:
def print_func( par ):
   print ("Hello : {0} " .format(par))
   return

def CalculateSum (*Args):
    sum=0
    for item in Args:
        sum+=item
    return sum
</code>        

<code>
#The next line will set the filepath:
PYTHONPATH=r'C:\Users\Black2\Desktop\python\modular programming in python'
#The next line will import a specific module:
import module_with_functions

#Calling functions from inside the module:
module_with_functions.print_func("Dragos")

print("Sum of {0} and {1} is: {2}" .format(4,10,module_with_functions.CalculateSum(4,10)))

#There is possible to import a single function from the whole module below is the
#synthax:
from module_with_functions import print_func
#The effect is here: the fuction can be called without mentioning the module, whereas
#in the example above it couldn't.
print_func("Black")

#The following synthax will import anything from the mentioned module:
from module_with_functions import *

print("{0}+{1}={2}" .format(3,4,CalculateSum(3,4)))
#Once again there was no need of mentioning the module for CalculateSum()


#Namespace and scoping:
#Variables are names (identifiers) that map to objects. A namespace is a dictionary
#of variable names (keys) and their corresponding objects (values).

#A Python statement can access variables in a local namespace and in the global
#namespace. If a local and a global variable have the same name, the local
#variable shadows the global variable.

#Python makes educated guesses on whether variables are local or global. It
#assumes that any variable assigned a value in a function is local.
#Therefore, in order to assign a value to a global variable within a function,
#you must first use the global statement.

#THIS STATEMENT WILL THE COMMAND PROMPT OPEN UNTIL THE NEXT BUTTON PRESS:
input("\nPress any key to exit: ")

</code>
        </modular-programming>
        <string-methods>
            <green>String methods in Python:</green>
            <br></br><br></br>
            Python has a set of built-in <red>methods</red> that you can use on <blue>strings</blue>.
            <br></br><br></br>
            <red>All string <blue>methods</blue> returns new values. They do not change
            the original string.</red>
            <br></br><br></br>
            <code>capitalize()</code><br></br>
            <red>Converts</red> the first character to upper case.
            <br></br><br></br>
            <code>casefold()</code><br></br>
            <red>Converts</red> string into lower case.
            <br></br><br></br>
            <code>center()</code><br></br>
            <red>Returns</red> a centered string.
            <br></br><br></br>
            <code>count()</code><br></br>
            <red>Returns</red> the number of times a specified value occurs in a string.
            <br></br><br></br>
            <code>encode()</code><br></br>
            <red>Returns</red> an encoded version of the string.
            <br></br><br></br>
            <code>endswith()</code><br></br>
            <red>Returns</red> true if the string ends with the specified value.
            <br></br><br></br>
            <code>expandtabs()</code><br></br>
            <red>Sets</red> the tab size of the string.
            <br></br><br></br>
            <code>find()</code><br></br>
            <red>Searches</red> the string for a specified value and returns the position 
            of where it was found.
            <br></br><br></br>
            <code>format()</code><br></br>
            <red>Formats</red> specified values in a string.
            <br></br><br></br>
            <code>format_map()</code><br></br>
            <red>Formats</red> specified values in a string.
            <br></br><br></br>
            <code>index()</code><br></br>
            <red>Searches</red> the string for a specified value and returns the position 
            of where it was found.
            <br></br><br></br>
            <code>salnum()</code><br></br>
            <red>Returns</red> True if all characters in the string are alphanumeric.
            <br></br><br></br>
            <code>salpha()</code><br></br>
            <red>Returns</red> True if all characters in the string are in the alphabet.
            <br></br><br></br>
            <code>isascii()</code><br></br>
            <red>Returns</red> True if all characters in the string are ascii characters.
            <br></br><br></br>
            <code>isdecimal()</code><br></br>
            <red>Returns</red> True if all characters in the string are decimals.
            <br></br><br></br>
            <code>isdigit()</code><br></br>
            <red>Returns</red> True if all characters in the string are digits.
            <br></br><br></br>
            <code>isidentifier()</code><br></br>
            <red>Returns</red> True if the string is an identifier.
            <br></br><br></br>
            <code>islower()</code><br></br>
            <red>Returns</red> True if all characters in the string are lower case.
            <br></br><br></br>
            <code>isnumeric()</code><br></br>
            <red>Returns</red> True if all characters in the string are numeric.
            <br></br><br></br>
            <code>isprintable()</code><br></br>
            <red>Returns</red> True if all characters in the string are printable.
            <br></br><br></br>
            <code>isspace()</code><br></br>
            <red>Returns</red> True if all characters in the string are whitespaces.
            <br></br><br></br>
            <code>istitle()</code><br></br>
            <red>Returns</red> True if the string follows the rules of a title.
            <br></br><br></br>
            <code>isupper()</code><br></br>
            <red>Returns</red> True if all characters in the string are upper case.
            <br></br><br></br>
            <code>join()</code><br></br>
            <red>Converts</red> the elements of an iterable into a string.
            <br></br><br></br>
            <code>ljust()</code><br></br>
            <red>Returns</red> a left justified version of the string.
            <br></br><br></br>
            <code>lower()</code><br></br>
            <red>Converts</red> a string into lower case.
            <br></br><br></br>
            <code>lstrip()</code><br></br>
            <red>Returns</red> a left trim version of the string.
            <br></br><br></br>
            <code>maketrans()</code><br></br>
            <red>Returns</red> a translation table to be used in translations.
            <br></br><br></br>
            <code>partition()</code><br></br>
            <red>Returns</red> a tuple where the string is parted into three parts.
            <br></br><br></br>
            <code>replace()</code><br></br>
            <red>Returns</red> a string where a specified value is replaced with a specified value.
            <br></br><br></br>
            <code>rfind()</code><br></br>
            <red>Searches</red> the string for a specified value and returns the last position of 
            where it was found.
            <br></br><br></br>
            <code>rindex()</code><br></br>
            <red>Searches</red> the string for a specified value and returns the last 
            position of where it was found.
            <br></br><br></br>
            <code>rjust()</code><br></br>
            <red>Returns</red> a right justified version of the string.
            <br></br><br></br>
            <code>rpartition()</code><br></br>
            <red>Returns</red> a tuple where the string is parted into three parts.
            <br></br><br></br>
            <code>rsplit()</code><br></br>
            <red>Splits</red> the string at the specified separator, and returns a list.
            <br></br><br></br>
            <code>rstrip()</code><br></br>
            <red>Returns</red> a right trim version of the string.
            <br></br><br></br>
            <code>split()</code><br></br>
            <red>Splits</red> the string at the specified separator, and returns a list.
            <br></br><br></br>
            <code>splitlines()</code><br></br>
            <red>Splits</red> the string at line breaks and returns a list.
            <br></br><br></br>
            <code>startswith()</code><br></br>
            <red>Returns</red> true if the string starts with the specified value.
            <br></br><br></br>
            <code>strip()</code><br></br>
            <red>Returns</red> a trimmed version of the string.
            <br></br><br></br>
            <code>swapcase()</code><br></br>
            <red>Swaps</red> cases, lower case becomes upper case and vice versa.
            <br></br><br></br>
            <code>title()</code><br></br>
            <red>Converts</red> the first character of each word to upper case.
            <br></br><br></br>
            <code>translate()</code><br></br>
            <red>Returns</red> a translated string.
            <br></br><br></br>
            <code>upper()</code><br></br>
            <red>Returns</red> a string into upper case.
            <br></br><br></br>
            <code>zfill()</code><br></br>
            <red>Fills</red> the string with a specified number of 0 values at the beginning.
            <br></br>
        </string-methods>
        <datatype-conversions>
            *General-Programming-Knowledge*
<code>
#Converting integers to float:

# initializing string
s = "10010"
 
# printing string converting to int base 2
c = int(s,2)
print ("After converting to integer base 2 : ", end="")
print (c)
 
# printing string converting to float
e = float(s)
print ("After converting to float : ", end="")
print (e)
</code>

<code>
#Type conversion using hex(), ord(), orct():

#initializing integer
s = '4'

#printing character converting to integer
c = ord(s)
print ("After converting character to integer : ",end="")
print (c)

#printing integer converting to hexadecimal string
c = hex(56)
print ("After converting 56 to hexadecimal string : ",end="")
print (c)

#printing integer converting to octal string
c = oct(56)
print ("After converting 56 to octal string : ",end="")
print (c)
</code>

<code>
#Type conversion using tuple(), set(), list():

# initializing string
s = 'geeks'
 
# printing string converting to tuple
c = tuple(s)
print ("After converting string to tuple : ",end="")
print (c)
 
# printing string converting to set
c = set(s)
print ("After converting string to set : ",end="")
print (c)
 
# printing string converting to list
c = list(s)
print ("After converting string to list : ",end="")
print (c)
</code>
        </datatype-conversions>
        <decorators>
            *General-Programming-Knowledge*
<code>
#Example of decorators in Python:

import time

def measure_time(fct):
    if hasattr(fct, 'call_number') == False:
        fct.call_number = 1
        fct.call_time = 0
    
    print("Decorator call.")
    def proxy():
        print("Proxy call.")
        t = time.time()
        fct()
        fct.call_time += time.time() - t
        print("Function " + str(fct.__name__) + " : has executed within : " + str(time.time() - t))
        print("Function calls " + str(fct.call_number))
        print("Average duration: " + str(fct.call_time / fct.call_number))
        fct.call_number += 1
    return proxy


#measure_time it's a decorator. 

@measure_time #this is equivalent to function = measure_time(function)
def function():
    time.sleep(0.5)
    print("the function is executing.")

function()
function()
function()
function()
function()
</code>        
        </decorators>
        <optional-parameters>*General-Programming-Knowledge*</optional-parameters>
        <operators>*General-Programming-Knowledge*</operators>
        <abstract-classes>
            *General-Programming-Knowledge*
<code>
from p19_abs_class import PUNCT as abstract, PUNCT

#p = PUNCT()  #cannot be done, abstract classes cannot be instraciated

class LINE(PUNCT):
    def abstract_method(self): #providing definition for abstract parent method
        print("Abstract method is now redefined")

    #creating static methods:
    @staticmethod #the following method will be static. Static = shared among the instances.
    def staticMe(): #static method don't take self as argument
        print("\nThis is a static method\nAll instances of the class share same method")

l = LINE()

l.abstract_method()
l.staticMe()
#static methods can be invoked only with the class name

LINE.staticMe()

input("\nPress ENTER to exit.")
</code>
        </abstract-classes>
        <pre-post-incrementation>
            In Python, the <code>++</code> increment operator does not exist.
            <br></br>
            In order to increment a variable <code>+=</code> operator is being used.
            <br></br>
<code>
#Example of incrementing in Python:

#Initializing a variable 
x = 5
  
#Incrementing the variable by 1 
#Equivalent to x = x + 1 
x += 1 
  
#Displaying the result 
print("Incremented value:", x) 
</code>
        </pre-post-incrementation>
        <regular-expressions>
<code>
#A regular expression is a special sequence of characters that helps you match or find other strings or sets
#of strings, using a specialized syntax held in a pattern.

#The match() function -> This function attempts to match RE pattern to string with optional flags.
#Syntax: re.match(pattern, string, flags=0)
#pattern    This is the regular expression to be matched.
#string        This is the string, which would be searched to match the pattern at the beginning of string.
#flags        You can specify different flags using bitwise OR (|). These are modifiers, which are listed in the table below.

#The re.match function returns a match object on success, None on failure. We usegroup(num) or groups()
#function of match object to get matched expression.

import re #This library is used for regular expressions (re)

line = "Cats are smarter than dogs"

matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I) #find something at the beginning of the string and return a match object.

if matchObj:
   print ("matchObj.group() : {0}" .format(matchObj.group()))
   print ("matchObj.group(1) : {0}" .format (matchObj.group(1)))
   print ("matchObj.group(2) : {0}" .format(matchObj.group(2)))
else:
   print ("No match!!")

matchObj = re.match( "Cats", line, 0)
if matchObj:
   print ("matchObj.group() : {0}" .format(matchObj.group()))
   #print ("matchObj.group(1) : {0}" .format(matchObj.group(1)))
   #print ("matchObj.group(2) : {0}" .format(matchObj.group(2)))
else:
   print ("No match!!")

#The search() function - This function searches for first occurrence of RE pattern within string with optional flags.
searchObj = re.search( r'dogs*', line, re.M|re.I) #re* -> Matches 0 or more occurrences of preceding expression.
if searchObj:
   print ("searchObj.group() : {0}" .format(searchObj.group()))
   #print ("searchObj.group(1) : {0}" .format (searchObj.group(1)))
   #print ("searchObj.group(2) : {0}" .format(searchObj.group(2)))
else:
   print ("No match!!")

#Match checks for a match only at the beginning of the string, while search checks for a match anywhere in the string.

#The sub() function - replaces all occurrences of the pattern in the string with 'repl'
#Syntax: re.sub(pattern, repl, string, max=0)

phone = "2004-959-559 # This is Phone Number"

# Delete Python-style comments
num = re.sub(r'#.*$', "", phone)
print ("Phone Num : {0}" .format(num))

# Remove anything other than digits
num = re.sub(r'\D', "", phone)    
print ("Phone Num : {0}" .format(num))

#THIS STATEMENT WILL THE COMMAND PROMPT OPEN UNTIL THE NEXT BUTTON PRESS:
input("\nPress any key to exit: ")

#Following table lists the regular expression syntax that is available in Python :

#Pattern    Description
#^    Matches beginning of line.
#$    Matches end of line.
#.    Matches any single character except newline. Using m option allows it to match newline as well.
#[...]    Matches any single character in brackets.
#[^...]    Matches any single character not in brackets
#re*    Matches 0 or more occurrences of preceding expression.
#re+    Matches 1 or more occurrence of preceding expression.
#re?    Matches 0 or 1 occurrence of preceding expression.
#re{ n}    Matches exactly n number of occurrences of preceding expression.
#re{ n,}    Matches n or more occurrences of preceding expression.
#re{ n, m}    Matches at least n and at most m occurrences of preceding expression.
#a| b    Matches either a or b.
#(re)    Groups regular expressions and remembers matched text.
#(?imx)    Temporarily toggles on i, m, or x options within a regular expression. If in parentheses, only that area is affected.
#(?-imx)    Temporarily toggles off i, m, or x options within a regular expression. If in parentheses, only that area is affected.
#(?: re)    Groups regular expressions without remembering matched text.
#(?imx: re)    Temporarily toggles on i, m, or x options within parentheses.
#(?-imx: re)    Temporarily toggles off i, m, or x options within parentheses.
#(?#...)    Comment.
#(?= re)    Specifies position using a pattern. Doesn't have a range.
#(?! re)    Specifies position using pattern negation. Doesn't have a range.
#(?> re)    Matches independent pattern without backtracking.
#\w    Matches word characters.
#\W    Matches nonword characters.
#\s    Matches whitespace. Equivalent to [\t\n\r\f].
#\S    Matches nonwhitespace.
#\d    Matches digits. Equivalent to [0-9].
#\D    Matches nondigits.
#\A    Matches beginning of string.
#\Z    Matches end of string. If a newline exists, it matches just before newline.
#\z    Matches end of string.
#\G    Matches point where last match finished.
#\b    Matches word boundaries when outside brackets. Matches backspace (0x08) when inside brackets.
#\B    Matches nonword boundaries.
#\n, \t, etc.    Matches newlines, carriage returns, tabs, etc.
#\1...\9    Matches nth grouped subexpression.
#\10    Matches nth grouped subexpression if it matched already. Otherwise refers to the octal representation of a character code.

#Option flags:

#Modifier    Description
#re.I    Performs case-insensitive matching.
#re.L    Interprets words according to the current locale. This interpretation affects the alphabetic group (\w and \W), as well as word boundary behavior (\b and \B).
#re.M    Makes $ match the end of a line (not just the end of the string) and makes ^ match the start of any line (not just the start of the string).
#re.S    Makes a period (dot) match any character, including a newline.
#re.U    Interprets letters according to the Unicode character set. This flag affects the behavior of \w, \W, \b, \B.
#re.X    Permits "cuter" regular expression syntax. It ignores whitespace (except inside a set [] or when escaped by a backslash) and treats unescaped # as a comment marker.

#Character classes
#Example    Description
#[Pp]ython    Match "Python" or "python"
#rub[ye]    Match "ruby" or "rube"
#[aeiou]    Match any one lowercase vowel
#[0-9]    Match any digit; same as [0123456789]
#[a-z]    Match any lowercase ASCII letter
#[A-Z]    Match any uppercase ASCII letter
#[a-zA-Z0-9]    Match any of the above
#[^aeiou]    Match anything other than a lowercase vowel
#[^0-9]    Match anything other than a digit

#Special Character Classes
#Example    Description
#.    Match any character except newline
#\d    Match a digit: [0-9]
#\D    Match a nondigit: [^0-9]
#\s    Match a whitespace character: [ \t\r\n\f]
#\S    Match nonwhitespace: [^ \t\r\n\f]
#\w    Match a single word character: [A-Za-z0-9_]
#\W    Match a nonword character: [^A-Za-z0-9_]


#Repetition Cases
#Example    Description
#ruby?    Match "rub" or "ruby": the y is optional
#ruby*    Match "rub" plus 0 or more ys
#ruby+    Match "rub" plus 1 or more ys
#\d{3}    Match exactly 3 digits
#\d{3,}    Match 3 or more digits
#\d{3,5}    Match 3, 4, or 5 digits
</code>        
        </regular-expressions>
        <recursion>
            *General-Programming-Knowledge*
<code>
#Example of recursion in Python:

def try_recursion(k):
    if(k>0):
        result = k+try_recursion(k-1)
        print(result)
    
    else:
        result = 0
    return result

print("\n\nRecursion Example Results")
try_recursion(6)
</code>
        </recursion>
        <reflection>
            *General-Programming-Knowledge*
<code>
#Example of reflection in Python:

def reverse(sequence):  
    sequence_type = type(sequence)  
    empty_sequence = sequence_type()  
      
    if sequence == empty_sequence:  
        return empty_sequence  
      
    rest = reverse(sequence[1:])  
    first_sequence = sequence[0:1]  
      
    #Combine the result  
    final_result = rest + first_sequence 
      
    return final_result  
  
print(reverse([10, 20, 30, 40]))  
print(reverse("Reflection in Python"))  
</code>
        </reflection>
    </programming_language>
    
</content>
