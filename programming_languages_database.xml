<?xml version="1.0" encoding="UTF-8"?>

<content>
    <programming_language>
        <name>General-Programming-Knowledge</name>
        <oop>
            OOP stands for Object-Oriented Programming.
            <br></br><br></br>
            <blue>Procedural programming</blue> is about writing <red>procedures</red> or <red>functions</red> 
            that perform operations on the <red>data</red>, 
            while <blue>object-oriented programming</blue> is about creating objects that contain both 
            <red>data</red> and <red>functions</red>.
            <br></br><br></br>
            <green>
            Object-oriented programming has several advantages over procedural programming:
            </green>
            <br></br><br></br>
            <blue>
            OOP is faster and easier to execute;<br></br>
            OOP provides a clear structure for the programs;<br></br>
            OOP helps to keep the code <red>DRY "Don't Repeat Yourself"</red>, and makes the code 
            easier to maintain, modify and debug;<br></br>
            OOP makes it possible to create full reusable applications with less code and 
            shorter development time;
            </blue>
            <br></br><br></br>
            <red>
            Tip: The "Don't Repeat Yourself" (DRY) principle is about reducing the repetition 
            of code. <br></br>
            You should extract out the codes that are common for the application, 
            and place them at a single place and reuse them instead of repeating it.
            </red>
            <br></br>
        </oop>
        <encapsulation>
            The meaning of <red>Encapsulation</red>, is to make sure that <red>"sensitive"</red> data is hidden from 
            users.<br></br><br></br> 
            To achieve this, you must declare <red>class variables/attributes</red> as <code>private</code> 
            (cannot be accessed from outside the class). <br></br><br></br>
            If you want others to <red>read</red> or <red>modify</red> 
            the value of a <code>private</code> member, you can provide <code>public</code> <red>get</red> and 
            <red>set</red> methods.<br></br>
        </encapsulation>
        <polymorphism>
            Polymorphism means <red>"many forms"</red>, and it occurs when we have many 
            <red>classes</red> that are related to each other by <red>inheritance</red>.<br></br>
        </polymorphism>
        <simple-data-types>
            <code>short int</code> - has value range <red>[-32,768 to 32,767]</red> - format specifier <code>%hd</code> - 
            occupies <code>2 bytes</code> memory;
            <br></br><br></br>
            <code>unsigned short int</code> - has value range <red>[-32,768 to 65,535]</red> - format specifier <code>%hu</code> - 
            occupies <code>2 bytes</code> memory;
            <br></br><br></br>
            <code>unsigned int</code> - has value range <red>[0 to 4,294,967,295]</red> - format specifier <code>%u</code> - 
            occupies <code>4 bytes</code> memory;
            <br></br><br></br>
            <code>int</code> - has value range <red>[-2,147,483,648 to 2,147,483,647]</red> - format specifier <code>%d</code> - 
            occupies <code>4 bytes</code> memory;
            <br></br><br></br>
            <code>long int</code> - has value range <red>[-2,147,483,648 to 2,147,483,647]</red> - 
            format specifier <code>%ld</code> - occupies <code>4 bytes</code> memory;
            <br></br><br></br>
            <code>unsigned long int</code> - has value range <red>[0 to 4,294,967,295 ]</red> - format specifier <code>%lu</code> -
            occupies <code>4 bytes</code> memory;
            <br></br><br></br>
            <code>long long int</code> - has value range <red>[-(2^63) to (2^63)-1]</red> - format specifier <code>%lld</code> - 
            occupies <code>8 bytes</code> memory;
            <br></br><br></br>
            <code>unsigned long long int</code> - has value range <red>[-(2^63) to 18,446,744,073,709,551,615 ]</red> - 
            format specifier <code>%llu</code>  - occupies <code>8 bytes</code> memory;
            <br></br><br></br>
            <code>signed char</code> - has value range <red>[-128 to 127]</red> - format specifier <code>%c</code> - occupies 
            <code>1 byte</code> memory;
            <br></br><br></br>
            <code>unsigned char</code> - has value range <red>[0 to 255]</red> - format specifier <code>%c</code> - occupies 
            <code>1 byte</code> memory;
            <br></br><br></br>
            <code>float</code> - has value range <red>[1.2E-38 to 3.4E+38]</red> - format specifier <code>%f</code> - occupies 
            <code>4 bytes</code> memory;
            <br></br><br></br>
            <code>double</code> - has value range <red>[1.7E-308 to 1.7E+308]</red> - format specifier <code>%lf</code> - 
            occupies <code>8 bytes</code> memory;
            <br></br><br></br>
            <code>long double</code> - has value range <red>[3.4E-4932 to 1.1E+4932]</red> - format specifier <code>%Lf</code>  - 
            occupies <code>16 bytes</code> memory;
        </simple-data-types>
        <complex-data-types>
            In Programming, data type is an attribute associated with a piece of data that tells a 
            computer system how to interpret its value. <br></br>
            <br></br>
            <green>
                Data types that are derived from fundamental data types:
            </green>
            <br></br><br></br>
            <code>bool type</code> - The bool type is a <red>byte-sized</red> type that can only hold the value true or false.<br></br><br></br>
            <code>Enumerated type / Enums</code> - An <code>enum</code> is a special type that represents a group of constants 
            (unchangeable values).
            <br></br><br></br>
            <code>Arrays</code> - A collection of elements of the same data type. <br></br>
            These entities or elements can be of <code>int</code>, <code>float</code>, <code>char</code>, or <code>double</code> 
            data type or can be of <code>user-defined</code> data types such as    like <code>structures</code>.
            <br></br><br></br>
            <red>
            The size of an array can be calculated by multiplying the <code>data-type * numberOfElements</code> within the array.
            </red>
            <br></br><br></br>
            <code>Pointers</code> - A variable that stores the memory address of another variable. 
            <br></br>
            The size of a pointer varies depending on factors such as the operating system and CPU 
            architecture.<br></br><br></br>
            <red>
            Typically, on a <code>32-bit</code> computer system, the size of pointer is <code>4 bytes</code>,    
            while on a <code>64-bit</code> computer system, it is <code>8 bytes</code>.
            </red>
            <br></br><br></br>
            <code>Structures</code>: A collection of variables of different data types grouped 
            together under a single name. 
            <br></br><br></br>
            <red>
            The size of a <code>struct</code> can be calculated by summing up the size of all the element data-types.
            </red>
            <br></br><br></br>
            <code>Unions</code> - A special type of structure that can store only one value at a time. <br></br><br></br>
            <red>
            The size of the <code>union</code> is equal to the size of the largest element defined within the union.
            </red>
            <br></br><br></br>
            <code>Typedefs</code> - A way to create a new name for an existing data type to improve code 
            readability and maintainability.<br></br><br></br>
            <code>void</code> - It's used to indicate an empty data type, usually used with pointers.<br></br>
        </complex-data-types>
        <loops>
            In computer programming, a loop is a sequence of instruction s that is 
            continually repeated until a certain condition is reached. 
            <br></br>
            Typically, a certain process is done, such as getting an item of data 
            and changing it, and then some condition is checked such as whether a 
            counter has reached a prescribed number.
            <br></br><br></br>
            <green>
            For, while, do-while loops:<br></br><br></br>
            </green>
            <red>While loop</red> does not depend upon the number of iterations. 
            <br></br>
            If the test condition will 
            become <red>false</red> then it will break from the while loop else body will be executed.
            <br></br><br></br>
<code>
/*While loop syntax: */
int counter = 0;
while(counter &lt; 5)
{
    /*code goes here*/
     counter++;
}
</code>
            <br></br>
            <red>For loop</red> uses a loop variable to control the loop. 
            <br></br><br></br>
            Firstly    the loop variable is initialized with some value.<br></br>
            Then its test condition is checked. 
            <br></br><br></br>
            If the 
            statement is <red>true</red> then control will move to the body and the body of for 
            loop will be executed. 
            <br></br>
            Steps will be repeated untill the test condition becomes <red>false</red>. 
            <br></br>
            When the test condition will be <red>false</red> the loop will exit.
            <br></br><br></br>
            
            <blue>Initialization Expression</blue>: In this expression, we assign a loop variable 
            or loop counter to some value. <br></br>
            Example: <code>int counter=1;</code>
            <br></br><br></br>
            
            <blue>Test Expression</blue>: In this expression, test conditions are performed.
            <br></br>            
            If the condition evaluates to <red>true</red> then the loop body will be executed and 
            then an update of the loop variable is done. 
            <br></br>
            If the test expression becomes 
            <red>false</red> then the control will exit from the loop. <br></br>
            Example: <code>counter&lt;5;</code>
            <br></br><br></br>
            
            <blue>Update Expression</blue>: After execution of the loop body loop variable is updated 
            by some value. It could be incremented, decremented, multiplied, or divided by 
            any value. <br></br>
            Example: <code>counter++;</code><br></br><br></br>

<code>
/*For loop syntax: */
for(int counter = 0; counter &lt; 5; counter++)
{
    /*code goes here*/
}
</code>
            <br></br>        
            The <red>do-while loop</red> is similar to a while loop but the only difference 
            lies in the do-while loop test condition which is tested at the end of 
            the body. <br></br>
            In the <red>do-while loop</red>, the loop body will execute at least once 
            irrespective of the test condition.<br></br><br></br>
<code>
/*Do while loop syntax: */
do
{
    /*code goes here*/
     counter++;
}
while(counter &lt; 5)
</code>
        </loops>
        <dynamic-memory-allocation>
            Dynamic memory is allocated from the heap using some standard library functions. 
            The two dynamic memory key functions are <code>malloc()</code> and <code>free()</code>. 
            <br></br><br></br>
            The <code>malloc()</code> function takes a single parameter, which is the size of the requested memory 
            area in bytes. <br></br>
            It returns a pointer of type <red>void</red> which 
            can be cast into a pointer of any form. 
            <br></br><br></br>
            <red>
            It doesn’t initialize the memory at execution time.<br></br>
            So each block will initially have a default garbage value. 
            </red>
            <br></br><br></br>
<code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;conio.h&gt;

int main()
{
    int *A;
    int i;
    
    /*
    Prototype: void *malloc(size_t size);
    */

    A=(int *)malloc(20*sizeof(int)); // malloc return a void pointer that needs to be converted
    //into a pointer to however the type of the variable that uses it has. (int *) - is the type of pointer A
    //20 = the number of memory cells allocated;
    
    for (i=0;i&lt;20;i++)
        printf("A[%d]=%d\n", i, A[i]); //the value in each memory cell can be anything
    free(A);
}
</code>
            <red>Calloc</red> function allocates the requested memory and returns a pointer to it similarly to <red>malloc</red>. 
            <br></br><br></br>
            The <code>malloc()</code> and <code>calloc()</code> do differentiate in how the functions are used when allocating 
            memory at runtime. <br></br><br></br>
            The <code>malloc()</code> function only returns the starting address, <red>it doesn't zero it.</red>
            <br></br>            
            On the other hand, the <code>calloc()</code> function returns the starting address, <red>zeroing it.</red>
            <br></br>    
<code>
/*Prototype void *calloc(size_t nitems, size_t size)*/

A=(int *)calloc(20, sizeof(int)); //calloc does the same as malloc while initializing all elements to 0:
    
for (i=0;i&lt;20;i++)
    printf("A[%d]=%d\n", i ,A[i]); //the value in each memory cell is 0
    
free(A); //free is used to free the allocated memory. There is no delete() in C language.
    
</code>
        </dynamic-memory-allocation>
        <serialization>
            Serialization is the process of converting a <red>data object</red> <blue>(a combination of code and data 
            represented within a region of data storage)</blue> into a series of bytes that saves the state 
            of the object in an easily transmittable form.<br></br><br></br>
        </serialization>
        <deserialization>
            Deserialization is the process of <red>reconstructing a data structure or object</red> from a series 
            of bytes or a string in order to instantiate the object for consumption. 
            <br></br><br></br>
            This is the 
            reverse process of serialization, <red>i.e., converting a data structure or object into a 
            series of bytes for storage or transmission across devices</red>.<br></br><br></br>
        </deserialization>
        <enums>
            <red>Enumeration</red> (or <code>enum</code>) is a user defined data type. <br></br>
            It is mainly used to 
            assign names to integral constants, the names make a program easy to read and maintain.
            <br></br><br></br>
        </enums>
        <multi-threading>
            A <red>thread</red> is a single sequence stream within a process. Because threads have some of 
            the properties of processes, they are sometimes called lightweight processes. 
            <br></br><br></br>
            Threads are not independent from each other unlike processes. As a result, 
            threads shares with other threads their code section, data section and OS resources 
            like open files and signals. 
            <br></br>
            But, like processes, a <red>thread</red> has its own program 
            counter (PC), a register set, and a stack space. 
            <br></br><br></br>
            <green>
            Why Multithreading? 
            </green>
            <br></br><br></br>
            Threads are popular way to improve application through parallelism. 
            <br></br>
            For example, in a browser, multiple tabs can be different threads. <br></br>
            MS Word uses 
            multiple threads, one thread to format the text, other thread to process inputs, etc. 
            <br></br><br></br>
            Threads operate faster than processes due to following reasons: <br></br><br></br>
            <blue>
            1) Thread creation is much faster. <br></br>
            2) Context switching between threads is much faster. <br></br>
            3) Threads can be terminated easily <br></br>
            4) Communication between threads is faster.<br></br>
            </blue>
        </multi-threading>
        <bitwise-operators>
            The <code>&#38;</code> (bitwise <red>AND</red>) in C takes two numbers as operands and does <red>AND</red> on every bit 
            of two numbers. <br></br>
            The result of <red>AND</red> is 1 only if both bits are 1.  
            <br></br><br></br>
            The <code>|</code> (bitwise <red>OR</red>) in C takes two numbers as operands and does <red>OR</red> on every bit 
            of two numbers. <br></br>
            The result of <red>OR</red> is 1 if any of the two bits is 1. 
            <br></br><br></br>
            The <code>^</code> (bitwise <red>XOR</red>) takes two numbers as operands and does <red>XOR</red> on every 
            bit of two numbers.<br></br> 
            The result of <red>XOR</red> is 1 if the two bits are different. 
            <br></br><br></br>
            The <code>&lt;&lt;</code> (<red>left-shift</red>) takes two numbers, <red>left-shifts</red> the bits of the 
            first operand, and the second operand decides the number of places to shift. 
            <br></br><br></br>
            The <code>&gt;&gt;</code> (<red>right-shift</red>) takes two numbers, <red>right-shifts</red> the bits of the 
            first operand, and the second operand decides the number of places to shift.
            <br></br><br></br>
            The <code>~</code> (bitwise <red>NOT</red>) takes one number and inverts all bits of it.
            <br></br><br></br>
            <blue>
            The <red>left-shift</red> and <red>right-shift</red> operators should not be used for negative numbers.<br></br>
            The <red>left-shift</red> and <red>right-shift</red> operators are equivalent to multiplication and division by 
            2 respectively.<br></br><br></br>
            </blue>
            
            The bitwise <red>OR</red> of two numbers is just the sum of those two numbers if there is no carry 
            involved, otherwise, you just add their bitwise <red>AND</red>.
            <br></br><br></br>
            <blue>
            Let’s say, we have <code>a=5(101)</code> and <code>b=2(010)</code>, since there is no carry involved, 
            their sum is just <code>a|b</code>. <br></br>
            Now, if we change <red>'a'</red> to <red>6</red> which is <red>110</red> in binary, their sum would change 
            to <code>a|b + a&#38;b</code> since there is a carry involved.
            <br></br><br></br>
            The bitwise <red>XOR</red> operator is the most useful operator from a technical interview perspective.
            <br></br><br></br>
            It is used in many problems. <br></br>
            <br></br>
            </blue>
            The <code>&#38;</code> operator can be used to quickly check if a number is odd or even.<br></br>

            The value of the expression <code>(x &#38; 1)</code> would be non-zero only if x is odd, otherwise, 
            the value would be zero. <br></br><br></br>
            
            The <code>~</code> operator should be used carefully.
            <br></br><br></br>
            The result of the <code>~</code> operator on a small number can be a big number if the result 
            is stored in an unsigned variable. <br></br><br></br>
            <red>
            The result may be a negative number if the result 
            is stored in a signed variable (assuming that the negative numbers are stored into a
            complement form where the leftmost bit is the sign bit).<br></br>
            </red>
        </bitwise-operators>
        <macros>
            <red>Macros</red> are powerful tools that allow developers to define reusable code snippets. 
            <br></br><br></br>
            They are defined using preprocessor directives and primarily used for code substitution 
            and generation. 
            <br></br><br></br>
            <red>Macros</red> provide a convenient way to write concise and efficient code, 
            improving the readability and maintainability of programs.
            <br></br><br></br>
<code>
// Program to illustrate macros

#include &lt;stdio.h&gt;
 
// Macro definition
#define AREA(l, b) (l * b)
 
int main()
{
    // Given lengths l1 and l2
    int l1 = 10, l2 = 5, area;
 
    // Find the area using macros
    area = AREA(l1, l2);
 
    // Print the area
    printf("Area of rectangle"
           " is: %d",
           area);
 
    return 0;
}
</code>        
            <br></br>
            <green>
            Object-Like Macros:
            </green>
            <br></br><br></br>
            An <red>object-like macro</red> is a simple identifier that will be replaced by a code fragment. 
            <br></br>
            It is called <red>object-like</red> because it looks like an object in code that uses it. 
            <br></br>
            It is popularly used to replace a symbolic name with a numerical/variable represented 
            as a constant.
            <br></br><br></br>
<code>
//Chain Macros
  
// Macro definition
#define INSTAGRAM FOLLOWERS
#define FOLLOWERS 138 

/*
Both macros INSTAGRAM and FOLLOWERS have same value - 138
*/


Multi-line macros
#include &lt;stdio.h&gt;
 
// Multi-line Macro definition
#define ELE 1, \
            2, \
            3
 
int main()
{
 
    // Array arr[] with elements
    // defined in macros
    int arr[] = { ELE };
 
    // Print elements
    printf("Elements of Array are:\n");
 
    for (int i = 0; i &lt; 3; i++) {
        printf("%d  ", arr[i]);
    }
    return 0;
}
  
</code>
        </macros>
        <defines>
            In programming, <code>#define</code> is a preprocessor directive that is used to define <red>macros</red>. 
            The macros are the identifiers which are replaced by their value before 
            compilation. <br></br><br></br>
            We can define constants and <red>functions like macros</red> using <code>#define</code>.
        </defines>
        <command-line-arguments>
            Command line <red>arguments</red> are passed to the main function 
            as <code>argc</code> and <code>argv</code>. 
            <br></br>
            Command line <red>arguments</red> are used to control the program from 
            the outside. <code>argv[argc]</code> is a <red>NULL</red> pointer. 
            <br></br><br></br>
            The name of the program is 
            stored in <code>argv[0]</code>, the first command-line <red>parameter</red> in <code>argv[1]</code>, 
            and the    last argument in <code>argv[n]</code>.
            <br></br><br></br>
            <code>argv</code> <red>(ARGument Vector)</red> is an integer variable that stores the number of 
            command-line 
            <red>arguments</red> passed by the user including the name of the program. 
            <br></br>
            So if we pass a 
            value to a program, the value of <code>argc</code> would be <blue>2</blue> (one for <red>argument</red> and one for 
            <red>program name</red>). 
            <br></br><br></br>
            <blue>The value of argc should be non-negative.</blue>
            
            <br></br><br></br>
            <code>argv</code> <red>(ARGument Vector)</red> is an array of character pointers listing all the <red>arguments</red>.
            <br></br>
            If <code>argc</code> is greater than zero, the array elements from <code>argv[0]</code> 
            to <code>argv[argc-1]</code> will 
            contain pointers to strings.<br></br>
            <code>argv[0]</code> is the name of the program. 
            <br></br><br></br>
            After that until <code>argv[argc-1]</code> every element 
            is command -line arguments.<br></br><br></br>
            
            <green>Properties of Command Line Arguments in C:<br></br><br></br></green>
            <blue>
            They are passed to the <code>main()</code> function.<br></br>
            They are parameters/arguments supplied to the program when it is invoked.<br></br>
            They are used to control programs from outside instead of hard coding those values 
            inside the code.<br></br><br></br>
            <code>argv[argc]</code> is a <red>NULL</red> pointer.<br></br>
            <code>argv[0]</code> holds the name of the program.<br></br>
            <code>argv[1]</code> points to the first command line argument and <code>argv[argc-1]</code> points to 
            the last argument.<br></br>
            </blue>
            <br></br>
        </command-line-arguments>
        <ternary-operator>
            <red>Ternary operator</red> is used for decision making instead of placing longer <red>if and else</red>
            conditional statements.
            <br></br><br></br>
            Syntax:
            <code>condition ? value_if_true : value_if_false</code>
            <br></br>
            The statement evaluates to <code>value_if_true</code> if condition is met, and <code>value_if_false</code> 
            otherwise.<br></br><br></br>
            
            <green>The ternary operator take three arguments:</green>
            <br></br><br></br>
            <blue>
            The first is a comparison argument;<br></br>
            The second is the result upon a true comparison;<br></br>
            The third is the result upon a false comparison;<br></br><br></br>
            </blue>
        </ternary-operator>
        <modular-programming>
            Modular programming consists of separating implementation from interface and 
            hiding information in the implementation.
            <br></br><br></br>
            <green>Advantages of modular programming:</green>
            <br></br><br></br>
            
            <blue>Code is easier to read</blue> - Working on modular programming makes code easier to read 
            because functions perform different tasks as compared to monolithic codes. 
            Sometimes modular programming can be a bit messy if we pass arguments and 
            variables in different functions. The use of modules should be done in a 
            sensible manner so as to avoid any problem. Functions should be neat, clean, 
            and descriptive.<br></br><br></br>
            
            <blue>Code is easier to test</blue> - In software, some functions perform fewer tasks and 
            also functions that perform numerous tasks. If the software is easily split 
            using modules, it becomes easier to test. We can also focus on the riskier 
            functions during testing and need more test cases to make it bug-free.<br></br><br></br>
            
            <blue>Reusability</blue> - There are times where a piece of code is implemented everywhere in 
            our program. Instead of copying and pasting it, again and again, modularity 
            gives us the advantage of reusability so that we can pull our code from 
            anywhere using interfaces or libraries. The concept of reusability also 
            reduces the size of our program.<br></br><br></br>
            
            <blue>Faster fixes</blue> - Suppose there is an error in the payment options in any 
            application, and the bug needs to be removed. Modularity can be a great help 
            because we know that there will be a separate function that will contain the 
            code of payments, and only that function will only be rectified. Thus using 
            modules to find and fixing bugs becomes much more smooth and maintainable.<br></br><br></br>
            
            <blue>Low-risk update</blue> - In modular programming, a defined layer of APIs protects things that 
            use it from making changes inside the library. Unless there is a change in the API, 
            there is a low risk for someone's code-breaking. For example, if you didn't have 
            explicit APIs and someone changed a function they thought was only used within that 
            same library (but it was used elsewhere), they could accidentally break something.<br></br><br></br>
            
            
            <blue>Easy collaboration</blue> - Different developers work on a single piece of code in the team. 
            There are chances of conflicts when there's a git merge. This conflict can be reduced 
            if the code is split between more functions, files, repos, etc. We can also provide 
            ownership to specific code modules, where a team member can break them down into 
            smaller tasks.<br></br><br></br>
            
            <green>Disadvantages of modular programming:</green>
            <br></br><br></br>
            <blue>Requires more resources</blue> - There is a need for extra time and 
            budget for a product in modular programming.
            <br></br><br></br>
            
            <blue>Increases the risk and the difficulty</blue> - It is a challenging task to combine all the modules.
            <br></br><br></br>
            
            <blue>Additional efforts needed for documentation</blue> - Careful documentation is required so that other program modules are not affected.
            <br></br><br></br>
            
            <blue>The task repetition impacts the software performance</blue> - Some modules may partly repeat the task 
            performed by other modules. Hence, Modular programs need more memory space and extra time for execution.
            <br></br><br></br>
            
            <blue>The work efficiency might be impacted</blue> - It reduces the program's efficiency because testing and debugging are 
            time-consuming, where each function contains a thousand lines of code.
            <br></br><br></br>
            
            <blue>The code readability might be affected</blue> - Integrating various modules into a single program may not be an easy task because 
            different people working on the design of different modules may not have the 
            same style.
            <br></br><br></br>
            
        </modular-programming>
        <datatype-conversions>
            <green>Generally there are two types of conversion:</green>
            <br></br><br></br>
            <blue>
            - implicit conversion (done automatically by the compiler)<br></br>
            - explicit conversion (done manually by the developer)<br></br>
            </blue>
            <br></br>
            <red>Implicit conversion</red> is done automatically by the compiler when you assign a value 
            of one type to another.<br></br><br></br>
            <red>Explicit conversion</red> is done manually by placing the type in parentheses <red>()</red> in front 
            of the value. Also knows as <red>typecasting</red>. 
            <br></br>
        </datatype-conversions>
        <operators>
            An operator is a symbol that tells the compiler to perform specific mathematical or 
            logical functions. 
            <br></br><br></br>
            By definition, an operator performs a certain operation on 
            operands. 
            <br></br>
            An operator needs one or more operands for the operation to be performed.<br></br>
            <br></br>
            Depending on how many operands are required to perform the operation, operands are called as 
            <red>unary</red>, <red>binary</red> or <red>ternary</red> operators. <br></br>
            They need one, two or three operands respectively.<br></br>
            <br></br>
            <red>Unary operators</red> − <code>++</code> (increment), <code>--</code> (decrement), <code>!</code> (NOT), <code>~</code> (compliment), <code>&#38;</code> (address of), <code>*</code> (dereference)
            <br></br><br></br>
            <red>Binary operators</red> − arithmetic, logical and relational operators except !
            <br></br><br></br>
            <red>Ternary operators</red> − The <code>?</code> operator.
            <br></br><br></br>
            <green>Most programming languages are rich in built-in operators and provides the following types of operators:</green>
            <br></br><br></br>
            <brown>Assume variable <code>A = 10</code> and variable <code>B = 20 </code> then: 
            <br></br><br></br></brown>
            <br></br>
            <green>Arithmetic Operators: <br></br></green>
                <br></br>
                + <red>it adds two operands.</red><br></br>
                <code>A + B = 30</code><br></br>
                <br></br>
                
                − <red>it subtracts second operand from the first.</red><br></br>
                <code>A − B = -10</code><br></br>
                <br></br>
                
                * <red>it multiplies both operands.</red><br></br>
                <code>A * B = 200</code><br></br>
                <br></br>
                
                / <red>it divides numerator by de-numerator.</red><br></br>
                <code>B / A = 2</code><br></br>
                <br></br>
                
                % <red>is the Modulus Operator.</red><br></br>
                <blue>It gives the remainder after an integer division.</blue><br></br>
                <code>B % A = 0</code><br></br>
                <br></br><br></br>
                
                ++ <red>is the Increment operator. </red><br></br>
                <blue>It increases the integer value by one.</blue><br></br>
                <code>A++ = 11</code><br></br>
                <br></br>
                -- <red>is the Decrement operator.</red><br></br>
                <blue>It decreases the integer value by one.</blue><br></br>
                <code>A-- = 9</code><br></br>
                <br></br>
                <green><br></br>Relational Operators:<br></br></green>
                <br></br>
                
                == <red>it checks if the values of two operands are equal or not. </red><br></br>
                <blue>If yes, then the condition becomes true.</blue><br></br>
                <code>(A == B) is not true.</code><br></br>
                <br></br>

                != <red>it checks if the values of two operands are equal or not.</red><br></br>
                <blue>If the values are not equal, then the condition becomes true.</blue><br></br>
                <code>(A != B) is true.</code><br></br>
                <br></br>

                &gt; <red>it checks if the value of left operand is greater than the value of 
                right operand.</red><br></br>
                <blue>If yes, then the condition becomes true.</blue><br></br>
                <code>(A &gt; B) is not true.</code><br></br>
                <br></br>

                &lt; <red>it checks if the value of left operand is less than the value of 
                right operand.</red><br></br>
                <blue>If yes, then the condition becomes true.</blue><br></br>
                <code>(A &lt; B) is true.</code><br></br>
                <br></br>

                &gt;= <red>it checks if the value of left operand is greater than or equal to 
                the value of right operand.</red><br></br>
                <blue>If yes, then the condition becomes true.</blue><br></br>
                <code>(A &gt;= B) is not true.</code><br></br>
                <br></br>

                &lt;= <red>it checks if the value of left operand is less than or equal to the value 
                of right operand.</red><br></br>
                <blue>If yes, then the condition becomes true.</blue><br></br>
                <code>(A &lt;= B) is true.</code><br></br>
                <br></br>
                
                <green><br></br>Logical Operators:<br></br></green>
                <br></br>
    
                &#38;&#38; <red>it's called Logical AND operator.</red><br></br> 
                <blue>Results in TRUE if both the operands are non-zero, 
                then the condition becomes true.</blue><br></br>
                <code>(A &#38;&#38; B) is false.</code><br></br>
                <br></br>

                || <red>it's called Logical OR Operator.</red><br></br>  
                <blue>Results in TRUE if any of the two operands is non-zero, 
                then the condition becomes true.</blue><br></br>
                <code>(A || B) is true.</code><br></br>
                <br></br>

                ! <red>it's called Logical NOT Operator. </red><br></br>
                <blue>It is used to reverse the logical state of 
                its operand. 
                If a condition is true, then Logical NOT operator will make it false.</blue>
                <br></br>
                <code>!(A &#38;&#38; B) is true.</code><br></br>
                <br></br>
                
                <green><br></br>Bitwise Operators:<br></br></green>
                <br></br>
                &#38; <red>binary AND Operator copies a bit to the result if it exists in both operands.</red><br></br>    
                <code>(A &#38; B) = 12, i.e., 0000 1100</code><br></br>
                <br></br>

                | <red>binary OR Operator.</red><br></br>
                <blue>It copies a bit if it exists in either operand.</blue><br></br>
                <code>(A | B) = 61, i.e., 0011 1101</code><br></br>
                <br></br>
                ^ <red>binary XOR Operator.</red><br></br>
                <blue>It copies the bit if it is set in one operand but not both.</blue><br></br>
                <code>(A ^ B) = 49, i.e., 0011 0001</code><br></br>
                <br></br>
                ~ <red>binary One's Complement Operator.</red><br></br>
                <blue>Is unary and has the effect of 'flipping' bits.</blue><br></br>
                <code>(~A ) = ~(60), i.e,. -0111101</code><br></br>
                <br></br>
                &lt;&lt; <red>binary Left Shift Operator.</red><br></br>
                <blue>The left operands value is moved left by the number of bits specified by the 
                right operand.</blue><br></br>
                <code>A &lt;&lt; 2 = 240 i.e., 1111 0000</code><br></br>
                <br></br>
                &gt;&gt; <red>binary Right Shift Operator. </red><br></br>
                <blue>The left operands value is moved right by the number of bits specified 
                by the right operand.</blue><br></br>
                <code>A &gt;&gt; 2 = 15 i.e., 0000 1111</code><br></br>
                <br></br>
                
                <green><br></br>Assignment Operators:<br></br></green>
                <br></br>
                = <red>is the assignment operator. </red><br></br>
                <blue>Assigns values from right side operands to left side operand.</blue><br></br>
                <code>C = A + B will assign the value of A + B to C</code><br></br>
                <br></br>
                += <red>the add AND assign operator. </red><br></br>
                <blue>It adds the right operand to the left operand and assign the result 
                to the left operand.</blue><br></br>
                <code>C += A is equivalent to C = C + A</code><br></br>
                <br></br>
                -= <red>Subtract AND assignment operator. </red><br></br>
                <blue>It subtracts the right operand from the left operand and assigns 
                the result to the left operand.</blue><br></br>
                <code>C -= A is equivalent to C = C - A</code><br></br>
                <br></br>
                *= <red>Multiply AND assignment operator. </red><br></br>
                <blue>It multiplies the right operand with the left operand and assigns 
                the result to the left operand.</blue><br></br>    
                <code>C *= A is equivalent to C = C * A</code><br></br>
                <br></br>
                /= <red>the divide AND assign operator. </red><br></br>
                <blue>It divides the left operand with the right operand and assigns the 
                result to the left operand.</blue><br></br>
                <code>C /= A is equivalent to C = C / A</code><br></br>
                <br></br>
                %= <red>the modulus AND assign operator. </red><br></br>
                <blue>It takes modulus using two operands and assigns the 
                result to the left operand.</blue><br></br>
                <code>C %= A is equivalent to C = C % A</code><br></br>
                <br></br>
                &lt;&lt;= <red>the Left shift AND assign operator.</red><br></br>
                <blue>It takes the value stored in variable C shifts it to the left by 
                the number of bits specified 
                after the equal sign and then assigns the result of the operation back to C variable</blue><br></br>
                <code>C &lt;&lt;= 2 is same as C = C &lt;&lt; 2</code><br></br>
                <br></br>
                &gt;&gt;= <red>the Right shift AND assign operator.</red><br></br>
                <blue>It takes the value stored in variable C shifts it to the right by the 
                number of bits specified after the equal sign and then assigns the result of the 
                operation back to C variable.</blue><br></br>
                <code>C &gt;&gt;= 2 is same as C = C &gt;&gt; 2</code><br></br>
                <br></br>
                &#38;= <red>the bitwise AND assign operator.</red><br></br>
                <blue>It takes the value stored in variable C performs bitwise AND with 
                the value specified after the equal sign and then assigns the result of 
                the operation back to C variable.</blue><br></br>
                <code>C &#38;= 2 is same as C = C &#38; 2</code><br></br>
                <br></br>
                ^= <red>the bitwise exclusive OR and assign operator.</red><br></br>
                <blue>It takes the value stored in variable C performs bitwise XOR with the value 
                specified after the equal sign and then assigns the result of the 
                operation back to C variable.</blue><br></br>
                <code>C ^= 2 is same as C = C ^ 2</code><br></br>
                <br></br>
                |= <red>the bitwise inclusive OR and assign operator.</red><br></br>
                <blue>It takes the value stored in variable C performs bitwise OR with the 
                value specified after the equal sign and then assign the result of the 
                operation back to C variable.</blue><br></br>
                <code>C |= 2 is same as C = C | 2</code><br></br>
                <br></br>
        </operators>
        <pre-post-incrementation>
            <red>Increment operators</red> are used to increase the value of a variable by <blue>1</blue>.<br></br>
            This operator is represented by the <red>++</red> symbol. <br></br><br></br>
            The increment operator can either
            increase the value of the variable by <blue>1</blue> before assigning it to the variable or 
            can increase the value of the variable by <blue>1</blue> after assigning the variable. 
            <br></br><br></br>
            <green>Thus it can be classified into two types:</green>
            <br></br><br></br>
            <blue>
            Pre-Increment Operator<br></br>
            Post-Increment Operator<br></br>
            </blue>
        </pre-post-incrementation>
        <constructors>
            A constructor in C++ is a special method that is automatically called when an object 
            of a class is created.
            <br></br><br></br>
            Constructors can also take parameters (just like regular functions), which can be 
            useful for setting initial values for attributes.<br></br>
        </constructors>
        <instantiation>
            In object-oriented programming, an instance is a concrete realization of a class. <br></br>
            When you define a class, you're essentially creating a blueprint. <br></br>
            An instance, then, is an object built from that blueprint. <br></br>
            It has all the characteristics defined in the class, but with specific values.<br></br>
        </instantiation>
        <destructors>
            Destructor is an instance member function that is invoked automatically whenever an object is 
            going to be destroyed. 
            Meaning, a destructor is the last function that is going to be called before an object is destroyed.
            <br></br><br></br>
            - A destructor is also a special member function like a constructor.
            Destructor destroys the class objects created by the constructor. <br></br>
            - Destructor has the same name as their class name preceded by a tilde (~) symbol.<br></br>
            - It is not possible to define more than one destructor. <br></br>
            - The destructor is only one way to destroy the object created by the constructor. 
            Hence destructor can-not be overloaded.<br></br>
            - Destructor neither requires any argument nor returns any value.<br></br>
            - It is automatically called when an object goes out of scope. <br></br>
            - Destructor release memory space occupied by the objects created by the constructor.<br></br>
            - In destructor, objects are destroyed in the reverse of an object creation.<br></br>
        </destructors>
        <function-overloading>
            Function overloading is a feature of object-oriented programming where two or more 
            functions can have the same name but different parameters. <br></br>
            Function overloading can be considered as an example of a polymorphism feature.<br></br>
            <br></br><br></br>
            If multiple functions having same name but parameters of the functions should be different is 
            known as Function Overloading.<br></br>
            If we have to perform only one operation and having same name of the functions increases 
            the readability of the program.<br></br><br></br>
            Overloaded functions can be defined both outside and inside classes.<br></br>
        </function-overloading>
        <operator-overloading>
            Operator overloading is a compile-time polymorphism. <br></br>
            It is an idea of giving special meaning to an existing operator 
            without changing its original meaning. <br></br>
        </operator-overloading>
        <namespaces>
            A namespace is a feature which can be defined as a
            declarative region that provides a scope to the identifiers (names of functions, 
            variables or other user-defined data types) inside it. <br></br>
        </namespaces>
        <exception-handling>
            In computer programming exceptions are <red>runtime anomalies</red> or <red>abnormal conditions</red> that a program 
            encounters during its execution. The process of handling these exceptions is 
            called <red>exception handling</red>. <br></br>
            <br></br>
            Using the <red>exception handling</red> mechanism, the control 
            from one part of the program where the <red>exception</red> occurred can be transferred 
            to another part of the code.
            <br></br><br></br>
            By using <red>exception handling</red> we can handle the anomalies so that our 
            program keeps running.<br></br>
        </exception-handling>
        <default-parameters>
            A <red>default parameter/argument</red> is a value provided in a function declaration that is 
            automatically assigned by the compiler if the calling function doesn’t provide 
            a value for the argument. <br></br>
            <br></br>
            In case any value is passed, the default value is 
            overridden. <br></br>
        </default-parameters>
        <interfaces>
            In programming: an <red>interface</red> describes the behavior or capabilities of a <red>class</red> without 
            committing to a particular implementation of that <red>class</red>.
            <br></br><br></br>
            The <red>interfaces</red> are implemented using <red>abstract classes</red> and these abstract classes 
            should not be confused with <red>data abstraction</red> which is a concept of keeping 
            implementation details separate from associated data.<br></br>
        </interfaces>
        <abstract-classes>
            The purpose of an <red>abstract class</red> (often referred to as an <red>ABC</red>) is to provide an 
            appropriate <red>base class</red> from which other classes can inherit. <br></br>
            <red>Abstract classes</red> cannot be used to instantiate objects and serves only as an 
            interface. <br></br>
            Attempting to instantiate an object of an <red>abstract class</red> causes a 
            compilation error. <br></br>
            <br></br>
            Thus, if a subclass of an <red>ABC</red> needs to be instantiated, it has to implement each of 
            the <red>virtual functions</red>, which means that it supports the interface declared by the 
            <red>ABC</red>. Failure to override a pure <red>virtual function</red> in a <red>derived class</red>, 
            then attempting to instantiate objects of that class, is a compilation error.
            <br></br><br></br>
            An object-oriented system might use an <red>abstract base class</red> to provide a common and 
            standardized interface appropriate for all the external applications. <br></br>
            Then, through inheritance from that <red>abstract base class</red>, derived classes are 
            formed that operate similarly.
            <br></br><br></br>
            The capabilities (i.e., the <red>public functions</red>) offered by the external applications 
            are provided as pure <red>virtual functions</red> in the <red>abstract base class</red>. <br></br>
            The implementations of these pure <red>virtual functions</red> are provided in the <red>derived 
            classes</red> that correspond to the specific types of the application.<br></br>
        </abstract-classes>
        <optional-parameters>
            A parameter with a default value, is often known as an <blue>"optional parameter"</blue>.
            <br></br><br></br> 
            For more information see the <blue>default-parameters</blue> section.
        </optional-parameters>
        <decorators>
            <red>Decorator</red> is a structural pattern that allows adding new behaviors to objects 
            dynamically by placing them inside special wrapper objects, called decorators. 
            <br></br>
            Using decorators you can wrap objects countless number of times since both target 
            objects and decorators follow the same interface.<br></br>
        </decorators>
        <generic-programming>
            Generic programming is a style of computer programming in which algorithms are 
            written in terms of <red>data types to-be-specified-later</red> that are then instantiated 
            when needed for specific types provided as parameters.<br></br>
        </generic-programming>
    </programming_language>
    
    <programming_language>
        <name>C</name>
        <description>
            C is a general-purpose computer programming language.<br></br><br></br>
            It was created in the 1970s by Dennis Ritchie, and remains very widely used and 
            influential. <br></br><br></br>
            By design, C's features cleanly reflect the 
            capabilities of the targeted CPUs. It has found lasting use in operating 
            systems, device drivers, and protocol stacks, but its use in application 
            software has been decreasing. <br></br><br></br>
            C is commonly used on computer architectures that range from the largest 
            supercomputers to the smallest microcontrollers 
            and embedded systems.
        </description>
        <generic-programming>
            *General-Programming-Knowledge*
            <br></br>
            <green>
            In C Language generic programming can be achieved using:
            </green>
            <br></br><br></br>
            <blue>
            Variable argument lists;<br></br>
            Using <code>void *</code> and function pointers to write generic code;<br></br>
            Using libraries to reuse code without copying and recompiling;<br></br>
            Using plugins to get run-time overriding and more;
            </blue>
        </generic-programming>
        <variable-arguments-lists>
            C allows a function call to have a variable number of
            arguments with the variable argument list mechanism.<br></br>
            Use ellipsis <code>...</code> to denote a variable number of arguments to
            the compiler. 
            <br></br>
            The ellipsis can only occur at the end of an
            argument list.<br></br><br></br>
            <green>
            Here are some standard function calls that use variable
            argument lists:
            </green>
            <br></br><br></br>
            <code>int printf(const char *format, ...);</code><br></br>
            <code>int scanf(const char *format, ...);</code><br></br>
            <code>int execlp(const char *file, const char *arg, ...);</code><br></br>
        </variable-arguments-lists>
        <simple-data-types>*General-Programming-Knowledge*</simple-data-types>
        <complex-data-types>*General-Programming-Knowledge*
            <br></br><br></br>
            <green>
            The C programming language, as of C99, supports complex number math with the three 
            built-in complex types:
            </green>
            <br></br><br></br>
            <code>double _Complex</code><br></br>
            <code>float _Complex</code><br></br>
            <code>long double _Complex</code><br></br>
            <br></br>
            When the header <code>complex.h</code> is 
            included, the three complex number types are also accessible as <code>double complex</code>, 
            <code>float complex</code>, <code>long double complex</code>.<br></br><br></br>
        </complex-data-types>
        <loops>*General-Programming-Knowledge*</loops>
        <collections>
            <code>Arrays</code> are collections of elements of the same data type with fixed size. 
            <br></br>
            Once the <red>array</red> is defined, its size cannot be changed.
            <br></br><br></br>

<code>
/*Declaring arrays and initializing arrays*/

int arr[5];
int array_initialized[7] = [1,2,3,4,5,6,7];
float array_floats[3] = [2.0f, 3.0f, 2.11f];
</code>
            <br></br>
            The <code>linked list</code> is a complex data type, which consists of a structure with at least 2 elements: value and pointer
            to the next element. <br></br>
            The memory can be allocated dynamically for each element added to the list. 
            <br></br><br></br>
            <brown>
            The main benefit of a linked-list
            consists in the possibility of adding a variable number of elements, being able to delete or add an element 
            without making copies
            or exchanges, but only by changing the addresses of the assigned pointers for the next / previous element.
            </brown>
            <br></br><br></br>
            
<code>
//Declaring and initializing a Linked List

//Linked list definition:
struct LinkedList{
    int value; // this will store the value
    struct LinkedList * previous; // this will store the address of the previous block of memory
    struct LinkedList * next; // this will store the address of the next block of memory
};

struct LinkedList* list = NULL; // creating a linked list

int counter = 0;
while(counter &lt; 10)
{
    if(list == NULL) // if this is the first element to be introduced on the linked list
    {
        list = (struct LinkedList* )malloc(sizeof(struct LinkedList)); // allocate memory.
        list->value = counter; // add value
        list->previous = NULL; // there is no previous element.
        list->next = NULL; // we don't know if there will be a next element.
    }

    else //enter here after the first element was added.
    {

        list->next = (struct LinkedList* ) malloc(sizeof(struct LinkedList)); // allocate space for the next element
        list->next->previous = list; // we're still on the previous element, so assign the link to the next element.previous
        list = list->next; // next element become current element
        list->value = counter; // add value
        list->next = NULL;  // we don't know if there will be a next element.
    }
    counter++;
}

//printing the linked list
while(list != NULL) // list is currently pointing to the last element. So we will display it from last to first.
{
    printf("%d ", list->value);
    list = list->previous; // go to the previous
}
</code>
        </collections>
        <collection-methods>There are no built in functions for working with collections.</collection-methods>
        <dynamic-memory-allocation>*General-Programming-Knowledge*</dynamic-memory-allocation>
        <read-from-file>
            C programming language supports <red>four</red> pre-defined functions to read contents from a file, defined in <code>stdio.h</code> header file:
            <br></br><br></br>
            <blue>fgetc()</blue><br></br>
            This function is used to read a single character from the file.<br></br><br></br>
            <blue>fgets()</blue><br></br>
            This function is used to read strings from files.
            <br></br><br></br>
            <blue>fscanf()</blue><br></br>
            This function is used to read formatted input from a file.<br></br><br></br>
            <blue>fread()</blue><br></br>
            This function is used to read the block of raw bytes from files. This is used 
            to read binary files.
            <br></br><br></br>
            <green>
            Opening a file:
            </green>
            <br></br><br></br>
            To open a file use: <code>fopen(filename, mode)</code>;
            <br></br><br></br>
            Where:<br></br><br></br>
            <code>filename</code><br></br>    
            The name of the actual file you want to open (or create), like <red>filename.txt</red>.
            <br></br><br></br>
            <code>mode</code><br></br>    
            A single character, which represents what you want to do with the file 
            (<red>read</red>, <red>write</red> or <red>append</red>):<br></br><br></br>
            <blue>w</blue> - Writes to a file<br></br>
            <blue>a</blue> - Appends new data to a file<br></br>
            <blue>r</blue> - Reads from a file<br></br>
    
<code>
/*Read file char by char*/

FILE* ptr; //FILE is basically a data type, and we need to create a pointer variable to work with it 
char ch;

// Opening file in reading mode
ptr = fopen("test.txt", "r");

if (NULL == ptr) {
    printf("file can't be opened \n");
}

printf("content of this file are \n");

// Printing what is written in file
// character by character using loop.
do {
    ch = fgetc(ptr);
    printf("%c", ch);

    // Checking if character is not EOF.
    // If it is EOF stop reading.
} while (ch != EOF); 

</code>

<code>
/*
Alternatively feof function can be used:
feof() function takes file pointer as argument and returns true if pointer reaches the end of the file. 
*/
while (!feof(ptr)) {
    ch = fgetc(ptr);
    printf("%c", ch);
}
</code>

<code>
//Reading whole content of the file as string:

//fgets() reads one string at a time from the file. fgets() returns a string if it is
//successfully read by function or returns NULL if can not read. 

//Prototype: char * fgets(char *str, int size, FILE * ptr);

while (fgets(str, 50, ptr) != NULL) {
    printf("%s", str);
}
</code>

<code>
/*
fscanf() reads formatted input from a stream.

Approach:

fscanf reads formatted data from the files and stores it in variables.
The data in the buffer is printed on the console till the end of the file is reached.

*/

char buf[100];
while (fscanf(ptr, "%*s %*s %s ", buf) == 1)
    printf("%s\n", buf);
</code>
        
        </read-from-file>
        <write-to-file>
            To create a file, or write to a file you can use the <red>w</red> mode inside the <code>fopen()</code> function.
            <br></br><br></br>
            <green>
            Opening a file:
            </green>
            <br></br><br></br>
            Function Prototype: <code>fopen(filename, mode)</code>;
            <br></br><br></br>
            Where:<br></br><br></br>
            <code>filename</code><br></br>    
            The name of the actual file you want to open (or create), like <red>filename.txt</red>.
            <br></br><br></br>
            <code>mode</code><br></br>    
            A single character, which represents what you want to do with the file 
            (<red>read</red>, <red>write</red> or <red>append</red>):<br></br><br></br>
            <blue>w</blue> - Writes to a file<br></br>
            <blue>a</blue> - Appends new data to a file<br></br>
            <blue>r</blue> - Reads from a file<br></br>
            <br></br>
            The <red>w</red> mode means that the file is opened for writing. 
            <br></br>
            To insert content to it, you can 
            use the <code>fprintf()</code> function and add the pointer variable (<red>fptr</red> in our example) and some text:
            <br></br><br></br>
            If you write to a file that already exists, the old content is deleted, and the new content 
            is inserted. 
            <br></br>
            This is important to know, as you might accidentally erase existing content.
            <br></br>
<code>
FILE *fptr; //FILE is basically a data type, and we need to create a pointer variable to work with it 

// Open a file in writing mode
fptr = fopen("filename.txt", "w");

// Write some text to the file using fprintf
fprintf(fptr, "Some text");

// Write some other text to the file fputs
fputs("Line wrote with fputs.", fp); 

// Close the file
fclose(fptr); // this will close the file when we are done with it.
</code>    
        <br></br>
        Closing the file:
        <br></br><br></br>
        It is considered as <red>good practice</red>, because it makes sure that:
        <br></br><br></br>
        <blue>
        Changes are saved properly. <br></br>
        Other programs can use the file (if you want). <br></br>
        Clean up unnecessary memory space. <br></br><br></br>
        </blue>
        If you want to add content to a file without deleting the old content, 
        you can use the <red>a</red> mode. <br></br>
        The <red>a</red> mode appends content at the end of the file:<br></br>
        
<code>
/*Example*/

FILE *fptr;

// Open a file in append mode
fptr = fopen("filename.txt", "a"); 

/*Just like with the w mode; if the file does not exist, the a mode will create a 
new file with the "appended" content.*/

// Append some text to the file
fprintf(fptr, "\nHi everybody!");

// Close the file
fclose(fptr);
</code>
        </write-to-file>
        <serialization>*General-Programming-Knowledge*</serialization>
        <deserialization>*General-Programming-Knowledge*</deserialization>
        <enums>
            *General-Programming-Knowledge*
<code>
//Syntax: enum flag{constant1, constant2, constant3, ....... };

// An example program to demonstrate working
// of enum in C

#include &lt;stdio.h&gt;
 
enum week{Mon, Tue, Wed, Thur, Fri, Sat, Sun};
 
int main()
{
    enum week day;
    day = Wed;
    printf("%d",day);
    return 0;
} 
</code>
        </enums>
        <multi-threading>
        *General-Programming-Knowledge*<br></br>
<code>
/*Example of using multi-threading in C Language*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt; //Header file for sleep(). man 3 sleep for details. 
#include &lt;pthread.h&gt;
  
// A normal C function that is executed as a thread  
// when its name is specified in pthread_create() 

void *myThreadFun(void *vargp) 
{ 
    sleep(1); 
    printf("Printing GeeksQuiz from Thread \n"); 
    return NULL; 
} 
   
int main() 
{ 
    pthread_t thread_id; 
    printf("Before Thread\n"); 
    pthread_create(&#38;thread_id, NULL, myThreadFun, NULL); 
    pthread_join(thread_id, NULL); 
    printf("After Thread\n"); 
    exit(0); 
}
</code>
        </multi-threading>
        <exception-handling>C does not provide direct support to error handling (or exception handling).</exception-handling>
        <bitwise-operators>
            *General-Programming-Knowledge*
            <br></br>
<code>
// Example on how to use the bitwise operators:

#include &lt;stdio.h&gt;

int main()
{
    // a = 5(00000101), b = 9(00001001)
    unsigned char a = 5, b = 9;
 
    // The result is 00000001
    printf("a = %d, b = %d\n", a, b);
    printf("a &#38; b = %d\n", a &#38; b);
 
    // The result is 00001101
    printf("a|b = %d\n", a | b);
 
    // The result is 00001100
    printf("a^b = %d\n", a ^ b);
 
    // The result is 11111010
    printf("~a = %d\n", a = ~a);
 
    // The result is 00010010
    printf("b&lt;&lt;1 = %d\n", b &lt;&lt; 1);
 
    // The result is 00000100
    printf("b&gt;&gt;1 = %d\n", b &gt;&gt; 1);
 
    return 0;
    
    /*
        OUTPUT: 
        
        a = 5, b = 9
        a&#38;b = 1
        a|b = 13
        a^b = 12
        ~a = 250
        b&lt;&lt;1 = 18
        b&gt;&gt;1 = 4
    */
}
</code>
        </bitwise-operators>
        <default-parameters>
            *General-Programming-Knowledge*
            <br></br>
            There are no default parameters in C. <br></br><br></br>
            But one way to achieve this is by passing <red>NULL</red> pointers and 
            then set the values to the default if <red>NULL</red> is passed.
        </default-parameters>
        <interfaces>
            *General-Programming-Knowledge*
            <br></br>
            In C - an <red>interface</red> can be implemented as a set of function declarations without 
            any implementation details. <br></br><br></br>
            <brown>
            It defines a contract that concrete implementations must adhere to by providing 
            definitions for all the functions declared in the <red>interface</red>.
            </brown>
<code>
// Declare an interface for a shape
struct shape_interface {
  // Function pointers for the interface functions
  double (*area)(void*);
  double (*perimeter)(void*);
}; 

/*
In OOP there are classes that store to both variables and methods of an object.

In C we can have structs that store variables and structs that hold function pointers to defined behaviours
Both of them are close to forming a class.

*/
</code>
        </interfaces>
        <macros>*General-Programming-Knowledge*</macros>
        <defines>*General-Programming-Knowledge*</defines>
        <random-generators>
            The <code>rand()</code> function returns the random integers whose range from <code>0</code> to 
            <code>RAND_MAX</code>. <br></br><br></br>
            The <code>RAND_MAX</code> is a symbolic constant that defines in <code>stdlib.h</code> header file, whose value 
            is greater but less than <blue>32767</blue> depending on the C libraries.<br></br><br></br>
<code>
//Example of using rand() to generate random numbers

#include &lt;stdio.h&gt;    
#include &lt;conio.h&gt;  
#include &lt;stdlib.h&gt;  

void main()  
{     
    // use rand() function to generate the number  
    printf (" The random number is: %d", rand());  
    printf ("\n The random number is: %d", rand());  
      
    printf (" \n The random number is: %d", rand());  
    printf ("\n The random number is: %d", rand());  
    getch();  
}          
</code>
            <br></br>
            The <code>srand()</code> function is a C library function that determines the initial 
            point to generate 
            different series of <red>pseudo-random numbers</red>. 
            <br></br><br></br>
            A <code>srand()</code> function cannot be used without 
            using a <code>rand()</code> function. 
            <br></br><br></br>
            The <code>srand()</code> function is required to set the value of the <red>seed</red> 
            only once in a program to generate the different results of random integers before 
            calling the <code>rand()</code> function. <br></br><br></br>
<code>
//Example of using srand() to generate pseudo-random numbers

#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;time.h&gt;  // use time.h header file to use time  
      
int main()  
{  
    int num, i;  
    time_t t1; // declare time variable  
      
    printf(" Enter a number to set the limit for a random number \n");  
    scanf (" %d", &#38;num);  
      
    /* define the random number generator */  
    srand ( (unsigned) time (&#38;t1)); // pass the srand() parameter  
    printf("\n"); // print the space
    /* generate random number between 0 to 50 */  
}  
</code>
        </random-generators>
        <command-line-arguments>
            *General-Programming-Knowledge*
<code>
/*Example*/
int main(int argc, char *argv[]) { /* ... */ }

//OR
int main(int argc, char **argv) { /* ... */ }
</code>
        </command-line-arguments>
        <ternary-operator>
            *General-Programming-Knowledge*
<code>
/*Using IF ELSE statements:*/

int a = 10, b = 20, c;

if (a &lt; b) 
{
    c = a;
}
else 
{
    c = b;
}

printf("%d", c);
</code>

<code>
/*Using TERNARY operator:*/

int a = 10, b = 20, c;

c = (a &lt; b) ? a : b;

printf("%d", c);

/*The output of both samples of code from above will result in: c = 3*/
</code>
        </ternary-operator>
        <modular-programming>
            *General-Programming-Knowledge*
            <br></br>
            In C language this is achieved by placing 
            the interface definition in a header file and the implementation in a source 
            file. <br></br>
            The disciplined use of <code>static</code> keyword is practiced in order to hide implementation details.
            <br></br><br></br>
<code>
/*FILE module.h*/
 extern unsigned int Calculate_NoOfChars_In_string(char* str);

/*FILE module.c*/
unsigned int Calculate_NoOfChars_In_string(char* str)
{
    unsigned int counter = 0;
    while(str[counter]!="\0")
    {
        counter++;
    }
    return counter;
}

/*FILE main.c*/
#include &lt;module.h&gt;  
#include &lt;stdio.h&gt;  

int main()
{
    char strA[10] = "Some text.";
    unsigned int length = Calculate_NoOfChars_In_string(strA);
    print("String length is: %d\n", length);
}
</code>
        </modular-programming>
        <string-methods>
            C has many useful string functions, which can be used to perform certain operations 
            on strings.<br></br><br></br>
            To use them, you must include the <code>&lt;string.h&gt;</code> header file in your program.
            <br></br><br></br>
<code>
/* GET THE SIZE (IN CHARACTERS) OF STRINGS */

char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
printf("%d", strlen(alphabet));

/* Note that sizeof and strlen behaves differently, as sizeof also includes t
he \0 character when counting.*/

/* CONCATENATE STRINGS */

char str1[20] = "Hello ";
char str2[] = "World!";

// Concatenate str2 to str1 (result is stored in str1)
strcat(str1, str2);

// Print str1
printf("%s", str1);

/* COPY STRINGS */
char str1[20] = "Hello World!";
char str2[20];

// Copy str1 to str2
strcpy(str2, str1);

// Print str2
printf("%s", str2);

/* COMPARE STRINGS */

char str1[] = "Hello";
char str2[] = "Hello";
char str3[] = "Hi";

// Compare str1 and str2, and print the result
printf("%d\n", strcmp(str1, str2));  // Returns 0 (the strings are equal)

// Compare str1 and str3, and print the result
printf("%d\n", strcmp(str1, str3));  // Returns -4 (the strings are not equal)
</code>
        </string-methods>
        <datatype-conversions>
            *General-Programming-Knowledge*
            <br></br>
            It is one of the important concepts introduced in 'C' 
            programming.<br></br>
<code>
// Automatic conversion: int to float
float myFloat = 9;

printf("%f", myFloat); // 9.000000

// the compiler automatically converts the int value 9 to a float value of 9.000000.

// Automatic conversion: float to int
int myInt = 9.99;

printf("%d", myInt); // 9

// the compiler automatically converts the float value of 9.99 to int value 9.
</code>

<code>
//Calculate the percentage of a user's score in relation to the maximum score in a game:

// Set the maximum possible score in the game to 500
int maxScore = 500;

// The actual score of the user
int userScore = 420;

/* Calculate the percentage of the user's score in relation to the maximum available score.
Convert userScore to float to make sure that the division is accurate */
float percentage = (float) userScore / maxScore * 100.0;

// Print the percentage
printf("User's percentage is %.2f", percentage);
</code>
        </datatype-conversions>
        <optional-parameters>*General-Programming-Knowledge*</optional-parameters>
        <operators>
            *General-Programming-Knowledge*
            <green><br></br>Misc Operators:<br></br></green>
                <br></br> 
                <code>sizeof()</code><br></br> 
                <red>It returns the size of a variable. <br></br>
                <code>sizeof(a)</code>, 
                where <code>a</code> is integer, will return <blue>4</blue>.</red>
                <br></br><br></br>
                <code>&#38;</code><br></br>
                <red>It returns the <blue>address</blue> of a variable.<br></br> 
                <code>&#38;a;</code> 
                returns the actual 
                address of the variable.</red>
                <br></br><br></br>
                <code>*</code><br></br>
                <red>Pointer to a variable.<br></br>
                <code>*a;</code></red>
                <br></br><br></br>
                <code>? :</code><br></br>
                <red>Conditional Expression. <br></br>
                If Condition is <code>true</code> <blue>?</blue> 
                then value X <blue>:</blue> otherwise value Y; </red>
                <br></br>
        </operators>
        <pre-post-incrementation>
            *General-Programming-Knowledge*
            <br></br>
<code>
//pre increment operator

#include &lt;stdio.h&gt;  
 
int main()
{
    int x = 10, a;
 
    a = ++x; // x will be incremented to 11 then value of x is assigned to a;
 
    printf("a = %d\n", a);
 
    printf("x = %d\n", x);
    return 0;
    
    /*
        OUTPUT: 
        a = 11
        x = 11
    */
</code>

<code>
//post increment operator

#include &lt;stdio.h&gt;  
 
int main()
{
    int x = 10, a;
 
    a = x++; // x value is assined to a, then x value gets incremented to 11;

    printf("a = %d\n", a);
 
    printf("x = %d\n", x);
    return 0;
    
    /*
        OUTPUT: 
        a = 10
        x = 11
    */

}
</code>
        </pre-post-incrementation>
    </programming_language>
    
    <programming_language>
        <name>C++</name>
        <description>
            C++ is a high-level, general-purpose programming language created by 
            Danish computer scientist Bjarne Stroustrup. <br></br><br></br>
            First released in 1985 as an extension of the C programming language, 
            it has since expanded significantly over time; as of 1997, C++ has object-oriented, 
            generic, and functional features. <br></br>
            In addition to facilities for low-level memory 
            manipulation for making things like microcomputers or to make operating systems 
            like Linux or Windows. <br></br><br></br>
            
            It is almost always implemented as a compiled language, 
            and many vendors provide C++ compilers, including the Free Software Foundation, 
            LLVM, Microsoft, Intel, Embarcadero, Oracle, and IBM.
        </description>
        <oop>*General-Programming-Knowledge*</oop>
        <encapsulation>
            *General-Programming-Knowledge*
<code>
//Example of encapsulation

#include &lt;iostream&gt;  
using namespace std;

class Employee 
{
  private:
    // Private attribute
    int salary;

  public:
    // Setter
    void setSalary(int s) 
    {
      salary = s;
    }
    
    // Getter
    int getSalary() 
    {
      return salary;
    }
};

int main() 
{
    Employee myObj;
    myObj.setSalary(50000);
    cout &lt;&lt; myObj.getSalary();
    return 0;
}
</code>
        </encapsulation>
        <polymorphism>
            *General-Programming-Knowledge*
<code>
//Example of polymorphism

#include &lt;iostream&gt;  

/*

The word polymorphism means having many forms. 
Typically, polymorphism occurs when there is a hierarchy of classes and they are related by inheritance.

C++ polymorphism means that a call to a member function will cause a different function to be executed depending on the type of object that invokes the function. 

Example: if a parent class function is set to be override-able, then a parent class pointer can have functionality of the a child class object.

A pure virtual function is a function that is declared in the parent class and it really needs to be defined in
each one of the child classes.

Syntax: virtual void DisplayFunction () = 0;

*/

using namespace std;

class Shape
{
    //By default a member without access-specifier is set to private.

    protected:
        int length;
        int height;

    public:
        virtual void DisplayInfo() //Each child class has to provide its own definition of this method.
        {
            cout &lt;&lt; "This is the parent class." &lt;&lt; endl;
        }
};

class Square: public Shape
{
    private:
        int area;
        void CalcArea()
        {
            area=length*height;
        }

    public:
        Square (int len, int hg)
        {
            length=len;
            height=hg;
            CalcArea();
        };
        
        void DisplayArea()
        {
            cout &lt;&lt; "Area: " &lt;&lt; area &lt;&lt; endl;
        }
        
        //This function overrides the parent class function
        void DisplayInfo()
        {
            cout &lt;&lt; "This is the child class." &lt;&lt; endl;
        }
};

class Circle: public Shape
{
    private:
        int radius;
    
    public:
        Circle(int len)
        {
            radius=len/2;
        }
        void DisplayRadius()
        {
            cout &lt;&lt; "Radius: " &lt;&lt; radius &lt;&lt; endl;
        }
};

int main()
{
    Shape *p;
    Circle circle_object(22);
    Square square_object(4,3);
    
    /*
    The pointer of type Shape can reference any of the Shape class children, 
    but having only the functionality of Shape Class.
    */
    
    p=&#38;circle_object;
    p-&gt;DisplayInfo();
    p=&#38;square_object;
    p-&gt;DisplayInfo();
    
    int a;
    cin &gt;&gt; a;
    return 0;
    
    /*
    Using same variable we accessed different behaviour for each child class.
    */
}
</code>    
        </polymorphism>
        <inheritance>
            In C++, it is possible to <red>inherit</red> attributes and methods from one <code>class</code> 
            to another. 
            We group the <red>"inheritance concept"</red> into two categories:
            <br></br><br></br>
            <green>
            - derived class (child) - the class that inherits from another class;<br></br>
            - base class (parent) - the class being inherited from;<br></br><br></br>
            </green>
            To <red>inherit</red> from a <code>class</code>, use the <blue>:</blue> symbol.<br></br>
<code>
#include &lt;iostream&gt;  
#include &lt;conio.h&gt;  

using namespace std;

//BASE CLASS
class Shape{

    protected: 
    //protected variables are visible into this class and the other classes that are inherited to this.

    string name;
        
    public:
    Shape(string newname)
    {
        name=newname;
    }
    string getName() const
    {
        return name;
    }
};

//CHILD CLASS ONE
class Circle : public Shape //making Circle class derive from the Shape class (setting the inheritance).
{
    //inheritance is a way to make 2 classes share the same variables between each other

    double radius; //this variable can be private, or protected or public (anything).

    public:
    Circle(string inheritedName, double newradius) : Shape (inheritedName)//this will call the Shape constructor
    //which will set a value into it's string variable called 'name', in this way, a variable will be used in 2 classes.
    {
        radius=newradius;
    }
    double getCircleRadius() const
    {
        return radius;
    }

};

//CHILD CLASS TWO
class Rectangle : public Shape // making the Rectangle class derive from Shape Class, let the Rectangle Class, use the
//protected variables of the Shape Class.
{
    double length, width;

    public:
    Rectangle (string inheritedName2, double newlength, double newwidth): Shape (inheritedName2)
    {
        length=newlength;
        width=newwidth;
    }
    double getRectangleLength() const
    {
        return length;
    }
    double getRectangleWidth () const
    {
        return width;
    }
};

int main()
{
    Shape object("Shape Class String"); //create object
    cout &lt;&lt; object.getName() &lt;&lt; endl; //calling a function from the class

    cout &lt;&lt; endl &lt;&lt; "CHILD ONE CLASS: " &lt;&lt; endl;
    
    Circle objectchild ("Circle (stored in Shape Class String)", 3.0); //create object
    cout &lt;&lt; objectchild.getName() &lt;&lt; endl; //calling a function from Shape Class using the object from Circle Class.
    cout &lt;&lt; objectchild.getCircleRadius() &lt;&lt; endl;

    cout &lt;&lt; endl &lt;&lt; "CHILD TWO CLASS: " &lt;&lt; endl;
    
    Rectangle objectchild2("Rectangle (stored in Shape Class String)", 20.0, 65.0); //create object
    cout &lt;&lt; objectchild2.getName() &lt;&lt; endl; //calling a function from Shape Class using the object from Rectangle Class.
    cout &lt;&lt; objectchild2.getRectangleLength() &lt;&lt; endl;
    cout &lt;&lt; objectchild2.getRectangleWidth() &lt;&lt; endl;

    getch();
    return 0;
}
</code>
        </inheritance>
        <abstraction>
            Data abstraction is one of the most essential and important features of object-oriented 
            programming in C++. <br></br><br></br>
            Abstraction means displaying only essential information and hiding the 
            details. Data abstraction refers to providing only essential information about the 
            data to the outside world, hiding the background details or implementation. 
            <br></br><br></br>

<code>
#include &lt;iostream&gt;  
using namespace std;
 
class implementAbstraction {
private:
    int a, b;
 
public:
    // method to set values of
    // private members
    void set(int x, int y)
    {
        a = x;
        b = y;
    }
 
    void display()
    {
        cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;
        cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;
    }
};
 
int main()
{
    implementAbstraction obj;
    obj.set(10, 20);
    obj.display();
    return 0;
    
    /*
    OUTPUT:
    a = 10
    b = 20
    */
}
</code>
        We are not allowed to access the variables a and b directly, however, one can call 
        the function set() to set the values in a and b and the function display() to 
        display the values of a and b. 
        <br></br><br></br>
        
        <red>Advantages of Data Abstraction:</red>
        <br></br><br></br>
        <green>
        Helps the user to avoid writing the low-level code;<br></br>
        Avoids code duplication and increases reusability.<br></br>
        Can change the internal implementation of the class independently without 
        affecting the user.<br></br>
        Helps to increase the security of an application or program as only important 
        details are provided to the user.<br></br>
        It reduces the complexity as well as the redundancy of the code, therefore 
        increasing the readability.
        <br></br>
        </green>
        </abstraction>
        <generic-programming>
            *General-Programming-Knowledge*
            <br></br>    
            In C++ the <red>templates</red> generalize the algorithm to make it <red>data type-independent</red>.
            <br></br><br></br>            
            The functions and classes which are data type independent are called <red>generics</red>, 
            and this concept is called generic programming. 
            <br></br><br></br>
            <brown>
            Generic Programming reduces code 
            repetition and in-demand compilation; hence efficient.
            </brown>
            <br></br>

<code>
#include &lt;iostream&gt;  

// Template Function with a Type T
// During instantiation, this T will be replaced by the data type of argument.
template &lt;class T&gt;  
T maxNum (T a, T b) {
 return (a &gt;   b ? a : b); //ternary operator
}

int main()
{
    int x = 5, y = 2;
    float a = 4.5, b = 1.3;
    
    std::cout &lt;&lt; maxNum&lt;int&gt;(x, y) &lt;&lt; "\n";
    std::cout &lt;&lt; maxNum&lt;float&gt;(a, b);
    return 0;
}
</code>
        </generic-programming>
        <variable-arguments-lists>
            The variable number of arguments in C++ is a feature that permits a function to 
            accept any number of arguments.<br></br>
            This type of function is called <red>variadic functions</red>.
            <br></br><br></br>
            Functions with a variable number of arguments in C++ can be easily implemented using 
            a <red>vector</red> or an <red>array</red> if all the arguments are the same type.
            <br></br><br></br>
            If all arguments are of different types, then we need to use the <code>cstdarg</code> header file 
            to implement <red>variadic functions</red>.
            <br></br><br></br>
            <blue><red>Variadic functions</red> do not put restrictions on the types of arguments. <br></br>
            They also do not perform integer and floating-point enhancements.</blue>
            <br></br>
<code>
// Implementation of variable arguments using vector.

#include &lt;iostream&gt; 
#include &lt;vector&gt; 
using namespace std;

// Using vector of string as a parameter to store a variable number of strings.

void printNames(vector&lt;string&gt;  nameVector) {
    for (string &#38;name : nameVector) {
        cout &lt;&lt; name &lt;&lt; " ";
    }
    cout &lt;&lt; '\n';
}

int main() {
    printNames({"Scaler", "Topics"});
    printNames({"Technopedia", "for", "your", "mastermind!"});
    return 0;
}
</code>

<code>
// Implementation of variable arguments using cstdarg variadic functons.

#include &lt;iostream&gt; 
#include &lt;cstdarg&gt; 

using namespace std;

void printDeveloperData(const char* fmt...) {
    va_list args;
    va_start(args, fmt);
 
    while (*fmt != '\0') 
    {
        if (*fmt == 'd') 
        {
            int version = va_arg(args, int);
            std::cout &lt;&lt; "C++ Version: " &lt;&lt; version;
        } 
        else if (*fmt == 'c') 
        {
            int name = va_arg(args, int);
            std::cout &lt;&lt; "Name: " &lt;&lt; static_cast&lt;char&gt; (name);
        } 
        else if (*fmt == 'f') 
        {
            double stability_percentage = va_arg(args, double);
            std::cout &lt;&lt; "Stability Percentage: " &lt;&lt; stability_percentage &lt;&lt; "%";
        }
        ++fmt;
        cout &lt;&lt; '\n';
    }
 
    va_end(args);
}
 
int main() {
    printDeveloperData("cdf", 'B', 20, 94.7);
    
    return 0;

}
</code>

<code>
// Implementation of variable arguments using variadic templates.

#include &lt;iostream&gt; 
using namespace std;

template &lt;typename T&gt; 
void printDeveloperData(T t) {
    cout &lt;&lt; t &lt;&lt; '\n' ;
}

template&lt;typename T, typename... Args&gt; 
void printDeveloperData(T t, Args... args) {
    cout &lt;&lt; t &lt;&lt; '\n';
    printDeveloperData(args...) ;
}

int main() {
    printDeveloperData("Bjarne", 20, 94.7);
}
</code>
        </variable-arguments-lists>
        <simple-data-types>
            All <red>variables</red> use data type during declaration to <blue>restrict</blue> the type of data to 
            be stored. <br></br>
            Therefore, we can say that data types are used to tell the variables 
            the type of data they can store. <br></br><br></br>
            Whenever a <red>variable</red> is defined in C++, 
            the compiler allocates some memory for that <red>variable</red> based on the data type 
            with which it is declared. <br></br><br></br>
            Every data type requires a different amount of memory.
            <br></br><br></br>
            <green>The datatypes presented on C Language are still available in C++:</green>
            <br></br><br></br>
            *General-Programming-Knowledge*
            <br></br><br></br>
            <green>Primitive Datatypes:</green><br></br><br></br>
            <blue>
            Integer<br></br>
            Character<br></br>
            Boolean<br></br>
            Floating Point<br></br>
            Double Floating Point<br></br>
            Valueless or Void<br></br>
            Wide Character<br></br>
            </blue>
            <br></br>
        </simple-data-types>
        <complex-data-types>
            *General-Programming-Knowledge*
            <br></br>
            <brown>Aditional to the C Language, C++ introduced classes as a user-defined datatype. </brown>
            <br></br><br></br>
            <green>Derived Datatypes:</green><br></br>
            <blue>
            Function<br></br>
            Array<br></br>
            Pointer<br></br>
            Reference<br></br>
            </blue>
            <br></br>
            <green>User-defined Datatypes:</green><br></br>
            <blue>
            Class<br></br>
            Structure<br></br>
            Union<br></br>
            Enumeration<br></br>
            Typedef defined Datatype<br></br>
            </blue>
        </complex-data-types>
        <loops>
            *General-Programming-Knowledge*
            <br></br>
            Additional to the loops presented in C language, there is also a <red>"for-each loop"</red> 
            <blue>(introduced in C++ version 11 (2011)</blue>, which is used exclusively to loop through 
            elements in an array (or other data sets):
<code>
/*Example of foreach loop in C++*/

int myNumbers[5] = {10, 20, 30, 40, 50};

for (int i : myNumbers) 
{
  cout &lt;&lt;  i &lt;&lt;  "\n";
}
</code>
        </loops>
        <collections>
            *General-Programming-Knowledge*
            <br></br>
            Additional to C Language: C++ introduced several new collection classes datatypes:
            <br></br><br></br>
            <green>
                Vector: 
            </green>
            <br></br><br></br>
            The C++ Standard Library vector class is a class template for sequence containers.<br></br>
            <br></br>
            <blue>
            Vector is a type of <red>dynamic array</red> which has the ability to <red>resize 
            automatically</red> after insertion or deletion of elements. <br></br>
            The elements in vector 
            are placed in contiguous storage so that they can be accessed and traversed using 
            <red>iterators</red>. <br></br>
            Element is inserted at the end of the vector.<br></br><br></br>
            </blue>
<code>
#include &lt;iostream&gt; 
#include &lt;vector&gt; 
 
int main()
{
    // Create a vector containing integers
    std::vector&lt;int&gt;  v = {8, 4, 5, 9};
 
    // Add two more integers to vector
    v.push_back(6);
    v.push_back(9);
 
    // Overwrite element at position 2
    v[2] = -1;
 
    // Print out the vector
    for (int n : v)
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
</code>    
        <green>
        List: 
        </green>
        <br></br><br></br>
        <blue>
        List is a <red>double linked sequence</red> that supports both forward and backward 
        traversal. <br></br>
        The time taken in the insertion and deletion in the beginning, end 
        and middle is constant.<br></br> 
        It has the <red>non-contiguous memory</red> and there is no 
        pre-allocated memory.<br></br>
        </blue>
<code>
// C++ program to demonstrate the use of list containers

#include &lt;iostream&gt; 
#include &lt;list&gt; 
using namespace std;
 
int main()
{
    // defining list
    list&lt;int&gt;  gqlist{12,45,8,6};
 
    for (auto i : gqlist) {
        cout &lt;&lt; i &lt;&lt; ' ';
    }
    return 0;
}
</code>
        </collections>
        <collection-methods>
            Some of the methods available in C++ for the Collection Type Classes: 
            <red>Vector</red> or <red>List</red> are:
            <br></br><br></br>
            <green>Capacity:</green><br></br>
            <code>size()    </code><br></br>Return size<br></br><br></br>
            <code>max_size()</code><br></br>Return maximum size<br></br><br></br>
            <code>resize()    </code><br></br>Change size<br></br><br></br>
            <code>capacity()</code><br></br>Return size of allocated storage capacity<br></br><br></br>
            <code>empty()    </code><br></br>Test whether vector is empty<br></br><br></br>
            <code>reserve()    </code><br></br>Request a change in capacity<br></br><br></br>
            <code>shrink_to_fit()</code><br></br>Shrink to fit<br></br><br></br>
            <br></br>
            <green>Element access:</green><br></br>
            <code>operator[]</code><br></br>Access element<br></br><br></br>
            <code>at()</code><br></br>Access element<br></br><br></br>
            <code>front()</code><br></br>Access first element<br></br><br></br>
            <code>back()</code><br></br>Access last element<br></br><br></br>
            <code>data()</code><br></br>Access data<br></br><br></br>
            <br></br>
            <green>Modifiers:</green><br></br>
            <code>assign()</code><br></br>Assign vector content<br></br><br></br>
            <code>push_back()</code><br></br>Add element at the end<br></br><br></br>
            <code>pop_back()</code><br></br>Delete last element<br></br><br></br>
            <code>insert()</code><br></br>Insert elements<br></br><br></br>
            <code>erase()</code><br></br>Erase elements<br></br><br></br>
            <code>swap()</code><br></br>Swap content<br></br><br></br>
            <code>clear()</code><br></br>Clear content<br></br><br></br>
            <code>emplace()</code><br></br>Construct and insert element<br></br><br></br>
            <code>emplace_back()</code><br></br>Construct and insert element at the end<br></br><br></br>
        </collection-methods>
        <dynamic-memory-allocation>
            *General-Programming-Knowledge*
            <br></br>
            <green>
            Additional to the C language: 
            </green>
            <br></br><br></br>
            C++ integrates the operators <code>new</code> and <code>delete</code> for allocating dynamic memory.
            <br></br><br></br>
            <red>Operators new and new[]: </red>
            <br></br>
            Dynamic memory is allocated using operator <code>new</code>. <br></br>
            <code>new</code> is followed by a data 
            type specifier and, if a sequence of more than one element is required, 
            the number of these within brackets <code>[]</code>. <br></br>
            It returns a pointer to the beginning of the new block of memory allocated. <br></br>
<code>
//Example:

int * foo;
foo = new int [5];
</code>
        In this case, the system <red>dynamically allocates space</red> for five elements of type <code>int</code> 
        and <red>returns</red> a pointer to the first element of the sequence, which is assigned to 
        <code>foo</code> (a pointer). <br></br><br></br>
        Therefore, <code>foo</code> now points to a valid block of memory with space 
        for five elements of type <code>int</code>.<br></br>
        <br></br>
        <red>Operators delete and delete[]: </red>
        <br></br>
        In most cases, <red>memory allocated dynamically</red> is only needed during specific periods 
        of time within a program; once it is no longer needed, it can be <red>freed</red> so that 
        the memory becomes available again for other requests of <red>dynamic memory</red>. <br></br>
        <br></br>
        This is the purpose of operator <code>delete</code>, whose syntax is: <br></br>
<code>
// Example of dynamic allocation
// and deallocation of memory using new and delete

#include &lt;iostream&gt; 
using namespace std;

int main()
{
    // Pointer initialization to null
    int* p = NULL;

    // Request memory for the variable
    // using new operator
    p = new (nothrow) int;
    if (!p)
        cout &lt;&lt; "allocation of memory failed\n";
    else {
        // Store value at allocated address
        *p = 29;
        cout &lt;&lt; "Value of p: " &lt;&lt; *p &lt;&lt; endl;
    }

    // Request block of memory
    // using new operator
    float* r = new float(75.25);

    cout &lt;&lt; "Value of r: " &lt;&lt; *r &lt;&lt; endl;

    // Request block of memory of size n
    int n = 5;
    int* q = new (nothrow) int[n];

    if (!q)
        cout &lt;&lt; "allocation of memory failed\n";
    else {
        for (int i = 0; i &lt; n; i++)
            q[i] = i + 1;

        cout &lt;&lt; "Value store in block of memory: ";
        for (int i = 0; i &lt; n; i++)
            cout &lt;&lt; q[i] &lt;&lt; " ";
    }

    // freed the allocated memory
    delete p;
    delete r;

    // freed the block of allocated memory
    delete[] q;

    return 0;
    
    /*
        OUTPUT:
        Value of p: 29
        Value of r: 75.25
        Value store in block of memory: 1 2 3 4 5 
    */
}
</code>
        </dynamic-memory-allocation>
        <read-from-file>
            The fstream library can be used in C++ to work with files.
            <br></br><br></br>
            There are three classes included in the fstream library, which are used to create, write or read files:
            <br></br><br></br>
            <green>Class description:</green><br></br><br></br>
            <red>ofstream</red>    Creates and writes to files<br></br>
            <red>ifstream</red>    Reads from files<br></br>
            <red>fstream</red>        A combination of ofstream and ifstream: creates, reads, and writes to files
            <br></br><br></br>
            To read from a file, use either the <code>ifstream</code> or <code>fstream class</code>, and the name of the file.
            <br></br><br></br>
            <blue>Note: we also use a while loop together with the <code>getline()</code> function 
            (which belongs to the <code>ifstream</code> class) to read the file line by line, and to print 
            the content of the file:</blue>
            <br></br>
<code>
// Create a text string, which is used to output the text file

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;

int main() 
{
    string myText;

    // Read from the text file
    ifstream MyReadFile("filename.txt");

    // Use a while loop together with the getline() function to read the file line by line
    while (getline (MyReadFile, myText)) 
    {
      // Output the text from the file
      cout &lt;&lt; myText;
    }

    // Close the file
    MyReadFile.close(); //It is considered good practice to close the file, 
    //and it can clean up unnecessary memory space.
}
</code>
        </read-from-file>
        <write-to-file>
            The <code>fstream</code> library can be used in C++ to work with files.
            <br></br><br></br>
            There are three classes included in the <code>fstream</code> library, which are used to create, 
            write or read files:
            <br></br><br></br>
            <green>Class description:</green><br></br><br></br>
            <red>ofstream</red>    Creates and writes to files<br></br>
            <red>ifstream</red>    Reads from files<br></br>
            <red>fstream</red>    A combination of <red>ofstream</red> and <red>ifstream</red>: creates, reads, and writes to files
            <br></br><br></br>
            Create and Write To a File:<br></br>
            To create a file, use either the ofstream or <red>fstream</red> class, and specify 
            the name of the file.
            <br></br><br></br>
            To write to the file, use the insertion operator (<code>&lt;&lt;</code>).<br></br>
<code>
//Example of writing to file using fstream in C++

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;

int main() 
{
    // Create and open a text file
    ofstream MyFile("filename.txt");

    // Write to the file
    MyFile &lt;&lt; "Files can be tricky, but it is fun enough!";

    // Close the file
    MyFile.close(); //It is considered good practice to close the file, 
    //and it can clean up unnecessary memory space.
}
</code>
        </write-to-file>
        <serialization>
            *General-Programming-Knowledge*
            <br></br>
            Storing the state of an object to a file:<br></br>
<code>
/*Example of C++ object.field serialization and deserialization*/

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;

class Student 
{
    public:
    
    string name;
    int rollno;
    string branch;

    Student () // default constructor
    {
    } 
    
    Student (string n, int r, string b) // overloading constructor
    {
        name = n;
        rollno = r;
        branch = b;
    }
    
    //override the insertion operator for object.field serialization
    friend ofstream &#38; operator &lt;&lt; (ofstream &#38; ofs, Student s);
    //now we can write individually every class field member to the file.
    //Example: ofs &lt;&lt; s1.name; 
    
    //override the extraction for object.field deserialization
    friend ifstream &#38; operator &gt;&gt; (ifstream &#38; ifs, Student &#38; s);
    //now we can read individually every class field member from the file. 
    //Example: ifs &gt;&gt; s1.name; 
};

int main() 
{
    Student s1 ("James", 28, "IT");

    //Open the output stream
    ofstream ofs ("Student.txt", ios::trunc);

    //writing to the file
    ofs &lt;&lt; s1.name &lt;&lt; endl;
    ofs &lt;&lt; s1.rollno &lt;&lt; endl;
    ofs &lt;&lt; s1.branch &lt;&lt; endl;
    ofs.close();

    Student s2; //empty object

    //Open the input stream
    ifstream ifs("Student.txt");

    //reading from the file
    ifs &gt;&gt; s2.name;
    ifs &gt;&gt; s2.rollno;
    ifs &gt;&gt; s2.branch;
    ifs.close();

    cout &lt;&lt; s2.name &lt;&lt; endl;
    cout &lt;&lt; s2.rollno &lt;&lt; endl;
    cout &lt;&lt; s2.branch &lt;&lt; endl;

    /*
    
        OUTPUT: 
        James 
        28 
        IT
    
    */
}
</code>
        </serialization>
        <deserialization>
            *General-Programming-Knowledge*
            <br></br>
            Deserialization is the reverse process of Serialization, 
            where the byte stream is used to reconstruct the original object.<br></br>
<code>
/*Example of C++ whole-object serialization and deserialization*/

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;
class Student
{
    public:
    
    string name;
    int rollno;
    string branch;
    Student () // default constructor
    {
    }
    
    Student (string n, int r, string b) // overloading constructor
    {
        name = n;
        rollno = r;
        branch = b;
    }

    //override the insertion operator for object.field serialization
    friend ofstream &#38; operator &lt;&lt; (ofstream &#38; ofs, Student s);
    //now we can write individually every class field member to the file. 
    //Example: ofs &lt;&lt; s1.name; 
    
    //override the extraction for object.field deserialization
    friend ifstream &#38; operator &gt;&gt; (ifstream &#38; ifs, Student &#38; s);
    //now we can read individually every class field member from the file. 
    //Example: ifs &gt;&gt; s1.name; 
};

//Overriding the operators for whole-object serialization and deserialization
ofstream &#38;  operator &lt;&lt; (ofstream &#38; ofs, Student s)
{
    ofs &lt;&lt; s.name &lt;&lt; endl;
    ofs &lt;&lt; s.rollno &lt;&lt; endl;
    ofs &lt;&lt; s.branch &lt;&lt; endl;
    return ofs;
}
ifstream &#38; operator &gt;&gt; (ifstream &#38; ifs, Student &#38; s)
{
    ifs &gt;&gt; s.name &gt;&gt; s.rollno &gt;&gt; s.branch;
    return ifs;
}

/*
now we can read/write the whole object to and from the file. 

Example: 
ofs &lt;&lt; s1; 
ifs &gt;&gt; s2; 

*/

int main()
{
    Student s1("James", 28, "IT");

    //Open the output stream
    ofstream ofs("Student.txt", ios::trunc);
    ofs &lt;&lt;  s1;
    ofs.close();

    Student s2; // empty object

    //Open the input stream
    ifstream ifs("Student.txt");
    ifs &gt;&gt; s2;
    ifs.close();
        
    cout &lt;&lt; s2.name &lt;&lt; " " &lt;&lt; s2.rollno &lt;&lt; " " &lt;&lt; s2.branch &lt;&lt; endl;

    /*
    
        OUTPUT:
        James 28 IT
    
    */
}
</code>
        </deserialization>
        <constructors>
            *General-Programming-Knowledge*
<code>
/*Example*/
#include &lt;iostream&gt; 

using namespace std;

class MyClass {     // The class
  public:           // Access specifier
    MyClass() {     // Constructor
    
    /*
    The constructor has the same name as the class, it is always public, and it does not have any return value.
    */
    
      cout &lt;&lt; "Hello World!";
    }
};

int main() {
  MyClass myObj;    // Create an object of MyClass (this will call the constructor)
  return 0;
}
</code>

<code>
/*Example*/
#include &lt;iostream&gt; 
#include &lt;string&gt; 

using namespace std;

class MyClass {     // The class
  public:           // Access specifier
    MyClass(string message) {     // Constructor with parameter
    
      cout &lt;&lt; message;
    }
};

int main() {
  MyClass myObj("Hello World!");    // Create an object of MyClass (this will call the constructor)
  return 0;
}
</code>
        </constructors>
        <instantiation>
            *General-Programming-Knowledge*
<code>
/*Example of instantiation*/

#include &lt;stdio.h&gt; 

class MyClass{

public:
    MyClass(){}
    void PrintMessage()
    {
        printf("Message from class member.\n");
    }
};

int main()
{
    //Instantiating the class:
    MyClass obj; 
    obj.PrintMessage();

    return 0;
}
</code>
        </instantiation>
        <destructors>
            *General-Programming-Knowledge*
<code>
class Test {
public:
    // User-Defined Constructor
    Test() { cout &lt;&lt; "\n Constructor executed"; }
 
    // User-Defined Destructor
    ~Test() { cout &lt;&lt; "\n Destructor executed"; }
};
</code>
        </destructors>
        <function-overloading>
            *General-Programming-Knowledge*
<code>
/*Example of function overloading*/

#include &lt;iostream&gt; 
using namespace std;
 
 
void add(int a, int b)
{
  cout &lt;&lt; "sum = " &lt;&lt; (a + b);
}
 
void add(double a, double b)
{
    cout &lt;&lt; endl &lt;&lt; "sum = " &lt;&lt; (a + b);
}
 
int main()
{
    add(10, 2); //calling function with ints
    add(5.3, 6.2); //calling function with floats
 
    return 0;
}
</code>
        </function-overloading>
        <operator-overloading>
            *General-Programming-Knowledge*
<code>
// Example of Operator Overloading

#include &lt;iostream&gt; 
using namespace std;
 
class Complex {
private:
    int real, imag;
 
public:
    Complex(int r = 0, int i = 0)
    {
        real = r;
        imag = i;
    }
 
    // This is automatically called when '+' is used with
    // between two Complex objects
    Complex operator+(Complex const    &#38; obj)
    {
        Complex res;
        res.real = real + obj.real;
        res.imag = imag + obj.imag;
        return res;
    }
    void print() { cout &lt;&lt; real &lt;&lt; " + i" &lt;&lt; imag &lt;&lt; '\n'; }
};
 
int main()
{
    Complex c1(10, 5), c2(2, 4);
    Complex c3 = c1 + c2;
    c3.print();
    
    /*
    OUTPUT:
    12 + i9
    */
}
</code>
        </operator-overloading>
        <enums>
            *General-Programming-Knowledge*
            <green>Comparison to C Language: </green>
            <br></br><br></br>
            In C, an enum is basically a way to <red>alias names</red> to integers. 
            This does not lead to 
            improved type checking. <br></br>
            In C++, an enum defines an actual type, which results in 
            <red>strong type checking</red>.<br></br>
<code>
#include &lt;iostream&gt; 
#include &lt;conio.h&gt; 

using namespace std;

/*
While processing a game loop, there are lots of statements to be checked, so in order to use those statements, variables
that will hold a certain value will be created. 

Example:
int GamePlay =1;
int PauseGame = 2;
int ExitGame = 3;

So in this way the statements can be checked, to see when the game should be paused, should run, or should exit. As you see
above, the variables that are used needs to have different values.

An ENUM is a way to enclose a bunch of constants, an ENUM guarantees that every variable inside it, will have different values.

Example: an ENUM with the variables above, can be created as follows:
enum GameStates {GamePlay, PauseGame, ExitGame};

So the synthax is:
enum &lt;name&gt; {states/members};
*/

//Creating a GLOBAL enum:
enum GameStates {GamePlay, PauseGame, ExitGame}; //the elements will take as constant value the position inside the enum;
//In this case: GamePlay = 0; PauseGame=1; ExitGame=2;

/*

ENUM Members cannot be initialized with values: 
Example GamePlay = 5, this will give compilation error.

Instead the ENUM can be initialized only as follows:
GameStates=ExitGame;

In this case the active value of the ENUM will be ExitGame;
The syntax is : &lt;enum name&gt; = &lt;enum member&gt;;

An ENUM Class is an ENUM that will use the scope resolution and an object of the ENUM class for assignments as above.

Example:
GameStates gameStates=GameStates::ExitGame;

An ENUM Class will make possible that you can have multiple ENUMS with the same MEMBERS. 

So we could have for example:
enum class GameState {Exit, MainMenu};
enum class SoftwareState (Exit, MainMenu);

Without using an ENUM Class this could not be possible because, the TWO MEMBERS will conflict to each other
(compilation error).

Syntax to create an ENUM Class:

enum class &lt;name&gt; { member1, member2...}
An ENUM cannot be forward declared, unless it's an ENUM Class. 
So only ENUM Classes can be forward declared.

To change the default value of an ENUM Member which consist in it's position on the ENUM, you can do as follows:

enum GameState {MainMenu=5, GamePlay=7, GameExit, GamePaused}; //the two uninitialized members follow gets the value of the
previous member+1; so GameExit will be 8, GamePause will be 9;

*/

int main()
{
    cout &lt;&lt; "GamePlay value: " &lt;&lt; GamePlay &lt;&lt; endl; // this is 0;
    cout &lt;&lt; "PauseGame value: " &lt;&lt; PauseGame &lt;&lt; endl; // this is 1;
    cout &lt;&lt; "ExitGame value: " &lt;&lt; ExitGame &lt;&lt; endl; // this is 2;
    getch();
    return 0;
}
</code>
        </enums>
        <multi-threading>
            *General-Programming-Knowledge*
            <br></br>
            C++ multithreading involves creating and using thread objects, seen as <code>std::thread</code> 
            in code, to carry out delegated sub-tasks independently. <br></br>
            New threads are passed a 
            function to complete, and optionally some parameters for that function.
            <br></br>
<code>
#include &lt;iostream&gt; 
#include &lt;cstdlib&gt; 
#include &lt;pthread.h&gt; 

using namespace std;

#define NUM_THREADS 5

void *PrintHello(void *threadid) 
{
   long tid;
   tid = (long)threadid;
   cout &lt;&lt; "Hello World! Thread ID, " &lt;&lt; tid &lt;&lt; endl;
   pthread_exit(NULL);
}

int main () 
{
   pthread_t threads[NUM_THREADS];
   int rc;
   int i;
   
   for( i = 0; i &lt; NUM_THREADS; i++ ) 
   {
      cout &lt;&lt; "main() : creating thread, " &lt;&lt; i &lt;&lt; endl;
      rc = pthread_create(&#38;threads[i], NULL, PrintHello, (void *)i);
      
      if (rc) 
      {
         cout &lt;&lt; "Error:unable to create thread," &lt;&lt; rc &lt;&lt; endl;
         exit(-1);
      }
   }
   pthread_exit(NULL);
}
</code>
        </multi-threading>
        <namespaces>
            *General-Programming-Knowledge*
            <br></br><br></br>
            In C++ multiple namespace blocks 
            with the same name are allowed.<br></br>
<code>
namespace Data
{
    class ObjectManager
    {
    public:
        void DoSomething() {}
    };
    void Func(ObjectManager) {}
}
</code>
        </namespaces>
        <exception-handling>
            *General-Programming-Knowledge*
            <br></br>
<code>
// C++ example on how to use of try,catch and throw
// for exception handling.
 
#include &lt;iostream&gt; 
#include &lt;stdexcept&gt; 
using namespace std;
 
int main()
{
 
    // try block
    try 
    {
        int numerator = 10;
        int denominator = 0;
        int res;
 
        // check if denominator is 0 then throw runtime
        // error.
        if (denominator == 0) 
        {
            throw runtime_error(
                "Division by zero not allowed!");
        }
 
        // calculate result if no exception occurs
        res = numerator / denominator;
        //[printing result after division
        cout &lt;&lt; "Result after division: " &lt;&lt; res &lt;&lt; endl;
    }
    // catch block to catch the thrown exception
    catch (const exception&#38; e) 
    {
        // print the exception
        cout &lt;&lt; "Exception " &lt;&lt; e.what() &lt;&lt; endl;
    }
 
    return 0;
}
</code>
        </exception-handling>
        <bitwise-operators>
            *General-Programming-Knowledge*
            <br></br>
            Bitwise operators in C/C++ are 
            tools for working with individual <red>bits</red> in data. <br></br>
            They might not be as famous as other 
            operators, but they’re essential for tasks like making code more <red>efficient</red> or 
            <red>controlling hardware</red>.
        </bitwise-operators>
        <default-parameters>
            *General-Programming-Knowledge*
<code>
// Example of Default Parameters/Arguments in C++.

#include &lt;iostream&gt; 
using namespace std;
 
// A function with default arguments,
// it can be called with
// 2 arguments or 3 arguments or 4 arguments.

int sum(int x, int y, int z = 0, int w = 0) //assigning default values to z,w as 0
{
    return (x + y + z + w);
}
 
int main()
{
    // Statement 1
    cout &lt;&lt; sum(10, 15) &lt;&lt; endl;
   
    // Statement 2
    cout &lt;&lt; sum(10, 15, 25) &lt;&lt; endl;
   
    // Statement 3
    cout &lt;&lt; sum(10, 15, 25, 30) &lt;&lt; endl;
    return 0;
}
</code>
        </default-parameters>
        <interfaces>
            *General-Programming-Knowledge*
<code>
/*Example of an interface implementation*/

class Box {
   public:
      // pure virtual function
      virtual double getVolume() = 0;
      
   private:
      double length;      // Length of a box
      double breadth;     // Breadth of a box
      double height;      // Height of a box
};
</code>
        </interfaces>
        <abstract-classes>
            *General-Programming-Knowledge*
<code>
/*Example of abstract class*/

#include &lt;iostream&gt; 
 
using namespace std;
 
// Base class
class Shape {
   public:
      // pure virtual function providing interface framework.
      virtual int getArea() = 0;
      void setWidth(int w) {
         width = w;
      }
   
      void setHeight(int h) {
         height = h;
      }
   
   protected:
      int width;
      int height;
};
 
// Derived classes
class Rectangle: public Shape {
   public:
      int getArea() { 
         return (width * height); 
      }
};

class Triangle: public Shape {
   public:
      int getArea() { 
         return (width * height)/2; 
      }
};
 
int main(void) {
   Rectangle Rect;
   Triangle  Tri;
 
   Rect.setWidth(5);
   Rect.setHeight(7);
   
   // Print the area of the object.
   cout &lt;&lt; "Total Rectangle area: " &lt;&lt; Rect.getArea() &lt;&lt; endl;

   Tri.setWidth(5);
   Tri.setHeight(7);
   
   // Print the area of the object.
   cout &lt;&lt; "Total Triangle area: " &lt;&lt; Tri.getArea() &lt;&lt; endl; 

   return 0;
}
</code>
        
        </abstract-classes>
        <macros>
            *General-Programming-Knowledge*
            <green>Similar to C Language:</green> 
            <br></br><br></br>
            A C++ <red>macro</red> is defined as a section of code that that particular <red>macro</red> value can 
            replace. <br></br><br></br>
            We can define the <red>macro</red> by using a <code>#define</code> directive.<br></br> 
            When the compiler goes to the macros while program compilation, 
            the <red>macro</red>'s name is replaced by the definition of the <red>macro</red>. 
            <br></br><br></br>
            The termination of the C++ <red>Macros</red> does not need a 
            semi-colon (;).
            <br></br><br></br>
            <blue>Additionally to the C Language</blue><br></br>
            The header file: <code>&lt;limits.h&gt;</code> 
            is defined to help finding 
            the range of fundamental <red>data-types</red>. <br></br>
             <br></br>
            <red>Unsigned</red> modifiers have minimum value is <blue>zero</blue>. 
            So, no <red>macro</red> constants are defined for the <red>unsigned minimum value</red>.
            <br></br><br></br>
            <green>
            Macro Constants:<br></br><br></br>
            </green>
            <red>
            <blue>CHAR_MIN</blue>  - The minimum value for an object of type char; <br></br><br></br>    
            <blue>CHAR_MAX</blue>  - Maximum value for an object of type char; <br></br><br></br>        
            <blue>SCHAR_MIN</blue>  - The minimum value for an object of type Signed char; <br></br><br></br>    
            <blue>SCHAR_MAX</blue>  - Maximum value for an object of type Signed char; <br></br><br></br>        
            <blue>UCHAR_MAX</blue>  - Maximum value for an object of type Unsigned char; <br></br><br></br>        
            <blue>CHAR_BIT</blue>  - Number of bits in a char object; <br></br><br></br>        
            <blue>MB_LEN_MAX</blue>  - Maximum number of bytes in a multi-byte character; <br></br><br></br>        
            <blue>SHRT_MIN</blue>  - The minimum value for an object of type short int; <br></br><br></br>        
            <blue>SHRT_MAX</blue>  - Maximum value for an object of type short int; <br></br><br></br>        
            <blue>USHRT_MAX</blue>  - Maximum value for an object of type Unsigned short int; <br></br><br></br>        
            <blue>INT_MIN</blue>  - The minimum value for an object of type int; <br></br><br></br>        
            <blue>INT_MAX</blue>  - Maximum value for an object of type int; <br></br><br></br>        
            <blue>UINT_MAX</blue>  - Maximum value for an object of type Unsigned int; <br></br><br></br>    
            <blue>LONG_MIN</blue>  - The minimum value for an object of type long int; <br></br><br></br>        
            <blue>LONG_MAX</blue>  - Maximum value for an object of type long int; <br></br><br></br>        
            <blue>ULONG_MAX</blue>  - Maximum value for an object of type Unsigned long int; <br></br><br></br>        
            <blue>LLONG_MIN</blue>  - The minimum value for an object of type long long int; <br></br><br></br>        
            <blue>LLONG_MAX</blue>  - Maximum value for an object of type long long int; <br></br><br></br>    
            <blue>ULLONG_MAX</blue> - Maximum value for an object of type Unsigned long long int;<br></br>            
            </red>
<code>
/*An example of defining a C++ macro:*/

using namespace std;
 
// Here is the definition of macro.
#define AREA(l, b) (l * b)

int main() {
    // The given lengths are l1 and l2.
    int l1 = 20, l2 = 2, area;
 
    // Here, finding the area using macro.
    area = AREA(l1, l2);
 
    return 0;
}
</code>
        </macros>
        <defines>*General-Programming-Knowledge*</defines>
        <random-generators>
            *General-Programming-Knowledge*
            <br></br>
            <green>Within C++:</green>
            <br></br><br></br>
            <code>rand()</code> function is an inbuilt function in <red>C++ Standard Library</red>, which is defined in 
            header file <code>&lt;cstdlib&gt;</code>. <br></br><br></br>

            The <code>rand()</code> function is 
            used in C++ to generate random numbers in the range <code>[0, RAND_MAX)</code>.
            <br></br><br></br>
            The random number is generated by using an algorithm that gives a series of 
            non-related numbers whenever this function is called.
            <br></br><br></br>
            <red>Syntax of rand():</red><br></br>
            <code>int rand(void);</code><br></br><br></br>
            <red>Parameters of rand():</red><br></br>
            This function does not take any parameters.<br></br><br></br>
            <red>Return Value of rand():</red><br></br>
            <code>rand()</code> returns a pseudo-random number in the range of <code>[0, RAND_MAX)</code>.
            <br></br>
<code>
// C++ program to demonstrate 
//  the use of rand() 

#include &lt;cstdlib&gt; 
#include &lt;iostream&gt;  
using namespace std; 
  
int main() 
{ 
    // This program will create some sequence of 
    // random numbers on every program run 
    for (int i = 0; i &lt; 5; i++) 
        cout &lt;&lt; rand() &lt;&lt; " "; 

    return 0; 
}
</code>
            <code>srand()</code> function is also available in C++.<br></br>
            This function sets the
            <red>seed</red> which is used by <red>rand</red> to generate <red>"random"</red> numbers.
        </random-generators>
        <command-line-arguments>*General-Programming-Knowledge*</command-line-arguments>
        <ternary-operator>*General-Programming-Knowledge*</ternary-operator>
        <modular-programming>*General-Programming-Knowledge*
            <br></br>
            <red>Example of modular programming in C++</red>
<code>
//FILE: vectors_of_objects_mainfile.cpp
//In this file we put everything together

#include "vectors_of_objects_class.h" //by this inclusion we get access to: vectors_of_objects_class

//Function prototyping or declaration
void createObjects(vector &lt;vectors_of_objects_class&gt;&#38;);
void printObjectsInfo(const vector &lt;vectors_of_objects_class&gt;&#38;); 

//The main function is the entry point of the program
int main()
{
    vector &lt;vectors_of_objects_class&gt; ObjectVector; //creating a vector of objects;
    
    //Calling the function that populates the vector of objects.
    createObjects(ObjectVector);
    
    //Calling the function that prints out the vector of objects.
    printObjectsInfo(ObjectVector);
    return 0;
}

//Function definition
void createObjects(vector &lt;vectors_of_objects_class&gt;&#38; newObjVec) //defining the function
{
    int age;
    string name;
    cout &lt;&lt; "How many people do you wish to add? ";
    int people;
    cin &gt;&gt; people;
    for(int i=0;i&lt;people;i++)
    {
        cout &lt;&lt; "People_" &lt;&lt; i &lt;&lt; " Name: ";
        cin &gt;&gt; name; //get the name from the keyboard
        cout &lt;&lt; "People_" &lt;&lt; i &lt;&lt; " Age: ";
        cin &gt;&gt; age; //get the age from the keyboard
        vectors_of_objects_class ObjectInVector(name, age); //creating the object with self made constructor
        ObjectInVector.setAge(age); //calling the class function
        ObjectInVector.setName(name); //calling the class function
        newObjVec.push_back(ObjectInVector); //put the object into the vector;
    }
    cout &lt;&lt; endl;
}

void printObjectsInfo(const vector &lt;vectors_of_objects_class&gt;&#38; newObjVec) //defining the function
{
    unsigned int sizeOfVector=newObjVec.size();
    for(int i=0;i&lt;sizeOfVector; i++)
    {
        cout &lt;&lt; "People_" &lt;&lt; i &lt;&lt; " Name: " &lt;&lt; newObjVec[i].getName() &lt;&lt; endl;
        cout &lt;&lt; "People_" &lt;&lt; i &lt;&lt; " Age: " &lt;&lt; newObjVec[i].getAge() &lt;&lt; endl;
    }
}

</code>

<code>
//FILE: vectors_of_objects_class.cpp
//In this file we implement the vectors_of_objects_class interface

#include "vectors_of_objects_class.h"

//Implementing the custom vector class interface

//Adding a default constructor
vectors_of_objects_class::vectors_of_objects_class() //default constructor
{
    //constructor
}

//Adding an overloading constructor that takes 2 arguments
vectors_of_objects_class::vectors_of_objects_class(string name, int age) //self made constructor
{
    //initializing the variables;
    newage=0;
}

//Adding a default destructor
vectors_of_objects_class::~vectors_of_objects_class()
{
    //destructor
}

//Adding methods
string vectors_of_objects_class::getName() const //getter defined to access the private variable of the class
{
    return newname;
}
int vectors_of_objects_class::getAge() const //getter defined to access the private variables of the class
{
    return newage;
}
void vectors_of_objects_class::setName(string name) //setter defined to set the private variables of the class
{
    newname=name;
}
void vectors_of_objects_class::setAge(int age) //setter defined to set the private variables of the class
{
    newage=age;
}

</code>

<code>
//FILE: vectors_of_objects_class.h
//In this file we declare an interface called: vectors_of_objects_class

#ifndef VECTORS_OF_OBJECTS_CLASS_H //this will ensure that the header file is only included once
#define VECTORS_OF_OBJECTS_CLASS_H

#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

//Creating a custom vector class interface
class vectors_of_objects_class
{
    public:
        vectors_of_objects_class(); //default constructor
        vectors_of_objects_class(string, int); //self made constructor

        //Accessor functions:
        string getName () const;
        int getAge () const;

        //Mutator functions;
        void setName(string);
        void setAge(int);

        virtual ~vectors_of_objects_class();

    protected:

    private: //private variables;
        string newname; 
        int newage;
};

#endif // VECTORS_OF_OBJECTS_CLASS_H

</code>
        </modular-programming>
        <string-methods>
            The <code>std::string</code> is a <code>class</code> in <red>C++ since C++98</red>. 
            This <code>class</code> is the standard 
            representation for a text string. It includes some typical string operations 
            like find, replace, concatenate, compare etc. It is present in <code>&lt;string&gt;</code> 
            header file. <br></br><br></br>
            <green>
            Commonly Used String Functions in C++:<br></br>
            </green>
            <br></br>
            <blue>length() or size()</blue><br></br>
            It will <red>return the length</red> of the string.<br></br>
            <br></br>
            <blue>array[index]</blue><br></br>
            To <red>access</red> individual characters using array indexing.<br></br>
            <br></br>
            <blue>at()</blue><br></br>
            Used to <red>access</red> a character at a specified index.<br></br>
            <br></br>
            <blue>+ Operator</blue><br></br>
            <code>+</code> operator is used to <red>concatenate</red> two strings.<br></br>
            <br></br>
            <blue>append()</blue><br></br>
            The <code>append()</code> function <red>adds one string</red> to the end of another.<br></br>
            <br></br>
            <blue>== Operator</blue><br></br>
            You can <red>compare</red> strings using the <code>==</code> operator.<br></br>
            <br></br>
            <blue>compare()</blue><br></br>
            The <code>compare()</code> function <red>returns an integer</red> value indicating the 
            comparison result.<br></br>
            <br></br>
            <blue>substr()</blue><br></br>
            Use the <code>substr()</code> function to <red>extract a substring</red> from a string.<br></br>
            <br></br>
            <blue>find()</blue><br></br>
            The <code>find()</code> function <red>returns the position</red> of the first occurrence of a substring.<br></br>
            <br></br>
            <blue>replace()</blue><br></br>
            Use the <code>replace()</code> function to <red>modify</red> a part of the string.<br></br>
            <br></br>
            <blue>insert()</blue><br></br>
            The <code>insert()</code> function <red>adds a substring</red> at a specified position.<br></br>
            <br></br>
            <blue>erase()</blue><br></br>
            Use the <code>erase()</code> function to <red>remove</red> a part of the string.<br></br>
            <br></br>
            <blue>c_str()</blue><br></br>
            To obtain a <red>C-style string</red> from a <code>std::string</code>, you can use the 
            <code>c_str()</code> function.<br></br>
        </string-methods>
        <datatype-conversions>*General-Programming-Knowledge*</datatype-conversions>
        <optional-parameters>*General-Programming-Knowledge*</optional-parameters>
        <decorators>
            *General-Programming-Knowledge*
<code>
/*Example*/

#include &lt;iostream&gt; 
using namespace std;

class Computer
{
public:
    virtual void display()
    {
        cout &lt;&lt; "I am a computer..." &lt;&lt; endl;
    }
};

class CDDrive : public Computer
{
private:
    Computer* c;
public:
    CDDrive(Computer* _c)
    {
        c = _c;
    }
    void display()
    {
        c-&gt;display();
        cout &lt;&lt; "with a CD Drive..." &lt;&lt; endl;
    }
};

class Printer : public Computer
{
private:
    CDDrive* d;
public:
    Printer(CDDrive* _d)
    {
        d = _d;
    }
    void display()
    {
        d-&gt;display();
        cout &lt;&lt; "with a printer..." &lt;&lt; endl;
    }
};

int main()
{
    Computer* c = new Computer();
    CDDrive* d = new CDDrive(c);
    Printer* p = new Printer(d);

    p-&gt;display();
}
</code>
        </decorators>
        <operators>*General-Programming-Knowledge*</operators>
        <pre-post-incrementation>*General-Programming-Knowledge*</pre-post-incrementation>
    </programming_language>
    
    <programming_language>
        <name>C#</name>
        <description>
            C# is a general-purpose high-level programming language supporting multiple 
            paradigms. C# encompasses static typing, strong typing, lexically scoped, 
            imperative, declarative, functional, generic, object-oriented (class-based), 
            and component-oriented programming disciplines. <br></br><br></br>

            The C# programming language was designed by Anders Hejlsberg from Microsoft in 
            2000. <br></br><br></br>

            Microsoft introduced C# along with .NET Framework and Visual Studio, both of 
            which were closed-source. At the time, Microsoft had no open-source products. 
            <br></br><br></br>

            Four years later, in 2004, a free and open-source project called Mono began, 
            providing a cross-platform compiler and runtime environment for the C# 
            programming language. <br></br><br></br>

            A decade later, Microsoft released Visual Studio Code (code editor), 
            Roslyn (compiler), and the unified .NET platform (software framework), 
            all of which support C# and are free, open-source, and cross-platform. 
            Mono also joined Microsoft but was not merged into .NET.<br></br><br></br>
        </description>
        <oop>*General-Programming-Knowledge*</oop>
        <encapsulation>*General-Programming-Knowledge*
<code>
using System;

/*Members of the class should never be set to public, because public means that anyone who works at that program
 *is able to change the variable's value, so to avoid that, all the members (sometimes called proprieties), should
 * be private, (or protected for inheritance purposes).
 * Encapsulation - is the use of getter functions for getting the value of private member of the class.
 * and setter function for setting the value of a private member of the class.
 */
namespace project27_classes_encaptulation_and_exceptions_throwing
{
    class Program
    {
        public static void Main(string[] args)
        {
            Encapsulation_Example pobject = new Encapsulation_Example();
            pobject.SetAge(15);
            pobject.SetName("Ellias Mustellar");
            Console.WriteLine("Name: {0}\nAge: {1}", pobject.GetName(), pobject.GetAge());
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    class Encapsulation_Example
    {
        //Members: (sometimes called proprieties)
        private int _age; //as good programming habbit the private variables in a function should start with 
        //underscore/underline.
        private string _Name;
        
        //Setters:
        public void SetAge(int NewAge)
        {
            if(NewAge&lt;=0)
            {
                //An exception is an error message, that occures and terminates the program in case that
                //something goes wrong.
                //Sinthax for throwing exception
                throw new Exception("A person cannot have NULL or NEGATIVE age.");
            }
            _age=NewAge;
        }
        public void SetName(string NewName)
        {
            //string.IsNullOrEmpty (string_name) -> function that checks if a string is null or empty
            if(string.IsNullOrEmpty(NewName))
            {
                throw new Exception("The name cannot be NULL or EMPTY.");
            }
            _Name = NewName;
        }
        
        //Getters:
        public int GetAge()
        {
            return this._age;
        }
        public string GetName()
        {
            return this._Name;
        }
    }
}
</code>
        </encapsulation>
        <polymorphism>*General-Programming-Knowledge*
<code>
using System;

namespace project25_polymorphism
{
    class Program
    {
        public static void Main(string[] args)
        {
            /*The idea of polymorphism is creating an array of type parent class, to which you can assign
             any object of type child classes.*/
            Parent [] objarray = new Parent[4];
            objarray[0]=new Parent();
            objarray[1]=new Child1();
            objarray[2]=new Child2();
            objarray[3]=new Child3();
            foreach(Parent k in objarray)
            {
                k.DisplayInfo(); //each child has the proprieties of the parent class
                
                /*To see the information of each child class we could make a function which will hide the parent
                 * class function, and contain the updated information of the child class. But a better way doing
                 * that is marking the parent class you'd wish to hide with virtual keyword, which will allow
                 * every child class overide the method by their own needs.
                 */
            }
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    class Parent
    {
        protected string FirstName, LastName;
        public Parent()
        {
            FirstName="FN";
            LastName="LN";
        }
        public virtual void DisplayInfo()
            //The virtual keyword will make this function overidable for each child class.
        {
            Console.WriteLine("This is parent class");
        }
    }
    class Child1:Parent
    {
        //This is the sinthax: for overriding (overwriting) a function.
        public override void DisplayInfo()
        {
            Console.WriteLine("This is a child 1 class.");
        }
    }
    class Child2:Parent
    {
        //This is the sinthax: for overriding (overwriting) a function.
        public override void DisplayInfo()
        {
            Console.WriteLine("This is a child 2 class.");
        }
    }
    class Child3:Parent
    {
        //This is the sinthax: for overriding (overwriting) a function.
        public override void DisplayInfo()
        {
            Console.WriteLine("This is a child 3 class.");
        }
    }
}
</code>
        </polymorphism>
        <inheritance>*General-Programming-Knowledge*
<code>
//FILE: MyClass.cs

using System;
using System.Collections.Generic;

/*

In C# for an inherited class can be only one parent class (only single class inheritance is allowed).
 IN CASE OF INHERITED CLASSES: the parent class constructor gets automatically executed before the child class 
constructor if the parent class constructor has no arguments.
Otherwise if the parent class has a constructors with multiple arguments/parameters it must be specified
at the child class constructor declaration a sinthax:
    :base()
and specify the arguments of the constructor that you want to be executed inside the pharanteses.
 
 IMPORTANT: To prevent a class of having children (inheritance), you can use the sealed keyword.
 A sealed class cannot have children (cannot be base class).
 
 */
namespace inherited_classes
{
    //These are called XML Comments:
    /// &lt;summary&gt;
    /// Inherited Classes
    /// &lt;/summary&gt;
    //This is the parent class.
    public class MyClass
    {
        protected string FirstName;
        protected string LastName;
        protected uint ?age;
        protected MyClass(string FSS)
        {
            Console.WriteLine(FSS);
        }
        public void DisplayInfo()
        {
            Console.WriteLine("Name: {0} {1}",FirstName, LastName);
            if(age==null)
            {
                Console.WriteLine("Age: No Age Provided");
            }
            else
            {
                Console.WriteLine("Age: {0}", age);
            }
        }
    }
    //This is the inherited class.
    public class Mates:MyClass
    {
        char Grades;
        //THIS IS DEFAULT CONSTRUCTOR
        public Mates(): base("CHILD CLASS CONTROLS THE PARENTS CLASS") //this needs to be public.
            //AS YOU SEE THE :base () sinthax appears here too.
        {
            FirstName="No First Name Provided";
            LastName="No Last Name Provided";
            age = null;
        }
        //THIS IS OVERLOADED CONSTRUCTOR
        public Mates(string FS, string LS, uint AGE_m, char GRD) : base("CHILD CLASS CONTROLS THE PARENTS CLASS")
            //the constructor needs to be public
            //:base () -> it's used to explicitely specify which constructor should be used for the parent class
            //THE SINTHAX must be used for each constructor of the child class.
            //if the parent class constructor takes no arguments, then the sinthax is optional.
        {
            FirstName=FS;
            LastName=LS;
            age=AGE_m;
            Grades=GRD;
        }
        public void DisplayGrades()
        {
            ///&lt;summary&gt;Displays the grades of the objects in this class.&lt;/summary&gt;
            Console.WriteLine("Grade: {0}", Grades);
        }
    }
}
</code>

<code>
</code>
        </inheritance>
        <abstraction>*General-Programming-Knowledge*
<code>
using System;

/*

An abstract class is similar to an interface, dispite that it can contain variable_members (field members), and
 an abstract class it's acting like a class when it comes to inheritance. An abstract class can have implementation
 for some or even for all its members/field, while the interface cannot. An abstract class can use the (public) 
access modifiers while an interface cannot. An abstract class member is private by default while an interface
member is public by default. An interface can be inherited ONLY from another interface, while an abstract class
can be inherited either from an interface or abstract class. A class can be inherited from multiple interfaces in the
same time whereas a class cannot be inherited from multiple classes.

RULES FOR ABSTRACT CLASSES:
 1.An abstract class cannot be instanciated (an instance of the class cannot be created).
 2.An abstract class can contain abstract members, and the abstract members are not allowed to be implemented in
 that class.
 3.An abstract class can inherit (can have children classes), and every child of the class must provide its
 own implementations for the abstract members of the parent class.
 4.Any class provides single inheritance (the child of the class can have only one parent/base class).
 5.An abstract class can only be used as a base class. SO an abstract class cannot be SEALED.
 6.An abstract class CAN HAVE NO ABSTRACT MEMBERS, so it can provide implementation for all its fields and members.
 7.If a class that's inherited from an abstract class doesn't wish to provide implementation for the parent class
 abstract members, then that class can be also set as abstract.
 
 */

namespace project32_abstract_classes
{
    class Program: AbsClass //A class can inherit only from a single class. (multiple class inheritance is not allowed)
    {
        public static void Main(string[] args)
        {
            Program p1 = new Program();
            p1.MessageShow();
            p1.Print();
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
        //IN order to provide implementation for an abstract member of the parent class the override keyword 
        //must be used.
        protected override void Print()
        {
            Console.WriteLine("Providing implementation for the parent abstract class member.");
        }
    }
    //Creating an abstract class:
    public abstract class AbsClass
    {
        protected abstract void Print(); //this function is abstract
        public void MessageShow() //this is a normal function
        {
            Console.WriteLine("This is not an abstract member.");
        }
    }
}
</code>
        </abstraction>
        <generic-programming>*General-Programming-Knowledge*
<code>
using System;
/* The generic is a specification that allows to a function/method or class to operate without depending on the data type that's been taking 
 * as parameters, and without losing the strong typed property of the function, and the performance.
 * Generics were introduced in C# 2.0, and they are used especially for class collections.
 * 
 * The conversion from value type to reference type is called boxing. When we talk about performance provided by generics, we mean that
 * no boxing will be effectuated. Boxing are weak in performance.
 */

namespace project45_generics
{
    class Program
    {
        public static void Main(string[] args)
        {
            Program aProg = new Program();
            //Using the generic function:
            bool result = aProg.IsEqual&lt;int&gt; (21,44); //the function works for any data type.
            Console.WriteLine("Result of the comparison: {0}", result);
            result = aProg.IsEqual&lt;string&gt; ("Adam", "Exit"); //the function works for any data type.
            Console.WriteLine("Result of the comparison: {0}", result);
            result = aProg.IsEqual&lt;char&gt;('a', 'a'); //the function works for any data type.
            Console.WriteLine("Result of the comparison: {0}", result);
            
            //Working with the generic class:
            MyClass&lt;int&gt; GenCls = new MyClass&lt;int&gt;();
            GenCls.printStuff(12,3);
            MyClass&lt;string> GenCls2 = new MyClass&lt;string&gt;();
            GenCls2.printStuff("Deady", "Online");
            //End of program.
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
        //Creating a generic function:
        public bool IsEqual &lt;T&gt; (T value1, T value2) //the parameters are of type T, into that type could be encapsulated any data type.
        {
            return value1.Equals(value2);
        }
        //The sinthax to create a generic function is: access_modifier return_type function_name &lt;variable_type_name&gt; (arguments of 
        //variable_type_name).
    }
    //Creating a generic class
    #region GenericClass //this is how you can structure your code using regions
    class MyClass &lt;A&gt; //the sinthax is class Class_Name &lt;variable_type_name&gt;
    {
        //Creating a function for the generic class.
        public void printStuff(A value1, A value2)
        {
            Console.WriteLine("The stuff sent is: {0} &#38;&#38; {1}", value1, value2);
        }
    }
    #endregion //end of the region
}
</code>
        </generic-programming>
        <variable-arguments-lists>*General-Programming-Knowledge*
        <br></br>
        Use the param keyword to get the variable arguments in C#.
<code>
using System;

class Program {
   static void Main() {
      int mulVal1 = Multiply(5);
      int mulVal2 = Multiply(5, 10);

      Console.WriteLine(mulVal1);
      Console.WriteLine(mulVal2);
   }

   static int Multiply(params int[] b) {
      int mul =1;
      foreach (int a in b) {
         mul = mul*a;
      }
      return mul;
   }
}
</code>
        </variable-arguments-lists>
        <simple-data-types>*General-Programming-Knowledge*
<code>
using System;

namespace project1_introduction 
{
    class Program
    {
        public static void Main(string[] args) //the main function starts here;
        { 
            //string[] args is an optional argument;
            
            //function to print on the screen;
            Console.WriteLine("Hello World!");
            //Data types:
            int numb_one = 5;
            float numb_two = 6.034f;
            double numb_three = 3.0;
            bool istrue = false;
            string name = "Black";
            object ANYTHING = "A variable that can be initialized with anything!";
            char character = 'X';
            
            //Printing the result on the screen;
            Console.Write("The result of addition is: " + (numb_one+numb_two) + "\n");
            Console.WriteLine("An object is: " + "\"" + ANYTHING + "\"");
            /*
             Console.WriteLine - automatically puts '\n' at the end of the line, because it is a function
            designed to be used only for writing a line.
             */
            
            Console.Write(character + "\n");
            Console.WriteLine("Processing data!\n\n");
            while (numb_one>0)
            {
                if(numb_one==1)
                {
                    Console.WriteLine("The program will end.\n\n");
                }
                numb_one--;
            }
            Console.Write("Press any key to continue . . . ");
            //function to read keys;
            Console.ReadKey(true);
        }
    }
}
</code>
        </simple-data-types>
        <complex-data-types>*General-Programming-Knowledge*</complex-data-types>
        <loops>*General-Programming-Knowledge*
<code>
using System;

namespace project6_foreach_loop
{
    class Program
    {
        public static void Main(string[] args)
        {
            int [] myarray = new int[10];
            for (int i=0;i&lt;10;i++)
            {
                myarray[i]=3*i;
            }
            Console.WriteLine("\nDisplaying elements using FOR LOOP: ");
            for (int i=0;i&lt;10;i++)
            {
                Console.WriteLine("myarray[" + i + "]=" +myarray[i]);
            }
            Console.WriteLine("\nDisplaying elements using FOREACH LOOP: ");
            /*FOREACH LOOP is used especially when trying to iterrate into a list which has dinamic size, or 
             * an array with unknown size.
             * FOREACH is very similar to a FOR loop. FOREACH is used only for Collection of data.
             * The difference between FOR LOOP and FOREACH LOOP is that in FOREACH LOOP there is no access to
             * the index.
             */
            foreach(int iter in myarray) // synthax forech (datatype iterator_name in data_collection)
            {
                    Console.WriteLine("myarray[" + iter/3 + "]=" +iter);
            }
            Console.WriteLine("\nSimple task for FOREACH LOOP");
            foreach(int iter in myarray) // synthax forech (datatype iterator_name in data_collection)
            {
                if(iter%5==0 &#38;&#38; iter>0)
                {
                    Console.WriteLine (iter + " is divisible with five.");
                }
            }
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </loops>
        <collections>*General-Programming-Knowledge*
<code>
using System;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic;

/*A queue is a collection type just like a list or dictionary, dispite that once an object is retrieved from Queue (Dequeue), that object gets
 automatically deleted from the beggining of the Queue.*/
 
/*You can thing of a Queue just like an RAR archieve, because to use an object from the Queue, that object needs to be Dequeued into an another
  object, otherwise it will affect the entire content of the Queue, unless an foreach loop it's used.
  To prevent an object be deleted from the Queue, you have to use a foreach loop or the .Peak function, also you can iterate through the Queue using foreach loop, 
  and effect changes without affecting the content of the Queue.
 */

namespace queue_collection_type
{
    class Program
    {
        public static void Main(string[] args)
        {
            people p1 = new people ("Black", 22);
            people p2 = new people ("Mark", 24);
            
            //Creating Queue
            Queue &lt;people&gt; FirstQueue = new Queue &lt;people&gt; ();
            FirstQueue.Enqueue(p1);
            FirstQueue.Enqueue(p2);
            //Printing Information:
            Console.WriteLine("Number of objects in Queue: {0}\n", FirstQueue.Count());
            
            // Console.WriteLine ("Name: {0}, Age: {1}", FirstQueue.Dequeue().name, FirstQueue.Dequeue().Age); //this is wrong, unless it is
            //moved into a foreach loop:
            
            //A Queue is like an archieve, you need to extract the object from it, before using that object.
            Queue&lt;people&gt; SecondQueue = new Queue&lt;people&gt; ();
            SecondQueue.Enqueue(p1);
            SecondQueue.Enqueue(p2);
            people deq1 = FirstQueue.Dequeue();
            people deq2 = FirstQueue.Dequeue();
            
            /*SecondQueue=FirstQueue // these two Queues become highly connected one to another in the way that, SecondQueue take all the objects
             from the FirstQueue, but if in FirstQueue an object is removed so it is in the SecondQueue.*/
            
            Console.WriteLine("Name: {0}, Age: {1}", deq1.name, deq1.Age);
            Console.WriteLine("Name: {0}, Age: {1}", deq2.name, deq2.Age);
            Console.WriteLine();
            //Auxiliar way -> Iteration:
            foreach (people p in SecondQueue)
            {
                Console.WriteLine("Name: {0}, Age: {1}", p.name, p.Age);
                Console.WriteLine ("Number of objects in Queue: {0}", FirstQueue.Count());
                Console.WriteLine("In the foreach loop the content of the Queue is it not affected, \n(Dequeue is made without removal).\n");
            }
            
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    class people 
    {
        public int Age {get; set;}
        public string name {get; set;}
        public people (string GivenName, int GivenAge) 
        {
            this.Age = GivenAge; 
            this.name = GivenName;
        }
    }
}
</code>

<code>
using System;
using System.Collections.Generic;

/*
 * A stack uses the principle LIFO - Last In First Out, it is just like a list.
 * Once an element gets retrieved from the Stack that object will be removed, unless a foreach loop, or the Peek function it's used.
 */
namespace project61_stack_collection_type
{
    class Program
    {
        public static void Main(string[] args)
        {
            people p1 = new people ("Dragos", 22);
            people p2 = new people ("Adrian", 21);
            Stack&lt;people&gt; FirstStack = new Stack&lt;people&gt;();
            FirstStack.Push(p1);
            FirstStack.Push(p2);
            //The first will be the last:
            foreach (people p in FirstStack)
            {
                Console.WriteLine("Name: {0}    Age: {1}", p.Name, p.Age);
                Console.WriteLine("Number of elements on Stack: {0}", FirstStack.Count);
            }
            Console.WriteLine();
            Console.WriteLine("Outside the forech loop:");
            Console.WriteLine("Name: {0}", FirstStack.Pop().Name);
            Console.WriteLine("Number of elements on Stack: {0}", FirstStack.Count);
            Console.WriteLine("Name: {0}", FirstStack.Pop().Name);
            Console.WriteLine("Number of elements on Stack: {0}", FirstStack.Count);
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    class people
    {
        public string Name {get; set;}
        public int Age {get; set;}
        public people (string NewName, int NewAge) {Name=NewName; Age=NewAge;}
    }
}
</code>
        </collections>
        <collection-methods>*General-Programming-Knowledge*</collection-methods>
        <dynamic-memory-allocation>
            In C#, objects are dynamically allocated on the heap using the new keyword.
            <br></br><br></br>
            When an object is no longer needed, it is the responsibility of the garbage 
            collector to deallocate the memory and reclaim it for future use.
        </dynamic-memory-allocation>
        <read-from-file>*General-Programming-Knowledge*
<code>
using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;

namespace read_from_file
{
    class Program
    {
        public static void Main(string[] args)
        {
            string textFromFile = System.IO.File.ReadAllText("textfile.txt"); // in this case location of the file is in project folder/debug.
            if(textFromFile!=string.Empty)
            {
                Console.WriteLine("Text From File: \n\n{0}", textFromFile);
            }
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </read-from-file>
        <write-to-file>*General-Programming-Knowledge*
<code>
// Write file using StreamWriter
using (StreamWriter writer = new StreamWriter(fullPath))
{
   writer.WriteLine("Monica Rathbun");
   writer.WriteLine("Vidya Agarwal");
   writer.WriteLine("Mahesh Chand");
   writer.WriteLine("Vijay Anand");
   writer.WriteLine("Jignesh Trivedi");
}
// Read a file
string readText = File.ReadAllText(fullPath);
Console.WriteLine(readText);
</code>
        </write-to-file>
        <serialization>*General-Programming-Knowledge*
<code>
using System;  
using System.IO;  
using System.Runtime.Serialization.Formatters.Binary;  
[Serializable]  
class Student  
{  
    int rollno;  
    string name;  
    public Student(int rollno, string name)  
    {  
        this.rollno = rollno;  
        this.name = name;  
    }  
}  
public class SerializeExample  
{  
    public static void Main(string[] args)  
    {  
        FileStream stream = new FileStream("e:\\sss.txt", FileMode.OpenOrCreate);  
        BinaryFormatter formatter=new BinaryFormatter();  
          
        Student s = new Student(101, "sonoo");  
        formatter.Serialize(stream, s);  
  
        stream.Close();  
    }  
}  
</code>
        </serialization>
        <deserialization>*General-Programming-Knowledge*
<code>
using System;  
using System.IO;  
using System.Runtime.Serialization.Formatters.Binary;  
[Serializable]  
class Student  
{  
    public int rollno;  
    public string name;  
    public Student(int rollno, string name)  
    {  
        this.rollno = rollno;  
        this.name = name;  
    }  
}  
public class DeserializeExample  
{  
    public static void Main(string[] args)  
    {  
        FileStream stream = new FileStream("e:\\sss.txt", FileMode.OpenOrCreate);  
        BinaryFormatter formatter=new BinaryFormatter();  
  
        Student s=(Student)formatter.Deserialize(stream);  
        Console.WriteLine("Rollno: " + s.rollno);  
        Console.WriteLine("Name: " + s.name);  
  
        stream.Close();  
    }  
}  
</code>
        </deserialization>
        <constructors>*General-Programming-Knowledge*
<code>
using System;

/*A struct is a similar data type with a class, but structs works with values, while classes works as reference
     FOR A STRUCT:
     if we create 2 objects:
     object1 = object2, in this case object1 will have all the values that object2 has.
     
     FOR A CLASS:
     if we create 2 objects:
     object1 = object2, in this case object1, will be poiting to the object2's values which are stored on the heap.
 */

namespace project5_structs_with_constructors
{
    class Program
    {
        struct MyStr
            {
                //Variables of the struct:
                public int posx, posy;
                //Constructor of the struct:
                public MyStr (int newposx, int newposy)
                {
                    posx = newposx;
                    posy = newposy;
                }
            }
        public static void Main(string[] args)
        {
            //Creating the instances/objects of the struct
            MyStr structure1 = new MyStr (4, 5);
            MyStr structure2 = new MyStr (10, 12);
            //Printing the values:
            Console.WriteLine("The first structure has: X=" +structure1.posx +" and Y=" +structure1.posy);
            Console.WriteLine("The second structure has: X=" +structure2.posx +" and Y=" +structure2.posy);
            structure1 = structure2;
            //Printing the values:
            Console.WriteLine("\nAfter setting structure1 = structure2.\n");
            Console.WriteLine("The first structure has: X=" +structure1.posx +" and Y=" +structure1.posy);
            Console.WriteLine("The second structure has: X=" +structure2.posx +" and Y=" +structure2.posy);
            //End of program:
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </constructors>
        <instantiation>*General-Programming-Knowledge*
        <br></br>
        When you create a new object in C# for a class using the new keyword, then it is called instantiation.
        <br></br>
<code>
Student s1 = new Student();
</code>
        </instantiation>
        <destructors>*General-Programming-Knowledge*
<code>
class Example
{ 
    // Rest of the class
    // members and methods.

   // Destructor
   ~Example()
    {
        // Your code
    }

} 
</code>
        </destructors>
        <function-overloading>*General-Programming-Knowledge*
<code>
using System;

namespace project26_methods_and_functions_overloading
{
    class Program
    {
        public static void Main(string[] args)
        {
            int outsider;
            Program p = new Program();
            p.Add(10,12);
            p.Add(1,102,34);
            p.Add(0.2f,3.3f);
            p.Add(1,33, out outsider);
            Console.WriteLine("Func4 Result: {0}", outsider);
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
        /*A function or method can be overloaded using different number of parameters, different types of 
        parameters or different kind of parameters.
        Kinds of parameters are: input parameters, output parameters, reference parameters
        Types of parameters are: float, int, double, char, etc...
        Overloading means that you can have multiple functions with the same name, but respecting at least one of
        the criteria above (also it can respect all of the criteria above). This means that the signature of the
        overloaded function must be different from the primary function.
        Signature consist in number, type and kind of parameters, and also in the code inside the brackets. But
        a signature does not consist in the return type of the function, the access modifier of the function, or
        the optional parameters (params) of the function.
        So a function CANNOT be overloaded ONLY by using different return types, access modifiers, or optional
        params, there must be respected the criteria above.
        
        Examples:*/
        public void Add(int numb1, int numb2)
        {
            Console.WriteLine("Func1\nThe Sum: {0}\n", numb1+numb2);
        }
        public void Add(int numb1, int numb2, int numb3) //method overloaded
        {
            Console.WriteLine("Func2\nThe Sum: {0}\n", numb1+numb2+numb3);
        }
        public void Add(float numb1, float numb2) //method overloaded
        {
            Console.WriteLine("Func3\nThe Sum: {0}\n", numb1+numb2);
        }
        public void Add (int numb1, int numb2, out int sum) //method overloaded
        {
            sum=numb1+numb2;
        }
    }
}
</code>
        </function-overloading>
        <operator-overloading>*General-Programming-Knowledge*
<code>
// C# program to illustrate the
// unary operator overloading
using System;
namespace Calculator 
{
     
    class Calculator {
         
        public int number1 , number2;
        public Calculator(int num1 , int num2)
        {
            number1 = num1;
            number2 = num2;
        }
         
    // Function to perform operation
    // By changing sign of integers
    public static Calculator operator -(Calculator c1)
    {
        c1.number1 = -c1.number1;
        c1.number2 = -c1.number2;
        return c1;
    }
     
    // Function to print the numbers
    public void Print()
    {
        Console.WriteLine ("Number1 = " + number1);
        Console.WriteLine ("Number2 = " + number2);
    }
    }
     
    class EntryPoint
    {
         
        // Driver Code
        static void Main(String []args)
        { 
             
            // using overloaded - operator 
            // with the class object
            Calculator calc = new Calculator(15, -25);
             
            calc = -calc;
             
            // To display the result
            calc.Print();
        }
    }
}
</code>
        </operator-overloading>
        <enums>*General-Programming-Knowledge*
<code>
using System;
using System.Threading.Tasks;
using System.Text;
using System.Linq;
using System.Collections.Generic;

namespace Software
{
    class Software{
        /*
         NOTE: Enums cannot be declared inside a function, or method. NOT EVEN the Main function.
         */
        enum Gamestate {Playing, Menu, Pause=6}; //from now on, Gamestate is like a datatype.
        /*From the moment of declaration the enum is initializing to true the first state. In this case
         * Playing = true, until the programmer sets it otherwise.
         * The elements of the enum can also hold values, as it sets above, Pause = 6, Playing = 0, Menu = 1 
            (by default the    value set for each element is its index).
         */
        public static int Main()
        {
            //Creating an object/instance for the enum;
            Gamestate gamestate;
            Console.WriteLine("Gamestate: " + Convert.ToInt32(Gamestate.Pause));
            Console.WriteLine("Gamestate: " + Convert.ToInt32(Gamestate.Playing));
            //Changing the state of the Gamestate enum;
            gamestate=Gamestate.Menu;
            /*Equivalence for this case:
             * bool Playing = false;
             * bool Menu = true;
             * bool Pause = false;
             * 
             * As denoted, the enum is like an array of boolean values, in which only one can be true at a time.
             * This is useful while creating game engines, or software engines, to know when a certain option is
             * available. Also this is used to control and interract the states in a certain application.
             */
            Console.WriteLine("Gamestate: " + gamestate);        
            gamestate=Gamestate.Playing;
            /*Equivalence:
             * bool Playing = true;
             * bool Menu = false;
             * bool Pause = false;
             */
            Console.WriteLine("Gamestate: " + gamestate);
            
            //Interraction of the user:
            int input=9;
            while(input>0 &#38;&#38; input&lt;10)
            {
                Console.WriteLine("Enter the option: ");
                input = Convert.ToInt16 (Console.ReadLine());
                switch(input)
                {
                        case 1:
                        {
                            gamestate = Gamestate.Menu;
                            Console.WriteLine("The active state: " + gamestate);
                            break;
                        }
                        case 2:
                        {
                            gamestate = Gamestate.Pause;
                            Console.WriteLine("The active state: " + gamestate);
                            break;
                        }
                        case 3:
                        {
                            gamestate = Gamestate.Playing;
                            Console.WriteLine("The active state: " + gamestate);
                            break;
                        }
                        default:
                        {
                            Console.WriteLine("This is not a gamestate");
                            break;
                        }
                }
            }
            Console.WriteLine("Out of the loop!");
            Console.ReadLine();
            return 0;
        }
    }
}
</code>
        </enums>
        <multi-threading>*General-Programming-Knowledge*
<code>
using System;
using System.Threading;

namespace MultithreadingApplication {
   class ThreadCreationProgram {
      public static void CallToChildThread() {
         try {
            Console.WriteLine("Child thread starts");
            
            // do some work, like counting to 10
            for (int counter = 0; counter &lt;= 10; counter++) {
               Thread.Sleep(500);
               Console.WriteLine(counter);
            }
            
            Console.WriteLine("Child Thread Completed");
         } catch (ThreadAbortException e) {
            Console.WriteLine("Thread Abort Exception");
         } finally {
            Console.WriteLine("Couldn't catch the Thread Exception");
         }
      }
      static void Main(string[] args) {
         ThreadStart childref = new ThreadStart(CallToChildThread);
         Console.WriteLine("In Main: Creating the Child thread");
         
         Thread childThread = new Thread(childref);
         childThread.Start();
         
         //stop the main thread for some time
         Thread.Sleep(2000);
         
         //now abort the child
         Console.WriteLine("In Main: Aborting the Child thread");
         
         childThread.Abort();
         Console.ReadKey();
      }
   }
}
</code>
        </multi-threading>
        <namespaces>*General-Programming-Knowledge*
<code>
//FILE: MyClass.cs

using System;

//The namespace need to be declared in here
using Project20.DeadyOnline; //declaration of the namespace.
using PATA = Project20.DeadyOnline; //Creating a namespace alias called PATA.
//Namespace ALIASES can be used to avoid ambiguity errors. An ambiguity erros is when declaring 2 namespaces which
//may contains some classes or functions with the same name, so when trying to call the function, the compiler
//will not know to which one are you refering to.

//THIS IS AN EXTERNAL CLASS PROJECT
using ProjectA.TeamB; // in order to use this you need to right click on this project and add the ProjectA.TeamB
//as reference to the main project (in this case this is the main project).

namespace project20_namespaces
{
    class Program
    {
        public static void Main(string[] args)
        {
            //Creating an instance for the Class that's inside the namespace Project20.DeadyOnline
            //A namespace is using much like a path to a file, or a directory(folder).
            
            Project20.DeadyOnline.FirstClass p = new Project20.DeadyOnline.FirstClass();
            //If the namespace is declared above, an object of the class can be created as follows:
            FirstClass p2 = new FirstClass();
            
            //Calling the function that's inside the namespace below.
            Project20.DeadyOnline.FirstClass.PrintingMethod(); //calling the STATIC function, which needs to be
            PATA.FirstClass.PrintingMethod();//calling the function using the namespace alias PATA.
            //called using the qualify name of the class
            
            //Also the function can be called like this if the namespace is declared above.
            FirstClass.PrintingMethod();
            p.AnotherMessage();//calling the INSTANCE (non-static) function.
            p2.AnotherMessage(); //calling the INSTANCE (non-static function) using the object 2.
            
            //Calling a function from external namespace and class.
            MyClass ms = new MyClass(); //creating an instance of the class.
            ms.PrintName();//the function is INSTANCE function (so it needs to be called with and instance of
            //the class that it belongs to).
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}

//Namespaces are used to organize the code/programs, and to avoid name clashes.
//Creating a namespace: (this is internal namespace because it's written into the same file.)
namespace Project20
{
    namespace DeadyOnline
    {
        class FirstClass
        {
            public static void PrintingMethod()
            {
                Console.WriteLine("This is a function from a SELF-CREATED namespace.");
            }
            public void AnotherMessage()
            {
                Console.WriteLine("This function is INSTANCE function.");
            }
        }
    }
}
</code>

<code>
//FILE: Program.cs

using System;
using System.Collections.Generic;

namespace ProjectA.TeamB
{
    //This are called XML Coments, and are used to create descriptions.
    /// &lt;summary&gt;
    /// This is an Outside Class Project that contains a PrintName Function.
    /// &lt;/summary&gt;
    public class MyClass
    {
        public void PrintName()
        {
            Console.WriteLine("This is an external Class Project called ProjectA.TeamA");
        }
    }
}
/*The code above is equivalent to this:
 * 
 * namespace ProjectA
{
    namespace TeamB
    {
        public class MyClass
        {
            public void PrintName()
            {
                Console.WriteLine("This is an external Class Project called ProjectA.TeamA");
            }
        }
    }
}
 //THIS IS CALLED NASTED NAMESPACE (or a namespace inside of another).
 */
</code>
        </namespaces>
        <exception-handling>*General-Programming-Knowledge*
<code>
using System;
using System.IO; //namespace for files.

/*DISADVANTAGES OF UNHANDLING EXCEPTION:
 An unhandled exception would provide annoying error message to a user, which could make the program be devoid
 using.
 An unhandled exception could also provide important information to a hacker.
 */
 //While handling the exceptions the catch block containing the specific Classes must be above 
 //the general Class which should be the last one at the bottom.
namespace project37_read_write_to_files_handling_exceptions
{
    class Program
    {
        public static void Main(string[] args)
        {
            
            //Creating a file read streamer:
            StreamReader readFromFile = new StreamReader(@"D:\error.txt"); // @ -> using the escape sequence
            //EXCEPTION HANDLING:
            try //try to do this without exception
            {
                Console.WriteLine(readFromFile.ReadToEnd()); //ReadToEnd will read all the content of the file (until the end).
            }
            //If there was an exception come to this catch statement
            //THIS IS A SPECIFIC CATCH, this is the child of EXCEPTION CLASS
            catch(FileNotFoundException fNotFound) //try to handle the exception with this object.
                //This object is mostly for FileNotFoundException.
            {
                //AN object of type FileNotFoundException contain more information about the file that could 
                //not be found then an object of type Exception (as we use in our case).
                Console.WriteLine(fNotFound.Message);
                Console.WriteLine("Check for the file: {0}", fNotFound.FileName);
            }
            //If the catch above was not able to handle the exception try this one:
            //THIS IS THE GENERAL CATCH (Exception class is the parent of all the other classes above.)
            catch(Exception ex) //this can handle also the DirectoryNotFoundException.
            {
                Console.WriteLine(ex.Message);
            }
            //THIS BLOCK IS ALWAYS EXECUTED while for the catch blocks is not a certainty which one is going to
            //be executed.
            finally //the finally block contain the code that should be executed by all means necessary
            {
                if(readFromFile!=null) //if the file is null then it cannot be closed.
                {
                    readFromFile.Close();
                }
            }
            //END OF EXCEPTION HANDLING.
            StreamWriter writeToFile = new StreamWriter(@"D:\writeToFile.txt");
            writeToFile.WriteLine("Project37 Read write to files, exeption handling Finally!");
            writeToFile.Close(); //the filestream needs to be closed for the writing to work.
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </exception-handling>
        <bitwise-operators>*General-Programming-Knowledge*</bitwise-operators>
        <default-parameters>*General-Programming-Knowledge*
<code>
//Example:

static void MyMethod(string country = "Norway") 
{
  Console.WriteLine(country);
}

static void Main(string[] args)
{
  MyMethod("Sweden");
  MyMethod("India");
  MyMethod();
  MyMethod("USA");
}

//OUTPUT:
// Sweden
// India
// Norway
// USA
</code>
        </default-parameters>
        <interfaces>*General-Programming-Knowledge*
<code>
using System;

/*An interface is mostly like a class but with some differences:
 1.An interface cannot have field members/variable members (can have only functions/methods, delegates, events or
proprieties).
 2.An interface cannot contain implementations for the functions/methods(an implementation of a function/method
is the code between the brackets).
 3.An interface has public fields set by default, so inside an interface you cannot use the public acces-modifier
for its members.
 4.A class CAN inherit from an interface. BUT with the condition of providing the implementation for all the
 interface function/method members.
 5.When a class provides implementation of an interface function member, it also needs to make the member function
 public. (The public access modifier must be used.)
 6.A class or struct can inherit from MORE interfaces in the same time. Whereas a class or struct cannot inherit from
 more then one class.
 7.An interface cannot be instanciated (an instance, object of the interface cannot be created), because doing this
 it would mean that you would be able to call a function from the interface, and the interface cannot contain
 implemented members.
 */

namespace project30_interfaces
{
    //Creating an interface:
    public interface Ifirst_interface //an interface name usually starts with I (capital i).
    {
        //int age; -> an interface cannot have such fields (variable fields).
        //public void Print(); -> an interface cannot contain public access modifier.
        void Print(); //this is a function of the interface.
    }
    public interface Isecond_interface : Ithird_interface
    {
        void Print2();
    }
    public interface Ithird_interface
    {
        void Print3();
    }
    class Program
    {
        public static void Main(string[] args)
        {
            Inherited_from_interface Iobject = new Inherited_from_interface();
            Iobject.Print();
            Iobject.Print3(); //calling the grandpa's function.
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    class Inherited_from_interface : Ifirst_interface, Isecond_interface
    {
        /*A class that inherits from an interface HAS to provide implementations for all the interface methods
         * members.
         */
        public void Print() //providing implementation for the interface function.
        {
            /*IMPORTANT: when providing implementation for an interface function/method member you have
             * to specify it to be public. (YOU need to use the public access modifier.)
             IF A CLASS inherits from multiple interfaces,  then the class has to provide implementation for all
             the interface members.
             IF A CLASS inherits from an interface which inherits from another interface, then the class has to
             provide implementation for both the parent interface and grandparent interface as well.
             */
            Console.WriteLine("Class inherited from an interface.");
        }
        public void Print2() //A method can be implemented like this. (The brackets can be empty.)
        {
            //By implementing a function inherited from an interface, you have to assure that the function
            //is public, and there exists the brackets (where the implementation should be made).
        }
        public void Print3() //this function is inherited from an interface which inherits from another interface.
        {
            Console.WriteLine("This is the grandpa's function!");
        }
    }
}
</code>
        </interfaces>
        <random-generators>*General-Programming-Knowledge*
<code>
using System;

namespace project68_random_numbers
{
    class Program
    {
        public static void Main(string[] args)
        {
            Random i = new Random();
            int nr;
            nr=i.Next(1,5);
            Console.WriteLine("Value: {0}",nr);
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </random-generators>
        <command-line-arguments>*General-Programming-Knowledge*</command-line-arguments>
        <ternary-operator>*General-Programming-Knowledge*
<code>
using System;

namespace project11_ternary_operator
{
    class Program
    {
        public static void Main(string[] args)
        {
            bool istrue;
            int simpletest;
            int number = 10;
            //Ternary Operator "?"
            istrue = number==10 ? true : false;
            //sinthax: boolean variable = condition ? value for true : value for false
            
            /*Equivalence of that:
             * if(number==10)
             * {
             *         istrue=true;
             * }
             * else
             * {
             *         istrue=false;
             * }
             */
            Console.WriteLine("The value of istrue is: {0}", istrue);
            //Other example:
            simpletest = number==10 ? 10+2 : 10-2;
            Console.WriteLine("The value of simpletest is: {0}", simpletest);
            
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </ternary-operator>
        <modular-programming>*General-Programming-Knowledge*</modular-programming>
        <string-methods>*General-Programming-Knowledge*
<code>
using System;
using System.Text; // using this for StringBuilder.
/*A stringbuilder is a data type just like string. The main difference between them is that the stringbuilder is mutable.
 Mutable means that once that is created the string can be changed, whereas System.string is not mutable, once created
 cannot be change. If you try to change a string after it was been initialized, the system will create another object of the string in
 memory and pass the new value of the string to that object, but the old object which holds the old value of the string will not be cleaned
 until the end of the program, when the garbage collector does its work.
 A stringbuilder should be used everytime when a string that's created tends to change its value, in this way, only a single object will
 be created in memory no matter how many times its value it will change, because it's mutable.
 */

namespace project46_working_with_string_builder
{
    class Program
    {
        public static void Main(string[] args)
        {
            //Creating a stringbuilder:
            StringBuilder stringbuiler = new StringBuilder("Adam"); //this is how a stringbuilder gets created and initialized
            //To concatenate string builders, there is a function called .Append();
            stringbuiler.Append(" has");
            stringbuiler.Append(" C#");
            stringbuiler.Append(" skills!");
            //Printing the stringbuilder:
            Console.WriteLine("{0}", stringbuiler);
            Console.WriteLine("{0}", stringbuiler.ToString()); //this is a better way to print the stringbuilder
            //Other stringbuilder operations:
            stringbuiler.Clear(); //clear the stringbuiler's content
            Console.WriteLine("{0}", stringbuiler);
            Console.WriteLine("Stringbuilder Capacity: {0}", stringbuiler.Capacity); //stringbuilder.Capacity returns the capacity of the
            //stringbuilder
            Console.WriteLine("Stingbuilder Max Capacity: {0}",stringbuiler.MaxCapacity);
            
            //End of program:
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </string-methods>
        <datatype-conversions>*General-Programming-Knowledge*
<code>
using System;

namespace project13_implicit__explicit__data_type_conversions
{
    class Program
    {
        public static void Main(string[] args)
        {
            /*An implicit conversion is done by the compiler when there are no loss of information. Also there is
             * no possibility of throwing exceptions during the conversion.
             * Example:
             */
            int numb1 = 100;
            float numb2 = numb1; //implicit conversion (done by the compiler).
            Console.WriteLine("The value of numb2 is: {0}", numb2);
            /*An explicit conversion is done by the programmer using type cast operators or predefined classes, 
             * data-conversion classes.
             Example:
             */
            float numb3=123.543f;
            numb1 = (int) numb3; //explicit conversion using type cast.
            Console.WriteLine("The value of numb1 is: {0}", numb1);
            numb1 = Convert.ToInt32(numb3); //explicit conversion using Conversion Class.
            Console.WriteLine("The value of numb1 is: {0}", numb1);
            /* Conversion Class - will throw an exception/message when the conversion fails because one variable
             * can't hold the value of the converted one.
             * Type Cast - will not throw any exception, will just print the minimum value that the variable 
             * can hold. 
             */
            
            //Parse Methods of converting string to int.
            string valueN = "199";
            numb1 = int.Parse(valueN); //parsing sinthax
            //in case if the string does not contain a valid number, an exception will be thrown. SO the program
            //will be terminated.
            Console.WriteLine("The value of numb1 after parsing is: {0}", numb1);
            
            //TryParse Methods of converting string to int.
            string valueB = "221a";
            int Result = 0;
            bool Success = int.TryParse(valueB, out Result); //sinthax of TryParse.    
            //if int.TryParsing is succesfull the bool Success will become true, else it will become false.
            //TryParse takes 2 arguments: the string to be converted and the variable that will stored the
            //converted result (if it is successful). If the TryParse is not successful the Result will not be 
            //changed.
            if(Success)
            {
                Console.WriteLine("The value of numb1 after tryparsing is: {0}", Result );
            }
            else
            {
                Console.WriteLine("The number is invalid. The conversion was unsuccesful!");
            }
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
<code>
using System;

namespace project30_explicit_vs_implicit_implementation
{
    interface I1
    {
        void Print(); //when there are 2 interfaces with identical function, which inherits into the same child
        //the explicit implementation must be used to avoid ambiguity.
    }
    interface I2
    {
        void Print();
    }
    interface I3
    {
        void MessageShow();
    }
    interface I4
    {
        void MessageShow();
    }
    class Program: I1,I2,I3,I4
    {
        public static void Main(string[] args)
        {
            Program soft = new Program(); //soft is reference variable for an object type Program stored in heap.
            soft.Print(); //calling the implicit implemented function
            
            //By TYPE CASTING - calling the explicit implemented functions.
            ((I3)soft).MessageShow(); //calling the explicit implemented function
            ((I4)soft).MessageShow(); //calling the explicit implemented function
            
            //By OBJECT REFERENCE - calling the explicit implemented functions.
            I3 explicit1 = new Program();
            I4 explicit2 = new Program();
            explicit1.MessageShow();
            explicit2.MessageShow();
            //END OF PROGRAM;
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
        //This is implicit implementation, the compilation and the runtime is fine, dispite that there is
        //a simple implementation for the both functions.
        public void Print()
        {
            Console.WriteLine("Implicit Implemetation!");
        }
        //Explicit Implementation:
        void I3.MessageShow() //when explicitly implementing a function the access modifiers are not allowed
        {
            Console.WriteLine("This is I3 function!");
        }
        void I4.MessageShow() //when explicitly implementing a function the access modifiers are not allowed
        {
            Console.WriteLine("This is I4 function!");
        }
    }
}
</code>
        </datatype-conversions>
        <optional-parameters>*General-Programming-Knowledge*
<code>
using System;
using System.Runtime.InteropServices; //using this for the [Optional] or [OptionalAttribute] attribute

/*WAYS OF ADDING OPTIONAL PARAMETERS:
 * 1.Using params arrays (optional arrays creating using params keyword as prefix).
 * 2.Methods overloading (overloading a method/function to provide many versions with different number of parameters);
 * 3.Methods with default parameter values.
 * 4.Methods that are using optional attribute.
 */

namespace project50_optional_parameters
{
    class Program
    {
        public static void Main(string[] args)
        {
            Program pr = new Program();
            Console.WriteLine("The result of adding 10, 3, 4, 6 is: {0}", pr.AddNumbers(10,3, new int[]{4,6}));
            Console.WriteLine("The result of adding 2 and 5 is: {0}", pr.AddNumbers(2,5));
            //Calling the second function:
            pr.PrintNrs(12);
            //To use the default value only for b (the second argument):
            pr.PrintNrs(1,c:22); //the value of b will be the default value (10);
            //To use default value only for c:
            pr.PrintNrs(1,2); //the value of c will be the default value (2);
            
            //CALLING THE OPTIONAL ATTRIBUTE FUNCTIONS:
            pr.DisplayArgs(1,3);
            pr.DisplayArgs(12,3,11);
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
        //Creating functions with default values:
        public int AddNumbers(int num1, int num2, int [] array = null) //sinthax is just like in C++;
        {
            int result=num1+num2;
            if(array!=null)
            {
                foreach (int i in array)
                {
                    result+=i;
                }
            }
            return result;
        }
        public void PrintNrs(int a, int b=10, int c=2) //for a function with default parameters, the parameters initialized with
            //default values must be the last in the list of parameters (just like in case of params arrays).
        {
            Console.WriteLine("Nr1= {0}\nNr2= {1}\nNr3= {2}", a, b, c);
        }
        
        //Creating functions with [Optional] attributes
        public void DisplayArgs(int num1, int num2, [Optional] int num3) //this can also be done with [OptionalAttribute].
        {
            //In case that num3 is not specified by the user, it's value will be 0.
            Console.WriteLine("The numbers are: {0}, {1}, {2}", num1,num2,num3);
        }
    }
}
</code>
        </optional-parameters>
        <partial-classes>*General-Programming-Knowledge*
<code>
using System;

/*A partial class its used to separate/split a class into two or more parts, across different files.
 If the part of the class are in different files, those files must be contained in the same assembly (directory of project), otherwise
 the compilation will fail. 
 A partial class can also be used in techniques of splitting an interface into more parts successfully.
 
 IMPORTANT: Without the partial keyword into the class declaration, the compiler will not know the intention of creating a partial class.
 All the parts of a partial class needs to be contained by the same namespace and assembly.
 All the parts must use the partial keyword in their declaration.
 All the parts must use the same access modifier in their declaration.
 If any of the parts is declared as abstract, the entire class will be abstract (even if only a part was declared abstract).
 If any of the parts is declared as sealed, the entire class will be sealed.
 If any of the parts is declared to be inherited from a a class, the entire class will be inherited from that class. IMPORTANT, different
 parts of the partial class cannot specify that they are inherited from different classes. (IN C# MULTIPLE CLASS INHERITANCE IS NOT ALLOWED).
 Different parts of the partial class can specify that they inherits from different interfaces, so after the compilation the partial class
 will be inherited from all the specified interfaces (even if they were specified in different parts of the class).
 The members declared to a part of the partial class are available to all the part of the partial class (available in the entire class).
 */


namespace project47_partial_classes
{
    class Program
    {
        public static void Main(string[] args)
        {
            //A partial class its used like a normal class.
            MyClass obj = new MyClass();
            obj.Age = 16;
            obj.Name = "Ellias";
            obj.PrintInfo();
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    //Example of partial class:
    partial class MyClass //the partial keyword must be used for all the parts of the class.
    {
        private string _Name;
        private int _Age;
        public int Age
        {
            get {
                return _Age;
            }
            set
            {
                _Age=value;
            }
        }
        public string Name
        {
            get {
                return _Name;
            }
            set
            {
                _Name=value;
            }
        }
        //THE SECOND PART OF THE CLASS IS IN THE ASSEMBLY DIRECTORY (PROJECT DIRECTORY), WITH THE NAME PartialClassPartTwo, AND
        //CONTAINS A METHOD CALLED PrintInfo().
    }
    
}
</code>
        </partial-classes>
        <decorators>*General-Programming-Knowledge*</decorators>
        <operators>*General-Programming-Knowledge*
<code>
using System;

namespace project12_new_types_null_coalescing_operator
{
    class Program
    {
        public static void Main(string[] args)
        {
            /*Non-Nullable type: Are Value TYPES: integers, boolean, double, float, long, long long, char...etc
             * Nullable type: Are Reference TYPES: classes, interface, delegates, arrays... etc
             * 
             * A Non-Nullable type can become Nullable type by using ? in their declaration.
             * Examples:
             */
            bool major = false; //non-nullable value type.
            bool ?minor = null; //nullable value type. 
            /*A nullable boolean type can hold on to 3 values: true, false or null.
             */
            Console.WriteLine("Are you a minor? Press Y/N to answear or anything else to skip.");
            char answear=Convert.ToChar(Console.ReadLine());
            switch(answear)
            {
                case 'y':  minor = true; break;
                case 'Y': minor = true; break;
                case 'n':  minor = false; break;
                case 'N': minor = false; break;
                default: minor = null; break;
            }
            if(minor==true)
            {
                Console.WriteLine("You are minor!");
            }
            else if(minor==false)
            {
                Console.WriteLine("You are not minor!");
            }
            else
            {    
                Console.WriteLine("You did not answear the question!");
            }
            //NULL COALESCING OPERATOR:
            int? TicketsOnSale = 100;
            int availableTickets=TicketsOnSale??0; //if TicketsOnSale is null, availableTickets will be 0, otherwise
            //availableTickets = (int)TicketsOnSale.
            /*Equivalent method:
             * if(TicketsOnSale==null)
             * {
             *         availableTickets=0;
             * }
             * else
             * {
             *         availableTickets=(int)TicketsOnSale; //TicketsOnSale is a nullable int, so it must be
             *         //casted to normal int.
             *         
             *         //Other method of casting:
             *         //available Tickets=TicketsOnSale.value;
             * }
             */
            Console.WriteLine("Available Tickets: {0}", availableTickets);
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </operators>
        <pre-post-incrementation>*General-Programming-Knowledge*</pre-post-incrementation>
    </programming_language>
    
    <programming_language>
        <name>JavaScript</name>
        <description>
            JavaScript often abbreviated as JS, is a programming language and core 
            technology of the Web, alongside HTML and CSS. 99% of websites use JavaScript 
            on the client side for webpage behavior.<br></br><br></br>

            Web browsers have a dedicated JavaScript engine that executes the client code. 
            These engines are also utilized in some servers and a variety of apps. The most 
            popular runtime system for non-browser usage is Node.js.<br></br><br></br>

            JavaScript is a high-level, often just-in-time compiled language that conforms 
            to the ECMAScript standard. It has dynamic typing, prototype-based 
            object-orientation, and first-class functions. It is multi-paradigm, 
            supporting event-driven, functional, and imperative programming styles. 
            It has application programming interfaces (APIs) for working with text, dates, 
            regular expressions, standard data structures, and the Document Object Model (DOM).
            <br></br><br></br>
            
            Difference between JavaScript and PHP is that JavaScript is running in the client computer's browser, and its performance
            depends only on the client computer's specifications. Whereas PHP is a programming language that runs on a server so when 
            the client is using a PHP script its computer will make a request to the server with the purpose of getting the compilation
            result and transfer that information back to the client computer. 
            <br></br><br></br>
            
            This action is significantly slower that the javascript
            because in case that the server is busy, that action might take place in a matter of seconds, or minutes. While in case of
            JavaScript the action completes almost instantaneos.
            <br></br><br></br>
            
            PHP is a back-end development language (related to the server), JavaScript is a front-end development language
            related to the client computer/machine.
        </description>
        <oop>*General-Programming-Knowledge*
            JavaScript is an object oriented programming language, having the 4 concept that any OOP language has:<br></br><br></br>
            1.Inheritance<br></br>
            2.Polymorphism<br></br>
            3.Encapsulation<br></br>
            4.Abstraction<br></br>
            <br></br><br></br>
            The objects can be classifed in 2 categories:<br></br>
            - standard built-in objects;<br></br>
            - custom objects;<br></br>
            <br></br><br></br>
            In Javascript there is no concept called "class", so an object will not be built based on classes, but based on 
            functions or literal notations (or singletons).<br></br>
<code>
//Creating an object using a function:

function Employee (firstName, lastName) //This will be the constructor;
{
    this.firstName=firstName;
    this.LastName=lastName;
    
    //This is an object method:
    this.getFullName = function () {
        return this.firstName + " " + this.LastName;
    }
}
//Creating an instance of the object:

var emp = new Employee("Black", "Yd");
document.write("First Name: " + emp.firstName + "&lt;br&gt;");
document.write("Last Name: " + emp.LastName + "&lt;br&gt;");
document.write("Full Name: " + emp.getFullName() + "&lt;br&gt;");

//Creating an object using a variable/literal notation or singleton:

var objct = { //in this case we already create an object.

//Here we are now describing the functionality of the object:

    firstName: "Alan", // In this case instead of equal sign we use colon operator and coma afterwards;
     lastName: "Walker",
    
    getFullName: function ()
    {
        return this.firstName + " " + this.lastName;
    }
} 

//Displaying the information about this objct:

document.write("&lt;br&gt;First Name: " + objct.firstName + "&lt;br&gt;");
document.write("Last Name: " + objct.lastName + "&lt;br&gt;");
document.write("Full Name: " + objct.getFullName() + "&lt;br&gt;");

/*
Differences between the 2 ways:

In the constructor case the properties are separed by their values using = operator, whereas in case
of literal notation we use : operator;

In contructor case we use ; to separate the properties, in literal notation we use , instead.

With the constructor method, you first need to create an object to can access its properties, but with literal
notation the object is already created and you can simply access it. 

Objects created using literal notation are singletons, this mean that when a value is changed for an object, it 
affects all the objects created. This is happening because all the objects created from literal notation will
reference the same set of values, so if any of them make a change, that change will affect the whole set of objects.
Whereas this is not the case using constructor objects.
*/

document.write("&lt;br&gt;Why singletons?&lt;br&gt;");
var a = { //Creating an object out of a;
    value:20,
}

var b = a; //Creating an object using the variable a;
document.write("&lt;br&gt;Before Changing value of obj2: &lt;br&gt;");
document.write("Object1: " + a.value + "&lt;br&gt;");
document.write("Object2: " + b.value + "&lt;br&gt;");
b.value=32;
document.write("&lt;br&gt;After Changing value of obj2: &lt;br&gt;");
document.write("Object1: " + a.value + "&lt;br&gt;");
document.write("Object2: " + b.value + "&lt;br&gt;");

/*
When to use Object Constructor or Object Literal

When multiple instances of an object are needed the object contructor will be used.
When single instance of an object is needed the object literal can be used.

Singleton means that the object cannot have multiple instances without affecting one another. That's why object literal
is a singleton.

The common used way of creating object in all the OOP languages is by using Object Constructor.
*/
</code>

<code>
/*
Reflection allows the inspection of meta data, assemblies, modules and type. If the object is derived from a base class than
reflection can also inspect the parent/base class data.
*/

var Class = function (objName, objID, objType) {
    //These are public fields:
    this.ObjectName = objName;
    this.ObjectID= objID;
    this.ObjectType = objType;
}

//These are public methods:
Class.prototype.getObjectName = function () {
    return this.ObjectName + "&lt;br&gt;";
}

Class.prototype.getObjectID = function () {
    return this.ObjectID + "&lt;br&gt;";
}

Class.prototype.getObjectType = function () {
    return this.ObjectType + "&lt;br&gt;";
}

var Class = new Class ("Car", "2", "Base Class");

//Creating a foreach loop:
for (var property in Class)
{
    //Checking if the property is a variable:
    if(typeof Class[property] != "function")
    {
        document.write(property + " : " + Class[property] + "&lt;br&gt;");
        //A property of class can be accessed using ClassName[foreach_variable].
    }
}

document.write("&lt;br&gt;");
//Another foreach loop:
for (var p in Class)
{
    //Checking if a property is not inherited:
    if( Class.hasOwnProperty(p) )
    {
        document.write(p + " : " + Class[p] + "&lt;br&gt;");
    }
    
    //Checking if a property is inherited:
    if( !Class.hasOwnProperty(p) )
    {
        document.write(p + " : " + Class[p] + "&lt;br&gt;");
    }
}
</code>
        </oop>
        <encapsulation>*General-Programming-Knowledge*
<code>

function Car ()
{
    //Creating private fields using the naming convention.
    var _speed;
    var _acceleration;
    
    //Creating properties: getters and setters
    Object.defineProperty(this, "speed", {
        get: function () {
            return _speed;
        } 
        , //using the coma operator to separate between get and set properties:
        set: function (value){
            _speed = value;
        }
    })
    
    /*
    This concept of using fields (getters and setter or get and set functions) is called encapsulation, being on of the
    4 OOP concepts. Encapsulation is used to control the methods in which private fields get initialized or return value.
    Private variables limit the access to data, and encapsulation provides a way of working with that data.
    */
    
    //The second way of creating getters and setters
    
    //Private methods:
    function getAccel()
    {
        return _acceleration;
    }
    function setAccel(value)
    {
        _acceleration = value;
    }
    
    //Privileged methods;
    this.getAcceleration = function() //this is a get function
    {
        return getAccel();
    }
    this.setAcceleration = function (value) //this is a set function
    {
        setAccel(value);
    }
    
    /*
    Remember that privileged methods can be accessed from anywhere, and apart of public methods, privileged methods
    are the only methods that can access directly private fields and functions. In the case of public methods this is
    not possible.
    */
    
}

var c = new Car();

//Now we can use this syntax for initializing the private fields:
c.speed = 12; //using the set:

document.write ("The car speed is " + c.speed + "&lt;br&gt;"); //using the get;

//Using the second way of encapsulation:

c.setAcceleration(22); //using the setter
document.write ("The car acceleration is " + c.getAcceleration() + "&lt;br&gt;"); //using the getter;
</code>
        </encapsulation>
        <polymorphism>*General-Programming-Knowledge*
<code>
/*
Polymorphism is the act of creating a collection of different object types (also called as an interface) which are inherited from the same base class. 
 A polymorphic type is one whose operations can also be applied to values of some other type, or types. When calling a virtual function from any derived
 class the method overrided will be invoked.
 
There are several fundamentally different kinds of polymorphism:
Ad hoc polymorphism: when a function has different implementations depending on a limited range of individually specified types and combinations. 
    Ad hoc polymorphism is supported in many languages using function overloading.
Parametric polymorphism: when code is written without mention of any specific type and thus can be used transparently with any number of new types. 
    In the object-oriented programming community, this is often known as generics or generic programming. In the functional programming community, 
    this is often shortened to polymorphism. 
Subtyping (also called subtype polymorphism or inclusion polymorphism): when a name denotes instances of 
    many different classes related by some common superclass
*/

//Creating polymorphism in javascript:

//Creating a base class;
var Shape = function() { }
//Adding a function to the class:
Shape.prototype.draw = function () {
    return "I am a generic shape.";
}

//Creating another class
var Circle = function () {}

//Doing the inheritance:
Circle.prototype = Object.create(Shape.prototype);

//Overriding the base class function:
Circle.prototype.draw = function ()
{
    return "I am a circle shape.";
}

//Doing the same thing again:

var Square = function () {}
Square.prototype = Object.create(Shape.prototype);
Square.prototype.draw = function () 
{
    return "I am a square shape.";
}

//Creating a collection of objects:

var collection = [new Shape(), new Circle(), new Square()];

//Iterating through the collection / Creating a foreach loop:
collection.forEach(function (shape) {
    document.write(shape.draw() + "&lt;br&gt;");
})
</code>
        </polymorphism>
        <inheritance>*General-Programming-Knowledge*
<code>
/*
Inheritance is one of the 4 OOP concepts aside: encapsulation, abstraction, polymorphism.

Inheritance consist in classes that can inherit other classes behaviour and functionality. Example: A class that inherits
from another class can have access to its variables and methods as if it were its own.

In other programming languages a class inherits from another class, since in Javascript there is no classes, an object will
only inherit from another object (this is called prototype based inheritance). Also there is NOT possible for a constructor to
inherit from another constructor. A constructor can inherit only from an instance of another (also called object.)
*/

//Creating a singleton object constructor:

var Vehicle = function (Name, Traction)
{
    this.name = Name;
    this.traction = Traction;
}

/*
Creating a function object constructor will work as well:

function Vehicle(Name, Traction)
{
    this.name = Name;
    this.traction = Traction;
}
*/

//Creating a function using the prototype object:
Vehicle.prototype.getName = function ()
{
    return this.name;
}
Vehicle.prototype.getTraction = function()
{
    return this.traction;
}

//Creating another singleton object:

var car = function (speed, acceleration) 
//Inheritance can also be made using the first singleton object(var Vehicle), as well, but the main 
//fields should be initialized first, the example is below:
{
 //this keyword refers to the current instance's field.
    this.speed = speed;
    this.acceleration = acceleration;
}

//Creating an object from the singleton constructor:
var vehicle = new Vehicle("Bike", "2 wheels");

//Creating the inheritance:
car.prototype = vehicle; //Now the any object of the car constructor is a child of the "vehicle" object.

//Creating an object of the constructor "car".
var c = new car(22, 109); 

document.write("The following fields are inherited: &lt;br&gt;");
document.write("Name: " + c.getName() + "&lt;br&gt;"); //calling the function inherited from parent object.
document.write("Traction: " + c.getTraction() + "&lt;br&gt;"); //calling the function inherited from parent object.

/*Adding a new method to the parent object will automatically be available to the child object as well.

.hasOwnProperty() - this method will check whether a property/field/variable is defined on the actual 
object or prototype. By that it can be found all the inherited properties.
*/

document.write("Is Name a Property of c Object: " + c.hasOwnProperty("name") + "&lt;br&gt;");
document.write("Is Speed a Property of c Object: " + c.hasOwnProperty("speed") + "&lt;br&gt;");

/*
Another Example. Inheritance from the first object of the singleton:
*/
document.write("Singleton Nume: " + Vehicle.name + "&lt;br&gt;");
Vehicle.name = "Something";
Vehicle.traction = "4 wheels";
document.write("Singleton Nume: " + Vehicle.name + "&lt;br&gt;");

function Class (num)
{
    this.number = num;
}
Class.prototype = Vehicle;
var clas = new Class(4)

document.write("Inherited From Singleton: " + clas.name + "&lt;br&gt;");

/*
Inheritance can be realized without singletons as well:
function Class (num)
{
    this.number = num;
}

var cl = new Class(7);

function B (name)
{
    this.name = name;
}
B.prototype = cl;

var bb = new B("Alan");

document.write(bb.number + " is perfectly valid" + "&lt;br&gt;");
*/
</code>
        </inheritance>
        <abstraction>*General-Programming-Knowledge*
<code>
/*
Abstraction is one of the 4 OOP concepts, and it is regarded to abstract objects, which are the objects
that contain fields and methods to be inherited by their children. An abstract object is like a dead parent
which has to allow inheritance to their children and nothing more.

Abstract object constructors are those constructors that cannot be instantiated. That means 
that no object can be created out of them. 
The purpose of using such constructors is to provide inheritance to other prototypes. In this way
the functionality can be shared amongst the objects without needing any instances.

To block a constructor from being instantiated, an error will be thrown in such case.
*/

function House ()
{
    this.personName = "";
    
    //This will block anyone from creating an instance with this constructor.
    throw Error ("Cannot instantiate an abstract object.");
    
}

//This is a public-static method of House object;
House.prototype.printMsg = function()
{
    document.write("Printing a message!" + "&lt;br&gt;");
}

function Home(pn)
{
    //Using the base object (Home) field named personName;
    personName = pn;
    
    this.getHomeOwnerName = function ()
    {
        return personName;
    }
}

//Creating the inheritance:
Home.prototype = Object.create(House.prototype); //House is gonna be the base class for Home constructor
/*
Object.create - will create an object without using the constructor.
*/

//Creating an instance of the child object:
var h = new Home("Adrian");

//Using the child object method and parent object field:
document.write("Owner's name: " + h.getHomeOwnerName() + "&lt;br&gt;");
document.write("Is name owned by this class: " + h.hasOwnProperty("personName") + "&lt;br&gt;");
document.write("Is h instance of House: " + (h instanceof House) + "&lt;br&gt;")
document.write("Is h instance of Home: " + (h instanceof Home) + "&lt;br&gt;")

//Calling the base object method;
h.printMsg();
</code>
        </abstraction>
        <generic-programming>*General-Programming-Knowledge*</generic-programming>
        <variable-arguments-lists>
<code>
/*The argument object is used to store the value of arguments of a function.
Accessing the argument object outside a function will result in undefined error.
The argument object is not an array, but it only has one property of the array, and that is .length
*/

function Myfct(a,b,c)
{
    document.write("The function has: " + arguments.length + " arguments.&lt;br&gt;");
    //arguments.length will return the number of arguments that was passed to the function. Not the number
    //of parameters that the function has. 
    
    /*
    Example: the function has 3 parameters: a,b,c but it was called using 5 arguments: 0,1,3,4,5.
    */
    
    document.write("&lt;br&gt;The arguments are: &lt;br&gt;");
    for (var i =0; i&lt;arguments.length; i++)
    {
        document.write(" " + arguments[i] + " ");
    }
    document.write("&lt;br&gt;");
    
}; //Don't forget the semicolon here

Myfct(0,1,3,4,5); //In JavaScript a function can be called using any number of arguments. The unnecessary ones
//will be ignored.

//Creating a function with various number of arguments;

function getSum() //See how the function is declared without any parameters but it is called with aLinkcolor
//various number of arguments each time.
{
    var sum=0;
    for (var i=0; i&lt;arguments.length; i++)
    {
        sum+=arguments[i];
    }
    return sum;
    
}; //Don't forget the semicolon here.

document.write("&lt;br&gt;The sum of all the arguments is: " + getSum(1,12,3,22,1,3,4,22) + "&lt;br&gt;");
document.write("The sum of all the arguments is: " + getSum(-2,10,4,21) + "&lt;br&gt;"); 
//the function was called with different number of arguments each time and it worked fine.
</code>
        </variable-arguments-lists>
        <simple-data-types>
<code>
    Javascript is a dynamical type language this means that any variable can store any data type: 
    Example: 
    var A = 22;
    A="My string";
    This is perfectly valid, because the var size and type will be automatically converted as needed.

    Variables and function as in other programming languages they are case sensitive this means that var A is different
    from var a; and function A () {} is different from function a() {};

    Data Types: 
    Numbers: 22, 22.4, 44;
    Strings: "me", "you" //they can also be like single quoted: 
    'me', 'you'
    boolean: true, false; 
    All the variables are declared using the var keyword.
</code>
        </simple-data-types>
        <loops>*General-Programming-Knowledge*
<code>
/*Recursion is a programming concept available to all programming languages including JavaScript.

A recursive function, is a function that calls itself.
A recursive function needs to have a condition or break statement in order to stop the recursion and 
to avoid infinite loops and stack overflow.

Recursion is a method where the solution to a problem depends on solutions to smaller instances 
of the same problem (as opposed to iteration). Example: 5! = (4!*5) = (3! * 4 * 5) = (2! *3 *4 *5) etc.
*/

function RecursiveFunc(num)
{
    if (num &lt;= 1)
    {
        return 1;
    }
    else
    {
        return num * RecursiveFunc(num-1);
        //This will be equivalent to n* n-1* n-2* n-3* ...... *1; when it reaches 
        //1 all the functions will end
        
    }
    
    /*
    Using the loop the whole code above is equivalent to:
        var result=1;
        while(num > 1)
        {
            result*=num;
            num-=1;
        }
    */
};

document.write("This was a recursive function: " + RecursiveFunc(5) + "&lt;br&gt;");

/*
Recursion vs Loops:

Use the loop. It's easier to read and understand (reading code is always a lot harder than writing it), 
and is generally a lot faster.

Recursion is useful when it is the natural way of viewing the problem, but you must be sure that there 
is a manageable number of stack frames involved. A stack frame is a bunch of memory assigned to the stack 
memory when a function is called, if the stack frames exceeds the stack memory capacity, the stack overflow
error will terminate the program.
*/

document.write("&lt;br&gt;With Loops&lt;br&gt;");
var i;
for(i=0;i&lt;10;i++)
    document.write(i+" ");
    
//The equivalent recursive function is:

document.write("&lt;br&gt;With Recursion&lt;br&gt;");

function Rec(a)
{
    if(a&lt;10)
    {
        document.write(a + " ");
        Rec(a+1);
    }
};

Rec(0);
</code>        
        </loops>
        <collections>*General-Programming-Knowledge*</collections>
        <collection-methods>*General-Programming-Knowledge*
<code>
//Creating an array without a constructor:

var arr = ["James", 10, 2];
/*
An array is a collection of variable, and in JavaScript a variable can take any type of values. So
that's why the array above has a string and 2 integers in it.
*/

document.write("The length of arr is: " + arr.length + "&lt;br&gt;");
for (var i=0;i&lt;arr.length; i++)
{
    document.write(arr[i] + " ");
}
document.write("&lt;br&gt;&lt;br&gt;");

//Creating an array using the constructor

var arr2 = new Array(5); // the 5 between the parenthesis specifies the length.
//The elements of arr2 are not initialized

document.write("The length of arr2 is: " + arr2.length + "&lt;br&gt;");
for (var i=0;i&lt;arr2.length; i++)
{
    document.write(arr2[i] + " ");
}
document.write("&lt;br&gt;&lt;br&gt;");

//Another ways to create an array:
var arr3 = []; //Creating an array (without constructor), the size is not specified.

/*
Dispite the other C-like languages, creating an array using this syntax make it resizeable.
*/
arr3[0]= 22; //the array length is now 1.
arr3[4]= 44; //the array length is now 2.

document.write("The length of arr3 is: " + arr3.length + "&lt;br&gt;");
for (var i=0;i&lt;arr3.length; i++)
{
    document.write(arr3[i] + " ");
}
document.write("&lt;br&gt;&lt;br&gt;");

var arr4 = new Array(26,8,1994); //Creating an array using constructor, the elements are specified.

/*
The elements can be specified while creating an array using a constructor, by using multiple arguments when
calling it. So, you cannot create and initialize an array with a single element, using this syntax. 
*/

document.write("The length of arr4 is: " + arr4.length + "&lt;br&gt;");
document.write("This element was returned using pop method: " + arr4.pop() + "&lt;br&gt;");
document.write("The new length of arr4 is: " + arr4.length + "&lt;br&gt;");
document.write("This element was returned using shift method: " + arr4.shift() + "&lt;br&gt;");
document.write("The new length of arr4 is: " + arr4.length + "&lt;br&gt;");
for (var i=0;i&lt;arr4.length; i++)
{
    document.write(arr4[i] + " ");
}
document.write("&lt;br&gt;&lt;br&gt;");

/*
OTHER METHODS:

These are Mutator methods:
.push() - This method adds a new item at the end of the array.
.pop() - This method removes and returns the last item from the array.
.unshift() - This method adds a new item at the beginning of the array.
.shift() - This method removes and returns the first element of the array.

All the methods above change the size of the array. In JavaScript an Array is much like a Vector or a 
List, being dynamic in length (resizeable).

.reverse() - This method reverse the element order of an Array Object (the last element becomes the first, etc).
.sort() - This method sorts the items of an array (alphabetical, descending or ascending, etc).
.slice() - This method returns a shallow copy of a portion of an array into a new array object selected 
from begin to end (end not included). The original array will not be modified. It can be used for adding
or removing a group of item after the specified index. It takes 3 parameters:
    .splice(index, deleteCount, item1,.... itemX)
    where:
    index - specifies at what position to add or remove items;
    deleteCount - specified the number of elements to be removed, if 0 no elements will be removed.
    item1...itemX - optional, specifies the elements to be added at specified index in the array.

The 3 methods above change the content of the array object.

A mutator method is a method that change or modify the array object (in size or content).

Non-mutator methods:
.contains() - This method returns a boolean value specifying if the searched value is present in the array or not.
.lastIndexOf() - This method returns the position of the last occurrence of a specified value.
.indexOf() - This method returns the position of the first occurrence of a specified value.

*/
</code>
        </collection-methods>
        <serialization>*General-Programming-Knowledge*</serialization>
        <deserialization>*General-Programming-Knowledge*</deserialization>
        <constructors>*General-Programming-Knowledge*</constructors>
        <instantiation>*General-Programming-Knowledge*</instantiation>
        <destructors>*General-Programming-Knowledge*</destructors>
        <function-overloading>*General-Programming-Knowledge*
<code>
/*
Prototype object of a constructor function it is used for creating static methods or methods 
which share their code between all of the instances.

Advantages of using Prototype object for adding functions:

-no matter how many objects are created, functions are loaded only once into the memory. Every instance sharing the same code.
-it allows function overriding, if necessary.

Syntax for creating function using prototype:
ConstructorName.prototype.FunctionName = function () { function definition }
*/


//Creating a constructor for an object:
function Computer (ProcessorSpeed, Memory)
{
    this.CPU_core = ProcessorSpeed;
    var Memory = Memory;
}

var pc = new Computer (3.2, 200);
var pc2 = new Computer (3.4, 2000);

//Adding a function only to an instance of the object:
pc.getName = function ()
{
    //This function is public and can access only with the public fields:
    return this.CPU_core;
}

//Adding a private function to all the instances of the object:
Computer.printMessage = function () //this function will be private.
{
    return "this is a message";
}

document.write("Instance function: " + pc.getName() + "&lt;br&gt;");
//document.write("Instance function2: " + pc2.getName() + "&lt;br&gt;"); //this will throw an error
//because getName() method is define only for pc instance.


//document.write("Function Inst1: " + pc.printMessage() + "&lt;br&gt;"); //this will throw an error, because the function is private
//document.write("Function Inst2: " + pc2.printMessage() + "&lt;br&gt;"); //this will throw an error, because the function is private


//Adding a function using the prototype object:
Computer.prototype.printMsg = function () //this code will be executed until the function will be overrided.
{
    alert("This function is created using prototype object.");
}

//Calling the function:
pc.printMsg();
pc2.printMsg();

//Function Overriding:

Computer.prototype.printMsg = function () //from this moment on, when calling printMsg() method, this code will be executed.
{
    alert("This function war overrided.");
}

//Calling the overrided function:
pc.printMsg();

/*
Similarly built-in functions can be overrided as well:

Example:
var alert = function(msg)
{
    document.write (msg + "&lt;br&gt;")
}
*/

</code>
        </function-overloading>
        <operator-overloading>*General-Programming-Knowledge*</operator-overloading>
        <multi-threading>*General-Programming-Knowledge*
        <br></br><br></br>
        JavaScript is a single threaded language which does not support multithreading. <br></br>
        All the operations in JavaScript are non-blocking and are executed in the event loop. <br></br>
        This single-threaded nature along with event loop allows JavaScript to handle concurrent operations at once.<br></br>
        </multi-threading>
        <namespaces>*General-Programming-Knowledge*
<code>
/*
In JavaScript there is no concept called function overriding. So when creating 2 functions with the same name and different
number of arguments, the function declared later will replace the function declared sooner, in the global namespace. This
process is called namespace pollution (or name collision). Also if the scripts are written in different files, the file 
which is loaded last will replace the function declared into the file which was loaded first.

It is possible to declare 2 functions with the same name, but not in the same namespace. Similarly with creating 2 
variables with the same name but in different scope (global and local).

The global namespace in JavaScript can be accessed using window.Object - where object is an item in the global 
namespace "window".
*/

//Example of namespace pollution

function PrintSomething()
{
    alert("This is the first function.");
}

function PrintSomething() //this function will replace the first function declared above;
{
    alert("This is the second function.");
}

//Creating a namespace;

var NameSpace = NameSpace || {} // Create a variable named NameSpace if such an object already exists, than my variable will
//take its value, otherwise my variable will be an empty object {};

//Creating a nested namespace/object;

NameSpace.a = NameSpace.a || {} //If NameSpace.a exists than my variable NameSpace.a will take its value otherwise 
//it will be an empty object {}.

//Creating an object into the nested namespace:
NameSpace.a.print = function () 
{
    this.PrintMessage = function ()
    {
        alert("Message from the nested object.");
    }
}

//Creating an instance of the nested namespace object.
var a = new NameSpace.a.print;
//Setting the object method for the onclick button.
document.getElementById("but2").onclick = a.PrintMessage;

/*
Another example of creating a namespace:
    var yourNamespace = {

        foo: function() {
        },

        bar: function() {
        }
    };

    ...

    yourNamespace.foo();
*/
</code>
        </namespaces>
        <exception-handling>*General-Programming-Knowledge*
<code>
/*
Exceptions handling can be used to handle runtime errors:

try/catch blocks can catch exceptions but not syntax errors.
*/

try{
    //The code that can produce exception will be put here:
    document.write(sayHello()); //calling undefined function will cause an exception;
    
    document.write("This line will be skipped, once the exception was caught.&lt;br&gt;");
}
catch(e) //e is the type of exception to be caught;
{
    document.write("Error. Calling undefined function.&lt;br&gt;&lt;br&gt;");
    document.write(e.description+"&lt;br&gt;");
    document.write(e.message+"&lt;br&gt;");
    document.write(e.stack+"&lt;br&gt;");
}
finally //this will be executed no matter what.
{
    /*The code in this block will be executed regardless if there was an exception or no.*/
    document.write("&lt;br&gt;Finished. &lt;br&gt;");
}

//This line will create an execution error and because it's not caught the script execution will crash.
//document.write(sayHello()); //calling undefined function;
//document.write("Nothing happens here. Since the script crashed because of the error above.");



//Throwing customized exceptions:

function Fraction(a,b)
{
    try
    {
        if (b==0)
        {
            throw { //creating a custom exception.
                //Completing the exception properties:
                
                error: "Divide by zero error." ,  //here is coma not semicolon
                message: "Denominator cannot be ZERO."
            }
        }
        else{
            return a/b;
        }
    }
    catch(e) //catching the custom exception
    {
        document.write("Exception caught. " + e.error + "&lt;br&gt;");
        document.write(e.message + "&lt;br&gt;");
    }
};

var a = parseInt(prompt("Enter a number for nominator: "));
var b = parseInt(prompt("Enter a number for denominator: "));

document.write("&lt;br&gt;The result a/b is: " + Fraction(a,b) + "&lt;br&gt;");


//Using window.onerror for handling errors:
/*
Once the window.onerror is initialized with a function which takes 3 arguments: msg, url, line. Any error
that will occur will execute that code.
*/

window.onerror = function (msg, url, line){
    //This code will be executed each time an error occur, without the need of try/catch blocks.
    alert("Message: " + msg + "\nURL: " + url + "\nLine: " + line);
    return true;
}

//Raising window.onerror by calling undefined function:
UndefinedFunction();

/*
window.onerror is not displayed if it's places in a try/catch block, instead of that the try/catch will
handle it by itself.

window.onerror is raised only when there is an unhandled exception.
*/

//Handling an html element error:
function ImageErrorHandler() //this function will be executed when the html image will have an error.
{
    alert("The image is not present.");
}
</code>
        </exception-handling>
        <bitwise-operators>*General-Programming-Knowledge*</bitwise-operators>
        <default-parameters>*General-Programming-Knowledge*</default-parameters>
        <interfaces>*General-Programming-Knowledge*</interfaces>
        <random-generators>*General-Programming-Knowledge*<br></br>
            Generate a random whole number between 1 and 10 (inclusive):
            <br></br><br></br>
            <code>let x = Math.floor((Math.random() * 10) + 1);</code>
        </random-generators>
        <ternary-operator>*General-Programming-Knowledge*
<code>
function Funct()
{
    var a = document.getElementById('textBox').value;
    //Using if statement (if statement is used to execute code when a particular condition is true)
    if(isNaN(a))
    {
        document.getElementById('textBox').value+= " 'is not a number.'";
    }
    else //if the condition above is not true, then it will execute this code.
    {
        document.getElementById('textBox').value+= " is a number.";
    }

    //using ternary operator to change the color of the textbox:
    (isNaN(a)==true) ? alert("Entered ternary if.") //this part will be executed if the condition
    //in pharanteses is evaluated to true. 
                    : alert("Entered ternary else.") //this part is executed otherwise.
                    
    /*
    Ternary operator is also called the short if, and has the same functionality as an if statement, the only thing that
    differs is that ternary operator sinthax is shorter, and yet harder to be read, that way is much better to use if
    else if statements instead.
    */

    //using switch()
    if(isNaN(a) == false)
    {
        a = parseInt(a);
        switch(a) //switch works only with constant values, integer, long, chars values. switch cannot be used with floats
        //or doubles or strings just like in other programming languages.
        {
            case 1: {alert("you have entered 1."); break} // the break statement will break out of the switch.
            case 2: {alert("you have entered 2."); break}
            case 3: {alert("you have entered 3."); break}
            default : {alert("you have entered a number above 3 or below 1."); break}
            //the default case is equivalent to else statement, it will be executed only of the cases above do not match.
        }    
    }
    /*
    switch is very similar to an if, else if, else block, and even better a switch statement is faster in execution.
    */
}
</code>
        </ternary-operator>
        <modular-programming>*General-Programming-Knowledge*
            Minification of Javascript consists in reducing the amount of JavaScript files used in a webpage as well as reducing
            the size of each file, in order to optimize the server amount of requests from the client machine.
            <br></br><br></br>
            Instead of using 4 JavaScript files, it will be used a single file, and instead of arranging the code in that file to
            be readable, it will be arranged in such a way that the size will be reduced by removing unnecessary characters such used
            spaces, newline characters and comments.
        </modular-programming>
        <string-methods>*General-Programming-Knowledge*
<code>
    /*
    Example of global replacements in a string:
    var string1 = "Blue bottle on a blue table."
    var result = string1.replace(/blue/g , "green") // result will be: Blue bottle on a green table.
    result = string1.replace(/blue/gi, "green") // result will be: green bottle on a green table.
    
    Regular Expresions:
    // g - > comes from global, which will replace each occurance of the specified word, or expression in the string1
    // i -> come from insesitive, which won't take in count if it's blue, or Blue or bLuE, or whatever.
    //string.replace won't change the original string it will just return a string with the replacements made, but
    //the original string will still hold the same value.
    
    Substring methods:
    string1.substring(1, 4); will return the string: Blu, the forth character it won't be included:
    string1.substring(4, 1); will produce the same result as above, because the function will swap the values 4 with 1, 
    because the start value needs to be smaller than the end value. The value at the second parameter is not included
    in the returned result.
    
    string1.substring(4); will return a string containing all the character from 4th character until the end of the 
    string. so that will be: "e bottle on a blue table."
    
    string1.substr(1,4): has the same functionality as the function above, But it doesn't swap the parameters, and the 
    second parameter specifies the last caracter to be returned.
    
    string1.slice(1,4): has the same functionality as the functions above, except that slice method won't swap the 
    parameters, no matter if the start is greater than the end. (in that case it will return an empty string)
    
    string1.indexOf("B") : this function will return the index of "B" which is 0;
    string1.lastIndexOf(b) : this will return the last index of specified value "b" which is: 17
    */
</code>
        </string-methods>
        <datatype-conversions>*General-Programming-Knowledge*
            <br></br><br></br>
            JavaScript variables can be converted to a new variable and another data type - 
            the following functions can help with that: <br></br><br></br>
            Number()        Returns a number, converted from its argument<br></br>
            parseFloat()    Parses a string and returns a floating point number<br></br>
            parseInt()        Parses a string and returns an integer<br></br>
            String()        Converts to string<br></br>
        </datatype-conversions>
        <operators>*General-Programming-Knowledge*
<code>
Plus operator:
var a = 10;
var b = 20;
a + b will result 30;

var a = "10";
var b = 20;
a + b will result 1020;  //b will be converted to string and then concatenated with a.

Minus operator:
var a = "10";
var b = 20;
a-b will result -10, becausse the string a will be automatically converted to a number.
</code>
        </operators>
        <pre-post-incrementation>*General-Programming-Knowledge*</pre-post-incrementation>
    </programming_language>
    
    <programming_language>
        <name>Java</name>
        <description>
            Java is a high-level, class-based, object-oriented programming language that is 
            designed to have as few implementation dependencies as possible.<br></br><br></br>
            It is a general-purpose programming language intended to let programmers write once, 
            run anywhere meaning that compiled Java code can run on all platforms that support 
            Java without the need to recompile. <br></br><br></br>
            
            Java applications are typically compiled to bytecode that can run on any 
            Java virtual machine (JVM) regardless of the 
            underlying computer architecture. The syntax of Java is similar to C and C++, 
            but has fewer low-level facilities than either of them. The Java runtime provides 
            dynamic capabilities (such as reflection and runtime code modification) that are 
            typically not available in traditional compiled languages.
        </description>
        <oop>*General-Programming-Knowledge*</oop>
        <encapsulation>*General-Programming-Knowledge*
<code>
/*
The can be multiple classes in the same package. A package is actually the folder/directory
that contains the .java files. All the packages are actually created inside the directory: \project6\src
SO every folder inside the src directory is a package.

In java each class must have its own .java file. There cannot be multiple classes in the same file,
unless some of them are inner classes (class inside another class).

Encapsulation is one of the four fundamental OOP concepts. The other three are inheritance, polymorphism, and abstraction.

Encapsulation in Java is a mechanism of wrapping the data (variables) and code acting on the data (methods) together as a 
single unit. In encapsulation, the variables of a class will be hidden from other classes, and can be accessed only through 
the methods of their current class. Therefore, it is also known as data hiding.
*/

//PACKAGE needs to be written before the IMPORTS;
package project6;
import java.util.Random;
import java.util.Scanner;

public class DiceClass {
    int Faces;
    int StartingValue;
    //Creating a constructor for the class;
    public DiceClass(int numberOfFaces, int FirstValueOnDie) //A constructor is like a method/functions that is used
            //to initialized all the ValueType Variables inside the class. A constructor has the same name as
            //the class, and it doesn't need a return type, because it's not meant to return anything.
    {
        Faces = numberOfFaces;
        StartingValue = FirstValueOnDie;
    }
    //Public Functions/Methods:
    private int RollTheDice()
    {
        //Creating a random generator seeded with time (by default);
        Random newRandomGenerator = new Random(); // seeded by time;
        //Get a random number between 0 and Faces's Value;
        int ShownValue = newRandomGenerator.nextInt(Faces);
        //Increase that value with the StartingValue
        ShownValue+=StartingValue;
        //Return the result
        return ShownValue;
    }
    public void PrintTheDieValue()
    {
        Scanner myscanner = new Scanner(System.in);
        String UserInput = "DEFAULT";
        while(UserInput.toUpperCase().compareTo("X")!=0)
        {
            if(UserInput.toUpperCase().compareTo("DEFAULT")!=0     &#38;&#38; UserInput.toUpperCase().compareTo("A")!=0)
            {
                System.out.printf("Please enter only \"A\" or \"X\n");
            }
            else
            {
              System.out.printf("Press \"A\" to roll the dice, OR press \"X\" to quit!\n");
            }
            UserInput = myscanner.next();
            if(UserInput.toUpperCase().compareTo("A")==0)
            {
                System.out.printf("The value from dice is: %d\n", RollTheDice());
            }
        }
    }
    //ENCAPSULATIONS IS THE GOOD USE OF GETTERS AND SETTERS FOR GETTING OR SETTING THE VALUE OF
    //A FIELD INSIDE THE CLASS.
    /*
    CONVETIONS:
    -good programmer use private fields for a class. (A field is a variable declared in the class)
    -good programmers use at least a constructor for a class. (And that constructor is used to initialize the
    fields.)
    -good programmers use encapsulation for controling the value that get in or get out from the fields
    -a method inside a class is also called property of the class, there can be public or private properties
    */
}

</code>
        </encapsulation>
        <polymorphism>*General-Programming-Knowledge*
<code>
class Bike{  
  void run(){System.out.println("running");}  
}  
class Splendor extends Bike{  
  void run(){System.out.println("running safely with 60km");}  
  
  public static void main(String args[]){  
    Bike b = new Splendor();//upcasting  
    b.run();  
  }  
}  
</code>
        </polymorphism>
        <inheritance>*General-Programming-Knowledge*
<code>
package project25;

public class Product {
    private String name;
    private double Price;
    public Product(String NewName, double NewPrice)
    {
        this.name = NewName;
        this.Price = NewPrice;
    }
    //Getters:
    public String GetName()
    {
        return this.name;
    }
    public double GetPrice()
    {
        return this.Price;
    }
    public String GetType()
    {
        return "Product";
    }
}

</code>
<code>
package project25;

public class Books extends Product {
    private String Author;
    private int NrOfPages;
    public Books(String NewAuthor, int NewNrOfPages, String NewName, double NewPrice)
    {
        super(NewName, NewPrice); 
        //super refers to the parent class, so it will call the constructor of the parent class, and it will
        //initialize the two fields Price and Name.
        this.Author = NewAuthor;
        this.NrOfPages = NewNrOfPages;
    }
    //Getters:
    public String GetAuthor()
    {
        return this.Author;
    }
    public int GetNrOfPages()
    {
        return this.NrOfPages;
    }
    //Overriding the function of the parent class
    @Override
    public String GetType()
    {
        return "Book";
    }
}
</code>
        </inheritance>
        <abstraction>*General-Programming-Knowledge*
<code>
/*
As per dictionary, abstraction is the quality of dealing with ideas rather than events. 
For example, when you consider the case of e-mail, complex details such as what happens as soon as you send 
an e-mail, the protocol your e-mail server uses are hidden from the user. Therefore, to send an e-mail you 
just need to type the content, mention the address of the receiver, and click send.

Likewise in Object-oriented programming, abstraction is a process of hiding the implementation details from 
the user, only the functionality will be provided to the user. In other words, the user will have the 
information on what the object does instead of how it does it.

In Java, abstraction is achieved using Abstract classes and interfaces.
A class which contains the abstract keyword in its declaration is known as abstract class.

Abstract classes may or may not contain abstract methods, i.e., methods without body ( public void get(); )
But, if a class has at least one abstract method, then the class must be declared abstract.
If a class is declared abstract, it cannot be instantiated.
To use an abstract class, you have to inherit it from another class, provide implementations to the abstract 
methods in it.
If you inherit an abstract class, you have to provide implementations to all the abstract methods in it.

 */
package project26;

/**
 *
 * @author Black2
 */
public abstract class AbstractClass {
    private String PersonName;
    private int PersonAge;
    public abstract void PrintMessage(); //abstract functions can only be public.
    //Getters:
    public String GetPersonName()
    {
        return this.PersonName;
    }
    public int GetAge()
    {
        return this.PersonAge;
    }
    public AbstractClass(String Name, int Age)
    {
        this.PersonName = Name;
        this.PersonAge = Age;
    }
    //Setters:
    public void SetAge(int Age)
    {
        this.PersonAge = Age;
    }
    public void SetName(String Name)
    {
        this.PersonName = Name;
    }
    
}

</code>
        </abstraction>
        <generic-programming>*General-Programming-Knowledge*
<code>
/*
A generic class declaration looks like a non-generic class declaration, except that the class name is 
followed by a type parameter section.

As with generic methods, the type parameter section of a generic class can have one or more type parameters 
separated by commas. These classes are known as parameterized classes or parameterized types because they 
accept one or more parameters.
 */
package project29;
//The sinthax for a generic class is just like a basic class dispite that it contains: &lt;T&gt;, which is the type
//object, for the parameter.
public class GenericClass &lt;T&gt; {
   private T t;

   public void set(T t) {
      this.t = t;
   }

   public T get() {
      return t;
   }
}

</code>

<code>
/*
Generics is related to using the correspondant object of a primitive data type as it is for int (primitive) -> 
-> Integer(object), for double(primitive) -> Double(object) etc.

Generic methods are methods that can be called with arguments of different types.
Based on the types of the arguments passed to the generic method, the compiler handles each method 
call appropriately. Following are the rules to define Generic Methods.

This is possible only by using objects, but in Java each data type has an object correspondant. 

The java.lang.Integer class wraps a value of the primitive type int in an object. An object of type Integer 
contains a single field whose type is int.
*/
package project29;

import java.util.Scanner;

/**
 *
 * @author Black2
 */
public class Project29 {

    public static void main(String[] args) {
        Integer [] myArray = new Integer[] {1,42,13,24,5};
        Character [] myCharArray = new Character[] {'D', 'N', 'C', 'A'};
        printArray(myArray);
        printArray(myCharArray);
        //Using the GenericClass:
        GenericClass &lt;Integer&gt; FirstGeneric_Class = new GenericClass&lt;Integer&gt;();
        FirstGeneric_Class.set(2);
        System.out.printf("Value of GenericClass object: %d\n", FirstGeneric_Class.get());
        //Keep the window opened until a key is pressed:
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    //Creating a generic function:
    public static &lt; E &gt; void printArray( E[] inputArray ) {
      // Display array elements
      for(E element : inputArray) {
         System.out.printf("%s ", element);
      }
      System.out.println();
    }
}
/*
Another example of using generics:
public final class Integer extends Number implements Comparable&lt;Integer&gt;
*/
</code>
        </generic-programming>
        <variable-arguments-lists>*General-Programming-Knowledge*
<code>
// Java program to demonstrate varargs
 
class Test1 {
    // A method that takes variable 
    // number of integer arguments.
    static void fun(int... a)
    {
        System.out.println("Number of arguments: "
                           + a.length);
 
        // using for each loop to display contents of a
        for (int i : a)
            System.out.print(i + " ");
        System.out.println();
    }
 
    // Driver code
    public static void main(String args[])
    {
        // Calling the varargs method with 
        // different number of parameters
       
        // one parameter
        fun(100); 
           
          // four parameters
        fun(1, 2, 3, 4); 
         
          // no parameter
          fun(); 
    }
}
</code>
        </variable-arguments-lists>
        <simple-data-types>*General-Programming-Knowledge*
<code>
package project2;
//This import here, is like an include directive in C/C++, or like an using directive in C#
//It has the purpose of telling the compiler which functioning you use, and where to find them.

import java.util.Scanner;
public class Project2 { //just like in C# it is mandatory that the main function be contained by a class.
    public static void main(String[] args) {
        //Creating a scanner in order to take the input;
        Scanner myscanner = new Scanner(System.in);
        String Name; //in Java strings needs to be declared using String keyword (with capital S);
        int Age;
        double height=11.1;
        boolean IsFemale; //In Java the bool type got renamed to boolean.
        //In Java a variable cannot be displayed if it doesn't get initialized.
        String gender;
        System.out.printf("Enter you name: ");
        //Creating a scanner for inputting;
        Name = myscanner.nextLine();
        System.out.printf("Enter you age: ");
        Age = myscanner.nextInt(); //if any other data it's entered that cannot be converted into a integer
        //an exception will be thrown.
        System.out.printf("Enter your height: ");
        //if any other type it's entered that cannot be converted into a float, an exception will be thrown.
        height = myscanner.nextDouble();
        //Printing the stored information:
        System.out.printf("Are you a female? (True or False)\n");
        IsFemale = myscanner.nextBoolean();
        
        //Using the ternary operator:
        gender = IsFemale? "Female" : "Male";
        //Printing the information:
        System.out.printf("Hello %s. Your age is %d, and you're %f tall. \n", Name, Age, height);
        System.out.printf("%s, you are a %s!\n", Name, gender);
        //System.out.print(MyByte); => this code is not valid, because the variable MyByte is never
        //initialized so it cannot be displayed.
        System.out.printf("Press any key to terminate!\n");
        myscanner.next();
    }
    
}
/*
DOCUMENTATION ABOUT DATATYPE IN JAVA:
Data Type     Default Value (for fields)
byte                    0
short                   0
int                     0
long                    0L
float                   0.0f
double              0.0d
char                    '\u0000'
String (or any object)   null
boolean                 false
*/
</code>
        </simple-data-types>
        <complex-data-types>*General-Programming-Knowledge*</complex-data-types>
        <loops>*General-Programming-Knowledge*
<code>
package project7;

import java.util.Scanner;

/*
Loops: a loop is a sequence of instructions that is continually repeated until a certain condition is reached.
*/
public class Project7 {
    public static void main(String[] args) {
        //Using FOR LOOP for multiplication table:
        System.out.printf("USING FOR LOOP:\n");
        for (int i = 1; i&lt;4; i++) // SINTHAX: for (initialization, condition, incrementation) just like in c, c++, c#
        {
            System.out.printf("Multiplication Table with %d:\n", i);
            for (int j = 1; j&lt;11; j++)
            {
                System.out.printf("%d * %d = %d\n", i, j, i*j);
            }
            System.out.println();
        }
        //Using WHILE LOOP for multiplication table:
        int i=4,j=1;
        System.out.printf("USING WHILE LOOP:\n");
        while(i&lt;7) //SINTHAX: while (condition) just like in c, c++, c#
        {
            System.out.printf("Multiplication Table with %d:\n", i);
            while(j&lt;11)
            {
                System.out.printf("%d * %d = %d\n", i, j, i*j);
                j++;
            }
            System.out.println();
            j=1;
            i++;
        }
        i=7; j=1;
        System.out.printf("USING DO WHILE LOOP:\n");
        do{ //SINTHAX DO{this stuff} while(condition);
            System.out.printf("Multiplication Table with %d:\n", i);
            do{
                System.out.printf("%d * %d = %d\n", i, j, i*j);
                j++;
            }while(j&lt;11);
            System.out.println();
            j=1;
            i++;
        }while(i&lt;10);
        /*
        Nested LOOPS is a term used for one loop inside another.
        */
        int [] arrayC = {1,2,3,4,5,6,7,8,9,10};
        System.out.printf("USING FOREACH LOOP:\nMultiplication Table with 10:\n");
        for (int k : arrayC)
        {
            System.out.printf("10 * %d = %d\n", k, 10*k);
        }
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
}
/*
DIFFERENCES: WHILE LOOP AND FOR LOOP ARE VERY SIMILAR, DISPITE THAT FOR LOOP USES INITIALIZATION, AND
INCREMENTATION WITHIN ITS DECLARATION, WHILE LOOP DOESN'T
as while sinthax is this: while (condition) {do stuff}, for can be written just the same way
ignoring the initialization part, and incrementation part for(condition){do stuff}

DO WHILE DISPITE FOR AND WHILE LOOPS IT GUARENTEES THAT THE CERTAIN LOOP WILL BE EXECUTED AT LEAST
ONCE, BECAUSE THE EVALUATION OF THE CONDITION IT IS MADE AFTER THE LOOP  CODE BLOCK.

FOREACH LOOP it's used exclusively for collection like arrays, vectors, lists and so on, with
a FOREACH LOOP you can iterate through all the items in that collection and to access them as well.
SINTHAX: for(collection_data_type ITERATOR_NAME : COLLECTION_NAME);
EXAMPLE: if we have an int [] arrayDATA, a foreach loop for that would be: for(int NAME : arrayDATA);
so ITERATOR_NAME can have any name, and it doesn't need to be declared, you just put a name in there
and then you use that name to access each element.
*/
</code>
        </loops>
        <collections>
<code>
package project11;
import java.util.Scanner;
import java.util.Vector; //using this for Vector class.
/**
 * AN ARRAY IS A COLLECTION OF DATA OF THE SAME TYPE, WITH FIXED SIZE AND CAPACITY.
 A VECTOR IS A DYNAMIC ARRAY, THAT CAN CHANGE IT's SIZE/CAPACITY, and ITS AUTOMATICALLY CHANGING IT's CAPACITY
 * IN JAVA A VECTOR CAN STORE ANY TYPE OF DATA/OBJECT.
 * A VECTOR OF OBJECTS CAN MIX DIFFERENT TYPES TOGETHER, LIKE INTEGERS AND STRINGS.
 */
public class Project11 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Vector myVector = new Vector(3); //creating a vector (of objects by default) of size 3;
        //Creating a vector of integers:
    Vector &lt;Integer&gt; Vector2 = new Vector(); //using the default constructor, this vector will have
        //by default the size 10;
        System.out.printf("The capacity of the myVector before adding elements: %d\n", myVector.capacity());
        System.out.printf("The size of myVector before adding elements: %d\n", myVector.size());
    //A Vector of object can mix different types of data together.
        myVector.add(21);
        myVector.add(55);
        myVector.add(77);
        myVector.add(192);
        myVector.add("Name");
        System.out.printf("The capacity of the myVector after adding 5 elements: %d\n", myVector.capacity());
        System.out.printf("The size of myVector after adding 5 elements: %d\n", myVector.size());
        System.out.printf("The capacity of the Vector2 is: %d\n", Vector2.capacity());
        /*
        THE CAPACITY INCREASES AUTOMATICALLY WHEN IT's EXCEEDING ITS INITIAL VALUE.
        */
        System.out.printf("The index of NAME is: %d\n", myVector.indexOf("Name"));
        //Displaying elements:
        int i = 0;
        //USING FOREACH LOOP TO ITERATE THROUGH THE VECTOR:
        for(Object k : myVector)
        {
           if(i&lt;myVector.indexOf("Name"))
           {
               System.out.printf("vector [%d] = %d\n", i, Integer.parseInt(k.toString()));
           }
           else
           {
               System.out.printf("vector [%d] = %s\n", i, k.toString());
           }
           i++;
        }
        //SOME VECTOR FUNCTIONS:
        Object [] array = myVector.toArray(); //converting vector into array;
        //ITERATE THROUGH ARRAY:
        for(i=0;i&lt;array.length; i++)
        {
            System.out.printf("array[%d] = %s\n", i, array[i].toString());
        }
        myVector.insertElementAt("NAME2", 3); //insert element at index 3;
        myVector.removeElementAt(4); // remove element at index 4;
        i=0;
        //USING WHILE TO ITERATE THROUGH VECTOR:
        while(i&lt;myVector.size())
        {
            System.out.printf("myVector[%d] = %s\n", i, myVector.elementAt(i).toString());
            i++;
        }
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
}
</code>

<code>
package project16;
/*
Stack is a subclass of Vector that implements a standard last-in, first-out.
Stack only defines the default constructor, which creates an empty stack. Stack includes all the methods 
defined by Vector, and adds several of its own.
A stack has the same properties as a vector, it's dynamic in size, can store objects, so it can hold
any type of data... they get automatically resized to fit the objects pushed in.
*/
import java.util.Scanner; //used for Scanner class;
import java.util.Stack; //used for stack collection;

/**
 *
 * @author Black2
 */
public class Project16 {

    public static void main(String[] args) {
        Stack newStack = new Stack(); //Stack of objects
    Stack&lt;Integer&gt; intStack; //Stack of integers;
        //Adding object on stack...
        newStack.add(5);
        newStack.add(5);
        newStack.add(33);
        newStack.add(135);
        newStack.add(25);
        System.out.printf("The element on top of stack is: %d\n", newStack.peek());
        System.out.printf("The element on bottom of the stack is: %d\n", newStack.firstElement());
        //Stacks have the same methods, fields and functionality as vectors.
        Scanner myscanner = new Scanner (System.in);
        myscanner.next();
    }
    
}
</code>

<code>
/*
The Dictionary class is an abstract class that defines a data structure for mapping keys to values.
This is useful in cases where you want to be able to access data via a particular key rather than an 
integer index.
Since the Dictionary class is abstract, it provides only the framework for a key-mapped data structure 
rather than a specific implementation.
Given a key and value, you can store the value in a Dictionary object. Once the value is stored, you can 
retrieve it by using its key. Thus, like a map, a dictionary can be thought of as a list of key/value pairs.
The Dictionary class is obsolete. You should implement the Map interface to obtain key/value storage 
functionality.
*/
package project17;

import java.util.Dictionary; //used for dictionary;
import java.util.Scanner; //used for Scanner class;
import java.util.Hashtable; //used for the hashtable;
import java.util.Enumeration; //used for enumeration;

/**
 *
 * @author Black2
 */
public class Project17 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        //It can be constructed like this also: Dictionary myDict = new Hashtable();
        Dictionary &lt;Integer, String&gt; myDict = new Hashtable(); //creating a dictionary with Integer Keys, and
        //String Content.
        myDict.put(1, "Alan Walker");
        myDict.put(2, "Adam Lambert");
        myDict.put(3, "Tokio Hotel");
        myDict.put(4, "Deryck Whibley");
        myDict.put(5, "Avril Lavigne");
        Enumeration&lt;Integer&gt; MyKeys = myDict.keys();
        Enumeration&lt;String&gt; MyNames = myDict.elements();
        System.out.printf("Size of Dictionary: %d\n", myDict.size());
        //Using for loop to access dictionary:
        for(int i=0; i&lt;myDict.size(); i++)
        {
            System.out.printf("Name: %s     Key: %s\n", MyNames.nextElement(), MyKeys.nextElement());
        }
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
}
</code>

<code>
/*
The ArrayList class extends AbstractList and implements the List interface. 
ArrayList supports dynamic arrays that can grow as needed. This gives us a new collection data type that
can be used exactly as Vectors, Lists, Stacks, Dictionaries etc. 
Array lists are created with an initial size. When this size is exceeded, the collection is automatically 
enlarged. When objects are removed, the array may be shrunk.

SINTHAX: (all these sintaxes are correct)
ArrayList al = new ArrayList(); //creates an array list;
ArrayList&lt;Integer&gt; al = new ArrayList(); // creates an int arraylist;
ArrayList&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;(); // creates an int arraylist;

NOTE: TO create an int, double, float arraylist there must be used an object of that class, and for int
the object is Integer, for double the object is Double.

Functions of an ArrayList are similar to functions of a Vector or List, or Stack, or Dictionary, you can 
call Add() function, Remove(), RemoveAt() etc.
*/
package project20;

import java.util.ArrayList; //including this here for ArrayList Collection type.
import java.util.Scanner;

/**
 *
 * @author Black2
 */
public class Project20 {
    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; al = new ArrayList();
        al.add(22);
        al.add(44);
        al.add(59);
        //Accessing the elements:
        for(int i: al)
        {
            System.out.printf("%d ", i);
        }
        System.out.println();
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
}

</code>
        </collections>
        <collection-methods>
<code>
public boolean add(E e)        //It is used to insert an element in this collection.
public boolean addAll(Collection&lt;? extends E&gt; c)    //It is used to insert the specified collection elements in the invoking collection.
public boolean remove(Object element)    //It is used to delete an element from the collection.
public boolean removeAll(Collection&lt;?&gt; c)    //It is used to delete all the elements of the specified collection from the invoking collection.
default boolean removeIf(Predicate&lt;? super E&gt; filter)    //It is used to delete all the elements of the collection that satisfy the specified predicate.
public boolean retainAll(Collection&lt;?&gt; c)    //It is used to delete all the elements of invoking collection except the specified collection.
public int size()    //It returns the total number of elements in the collection.
public void clear()    //It removes the total number of elements from the collection.
public boolean contains(Object element)    //It is used to search an element.
public boolean containsAll(Collection&lt;?&gt; c)    //It is used to search the specified collection in the collection.
public Iterator iterator()    //It returns an iterator.
public Object[] toArray()    //It converts collection into array.
public &lt;T&gt; T[] toArray(T[] a)    //It converts collection into array. Here, the runtime type of the returned array is that of the specified array.
public boolean isEmpty()    //It checks if collection is empty.
default Stream&lt;E&gt; parallelStream()    //It returns a possibly parallel Stream with the collection as its source.
default Stream&lt;E&gt; stream()    //It returns a sequential Stream with the collection as its source.
default Spliterator&lt;E&gt; spliterator()    //It generates a Spliterator over the specified elements in the collection.
public boolean equals(Object element)    //It matches two collections.
public int hashCode()    //It returns the hash code number of the collection.
</code>
        </collection-methods>
        <dynamic-memory-allocation>
            Heap space is used for the dynamic memory allocation of Java objects and JRE classes 
            at runtime. <br></br>
            New objects are always created in heap space, and the references to these objects 
            are stored in stack memory. <br></br>
            These objects have global access and we can access them from anywhere in the 
            application.<br></br>
        </dynamic-memory-allocation>
        <read-from-file>For a concrete example - see the sample from Serialiation.</read-from-file>
        <write-to-file>For a concrete example - see the sample from Serialiation.</write-to-file>
        <serialization>*General-Programming-Knowledge*
<code>
package project23;

import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Scanner;

/**
 *
 * @author Black2
 */
public class Project23 {

    /**
     * @param args the command line arguments
     */
    //Making main function able to throw IOException, such that I don't need to use try catch blocks.
    public static void main(String[] args) throws IOException {
        File myfile = new File ("textFile.txt");
        try{
            
            //THESE STATEMENTS NEEDS TO BE PLACED INSIDE A TRY CATCH BLOCK:
            PrintWriter myPrintWriter = new PrintWriter(myfile);
            myPrintWriter.println("This is a TEXT File!");
            System.out.println("File has been successfully created!");
            //Closing the file:
            myPrintWriter.close(); //if the file doesn't get closed the modifications made to it 
            //won't get saved.
        }
        catch(IOException e)
        {
            System.out.printf("File: %s\n", e);
        }
        //Reading from the file:
        try{
            Scanner readerfile = new Scanner(myfile);
            String Message = readerfile.nextLine();
            //If this line is reached it means that there is no exception thrown.
            System.out.printf("FILE MESSAGE: %s\n", Message);
        }
        catch(IOException e)
        {
            System.out.println(e);
        }
        //Creating a collection of HumanClass objects:
        ArrayList&lt;HumanClass&gt; myList = new ArrayList();
        myList.add(new HumanClass(22, "Adam Lambert"));
        myList.add(new HumanClass(44, "Jackie Chan"));
        //Creating a file to store these objects:
        File myObjectsFile = new File ("objectFile.txt");
        //Serializing an object:
        try{
            FileOutputStream fo = new FileOutputStream(myObjectsFile);
            ObjectOutputStream os = new ObjectOutputStream(fo);
            for(HumanClass s:myList)
            {
                //Writing objects to a file ca be made only using binary mode. So that file will not contain
                //readable text.
                os.writeObject(s);
            }
        }
        catch(FileNotFoundException e)
        {
            System.out.printf("File not found: %s", e);
        }
        //Deserializing an object from the file:
        ArrayList&lt;HumanClass&gt; ObjectRead = new ArrayList();
        FileInputStream fi = new FileInputStream(myObjectsFile);
        ObjectInputStream oi = new ObjectInputStream(fi);
        try{
            while(true) //this loop will terminate when the catch block will terminate, and the catch block will
                //terminate then EOFException will be thrown.
            {
               HumanClass e = (HumanClass) oi.readObject(); //this will read until the file ends. 
               //When it cannot read any more object from the file it will throw an EOFException that needs
              //to be catched, and handled, otherwise the program will terminate.
              ObjectRead.add(e);
            }
        }
        catch(ClassNotFoundException e)
        {
             System.out.printf("File not found: %s", e);
        }
        catch(EOFException b) //Once the file was done reading, it will catch this exception.
        {
            System.out.println("\nDone reading the objects:\n");
            //Let's print the objects now:
            for(HumanClass s:ObjectRead)
            {
                System.out.printf("Name: %s, Age: %d\n", s.GetName(), s.GetAge());
            }
        }
        //Keep the console opened until I press a key.
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
}

</code>
        </serialization>
        <deserialization>*General-Programming-Knowledge*
        <br></br>
        For a concrete example - see the sample from Serialiation.
        </deserialization>
        <constructors>*General-Programming-Knowledge*</constructors>
        <instantiation>*General-Programming-Knowledge*</instantiation>
        <destructors>*General-Programming-Knowledge*</destructors>
        <function-overloading>*General-Programming-Knowledge*
<code>
// Java Program for Method overloading
// By using Different Types of Arguments 
 
// Class 1
// Helper class
class Helper {
 
    // Method with 2 integer parameters
    static int Multiply(int a, int b)
    {
        // Returns product of integer numbers
        return a * b;
    }
 
    // Method 2
    // With same name but with 2 double parameters
    static double Multiply(double a, double b)
    {
        // Returns product of double numbers
        return a * b;
    }
}
 
// Class 2
// Main class
class GFG {
    // Main driver method
    public static void main(String[] args)
    {
        // Calling method by passing
        // input as in arguments
        System.out.println(Helper.Multiply(2, 4));
        System.out.println(Helper.Multiply(5.5, 6.3));
    }
}
</code>
        </function-overloading>
        <operator-overloading>*General-Programming-Knowledge*
<code>
public class Vec {
   private float x, y, z;

   public Vec(float x, float y, float z) {
       this.x = x;
       this.y = y;
       this.z = z;
   }
   //Overloading the operator +
   public Vec plus(Vec other) {
       return new Vec(x + other.x, y + other.y, z + other.z);
   }
}
</code>
        </operator-overloading>
        <enums>*General-Programming-Knowledge*
<code>
/*
Enums can have constructors, and it needs to have contructors if they are provided with values.
 */
package project18;

public enum Directions {
    //Defining the fields:
    South(0), West(180), North(90), East(260);
    private final int Degrees; // a place to store the value for each field.
    
    //This constructor has the role of initializing the above fields with their values:
    Directions(int degreesNew)
    {
        this.Degrees = degreesNew;
    }
    public int GetDegrees()
    {
        return this.Degrees;
    }
}
/*
Enums make the code more readable, and instead of providing value and later on trying to convert values
from int to string, enums provides both string values and int values in the same patch.
*/
</code>

<code>
/*
The Enumeration interface defines the methods by which you can enumerate (obtain one at a time) the elements 
in a collection of objects.
Enumerations must not be confused with enums. They are different types, different objects, with different
utility.
 */
package project15;

import java.util.Enumeration; //used for enumerations;
import java.util.Scanner; // used for scanner class;
import java.util.Vector; //used for vectors;

/**
 *
 * @author Black2
 */
public class Project15 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
    //Creating an enumeration of objects;
        Enumeration Days; //enumerations cannot be initialized with an object of type enumeration;
    //because enumeration is abstract interface.
    Enumeration &lt;Integer&gt; intEnumeration; //enumeration of integers;
        Vector myVect = new Vector (3); //vector of objects
        myVect.add("Sunday");
        myVect.add("Monday");
        myVect.add("Friday");
        Days = myVect.elements(); //the elements from vector gets transfered to enumeration.
        while(Days.hasMoreElements())
        {
            System.out.println(Days.nextElement());
        }
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
}
</code>
        </enums>
        <multi-threading>*General-Programming-Knowledge*
<code>


// Java code for thread creation by extending
// the Thread class
class MultithreadingDemo extends Thread {
    public void run()
    {
        try {
            // Displaying the thread that is running
            System.out.println(
                "Thread " + Thread.currentThread().getId()
                + " is running");
        }
        catch (Exception e) {
            // Throwing an exception
            System.out.println("Exception is caught");
        }
    }
}
 
// Main Class
public class Multithread {
    public static void main(String[] args)
    {
        int n = 8; // Number of threads
        for (int i = 0; i &lt; n; i++) {
            MultithreadingDemo object
                = new MultithreadingDemo();
            object.start();
        }
    }
}
</code>
        </multi-threading>
        <namespaces>*General-Programming-Knowledge*</namespaces>
        <exception-handling>*General-Programming-Knowledge*
<code>
/*
try{} catch{} finally{} blocks is a way that you can trace errors and instead of doing the default exit from
the program you could follow another path.
SINTHAX:
try{ //doing the code that can throw an exception}
catch(//this kind of exception) {//if the exception has been caught, do this code here}
finally{//no matter if there was thrown an exception or not, just do this code here. THIS WILL ALWAYS BE EXECUTED}
 
the finally block is not mandatory. It is possible to have only try and catch blocks.
*/
package project22;
import java.util.InputMismatchException;
import java.util.Scanner;
/**
 *
 * @author Black2
 */
public class Project22 {
    public static void main(String[] args) {
        Scanner myscanner = new Scanner(System.in);
        try{
            System.out.println("Enter an integer: ");
            int number = myscanner.nextInt();
            //This code will run only if the line above doesn't produce an exception.
            System.out.printf("You entered: %d\n\n", number);
            //Throwing a Custom Exception:
            if(number>10||number&lt;0)
            {
                throw new CustomExceptionOutRange();
            }
        }
        //Handle the input mismatch exception:
        catch(InputMismatchException e)
        {
            System.out.println("You didn't entered an integer!\n");
        }
        //Handle the custom exception:
        catch(CustomExceptionOutRange r)
        {
            System.out.println("Your number is out of range!\n");
        }
        //This code gets executed anyhow.
        finally
        {
            System.out.println("Thank you for running this!");
        }
        myscanner.next();
    }
    
}

</code>
<code>
/*
This is the way of creating Custom Exceptions. You just create a class of the name you want and it make it
extends the Exception class.

IMPLEMENTS vs EXTENDS:
extends is for extending a class, for inheritance from another class.
implements is for implementing an interface.

Inheritance, extends the functionality of a class into another.
Interfaces, exhibits the same characteristics to multiple classes.

The difference between an interface and a regular class is that in an interface you can not implement any 
of the declared methods. Only the class that "implements" the interface can implement the methods. 
The C++ equivalent of an interface would be an abstract class (not EXACTLY the same but pretty much).

Also java doesn't support multiple inheritance for classes. This is solved by using multiple interfaces.
*/
package project22;

/**
 Making this class inherits from Exception class.
 */
public class CustomExceptionOutRange extends Exception{
    
}
</code>
        </exception-handling>
        <bitwise-operators>*General-Programming-Knowledge*</bitwise-operators>
        <default-parameters>*General-Programming-Knowledge*
<code>
public void doSomething(String name, int age, String city = "New York") {  
  // code to perform some action  
}  
</code>
        </default-parameters>
        <interfaces>*General-Programming-Knowledge*
<code>
/*
Just like classes, there can be only one interface in a .JAVA file. Java does not allow that interfaces and
classes to be defined in the same file.
There can be inner interfaces also, this is the only way to write 2 interfaces in the same .JAVA file.

 */
package project13;

/**
 *
 * @author DrVa
 */
public interface ToDoListInterface { //this is the outer interface
    public interface Numbers{ //this is the inner interface
        int findMax(int a, int b, int c);
    }
    void PrintMessage(String message);
}
</code>

<code>
/*
An interface is a reference type in Java. It is similar to class. It is a collection of abstract methods. 
A class implements an interface, thereby inheriting the abstract methods of the interface.

Along with abstract methods, an interface may also contain constants, default methods, static methods, and 
nested types. Method bodies exist only for default methods and static methods.

Writing an interface is similar to writing a class. But a class describes the attributes and behaviors of 
an object. And an interface contains behaviors that a class implements
 */
package project13;

//ONCE THAT A CLASS implement AN INTERFACE THAT CLASS IS OBLIGED TO PROVIDE IMPLEMENTATIONS FOR ALL THE
//METHODS IN THE INTERFACE:
import java.util.Scanner;

//THIS CLASS IS OBLIGED TO PROVIDE IMPLEMENTATIONS FOR ToDoListInterface and ToDoListInterface.Numbers
public class Project13 implements ToDoListInterface, ToDoListInterface.Numbers {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        //Creating an object of the class:
        Project13 InstanceOfClass = new Project13();
        InstanceOfClass.PrintMessage("This is a function that came from an interface!");
        System.out.printf("Max number is: %d\n", InstanceOfClass.findMax(12, 33, 21));
        Scanner myscanner = new Scanner (System.in);
        myscanner.next();
    }
    
    //IF Project13 class WILL NOT PROVIDE IMPLEMENTATIONS FOR THIS... THE PROGRAM WOULD NOT COMPILE.
    public void PrintMessage(String Message){
        System.out.println(Message);
    }
    public int findMax(int a, int b, int c)
    {
        //USING TERNARY OPERATOR:
        return a>b? a>c? a : c : b>c? b : c;
    }
}
/*
PROPERTIES OF INTERFACES:
An interface is implicitly abstract. You do not need to use the abstract keyword while declaring an 
interface.
Each method in an interface is also implicitly abstract, so the abstract keyword is not needed.
Methods in an interface are implicitly public.

SIMILARITIES BETWEEN INTERFACES AND CLASSES:
An interface can contain any number of methods.
An interface is written in a file with a .JAVA extension, with the name of the interface matching the name 
of the file.
The byte code of an interface appears in a .class file.
Interfaces appear in packages, and their corresponding bytecode file must be in a directory structure that 
matches the package name.

DIFFERENCES BETWEEN INTERFACES AND CLASSES:
You cannot instantiate an interface.
An interface does not contain any constructors.
All of the methods in an interface are abstract.
An interface cannot contain instance fields. The only fields that can appear in an interface must be declared 
both static and final.
An interface is not extended by a class; it is implemented by a class.
An interface can extend multiple interfaces.


*/
</code>
        </interfaces>
        <random-generators>*General-Programming-Knowledge*
<code>
package project37;

import java.util.Random;
import java.util.Scanner;

/**
 *
 * @author Black2
 */
public class Project37 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner myscanner = new Scanner(System.in);
        System.out.printf("Thinking of a number between 0 and 100:\n\n");
        Random rand = new Random();
        int Number = rand.nextInt(101);
        int choice = 101;
        int NrOfTries=0;
        while(Number!=choice)
        {
            System.out.printf("What is the number?\n");
            do{
                System.out.printf("Number = ");
                choice = myscanner.nextInt();
            }while(choice&lt;0 || choice>100);
            if(Number==choice)
            {
                System.out.printf("Congratulations, the number was: %d\n", Number);
            }
            else if(Number&lt;choice)
            {
               System.out.printf("Your number is too high, try a lower one!\n");
            }
            else
            {
                System.out.printf("Your number is too low, try a higher one!\n");
            }
            System.out.println();
            NrOfTries++;
        }
        System.out.printf("You required %d tries to guess the number!\n", NrOfTries);
        //Keep the console opened.
        myscanner.next();
    }
    
}
</code>
        </random-generators>
        <command-line-arguments>*General-Programming-Knowledge*
<code>
package Args_main;

//Working with command prompts arguments.

//IMPORTING PACKAGE:
import java.util.Scanner;

public class Args_main{
    public static void main(String[] args) { //args will store the command prompt arguments -- if any
        //Supposingly we have some arguments in args[]
        
        int [] lenNrs = Args_main.NumberOrNo(args); //convert them to numbers or get their string length
        Sorting(lenNrs, args); //sort the numbers of lenghts
        
        System.out.printf("Sorting by length or value: \n\n");
        for (int i=0; i&lt;args.length; i++)
        {
            System.out.printf("%d &lt;--&gt; %s\n", lenNrs[i], args[i]); //print results
        }
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
        //cursor to the next line.
        
    }
    public static int[] NumberOrNo(String[] arguments) //we shall return an array
    {
        int[] someArray = new int[arguments.length]; //lets build an array of the same length as arguments array
        for (int i=0; i&lt;arguments.length; i++)
        {
            try{
                someArray[i] = Integer.parseInt(arguments[i]); //try to convert to int
            }
            catch (Exception e){
                someArray[i] = arguments[i].length(); // if not succesfull then we are having a letter string / word
                //take out it's length
            }
        }
        return someArray;
    }
    
    public static void Sorting (int[] nrsOrNo, String[] arguments) //no need to return anything, lists/arrays are always passed by reference
    {
        //DO the sorting thing
        for (int i=0; i &lt; nrsOrNo.length; i++)
        {
            for (int j=0; j&lt;nrsOrNo.length; j++ )
                if (nrsOrNo[j] &lt; nrsOrNo[i])
                {
                    int temp = nrsOrNo[i];
                    nrsOrNo[i] = nrsOrNo[j];
                    nrsOrNo[j] = temp;
                    String argTmp = arguments[i];
                    arguments[i] = arguments [j];
                    arguments [j] = argTmp;
                }
        }
    }
}

</code>
        </command-line-arguments>
        <ternary-operator>*General-Programming-Knowledge*</ternary-operator>
        <modular-programming>
            *General-Programming-Knowledge*
            <br></br>
            Java Module System provides an additional layer of encapsulation to our programs as we can specify which package 
            can be utilized by the modules, and which modules could have entry to to them. 
            <br></br><br></br>
            Difference Between Module and Package<br></br>
            The principal difference between the module and package is given below.<br></br>
            <br></br><br></br>
            1. Module: In easy words, we can say that the module is a set of related applications or It is 
            a collection of related applications such that it affords an API handy to different modules that are 
            internal and encapsulated.
            <br></br><br></br>
            Suppose permits take an example from the built-in module in Java let’s take java.util for example. <br></br>
            If we expect java.util as a module we recognize that there are a variety of instructions and sub-packages 
            inside the java.util. <br></br>
            Now we’ve assumed that java.util is a package deal the modules could be like 
            java.util.Collections and java.util.stream.
            <br></br><br></br>
            2. Package: A package is a set of classes, interfaces, and sub-packages that are similar. 
            There are mainly two types of packages in Java, they are:
            <br></br><br></br>
            User Defined packages: The packages that contain the classes or interfaces which are built based on the user 
            and it is nothing but they are just defined by the user.
            <br></br><br></br>
            Built-In Packages: The packages that come pre-installed when we configure the Java in our system are called the 
            built-in packages such as java.net, java.awt, javax.swing, java.sql.
        </modular-programming>
        <string-methods>No information present in the database.</string-methods>
        <datatype-conversions>*General-Programming-Knowledge*
<code>
package project3;
import java.util.Scanner;

public class Project3 {

    public static void main (String[] args) {
       String ValueOne = "1";
       String ValueTwo = "2";
       System.out.printf("ValueOne + ValueTwo = %s\n", ValueOne+ValueTwo);
       //Converting Strings to int:
       int a = Integer.parseInt(ValueOne);
       int b = Integer.parseInt(ValueTwo);
       System.out.printf("a + b = %d\n", a+b);
       float val1 = 22.1f, val2 = 25.4f;
       //TypeCasting:
       a = (int)val1; // a gets the integer part of the floating number val1;
       b = (int)val2; // b gets the integer part of the floating number val2;
       System.out.printf("The value of a is: %d\nThe value of b is: %d\n", a, b);
       //Implicitly casting = casting that is made automatically by the compiler:
       val2 = 15; // so in this case the integer value 15 will be casted into a floating point
       //value, 15.00000, this is done automatically by the compiler, so it's implicit casting.
       
       //Explicitly casting = casting that is done by the programmer, because it cannot be done, 
       //automatically by the compiler.
       a = (int) 22.5; // in this case 22.5 will became 22, (only the integer part of the floating value will
       //be stored to int a);
       
       //INTERESTING STUFF:
       val2 = 20 / 15; // integer / integer will result an integer.
       System.out.printf("The value of division is: %f\n", val2); // this will output the value: 1, even if
       //20/15 is 1.33333333, and even if it is stored in a float.
       
       //FOR THE RESULT TO BE A FLOAT AT LEAST ONE OF THOSE NUMBERS NEEDS TO BE CASTED OR CONVERTED TO FLOAT:
       val2 = 20 / (1.0f * 15); // solution one for casting (1.0 * 15 will be converted to float implicitly).
       System.out.printf("The value of division after casting is: %f\n", val2);
       val2 = 25 / (float) a; // a is explicitly casted to float, so int divided by float will generate a float.
       System.out.printf("The value after explicitly casting is: %f\n", val2);
       System.out.printf("Press any key to terminate!\n");
       Scanner myscanner = new Scanner(System.in);
       myscanner.next();
    }
    
}

</code>
        </datatype-conversions>
        <partial-classes>*General-Programming-Knowledge*</partial-classes>
        <decorators>*General-Programming-Knowledge*</decorators>
        <operators>*General-Programming-Knowledge*</operators>
        <pre-post-incrementation>*General-Programming-Knowledge*</pre-post-incrementation>
    </programming_language>
    
    <programming_language>
        <name>Python</name>
        <description>
            Python is a high-level, general-purpose programming language. Its design 
            philosophy emphasizes code readability with the use of significant indentation.
            <br></br><br></br>

            Python is dynamically typed and garbage-collected. It supports multiple 
            programming paradigms, including structured (particularly procedural), 
            object-oriented and functional programming. It is often described as a 
            "batteries included" language due to its comprehensive standard library.
        
        </description>
        <oop>*General-Programming-Knowledge*
<code>
#Object Oriented Programming in Python (OOP)

#Documentation:

#Class: A user-defined prototype for an object that defines a set of attributes that characterize any object of the class.
#The attributes are data members (class variables and instance variables) and methods, accessed via dot notation.

#Class variable: A variable that is shared by all instances of a class. Class variables are defined within a class but
#outside any of the class's methods. Class variables are not used as frequently as instance variables are.

#Data member: A class variable or instance variable that holds data associated with a class and its objects.

#Function overloading: The assignment of more than one behavior to a particular function. The operation performed varies
#by the types of objects or arguments involved.

#Instance variable: A variable that is defined inside a method and belongs only to the current instance of a class.

#Inheritance: The transfer of the characteristics of a class to other classes that are derived from it.

#Instance: An individual object of a certain class. An object obj that belongs to a class Circle, for example, is an
#instance of the class Circle.

#Instantiation: The creation of an instance of a class.

#Method : A special kind of function that is defined in a class definition.

#Object: A unique instance of a data structure that's defined by its class. An object comprises both data members (class variables and instance variables) and methods.

#Operator overloading: The assignment of more than one function to a particular operator.

#Creating a class:
class Employee:
   'Common base class for all employees' #This works like documentation of the class.

   #This member is a class variable whose value is shared among all instances of a this class.
   empCount = 0 #this is like a static variable. The class will create only a variable for all the instances.

    #Creating a constructor for the class:
   def __init__(self, name, salary):    #the name of the constructor is always the same: "__init__"

    #Here is the place where the members of the class gets created and initialized.
      self.name = name
      self.salary = salary
      Employee.empCount += 1
   
   def displayCount(self): #The first parameter of any function in the class is always "self"
    #That means that the function will display information about that instance that calls it.
     print ("Total Employee {0}" .format(Employee.empCount))

   def displayEmployee(self):#The first parameter of any function in the class is always "self"
    #That means that the function will display information about that instance that calls it.
      print ("Name : {0}, Salary: {1}" .format(self.name,self.salary))

    #Implementing a destructor for the class.
   def __del__(self):
      #This code will be executed when calling 'del instance'
          class_name = self.__class__.__name__
          print ("Employee destroyed")


#Creating the instances:
"This would create first object of Employee class"
emp1 = Employee("Zara", 2000)
"This would create second object of Employee class"
emp2 = Employee("Manni", 5000)

#Calling the functions;
emp1.displayEmployee()
emp2.displayEmployee()
emp1.displayCount()
Employee.displayCount(emp2) #This can work like this as well. But it needs to be specified an instance
Employee.displayEmployee(emp1)  #This can work like this as well. But it needs to be specified an instance

#Instead of using the normal statements to access attributes, you can use the following functions:
#So there is no need for GETTERS and SETTERS:
hasattr(emp1, 'name')    # Returns true if 'name' attribute exists
getattr(emp1, 'name')    # Returns value of 'name' attribute
setattr(emp1, 'name', "Mark") # Set attribute 'name' at 8
# delattr(empl, 'name')    # Delete attribute 'name'

emp1.displayEmployee()


#Built-In Class Attributes:
#They can be accessed using dot operator like any other attribute,

#__dict__: Dictionary containing the class's namespace.
#__doc__: Class documentation string or none, if undefined.
#__name__: Class name.
#__module__: Module name in which the class is defined. This attribute is "__main__" in interactive mode.
#__bases__: A possibly empty tuple containing the base classes, in the order of their occurrence in the base class list.

#Accesing those attributes:
print ("Employee.__doc__: {0}" .format(Employee.__doc__))
print ("Employee.__name__: {0}" .format( Employee.__name__))
print ("Employee.__module__: {0}" .format( Employee.__module__))
print ("Employee.__bases__: {0}" .format( Employee.__bases__))
print ("Employee.__dict__: {0}" .format( Employee.__dict__))


#Python deletes unneeded objects (built-in types or class instances) automatically to free the memory space.
#Python's garbage collector runs during program execution and is triggered when an object's reference count
#reaches zero. An object's reference count changes as the number of aliases that point to it changes.
#You normally will not notice when the garbage collector destroys an orphaned instance and reclaims its space.

#A class can implement the special method __del__(), called a destructor, that is invoked when the instance is about to
#be destroyed.

#Example:
del emp1 # this will delete the instance callded emp1.
emp2.displayEmployee()
#emp1.displayEmployee() -> not defined anymore

#THIS STATEMENT WILL THE COMMAND PROMPT OPEN UNTIL THE NEXT BUTTON PRESS:
input("\nPress any key to exit: ")

</code>        
        </oop>
        <encapsulation>*General-Programming-Knowledge*
<code>
class Person: # for inheritance class Person(parent_class):
    #Static fields are declared here
    name = "name"
    __age = 0 #this is a public field
    width = 0 #this is a private
    #static field can become non-static field for a particular instance at a particular time when specified
    def __init__(self):
        #This is the constructor: Only one constructor function is allowed
        #Function overriding is forbidden
        self.width = 104
        #Non-Static field get declared in the constructor
    def setName(self, Name): # this is a setter
        self.name = Name
    #Encapsulation
    def setAge(self, Age):
        self.__age = Age
    def getAge(self):
        return self.__age

class Employee(Person):
    def __init__(self):
        super().__init__()
        self.name = "Employee"
#Creating a class
person = Person ()
#seting the field of the class
person.setName("Alin Popescu")
#Accesing the public field of the class
print (person.name)

#setting the value of private field
person.setAge(22)
#getting the value of a private field
print(person.getAge())

#accessing field modified by the constructor
print(person.width)

emp = Employee()
print(emp.name)

input("\nPress ENTER to exit.")
</code>        
        </encapsulation>
        <polymorphism>*General-Programming-Knowledge*</polymorphism>
        <inheritance>*General-Programming-Knowledge*
<code>
#Instead of starting from scratch, you can create a class by deriving it from a preexisting class by listing the parent class in
#parentheses after the new class name.

#The child class inherits the attributes of its parent class, and you can use those attributes as if they were defined in the
#child class. A child class can also override data members and methods from the parent.

class Parent:        # define parent class

    #Members declared here will be shared through all the instances
    
    #Creating a public member
   parentAttr = 100 #This is a public member which could be accessed from anywhere.

   #Creating hidden (private) member:
   __secretCount = 0 #this member is only visible for this class. So child classes won't be able to access or inherit it.
   #To create hidden members (private members), you just need to put __ as prefix.
   #Private members are only visible inside the class, and can be accessed only by class instances. IT DOES NOT INHERIT.


   #Defining a constructor:
   def __init__(self):

       #Members declared here will be individually created for each instance:
      print ("Calling parent constructor")
         #Creating protected member(variable):
      self._protectedVar = 2 # protected variables can be accessed by parent class and child class, they are not public.
        #Creating hidden (private) member:
      self.__privateVar = 1

   def parentMethod(self):
      print ("Calling parent method")
      
    #Defining a setter:
   def setAttr(self, attr):
      Parent.parentAttr = attr
      
    #Defining a getter:
   def getAttr(self):
      print ("Parent attribute : {0}" .format(Parent.parentAttr))

   def myMethod(self):
      print ("Calling parent method")
   def printPrivate(self):
       print("Private Variable: {0}" .format(self.__privateVar))

class Child(Parent): # define child class
    #Defining a contructor:
   def __init__(self):
      print ("Calling child constructor")
      Parent.__init__(self)
   def childMethod(self):
      print ("Calling child method")

    #This is an overrided function:
   def myMethod(self):
      print ("Calling the overrided method.")

c = Child()          # creating an instance of Child class
c.childMethod()      # child calls its method
c.parentMethod()     # calls parent's method
c.setAttr(200)       # again call parent's method
c.getAttr()          # again call parent's method

#Functions:
#The issubclass(sub, sup) boolean function returns true if the given subclass sub is indeed a subclass of the superclass sup.

#The isinstance(obj, Class) boolean function returns true if obj is an instance of class Class or is an instance of a
#subclass of Class

#You can always override your parent class methods. One reason for overriding parent's methods is because you may want
#special or different functionality in your subclass.
c.myMethod()

#Trying to print a private member:
#print("Private value: {0}" .format(c.__secretCount)) -> compilation error, child has no member named like that.
#print("Private value: {0}" .format(Parent.__secretCount)) -> compilation error, parent has no member like that.

print("The public member: {0}" .format(Parent.parentAttr))
#print("The protected member: {0}" .format(Parent._protectedVar)) -> compilation error, parent class has no member name like that.
print("The protected member: {0}" .format(c._protectedVar))
p1 = Parent()
#Accesing the private variable can only be made with public accessors (Getters and Setters)
p1.printPrivate()
#print("The private member: {0}" .format(p1.__privateVar)) -> this won't work.

#THIS STATEMENT WILL THE COMMAND PROMPT OPEN UNTIL THE NEXT BUTTON PRESS:
input("\nPress any key to exit: ")

</code>
        </inheritance>
        <abstraction>*General-Programming-Knowledge*</abstraction>
        <generic-programming>*General-Programming-Knowledge*
<code>
from typing import TypeVar, List

T = TypeVar('T')

def element(items: List[T]) -> T:
    return items[0]

# Usage
print(element([1, 2, 3])) 
print(element(['a', 'b', 'c']))  

# OUTPUT:
# 1
# a
</code>        
        </generic-programming>
        <variable-arguments-lists>*General-Programming-Knowledge*
<code>
def myFun(*argv):
    for arg in argv:
        print(arg)

myFun('Hello', 'Welcome', 'to', 'GeeksforGeeks')
</code>        
        </variable-arguments-lists>
        <simple-data-types>*General-Programming-Knowledge*
<code>
Python Data Types
In programming, data type is an important concept.

Variables can store data of different types, and different types can do different things.

Python has the following data types built-in by default, in these categories:

Text Type:    str
Numeric Types:    int, float, complex
Sequence Types:    list, tuple, range
Mapping Type:    dict
Set Types:    set, frozenset
Boolean Type:    bool
Binary Types:    bytes, bytearray, memoryview
None Type:    NoneType
</code>        
        </simple-data-types>
        <complex-data-types>*General-Programming-Knowledge*</complex-data-types>
        <loops>
<code>
#This synthax of FOR loop works like FOREACH

for letter in 'Python':     # letter is the variable in which will be stored
#each element of the collection (String).
   print ("Current Letter : {0}" .format(letter)) #This will print the current letter

print("\n")
fruits = ['banana', 'apple',  'mango']
for fruit in fruits:
   print ("Current fruit : {0}" .format(fruit))


#This works as a normal FOR loop:
for num in range(10,20):  #to iterate between 10 to 20
    for i in range(2,num): #to iterate on the factors of the number
        if num%i == 0:      #this "if statement" is in the inner loop.
            j=num/i          #to calculate the second factor
            print ("{0} equals {1} * {2}"  .format(num,i,j))
            break #to move to the next number, the #first FOR
    else:                  # this "else statement" is in the outer loop
        print ("{0} is prime number" .format(num)) 

#While Loops
print("The following is WHILE loop:\n")
count = 0
while (count &lt; 9):
   print ("The count is: {0}" .format(count))
   count = count + 1        

#Infinite While Loops
var = 1
while var == 1 :  # This constructs an infinite loop
   num = input("Enter a number  :")
   print ("You entered: {0}" .format(num))

#THIS STATEMENT WILL THE COMMAND PROMPT OPEN UNTIL THE NEXT BUTTON PRESS:
input("\nPress any key to exit: ")

</code>

<code>
cars = ["Mitsubishi", "Subaru", "Peugeot", "Renault", "Lamborghini", "Ferrari"]

#Printing the reverse list:
for i in range (5,-1, -1):
    print("{0}" .format(cars[i]))

#Printing the reverse list 2 by 2:
print()
for i in range (5,-1, -2):
    print("{0}" .format(cars[i]))

#Printing the list 2 by 2:
print()
for i in range (0,6, 2):
    print("{0}" .format(cars[i]))    

#Slicing a loop:
print()
for car in cars[:3]:
    print("{0}" .format(car))

#Same syntax for a while:
i=0;
print()
while (i&lt;10):
    print(i)
    i+=2

#Another way of for looping:
print()
for i in range (3):
    print (i)

#THIS STATEMENT WILL THE COMMAND PROMPT OPEN UNTIL THE NEXT BUTTON PRESS:
input("\nPress any key to exit: ")

</code>
        </loops>
        <collections>*General-Programming-Knowledge*
<code>
#Each key is separated from its value by a colon (:), the items are separated by
#commas, and the whole thing is enclosed in curly braces. An empty dictionary
#without any items is written with just two curly braces, like this: {}.

#Keys are unique within a dictionary while values may not be. The values of a
#dictionary can be of any type, but the keys must be of an immutable data type
#such as strings, numbers, or tuples.

dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}

print ("dict['Name']: {0}" .format(dict['Name']))
print ("dict['Age']: {0}" .format(dict['Age']))

#An item can be accessed only with a valid key, trying otherwise will result
#in an error.

#UPDATING DICTIONARY:
print("\nAfter the update:")
dict['Age'] = 8; # update existing entry
dict['Name'] = "DPS School"; # Add new entry
print ("dict['Name']: {0}" .format(dict['Name']))
print ("dict['Age']: {0}" .format(dict['Age']))

#LOOPING THROUGH DICTIONARY:
for name,key in dict.items(): #treat 'name' as the Name(from dictionary)
                        #and key as the Key(value from the dictionary)
    print("Key: ", key, "\t Name:", name)

#DELETING DICTIONARY ITEMS:
del dict['Name']; # remove entry with key 'Name'
#After the deletion the item with key 'Name', accessing it will result and error.
dict.clear();     # remove all entries in dict, the dictionary will be empty.
del dict ;        # delete entire dictionary, it won't exist anymore.




#Dictionary values have no restrictions. They can be any arbitrary Python object,
#either standard objects or user-defined objects. However, same is not true for
#the keys

#IMPORTANT: More than one entry per key not allowed. Which means no duplicate
#key is allowed. When duplicate keys encountered during assignment, the last
#assignment wins.

#Keys must be immutable. Which means you can use strings, numbers or tuples
#as dictionary keys but something like ['key'] is not allowed.

#Example: dict = {['Name']: 'Zara'}

#THIS STATEMENT WILL THE COMMAND PROMPT OPEN UNTIL THE NEXT BUTTON PRESS:
input("\nPress any key to exit: ")
</code>

<code>
#Accessing elements of dictionary using index in while loop:
i=0
dict = {"name1": "John", "name2": "Allan", "name3": "Mark"}
#Iterating through dictionary using while loop (FOR VALUES):
while(i&lt;len(dict)):
    print("While-loop Key: ", list(dict.keys())[i], \
                  " While-loop Value: ", list(dict.values())[i])
    i+=1
print()
#Iterating through dictionary using while loop (FOR VALUES):
i=0
while(i&lt;len(dict)):
    print("While-loop Value: ", list(dict.values())[i])
    i+=1
print()
#Iterating through dictionary using while loop (FOR VALUES):
i=0
while(i&lt;len(dict)):
    print("While-loop Key: ", list(dict.keys())[i])
    i+=1
print()
#Iterating through dictionary using for loop (BOTH FOR KEYS AND VALUES):
for n,k in dict.items():
    print("For-Loop key = ", n, " For-Loop Value = ", k)
print()
#Iterating through dictionary using for loop (ONLY FOR KEYS):
for k in dict:
    print("For-Loop key = ", k)
print()
#Iterating through dictionary using for loop (ONLY FOR VALUES):
for k in dict.values():
    print("For-Loop Value = ", k)

#Keep the console opened until the next button pressed:
input("Enter anything to quit.")
</code>

<code>
#Sets are like lists just that they cannot contain duplicate elements.

'''This is a multi-line comment'''
SetO = {"Fruits", "Vegetables", "Meal", "Drinks"}
print("This is the list: ", SetO)

#Printing item by item:
print("\nThese are the items in the list: ")
for item in SetO:
    print(item)

#Sets can use the same functions as lists and dictionaries:

print("The size of Set is: " + str(len(SetO)))

#THIS STATEMENT WILL THE COMMAND PROMPT OPEN UNTIL THE NEXT BUTTON PRESS:
input("\nPress any key to exit: ")

'''This
is a
multi
line
comment
'''
</code>

<code>
#A tuple is a sequence of immutable Python objects. Tuples are sequences, just
#like lists. The differences between tuples and lists are, the tuples cannot
#be changed unlike lists and tuples use parentheses, whereas lists use square
#brackets.

tup1 = ('physics', 'chemistry', 1997, 2000);
tup2 = (1, 2, 3, 4, 5 );
tup3 = "a", "b", "c", "d";

#An empty tuple is declared like this:
tup1 = (); #Tuples can be reinitialized with other values.

#To write a tuple containing a single value you have to include a comma, even
#though there is only one value −
tup1 = (50,); 
print("The tuple contain {0} elements: {1} " .format(len(tup1), tup1[0]))

#Like string indices, tuple indices start at 0, and they can be sliced, concatenated,
#and so on.

#Tuples are immutable which means you cannot update or change the values of tuple
#elements. You are able to take portions of existing tuples to create new tuples
#as the following example demonstrates −

tup1 = (12, 34.56); #Tuples can be reinitialized with other values.
tup2 = ('abc', 'xyz');

# Following action is not valid for tuples
# tup1[0] = 100;

# So let's create a new tuple as follows
tup3 = tup1 + tup2;
print (tup3)

#Tuples can be DELETED as follows:
del tup3
#print(tup3) -> this will result an error, tup3 won't exist anymore after its deletion

tup3 = tup1 + tup2;
#Tuples can use the same operation just as lists:
print ("\nExample: tup3[2] = {0}, tup3[-2] = {1}" .format(tup3[2], tup3[-2]))

print("Slicing tuples: {0}" .format(tup3[:2]))
print("Slicing tuples: {0}" .format(tup3[2:]))

#Any set of multiple objects, comma-separated, written without identifying symbols
#are by default set to tuples.
#Examples:
x, y = 1, 2;

#THIS STATEMENT WILL THE COMMAND PROMPT OPEN UNTIL THE NEXT BUTTON PRESS:
input("\nPress any key to exit: ")
</code>

<code>
#Unpacking a list of items:

item, name, price = ["Car", "Mustang Gt", "14000"]
#This is an unpacked list, where each element is actually a variable.

print("item: ", item, " name: ", name, " price: ", price);

#The lists that have many more elements:
print("\nThis is the second method: ")
start, *middle, end = ["element1", "element2", "element3", "element4"]
print(start) # this will print the first element
print(*middle) # this will print all the middle elements
print(end) # this will print the last element
</code>

<code>
Dict = { "GOOGLE": 53.22, "FACEBOOK": 77.22, "TUMBLR": 33.2}

#Splitting dictionary to lists:
#Dict.values() => this will return a list with all the values in dictionary
#Dict.keys() => this will return a list with all the keys in the dictionary

#Zipping a dictionary:
name = zip(Dict.values(), Dict.keys())

#The zipped dictionary will look like this:
#(33.2, 'TUMBLR'), (53.22, 'GOOGLE'), (77.22, 'FACEBOOK')
#The same would be in case of lists, 1->1, 2->2
#first element combined with first, second to second... etc

print("The original dictionary is: ", Dict)
#Sorting a zipped dictionary:
print("The sorted(by value) zipped dictionary is: ", sorted(name))

name = name = zip(Dict.keys(), Dict.values())
print("The sorted (by keys) zipped dictionary is: ", sorted(name))
</code>

<code>
#Zipping (combining) list together.

Lst1 = ["Dragos", "Alan", "Robin"]
Lst2 = ["Blake", "Walker", "Williams"]

names = zip(Lst1,Lst2)

#names will be a new list, a 2D list I might say, containing all the elements in
#Lst1 and Lst2 combined.

#Iterating names:
for a,b in names:
    print("Name = ", a, b)

</code>
        </collections>
        <collection-methods>
<code>
#Exercise the function below will take a list as an argument, and it will return
#back a list whom's items will be only the int's from the passed argument.
#IF none then it will return an empty list.

def filter_list(l):
    filtered = []
    for letter in l:
        if isinstance(letter, int):
            filtered.append(letter)
    return filtered

List=[103,44,55,'ABC', "c", 2]
print("The original list is: " + str(List))
print("The filtered list is: " + str(filter_list(List)))

#Keep the console opened until the next button pressed.
input("Press any key to quit. ")
</code>

<code>
#Exercise: given a list of names, return another list cotaining only the 4-letters
#elements from that list.
def friend(x):
    #Code
    count_letters=0
    Lst=[]
    for word in x:
        for letter in word:
            count_letters+=1
        if count_letters==4:
            Lst.append(word)
        count_letters=0
    return Lst

Lst=["Ryan", "Adam", "Carl", "John", "Marcus", "Derek", "Hilton"];
print("The original list is: ", Lst)
print("The returned list is: ", friend(Lst))

#Keep the console opened until the next button pressed:
input("Enter anything to quit.")
</code>

<code>
#Accesing an element of a string
StringVar = "This is a string!"

print("The string is: {0}" .format(StringVar))
print("The 8th element of the string is: {0}" .format(StringVar[8]))

#Accesing the last element of the string can be done using StringVar[-1]

print("The last element of the string is {0}" .format(StringVar[-1]))
print("The 8th character is also the -9th character in this case: {0}" . format(StringVar[-9]))

#Slicing strings

#StringVar[2:12] -> will access only from the 2nd index until the 8th index of the string.


#StringVar[:12] -> will access all the elements from the 0th until 12th
#StringVar[3:] -> will access all the elements form the 3th until the last
#StringVar[:] -> will access all the elements of the string

print("This is the string sliced [3:]: {0}" .format(StringVar[3:]))

#Get the length of a string
print("The length of StringVar is: {0}" .format(len(StringVar)))

#Changing multiple items of the string:
StringVar = StringVar[:4] #keep only the first 4 elements of the string.
StringVar += "ABC" #add these elements at the end of it

print("The new string is: {0}\n" .format(StringVar))

#LISTS

CharList = ['M','e','s','s','a','g','e']
#A list is like a vector(dynamic in length) and it can be accessed in the same way, by index.
#In Python a list can be created using any type of data.
#Dynamic length of a list, allows appending new elements at the end of the list,
#so that the size would change automatically.

print('The list is: {0}' .format(CharList))

#Accessing an element of the list:
print('This is the 4th element {0}' .format(CharList[4]))

#Changing an element of the list:
CharList[4] = 'O'
print("The new 4th element is: {0}" .format(CharList[4]))

#Appending elements at the end of the list.
CharList+= ['1', '2'] # this is used for temporarily change.
print("The list now, looks like this: {0}" .format(CharList))
CharList.append('3') # this is used for permanent change. 
print("The list now, looks like this: {0}" .format(CharList))

#Slicing lists:
print("The sliced list is: {0}" .format(CharList[:5])) #slicing a list can be done
#just like in case of strings.

#Changing multiple items of the list:
CharList[2:] = ['2', '3'] #this synthax can only be used on lists, to add multiple
#elements after a given index (will automatically erase the rest of the elements
#after that index)
print(CharList)

#Emptying the list:
CharList[:] = []
print(CharList)

#THIS STATEMENT WILL THE COMMAND PROMPT OPEN UNTIL THE NEXT BUTTON PRESS:
input("\nPress any key to exit: ")

</code>
        </collection-methods>
        <dynamic-memory-allocation>
            Memory is allocated to the objects at the run time. <br></br>
            We use the Heap for implement dynamic memory management. <br></br>
            We can use the memory throughout the program. <br></br><br></br>
            As we know, everything in Python is an object means dynamic memory 
            allocation inspires the Python memory management.<br></br>
        </dynamic-memory-allocation>
        <read-from-file>
<code>
#Input and Output to files.

#If the file doesn't exists, then it will be created.
MyFile = open("dragos.txt", "w")

#"w" - Opens a file for writing only. Overwrites the file if the file exists.
#If the file does not exist, creates a new file for writing.

#"r" - Opens a file for reading only. The file pointer is placed at the beginning
#of the file. This is the default mode.

#"rb" - Opens a file for reading only in binary format. The file pointer is placed
#at the beginning of the file. This is the default mode.

#"rb+" - Opens a file for both reading and writing in binary format. The file
#pointer placed at the beginning of the file.

#"wb" - Opens a file for writing only in binary format. Overwrites the file if the
#file exists. If the file does not exist, creates a new file for writing.

#"w+" - Opens a file for both writing and reading. Overwrites the existing file if
#the file exists. If the file does not exist, creates a new file for reading
#and writing.

#"wb+" - Opens a file for both writing and reading in binary format. Overwrites
#the existing file if the file exists. If the file does not exist, creates a
#new file for reading and writing.

#"a" -     Opens a file for appending. The file pointer is at the end of the file
#if the file exists. That is, the file is in the append mode. If the file does
#not exist, it creates a new file for writing.

#"ab" - Opens a file for appending in binary format. The file pointer is at the
#end of the file if the file exists. That is, the file is in the append mode.
#If the file does not exist, it creates a new file for writing.

#"a+" - Opens a file for both appending and reading. The file pointer is at the
#end of the file if the file exists. The file opens in the append mode. If the
#file does not exist, it creates a new file for reading and writing.

#"ab+" - Opens a file for both appending and reading in binary format. The file
#pointer is at the end of the file if the file exists. The file opens in the
#append mode. If the file does not exist, it creates a new file for reading
#and writing.

#The write() method writes any string to an open file. It is important to note that
#Python strings can have binary data and not just text.
#IMPORTANT - The write() method does not add a newline character ('\n')
MyFile.write("This program is written in Python language. By Program: 'files for inputting and outputting'")
#The string above will be written after the files gets closed (in the next line)
MyFile.close();
#The close() method of a file object flushes any unwritten information and closes
#the file object, after which no more writing can be done. Python automatically
#closes a file when the reference object of a file is reassigned to another file.
#It is a good practice to use the close() method to close a file.

MyFile = open("dragos.txt", "r")
Msg = MyFile.read(11) #Only the first 11 character will be extracted from the file.
print(Msg)
#IMPORTANT - when reading character from a file the cursor will move across the
#content of a file, so if it reaches the end, it will need to be reset using
#seek() function.

#The read() method reads a string from an open file. It is important to note that
#Python strings can have binary data. apart from text data.
Msg = MyFile.read(11) # This will print the next 11 character in the file
#since the cursor wasn't restarted.
print(Msg)
# Check current position
position = MyFile.tell();
print ("Current file position : {0}"  .format(position))
position = MyFile.seek(0, 0); #this will restart the cursor to the beginning of the file.
Msg = MyFile.read(11)
print(Msg)

#This function will rename a file:
import os #needed for the following function.
#Syntax: os.rename(current_file_name, new_file_name)

#Getting the current file name:
print("The current file name is: {0}" .format(MyFile.name))
#The attribute .name shows the name of the current file loaded.
MyFile.close() # without closing the file it won't work.
if os.path.isfile("dragos1.txt"): #checking if a file exists
    os.remove("dragos1.txt") #removing a file
os.rename("dragos.txt", "dragos1.txt")#renaming the file

#Renaming the file with the name of an existing file (at the same path) will
#throw an exception.

MyFile = open("dragos1.txt", "r")
print("The current file name is: {0}" .format(MyFile.name))
#Changing the name of the file will work only if the file is closed, and not being
#processed by another programs.

#Removing a directory:
os.chdir(r"C:\Users\Black2\Desktop\python") #Changing the current directory
if os.path.exists(r"C:\Users\Black2\Desktop\python\dragos dir"): #checking for a directory
    os.rmdir(r"C:\Users\Black2\Desktop\python\dragos dir") #removing directory

#Creating a directory:
os.mkdir("dragos dir")

#The os.getcwd() method displays the current working directory.
print("The current working directory is: {0}" .format(os.getcwd()))

#Renaming directories:
if os.path.exists(r"C:\Users\Black2\Desktop\python\dragos dir2"): #checking for a directory
    os.rmdir(r"C:\Users\Black2\Desktop\python\dragos dir2") #removing directory

os.rename(r"C:\Users\Black2\Desktop\python\dragos dir",
             r"C:\Users\Black2\Desktop\python\dragos dir2")#renaming the file

MyFile.close()
os.rmdir(r"C:\Users\Black2\Desktop\python\dragos dir2")
#The file Object Attributes
#file.closed    Returns true if file is closed, false otherwise.
#file.mode    Returns access mode with which file was opened.
#file.name    Returns name of the file.
#file.softspace    Returns false if space explicitly required with print, true otherwise.


#THIS STATEMENT WILL THE COMMAND PROMPT OPEN UNTIL THE NEXT BUTTON PRESS:
input("\nPress any key to exit: ")

</code>
        </read-from-file>
        <write-to-file>
<code>
import os

import sys
import xml.etree.ElementTree

class Persoana:
    def __init__(self, nume:str, prenume:str, varsta: int):
        self.nume = nume
        self.varsta = varsta
        self.prenume = prenume

    def __repr__(self):
        return self.nume+ " " + self.prenume + " " + str(self.varsta)

persoane = [
                Persoana("Geere", "Richard", 64),
                Persoana("Walker", "Alan", 24),
                Persoana("Manson", "Mary", 34),
                Persoana("Manson", "Deny", 36),
                Persoana("Menance", "Denise", 54),
                Persoana("Reyes", "Antonio", 22),
            ]

def write_xml(lista, filename):
    root  = xml.etree.ElementTree.Element("Persoane")
    for pers in lista:
        node = xml.etree.ElementTree.Element("persoana", varsta = str(pers.varsta))
        nume = xml.etree.ElementTree.SubElement(node, 'nume')
        prenume = xml.etree.ElementTree.SubElement(node, 'prenume')
        nume.text = pers.nume
        prenume.text = pers.prenume
        root.append(node)
    tree = xml.etree.ElementTree.ElementTree(root)
    try:
        tree.write(filename, "UTF-8")
    except EnvironmentError as err:
        print("{0}: import error: {1}".format(
            os.path.basename(sys.argv[0]), err))
        return False
    return True

write_xml(persoane, "fisier.xml")
</code>        
        </write-to-file>
        <serialization>*General-Programming-Knowledge*
<code>
import pickle  
# Object to serialize  
data = [1, 2, 3, 4, 5]  
# Serialize object to a file  
with open('data.pkl', 'wb') as file:  
pickle.dump(data, file)  
# Deserialize object from the file  
with open('data.pkl', 'rb') as file:  
loaded_data = pickle.load(file)  
print(loaded_data)    
</code>        
        </serialization>
        <deserialization>*General-Programming-Knowledge*
<code>
# importing the module
import marshal  
 
data = {'name': 'sunny','age': 34,'address': 'nasik'} 
 
# dumps() return byte object stored in variable 'bytes' 
bytes = marshal.dumps(data)    
print('After serialization : ', bytes) 
 
# loads() convert byte object to value
new_data = marshal.loads(bytes)    
print('After deserialization : ', new_data)
</code>        
        </deserialization>
        <constructors>*General-Programming-Knowledge*
<code>
# Python program to illustrate constructor
class Employee:
 
    # Initializing (Calling constructor)
    def __init__(self):
        print('Employee created.')
 
    # Deleting (Calling destructor)
    def __del__(self):
        print('Destructor called, Employee deleted.')
 
obj = Employee()
del obj
</code>        
        </constructors>
        <instantiation>*General-Programming-Knowledge*
<code>
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

person1 = Person("John", 25)
print(person1.name)
print(person1.age)
</code>        
        </instantiation>
        <destructors>*General-Programming-Knowledge*
<code>
def __del__(self):
  # body of destructor
</code>        
        </destructors>
        <function-overloading>*General-Programming-Knowledge*</function-overloading>
        <operator-overloading>*General-Programming-Knowledge*</operator-overloading>
        <multi-threading>*General-Programming-Knowledge*
<code>
import threading #used for threading
import time #used for time

def calculateSquare(numberList):
    for n in numberList:
        print(str(n) + " * " + str(n) + " = " + str(n*n))
        time.sleep(0.2) #this will add a 0.2 seconds delay

def calculateCube(numberList):
    for n in numberList:
        print(str(n) + " * " + str(n) + " * " + str(n) + " = " + str(n*n*n))
        time.sleep(0.2) #this will add a 0.2 seconds delay

numberList = [2,4,5,6,12,34]
#Creating threads:
thread1 = threading.Thread(target=calculateSquare, args =(numberList,))
thread2 = threading.Thread(target=calculateCube, args =(numberList,))

t_before = time.time() # this will get the time before starting the threads
calculateSquare(numberList)
calculateCube(numberList)
t_after = time.time()
print("Example1 (without threading): Time for execution: " + str(t_after-t_before) + " seconds.")
print()

#THIS THREAD EXAMPLE WORKS AS CALLING THE 2 FUNCTIONS WITHOUT THREADING (just like in the example above):
#because the second thread needs to wait until the first thread finishes its execution.
#just like the functions in the example above do.
#Get current time:
t1_before = time.time() # this will get the time before starting the threads
thread1.start()
thread1.join() #wait for the thread1 to finish its work.
thread2.start()
thread2.join() #wait for the thread2 to finish its work.
t1_after = time.time()
print("Example2 (inefficient threading) : Time for execution: " + str(t1_after-t1_before) + " seconds.")
print()

#THIS WAY IS FASTER BUT PRINTING IS A MESS (BECAUSE THE 2 FUNCTIONS EXECUTE SIMULTANEOUS):
#After finishing, the thread needs to be reinitialized.
thread1 = threading.Thread(target=calculateSquare, args =(numberList,))
thread2 = threading.Thread(target=calculateCube, args =(numberList,))
t2_before = time.time() # this will get the time before starting the threads
thread1.start()
thread2.start()
thread1.join() #wait for the thread1 to finish its work.
thread2.join() #wait for the thread2 to finish its work.
t2_after = time.time()
print("Example3 (good threading) : Time for execution: " + str(t2_after-t2_before) + " seconds.")

#INFORMATION:
'''Multi-Threading - is the action of executing tasks simultaneosly (in parallel)
in order to increase the speed of execution.

COMPARISON BETWEEN MULTI_THREADING AND MUTI_PROCESSING:

Multi-threading shares the same stack memory as the whole program (this is one main difference comparing to multi-processing)
Multi-threading returns a value to the same memory address (stack address) whereas the multi-processing doesn't because
it's has it's own stack memory (in which it will copy all the variables related to it).

ADVANTAGES FOR USING MULTI_THREADING (instead of multi-processing):
Lightweight - low memory footprint
Shared memory - makes access to state from another context easier
Allows you to easily make responsive UIs
cPython C extension modules that properly release the GIL will run in parallel
Great option for I/O-bound applications

DISADVANTAGES:

cPython - subject to the GIL
Not interruptible/killable
If not following a command queue/message pump model (using the Queue module), then manual use of synchronization primitives become a necessity (decisions are needed for the granularity of locking)
Code is usually harder to understand and to get right - the potential for race conditions increases dramatically
'''

#THIS STATEMENT WILL THE COMMAND PROMPT OPEN UNTIL THE NEXT BUTTON PRESS:
input("\nPress any key to exit: ")
</code>

<code>
import multiprocessing # used for multiprocessing
import time # used for time

def PrintHello():
    i=0
    while(i&lt;50):
        print("Hello " + str(i))
        time.sleep(0.2)
        i+=1
def PrintHi():
    i=0
    while(i&lt;50):
        print("Hi " + str(i))
        time.sleep(0.2)
        i+=1
def Funct(n): # functions used with ".pool and .map" needs to take an extra argument
    i=0
    while(i&lt;50):
        print("Hello " + str(i))
        time.sleep(0.2)
        i+=1
        
if __name__ == "__main__":
    t_before = time.time()
    p1 = multiprocessing.Process(target=PrintHello, args=())
    p2 = multiprocessing.Process(target=PrintHi, args=())
    p1.start()
    p2.start()
    p1.join() # wait for the process to finish
    p2.join() # wait for the process to finish
    t_after = time.time()
    print("Example1. Time for execution: " + str(t_after - t_before))
#Executing single process:
    t_before = time.time()
    p1 = multiprocessing.Process(target=PrintHello, args=())
    p1.start()
    p1.join() # wait for the process to finish
    t_after = time.time()
    print("Example2. Time for execution: " + str(t_after - t_before))
#Pooling and mapping processes:
# Functions used for "pooling and mapping" needs to take an extra argument for
#iteration (how many times to run the same function).
    t_before = time.time()
    p1 = multiprocessing.Pool()
    p1.map(Funct, range(1)) # run this function for 1 time.
#The extra argument specifies how many times the function should be runned.
    t_after = time.time()
    print("Example2 with Pooling and Mapping. Time for execution: " + str(t_after - t_before))
#Keep the console open until the next button pressed:
    input("Press any key to quit.")

'''Multi processing does almost the same thing as multi-threading: it is used
for speeding up the execution of tasks, by executing them simultaneosly (in parallel).

SIMILARITIES:
Both multi-processing and multi-threading are used to speed up the execution of multiple
tasks (the both execute individual multi-tasking in parallel).

THE DIFFERENCES:
Each process has its own memory address space (stack memory): so when returning a value
from a process, the value returned will not be seen by the rest of the program
unless it is saved in a file, in a shared memory address, or in a message pipe.
Whereas threading is able to return values which can be used later in the main program.

A process is treated as an individual program, (it even creates a process in the
task mananger),

Processes can be sent through different cores, that would speed up the program even more.

Creating multiple processes is costly compare to threads. Since for each process
there is allocated another stack memory space.

ADVANTAGES FOR USING MULTI_PROCESSING (instead of multi-threading):

Separate memory space
Code is usually straightforward
Takes advantage of multiple CPUs & cores
Avoids GIL limitations for cPython
Eliminates most needs for synchronization primitives unless if you use shared memory (instead, it's more of a communication model for IPC)
Child processes are interruptible/killable
Python multiprocessing module includes useful abstractions with an interface much like threading.Thread
A must with cPython for CPU-bound processing

DISADVANTAGES FOR USING MULTI_PROCESSING:

IPC a little more complicated with more overhead (communication model vs. shared memory/objects)
Larger memory footprint'''
</code>        
        </multi-threading>
        <namespaces>*General-Programming-Knowledge*</namespaces>
        <exception-handling>*General-Programming-Knowledge*
<code>
#Exceptions handling:

#EXCEPTION NAME    DESCRIPTION
#Exception    Base class for all exceptions
#StopIteration    Raised when the next() method of an iterator does not point to any object.
#SystemExit    Raised by the sys.exit() function.
#StandardError    Base class for all built-in exceptions except StopIteration and SystemExit.
#ArithmeticError    Base class for all errors that occur for numeric calculation.
#OverflowError    Raised when a calculation exceeds maximum limit for a numeric type.
#FloatingPointError    Raised when a floating point calculation fails.
#ZeroDivisionError    Raised when division or modulo by zero takes place for all numeric types.
#AssertionError    Raised in case of failure of the Assert statement.
#AttributeError    Raised in case of failure of attribute reference or assignment.
#EOFError    Raised when there is no input from either the raw_input() or input() function and the end of file is reached.
#ImportError    Raised when an import statement fails.
#KeyboardInterrupt    Raised when the user interrupts program execution, usually by pressing Ctrl+c.
#LookupError    Base class for all lookup errors.
#IndexError     Raised when an index is not found in a sequence.
#KeyError       Raised when the specified key is not found in the dictionary.
#NameError    Raised when an identifier is not found in the local or global namespace.
#UnboundLocalError   Raised when trying to access a local variable in a function or method but no value has been assigned to it.
#EnvironmentError   Same as above
#IOError        Raised when an input/ output operation fails, such as the print statement or the open() function when trying to open
#a file that does not exist.
#IOError    Same as above.
#SyntaxError    Raised when there is an error in Python syntax.
#IndentationError   Raised when indentation is not specified properly.
#SystemError    Raised when the interpreter finds an internal problem, but when this error is encountered the Python interpreter does not exit.
#SystemExit    Raised when Python interpreter is quit by using the sys.exit() function. If not handled in the code, causes the interpreter to exit.
#TypeError    Raised when an operation or function is attempted that is invalid for the specified data type.
#ValueError    Raised when the built-in function for a data type has the valid type of arguments, but the arguments have invalid values specified.
#RuntimeError    Raised when a generated error does not fall into any category.
#NotImplementedError    Raised when an abstract method that needs to be implemented in an inherited class is not actually implemented.


#An exception is an event, which occurs during the execution of a program that disrupts the normal flow of the program's
#instructions. In general, when a Python script encounters a situation that it cannot cope with, it raises an exception.
#An exception is a Python object that represents an error.

#Handling exceptions:
try:
   fh = open("dragos1.txt", "a")
   fh.write("This was added by 'handling exceptions' Program.")
except IOError:
   print ("Error: can't find file or read data from {0}" .format(fh.name))
else:
   print ("Written content in the file successfully!")
   fh.close()

#Example 2:
try:
    fh = open("file.txt", "r")
    fh.read(12)
except IOError:
    print ("Error: can\'t find file or read data from {0}" .format(fh.name))
finally:
    print ("Not working!")

#When an exception is thrown in the try block, the execution immediately passes to the finally block. After all the statements
#in the finally block are executed, the exception is raised again and is handled in the except statements if present in the
#next higher layer of the try-except statement.

#You can raise exceptions in several ways by using the raise statement. The general syntax for the raise statement is as follows.

level=1
if level &lt; 1:
      raise Exception('level &lt; 1')

#Creating user-defined exception:
class MyError(Exception):
     def __init__(self, value):
         self.value = value
     def __str__(self):
         return repr(self.value)

#Catching user-defined exceptions:
try:
    raise MyError(2*2)
except MyError as e:
     print ("My exception occurred, value: {0}" .format (e.value))


#THIS STATEMENT WILL THE COMMAND PROMPT OPEN UNTIL THE NEXT BUTTON PRESS:
input("\nPress any key to exit: ")
</code>        

<code>
try:
    lis = ['a', 'b']
    print(str(lis[4]))
except Exception as exp: # equivalent to except:
    print("Exception class: " + str(type(exp)) + "\nMessage: " + str(exp))
    #an exception created in the except block or finally will not be treated or caught.
else:
    print("No exception caught!")
finally:
    print("Operation done.")

#raise Exception ("Custom error") # this will throw an exception

assert 5&lt;8, "Nothing to do" #this is fine since condition is true
#assert 5&gt;8, "Condition is false" # this will raise an exception because the condition is false.

#assert can be used for debugging. can be turned off when running python script with -O

#LAMBDA functions:

DoubleValue = lambda value: value*2

print(DoubleValue(2)) #calling the lambda function

input("\nPress ENTER to exit.")
</code>
        </exception-handling>
        <bitwise-operators>*General-Programming-Knowledge*</bitwise-operators>
        <default-parameters>*General-Programming-Knowledge*
<code>
#Functions in Python:

#A function is a block of organized, reusable code that is used to perform a
#single, related action. Functions provide better modularity for your
#application and a high degree of code reusing.

#IMPORTANT: All parameters (arguments) in the Python language are passed by
#reference. 

def AddingNumbers(a,b):
    return a+b

print("The sum of {0} and {1} is: {2}\n" . format(5,4,AddingNumbers(5,4)))

#ABOVE in the print() function call the AddingNumbers() function is called using
#required arguments

#BELOW the function AddingNumbers() is called using keyword arguments:
print("The sum of {0} and {1} is: {2}" . format(5,4,AddingNumbers(a=5,b=4)))
#Keyword arguments are used to specify for which arguments you are giving a value
#when it comes to default arguments.

#A function can have default arguments:
def PrintFunct (str="Default argument"):
    print(str)
    return

print("This is PrintFunct: {0}" .format(PrintFunct()))

#If you have a function with 2 default arguments, you can use keyword to specify
#for which of them you are setting a value.

def PrintFunct2 (str="Default argument", str2="Default argument2"):
    print("{0} + {1}" .format(str, str2))
    return
print("This is PrintFunct2: ")
PrintFunct2(str="First String")

#The function PrintFunct() above is called using default argument (no value is
#passed).

#Variable-length arguments - > can be implemented using tuples as arguments:
def VarArgFct(arg1, *ArgTuple):
    print("\n")
    print(arg1)
    for item in ArgTuple:
        print("{0}" .format(item))
    return

#Calling function:
VarArgFct(22, 44,33,55)
VarArgFct(22, [44,33,55])


#Anonymous Functions - are called anonymous because they are not declared in
#the standard manner by using the def keyword. You can use the lambda keyword
#to create small anonymous functions.

#Example:
sum = lambda arg1, arg2: arg1 + arg2; #Anonymous functions are small single line functions

#Anonymous functions don't need a 'return' statement, they will return whoever the
#value after the ':' is. (return values similarily as ternary operator)

#Calling the function:
print ("Value of total: {0}" .format(sum(10,20)))

#Variables: local and global.
#Local variables - are those that are declared inside a function.
#Global variables - are those declared outside of any function.

#THIS STATEMENT WILL THE COMMAND PROMPT OPEN UNTIL THE NEXT BUTTON PRESS:
input("\nPress any key to exit: ")

</code>        
        </default-parameters>
        <interfaces>*General-Programming-Knowledge*</interfaces>
        <random-generators>*General-Programming-Knowledge*
<code>
#This program will print a random quotes from the .txt quotation file opened below. 
from random import randint

def ReadFromFile():
    MyFile = open(r"D:\my files\quotations.txt", "r")
    Line=MyFile.read(1000000)
    i=0
    numberOfQuotes=0
    MyList=[]
    buff=""
    while(i&lt;len(Line)):
        if(Line[i]=="\n"):
            MyList.append(buff)
            buff=""
            numberOfQuotes+=1
        else:
            buff+=Line[i]
        i+=1
    #Getting a random number between 0 and numberOfQuotes
    choice = randint(0,numberOfQuotes)
    #Printing the choice:
    print(MyList[choice])

#Calling the function:
while(input("Press C to continue, or Q to quit: ")=="C"):
    print()
    ReadFromFile()
    print()

#Keep the console opened until the next button pressed:
input("Press any key to quit.")

</code>
        </random-generators>
        <command-line-arguments>*General-Programming-Knowledge*
<code>
import sys

if __name__ == "__main__": #if script is run from this file do this, otherwise it means file imported by other module and you will ignore this.
    if len(sys.argv) > 1: #there is always gonna be at least one element in this... at index 0 the name of the file is stored.
        print ("The script has the name "  + str(sys.argv[0]))
        print ("The arguments which were passed are: " + str(sys.argv[1:]))
</code>        
        </command-line-arguments>
        <ternary-operator>*General-Programming-Knowledge*</ternary-operator>
        <modular-programming>*General-Programming-Knowledge*
<code>
#This is a module (a module can be any .py file):


#These are the functions:
def print_func( par ):
   print ("Hello : {0} " .format(par))
   return

def CalculateSum (*Args):
    sum=0
    for item in Args:
        sum+=item
    return sum
</code>        

<code>
#The next line will set the filepath:
PYTHONPATH=r'C:\Users\Black2\Desktop\python\modular programming in python'
#The next line will import a specific module:
import module_with_functions

#Calling functions from inside the module:
module_with_functions.print_func("Dragos")

print("Sum of {0} and {1} is: {2}" .format(4,10,module_with_functions.CalculateSum(4,10)))

#There is possible to import a single function from the whole module below is the
#synthax:
from module_with_functions import print_func
#The effect is here: the fuction can be called without mentioning the module, whereas
#in the example above it couldn't.
print_func("Black")

#The following synthax will import anything from the mentioned module:
from module_with_functions import *

print("{0}+{1}={2}" .format(3,4,CalculateSum(3,4)))
#Once again there was no need of mentioning the module for CalculateSum()


#Namespace and scoping:
#Variables are names (identifiers) that map to objects. A namespace is a dictionary
#of variable names (keys) and their corresponding objects (values).

#A Python statement can access variables in a local namespace and in the global
#namespace. If a local and a global variable have the same name, the local
#variable shadows the global variable.

#Python makes educated guesses on whether variables are local or global. It
#assumes that any variable assigned a value in a function is local.
#Therefore, in order to assign a value to a global variable within a function,
#you must first use the global statement.

#THIS STATEMENT WILL THE COMMAND PROMPT OPEN UNTIL THE NEXT BUTTON PRESS:
input("\nPress any key to exit: ")

</code>
        </modular-programming>
        <string-methods>No information present in the database.</string-methods>
        <datatype-conversions>No information present in the database.</datatype-conversions>
        <decorators>*General-Programming-Knowledge*
<code>
import time

def masoara_timp(fct):
    if hasattr(fct, 'call_number') == False:
        fct.call_number = 1
        fct.call_time = 0
    print("Apel decorator.")
    def proxy():
        print("Apel proxy.")
        t = time.time()
        fct()
        fct.call_time += time.time() - t
        print("Functia " + str(fct.__name__) + " : s-a executat in : " + str(time.time() - t))
        print("Apeluri functie " + str(fct.call_number))
        print("Durata medie: " + str(fct.call_time / fct.call_number))
        fct.call_number += 1
    return proxy


#masoara_timp it's a decorator. 

@masoara_timp #this is equivalent to functie = masoara_timp(functie)
def functie():
    time.sleep(0.5)
    print("se executa functia")

functie()
functie()
functie()
functie()
functie()
</code>        
        </decorators>
        <operators>*General-Programming-Knowledge*</operators>
        <abstract-classes>
<code>
from p19_abs_class import PUNCT as abstract, PUNCT

#p = PUNCT()  #cannot be done, abstract classes cannot be instraciated

class LINE(PUNCT):
    def abstract_method(self): #providing definition for abstract parent method
        print("Abstract method is now redefined")

    #creating static methods:
    @staticmethod #the following method will be static. Static = shared among the instances.
    def staticMe(): #static method don't take self as argument
        print("\nThis is a static method\nAll instances of the class share same method")

l = LINE()

l.abstract_method()
l.staticMe()
#static methods can be invoked only with the class name

LINE.staticMe()

input("\nPress ENTER to exit.")
</code>
        </abstract-classes>
        <pre-post-incrementation>*General-Programming-Knowledge*</pre-post-incrementation>
        <regular-expressions>
<code>
#A regular expression is a special sequence of characters that helps you match or find other strings or sets
#of strings, using a specialized syntax held in a pattern.

#The match() function -> This function attempts to match RE pattern to string with optional flags.
#Syntax: re.match(pattern, string, flags=0)
#pattern    This is the regular expression to be matched.
#string        This is the string, which would be searched to match the pattern at the beginning of string.
#flags        You can specify different flags using bitwise OR (|). These are modifiers, which are listed in the table below.

#The re.match function returns a match object on success, None on failure. We usegroup(num) or groups()
#function of match object to get matched expression.

import re #This library is used for regular expressions (re)

line = "Cats are smarter than dogs"

matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I) #find something at the beginning of the string and return a match object.

if matchObj:
   print ("matchObj.group() : {0}" .format(matchObj.group()))
   print ("matchObj.group(1) : {0}" .format (matchObj.group(1)))
   print ("matchObj.group(2) : {0}" .format(matchObj.group(2)))
else:
   print ("No match!!")

matchObj = re.match( "Cats", line, 0)
if matchObj:
   print ("matchObj.group() : {0}" .format(matchObj.group()))
   #print ("matchObj.group(1) : {0}" .format(matchObj.group(1)))
   #print ("matchObj.group(2) : {0}" .format(matchObj.group(2)))
else:
   print ("No match!!")

#The search() function - This function searches for first occurrence of RE pattern within string with optional flags.
searchObj = re.search( r'dogs*', line, re.M|re.I) #re* -> Matches 0 or more occurrences of preceding expression.
if searchObj:
   print ("searchObj.group() : {0}" .format(searchObj.group()))
   #print ("searchObj.group(1) : {0}" .format (searchObj.group(1)))
   #print ("searchObj.group(2) : {0}" .format(searchObj.group(2)))
else:
   print ("No match!!")

#Match checks for a match only at the beginning of the string, while search checks for a match anywhere in the string.

#The sub() function - replaces all occurrences of the pattern in the string with 'repl'
#Syntax: re.sub(pattern, repl, string, max=0)

phone = "2004-959-559 # This is Phone Number"

# Delete Python-style comments
num = re.sub(r'#.*$', "", phone)
print ("Phone Num : {0}" .format(num))

# Remove anything other than digits
num = re.sub(r'\D', "", phone)    
print ("Phone Num : {0}" .format(num))

#THIS STATEMENT WILL THE COMMAND PROMPT OPEN UNTIL THE NEXT BUTTON PRESS:
input("\nPress any key to exit: ")

#Following table lists the regular expression syntax that is available in Python :

#Pattern    Description
#^    Matches beginning of line.
#$    Matches end of line.
#.    Matches any single character except newline. Using m option allows it to match newline as well.
#[...]    Matches any single character in brackets.
#[^...]    Matches any single character not in brackets
#re*    Matches 0 or more occurrences of preceding expression.
#re+    Matches 1 or more occurrence of preceding expression.
#re?    Matches 0 or 1 occurrence of preceding expression.
#re{ n}    Matches exactly n number of occurrences of preceding expression.
#re{ n,}    Matches n or more occurrences of preceding expression.
#re{ n, m}    Matches at least n and at most m occurrences of preceding expression.
#a| b    Matches either a or b.
#(re)    Groups regular expressions and remembers matched text.
#(?imx)    Temporarily toggles on i, m, or x options within a regular expression. If in parentheses, only that area is affected.
#(?-imx)    Temporarily toggles off i, m, or x options within a regular expression. If in parentheses, only that area is affected.
#(?: re)    Groups regular expressions without remembering matched text.
#(?imx: re)    Temporarily toggles on i, m, or x options within parentheses.
#(?-imx: re)    Temporarily toggles off i, m, or x options within parentheses.
#(?#...)    Comment.
#(?= re)    Specifies position using a pattern. Doesn't have a range.
#(?! re)    Specifies position using pattern negation. Doesn't have a range.
#(?> re)    Matches independent pattern without backtracking.
#\w    Matches word characters.
#\W    Matches nonword characters.
#\s    Matches whitespace. Equivalent to [\t\n\r\f].
#\S    Matches nonwhitespace.
#\d    Matches digits. Equivalent to [0-9].
#\D    Matches nondigits.
#\A    Matches beginning of string.
#\Z    Matches end of string. If a newline exists, it matches just before newline.
#\z    Matches end of string.
#\G    Matches point where last match finished.
#\b    Matches word boundaries when outside brackets. Matches backspace (0x08) when inside brackets.
#\B    Matches nonword boundaries.
#\n, \t, etc.    Matches newlines, carriage returns, tabs, etc.
#\1...\9    Matches nth grouped subexpression.
#\10    Matches nth grouped subexpression if it matched already. Otherwise refers to the octal representation of a character code.

#Option flags:

#Modifier    Description
#re.I    Performs case-insensitive matching.
#re.L    Interprets words according to the current locale. This interpretation affects the alphabetic group (\w and \W), as well as word boundary behavior (\b and \B).
#re.M    Makes $ match the end of a line (not just the end of the string) and makes ^ match the start of any line (not just the start of the string).
#re.S    Makes a period (dot) match any character, including a newline.
#re.U    Interprets letters according to the Unicode character set. This flag affects the behavior of \w, \W, \b, \B.
#re.X    Permits "cuter" regular expression syntax. It ignores whitespace (except inside a set [] or when escaped by a backslash) and treats unescaped # as a comment marker.

#Character classes
#Example    Description
#[Pp]ython    Match "Python" or "python"
#rub[ye]    Match "ruby" or "rube"
#[aeiou]    Match any one lowercase vowel
#[0-9]    Match any digit; same as [0123456789]
#[a-z]    Match any lowercase ASCII letter
#[A-Z]    Match any uppercase ASCII letter
#[a-zA-Z0-9]    Match any of the above
#[^aeiou]    Match anything other than a lowercase vowel
#[^0-9]    Match anything other than a digit

#Special Character Classes
#Example    Description
#.    Match any character except newline
#\d    Match a digit: [0-9]
#\D    Match a nondigit: [^0-9]
#\s    Match a whitespace character: [ \t\r\n\f]
#\S    Match nonwhitespace: [^ \t\r\n\f]
#\w    Match a single word character: [A-Za-z0-9_]
#\W    Match a nonword character: [^A-Za-z0-9_]


#Repetition Cases
#Example    Description
#ruby?    Match "rub" or "ruby": the y is optional
#ruby*    Match "rub" plus 0 or more ys
#ruby+    Match "rub" plus 1 or more ys
#\d{3}    Match exactly 3 digits
#\d{3,}    Match 3 or more digits
#\d{3,5}    Match 3, 4, or 5 digits
</code>        
        </regular-expressions>
    </programming_language>
    
</content>
