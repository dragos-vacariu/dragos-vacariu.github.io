<?xml version="1.0" encoding="UTF-8"?>

<content>
	<programming_language>
		<name>General-Programming-Knowledge</name>
		<oop>
			OOP stands for Object-Oriented Programming.
			<br></br><br></br>
			Procedural programming is about writing procedures or functions that perform operations on the data, 
			while object-oriented programming is about creating objects that contain both data and functions.
			<br></br><br></br>
			Object-oriented programming has several advantages over procedural programming:
			<br></br><br></br>
			<green>
			OOP is faster and easier to execute;<br></br>
			OOP provides a clear structure for the programs;<br></br>
			OOP helps to keep the code DRY "Don't Repeat Yourself", and makes the code 
			easier to maintain, modify and debug;<br></br>
			OOP makes it possible to create full reusable applications with less code and 
			shorter development time;
			</green>
			<br></br><br></br>
			<red>
			Tip: The "Don't Repeat Yourself" (DRY) principle is about reducing the repetition 
			of code. You should extract out the codes that are common for the application, 
			and place them at a single place and reuse them instead of repeating it.
			</red>
			<br></br>
		</oop>
		<encapsulation>
			The meaning of Encapsulation, is to make sure that "sensitive" data is hidden from 
			users.<br></br><br></br> 
			To achieve this, you must declare class variables/attributes as private 
			(cannot be accessed from outside the class). <br></br><br></br>
			If you want others to read or modify 
			the value of a private member, you can provide public get and set methods.<br></br>
		</encapsulation>
		<polymorphism>
			Polymorphism means "many forms", and it occurs when we have many 
			classes that are related to each other by inheritance.<br></br>
		</polymorphism>
		<simple-data-types>
			<code>short int</code> - has value range <red>[-32,768 to 32,767]</red> - format specifier <code>%hd</code> - 
			occupies 2 bytes memory
			<br></br><br></br>
			<code>unsigned short int</code> - has value range <red>[-32,768 to 65,535]</red> - format specifier <code>%hu</code> - 
			occupies 2 bytes memory
			<br></br><br></br>
			<code>unsigned int</code> - has value range <red>[0 to 4,294,967,295]</red> - format specifier <code>%u</code> - 
			occupies 4 bytes memory
			<br></br><br></br>
			<code>int</code> - has value range <red>[-2,147,483,648 to 2,147,483,647]</red> - format specifier <code>%d</code> - 
			occupies 4 bytes memory
			<br></br><br></br>
			<code>long int</code> - has value range <red>[-2,147,483,648 to 2,147,483,647]</red> - 
			format specifier <code>%ld</code> - occupies 4 bytes memory
			<br></br><br></br>
			<code>unsigned long int</code> - has value range <red>[0 to 4,294,967,295 ]</red> - format specifier <code>%lu</code> -
			occupies 4 bytes memory
			<br></br><br></br>
			<code>long long int</code> - has value range <red>[-(2^63) to (2^63)-1]</red> - format specifier <code>%lld</code> - 
			occupies 8 bytes memory
			<br></br><br></br>
			<code>unsigned long long int</code> - has value range <red>[-(2^63) to 18,446,744,073,709,551,615 ]</red> - 
			format specifier <code>%llu</code>  - occupies 8 bytes memory
			<br></br><br></br>
			<code>signed char</code> - has value range <red>[-128 to 127]</red> - format specifier <code>%c</code> - occupies 1 
			byte memory
			<br></br><br></br>
			<code>unsigned char</code> - has value range <red>[0 to 255]</red> - format specifier <code>%c</code> - occupies 1 
			byte memory
			<br></br><br></br>
			<code>float</code> - has value range <red>[1.2E-38 to 3.4E+38]</red> - format specifier <code>%f</code> - occupies 
			4 byte memory
			<br></br><br></br>
			<code>double</code> - has value range <red>[1.7E-308 to 1.7E+308]</red> - format specifier <code>%lf</code> - 
			occupies 8 byte memory
			<br></br><br></br>
			<code>long double</code> - has value range <red>[3.4E-4932 to 1.1E+4932]</red> - format specifier <code>%Lf</code>  - 
			occupies 16 byte memory
		</simple-data-types>
		<complex-data-types>
			Data types that are derived from fundamental data types:<br></br><br></br>
			<code>bool type</code> - The bool type is a <red>byte-sized</red> type that can only hold the value true or false.<br></br><br></br>
			<code>Enumerated type / Enums</code> - An enum is a special type that represents a group of constants (unchangeable values).<br></br><br></br>
			<code>Complex types</code> - The C programming language, as of C99, supports complex number math with the three built-in types 
			<code>double _Complex</code>, <code>float _Complex</code>, and <code>long double _Complex</code>.
			<br></br>
			When the header <code>complex.h</code> is 
			included, the three complex number types are also accessible as double complex, 
			float complex, long double complex.<br></br><br></br>
			<code>Arrays</code> - A collection of elements of the same data type. <br></br>
			An array in C can be defined as a method of clubbing multiple entities of similar type into a larger group. <br></br>
			These entities or elements can be of int, float, char, or double data type or can be of user-defined data types too
			like structures.<br></br>
			The size of an array can be calculated by multiplying the <red>data-type * numberOfElements</red> within the array.
			<br></br><br></br>
			<code>Pointers</code> - A variable that stores the memory address of another variable. 
			The size of a pointer in C programming language varies depending on factors such as the operating system and CPU 
			architecture.<br></br>
			Typically, on a <blue>32-bit</blue> computer system, the size of pointer is <red>4 bytes</red>,	
			while on a <blue>64-bit</blue> computer system, it is <red>8 bytes</red>.<br></br><br></br>
			<code>Structures</code>: A collection of variables of different data types grouped 
			together under a single name. <br></br>
			The size of a struct can be calculated by summing up the size of all the element data-types.
			<br></br><br></br>
			<code>Unions</code> - A special type of structure that can store only one value at a time. <br></br>
			The size of the union is equal to the size of the largest element defined within the union.<br></br><br></br>
			<code>Typedefs</code> - A way to create a new name for an existing data type to improve code 
			readability and maintainability.<br></br><br></br>
			<code>void</code> - It's used to indicate an empty data type, usually used with pointers.<br></br>
		</complex-data-types>
		<loops>
			In computer programming, a loop is a sequence of instruction s that is 
			continually repeated until a certain condition is reached. <br></br>
			Typically, a certain process is done, such as getting an item of data 
			and changing it, and then some condition is checked such as whether a 
			counter has reached a prescribed number.<br></br><br></br>
			<br></br>
			For, while, do-while loops:<br></br><br></br>
			
			<red>
			While loop does not depend upon the number of iterations. In for loop the number 
			of iterations was previously known to us but in the While loop, the execution 
			is terminated on the basis of the test condition. If the test condition will 
			become false then it will break from the while loop else body will be executed.<br></br><br></br>
			<br></br>
			</red>	
			
			<green>
			In for loop, a loop variable is used to control the loop. Firstly we initialize 
			the loop variable with some value, then check its test condition. If the 
			statement is true then control will move to the body and the body of for 
			loop will be executed. <br></br>
			Steps will be repeated till the exit condition 
			becomes true. If the test condition will be false then it will stop.
			<br></br><br></br>
			
			Initialization Expression: In this expression, we assign a loop variable 
			or loop counter to some value. for example: <code>int i=1;</code>
			<br></br><br></br>
			Test Expression: In this expression, test conditions are performed. 
			If the condition evaluates to true then the loop body will be executed and 
			then an update of the loop variable is done. If the test expression becomes 
			false then the control will exit from the loop. for example, <code>counter&lt;5;</code>
			<br></br><br></br>
			
			Update Expression: After execution of the loop body loop variable is updated 
			by some value it could be incremented, decremented, multiplied, or divided by 
			any value.<br></br><br></br>
			</green>
			
			<blue>
			<br></br>		
			The do-while loop is similar to a while loop but the only difference 
			lies in the do-while loop test condition which is tested at the end of 
			the body. <br></br>
			In the do-while loop, the loop body will execute at least once 
			irrespective of the test condition.<br></br>
			</blue>
<code>
<red>/*While loop syntax: */</red>
int counter = 0;
while(counter &lt; 5)
{
	/*code goes here*/
	 counter++;
}
</code>
<code>
<red>/*For loop syntax: */</red>
for(int counter = 0; counter &lt; 5; counter++)
{
	/*code goes here*/
	 counter++;
}
</code>
<code>
<red>/*Do while loop syntax: */</red>
do
{
	/*code goes here*/
	 counter++;
}
while(counter &lt; 5)
</code>
		</loops>
		<dynamic-memory-allocation>
			Dynamic memory is allocated from the heap using some standard library functions. 
			The two dynamic memory key functions are <code>malloc()</code> and <code>free()</code>. <br></br>
			The <code>malloc()</code> function takes a single parameter, which is the size of the requested memory 
			area in bytes. <br></br>
			It returns a pointer to the allocated memory.
			<br></br><br></br>
			<red>C malloc() method:</red>
			<br></br><br></br>
			The “malloc” or “memory allocation” method in C is used to dynamically allocate a single 
			large block of memory with the specified size. <br></br><br></br>
			It returns a pointer of type void which 
			can be cast into a pointer of any form. 
			<br></br>
			It doesn’t Initialize memory at execution time 
			so that it has initialized each block with the default garbage value initially. 
			<br></br><br></br>
<code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;conio.h&gt;

int main()
{
	int *A;
	int i;
	
	/*
	Prototype: void *malloc(size_t size);
	*/

	A=(int *)malloc(20*sizeof(int)); // malloc return a void pointer that needs to be converted
	//into a pointer to however the type of the variable that uses it has. (int *) - is the type of pointer A
	//20 = the number of memory cells allocated;
	
	for (i=0;i&lt;20;i++)
		printf("A[%d]=%d\n", i, A[i]); //the value in each memory cell can be anything
	free(A);
}
</code>
			Calloc function allocates the requested memory and returns a pointer to it similarly to malloc. 
			<br></br><br></br>
			The <code>malloc()</code> and <code>calloc()</code> do differentiate in how the functions are used when allocating 
			memory at runtime. <br></br><br></br>
			The <code>malloc()</code> function only returns the starting address, <red>it doesn't zero it.</red>
			<br></br>			
			On the other hand, the <code>calloc()</code> function returns the starting address, <green>zeroing it.</green>
<code>
/*Prototype void *calloc(size_t nitems, size_t size)*/

A=(int *)calloc(20, sizeof(int)); //calloc does the same as malloc while initializing all elements to 0:
	
for (i=0;i&lt;20;i++)
	printf("A[%d]=%d\n", i ,A[i]); //the value in each memory cell is 0
	
free(A); //free is used to free the allocated memory. There is no delete() in C language.
	
</code>
		</dynamic-memory-allocation>
		<serialization>
			Serialization is the process of converting a data object—a combination of code and data 
			represented within a region of data storage—into a series of bytes that saves the state 
			of the object in an easily transmittable form.<br></br><br></br>
		</serialization>
		<deserialization>
			Deserialization is the process of reconstructing a data structure or object from a series 
			of bytes or a string in order to instantiate the object for consumption. 
			<br></br><br></br>
			This is the 
			reverse process of serialization, i.e., converting a data structure or object into a 
			series of bytes for storage or transmission across devices.<br></br><br></br>
		</deserialization>
		<enums>
			Enumeration (or enum) is a user defined data type in C. <br></br>
			It is mainly used to 
			assign names to integral constants, the names make a program easy to read and maintain.
			<br></br><br></br>
		</enums>
		<multi-threading>
			A thread is a single sequence stream within a process. Because threads have some of 
			the properties of processes, they are sometimes called lightweight processes. 
			<br></br><br></br>
			Threads are not independent from each other unlike processes. As a result, 
			threads shares with other threads their code section, data section and OS resources 
			like open files and signals. 
			<br></br>
			But, like processes, a thread has its own program 
			counter (PC), a register set, and a stack space. 
			<br></br><br></br>
			Why Multithreading? Threads are popular way to improve application through parallelism. 
			<br></br>
			For example, in a browser, multiple tabs can be different threads. MS word uses 
			multiple threads, one thread to format the text, other thread to process inputs, etc. 
			<br></br><br></br>
			Threads operate faster than processes due to following reasons: <br></br><br></br>
			<blue>
			1) Thread creation is much faster. <br></br>
			2) Context switching between threads is much faster. <br></br>
			3) Threads can be terminated easily <br></br>
			4) Communication between threads is faster.<br></br>
			</blue>
		</multi-threading>
		<bitwise-operators>
			The <code>&#38;</code> (bitwise AND) in C takes two numbers as operands and does AND on every bit 
			of two numbers. The result of AND is 1 only if both bits are 1.  
			<br></br><br></br>
			The <code>|</code> (bitwise OR) in C takes two numbers as operands and does OR on every bit 
			of two numbers. The result of OR is 1 if any of the two bits is 1. 
			<br></br><br></br>
			The <code>^</code> (bitwise XOR) in C takes two numbers as operands and does XOR on every 
			bit of two numbers. The result of XOR is 1 if the two bits are different. 
			<br></br><br></br>
			The <code>&lt;&lt;</code> (left shift) in C takes two numbers, the left shifts the bits of the 
			first operand, and the second operand decides the number of places to shift. 
			<br></br><br></br>
			The <code>&gt;&gt;</code> (right shift) in C takes two numbers, right shifts the bits of the 
			first operand, and the second operand decides the number of places to shift.
			<br></br><br></br>
			The <code>~</code> (bitwise NOT) in C takes one number and inverts all bits of it.
			<br></br><br></br>
			The left-shift and right-shift operators should not be used for negative numbers.<br></br>
			The left-shift and right-shift operators are equivalent to multiplication and division by 
			2 respectively.<br></br><br></br>
			
			The bitwise OR of two numbers is just the sum of those two numbers if there is no carry 
			involved, otherwise, you just add their bitwise AND.
			<br></br><br></br>
			Let’s say, we have <code>a=5(101)</code> and <code>b=2(010)</code>, since there is no carry involved, 
			their sum is just <code>a|b</code>. <br></br>
			Now, if we change ‘a’ to 6 which is 110 in binary, their sum would change 
			to <code>a|b + a&#38;b</code> since there is a carry involved. 
			<br></br><br></br>
			The bitwise XOR operator is the most useful operator from a technical interview perspective.
			<br></br><br></br>
			It is used in many problems. <br></br>
			A simple example could be: “Given a set of numbers where all 
			elements occur an even number of times except one number, find the odd occurring number.”
			<br></br>
			This problem can be efficiently solved by doing XOR to all numbers. 
			<br></br><br></br>
			
			The <code>&#38;</code> operator can be used to quickly check if a number is odd or even.<br></br>

			The value of the expression <code>(x &#38; 1)</code> would be non-zero only if x is odd, otherwise, 
			the value would be zero. <br></br><br></br>
			
			The <code>~</code> operator should be used carefully.
			<br></br><br></br>
			The result of the <code>~</code> operator on a small number can be a big number if the result 
			is stored in an unsigned variable. <br></br>
			The result may be a negative number if the result 
			is stored in a signed variable (assuming that the negative numbers are stored in 2’s 
			complement form where the leftmost bit is the sign bit).<br></br>
		</bitwise-operators>
		<macros>
			Macros in C are powerful tools that allow developers to define reusable code snippets. 
			<br></br>
			They are defined using preprocessor directives and primarily used for code substitution 
			and generation. 
			<br></br>
			Macros provide a convenient way to write concise and efficient code, 
			improving the readability and maintainability of C programs.<br></br>
<code>
// C program to illustrate macros
#include &lt;stdio.h&gt;
 
// Macro definition
#define AREA(l, b) (l * b)
 
int main()
{
    // Given lengths l1 and l2
    int l1 = 10, l2 = 5, area;
 
    // Find the area using macros
    area = AREA(l1, l2);
 
    // Print the area
    printf("Area of rectangle"
           " is: %d",
           area);
 
    return 0;
}
</code>		
			<br></br><br></br>
			Object-Like Macros:<br></br><br></br>
			An object-like macro is a simple identifier that will be replaced by a code fragment. 
			<br></br>
			It is called object-like because it looks like an object in code that uses it. 
			<br></br>
			It is popularly used to replace a symbolic name with a numerical/variable represented 
			as a constant.
			<br></br>
<code>
//Chain Macros
  
// Macro definition
#define INSTAGRAM FOLLOWERS
#define FOLLOWERS 138 

/*
Both macros INSTAGRAM and FOLLOWERS have same value - 138
*/


Multi-line macros
#include &lt;stdio.h&gt;
 
// Multi-line Macro definition
#define ELE 1, \
            2, \
            3
 
int main()
{
 
    // Array arr[] with elements
    // defined in macros
    int arr[] = { ELE };
 
    // Print elements
    printf("Elements of Array are:\n");
 
    for (int i = 0; i &lt; 3; i++) {
        printf("%d  ", arr[i]);
    }
    return 0;
}
  
</code>
		</macros>
		<defines>
			In C programming, <code>#define</code> is a preprocessor directive that is used to define macros. 
			The macros are the identifiers defined by #define which are replaced by their value before 
			compilation. <br></br><br></br>
			We can define constants and functions like macros using <code>#define</code>.
		</defines>
		<command-line-arguments>
			Command line arguments are passed to the main function 
			as <code>argc</code> and <code>argv</code>. <br></br>
			Command line arguments are used to control the program from 
			the outside. <code>argv[argc]</code> is a Null pointer. <br></br>
			The name of the program is 
			stored in <code>argv[0]</code>, the first command-line parameter in <code>argv[1]</code>, 
			and the	last argument in <code>argv[n]</code>.
			<br></br><br></br>
			<code>argc (ARGument Count)</code> is an integer variable that stores the number of 
			command-line 
			arguments passed by the user including the name of the program. 
			<br></br>
			So if we pass a 
			value to a program, the value of argc would be 2 (one for argument and one for 
			program name). <br></br>
			The value of argc should be non-negative.<br></br><br></br>
			<code>argv (ARGument Vector)</code> is an array of character pointers listing all the arguments.
			<br></br>
			If <code>argc</code> is greater than zero, the array elements from <code>argv[0]</code> 
			to <code>argv[argc-1]</code> will 
			contain pointers to strings.<br></br>
			<code>argv[0]</code> is the name of the program. 
			<br></br>
			After that until <code>argv[argc-1]</code> every element 
			is command -line arguments.<br></br><br></br>
			
			<red>Properties of Command Line Arguments in C:<br></br><br></br></red>
			<green>
			They are passed to the main() function.<br></br>
			They are parameters/arguments supplied to the program when it is invoked.<br></br>
			They are used to control programs from outside instead of hard coding those values 
			inside the code.<br></br><br></br>
			argv[argc] is a NULL pointer.<br></br>
			argv[0] holds the name of the program.<br></br>
			argv[1] points to the first command line argument and argv[argc-1] points to 
			the last argument.<br></br>
			</green>
		</command-line-arguments>
		<ternary-operator>
			Ternary operator is used for decision making instead of placing longer if and else 
			conditional statements.
			<br></br><br></br>
			Syntax:
			<code>condition ? value_if_true : value_if_false</code>
			<br></br>
			The statement evaluates to <code>value_if_true</code> if condition is met, and <code>value_if_false</code> 
			otherwise.<br></br><br></br>
			
			<red>The ternary operator take three arguments:</red>
			<br></br><br></br>
			<green>
			The first is a comparison argument;<br></br>
			The second is the result upon a true comparison;<br></br>
			The third is the result upon a false comparison;<br></br>
			</green>
		</ternary-operator>
		<modular-programming>
			Modular programming consists of separating implementation from interface and 
			hiding information in the implementation.
			<br></br><br></br>
			<red>Advantages of modular programming:</red>
			<br></br><br></br>
			
			<green>Code is easier to read</green> - Working on modular programming makes code easier to read 
			because functions perform different tasks as compared to monolithic codes. 
			Sometimes modular programming can be a bit messy if we pass arguments and 
			variables in different functions. The use of modules should be done in a 
			sensible manner so as to avoid any problem. Functions should be neat, clean, 
			and descriptive.<br></br><br></br>
			
			<green>Code is easier to test</green> - In software, some functions perform fewer tasks and 
			also functions that perform numerous tasks. If the software is easily split 
			using modules, it becomes easier to test. We can also focus on the riskier 
			functions during testing and need more test cases to make it bug-free.<br></br><br></br>
			
			<green>Reusability</green> - There are times where a piece of code is implemented everywhere in 
			our program. Instead of copying and pasting it, again and again, modularity 
			gives us the advantage of reusability so that we can pull our code from 
			anywhere using interfaces or libraries. The concept of reusability also 
			reduces the size of our program.<br></br><br></br>
			
			<green>Faster fixes</green> - Suppose there is an error in the payment options in any 
			application, and the bug needs to be removed. Modularity can be a great help 
			because we know that there will be a separate function that will contain the 
			code of payments, and only that function will only be rectified. Thus using 
			modules to find and fixing bugs becomes much more smooth and maintainable.<br></br><br></br>
			
			<green>Low-risk update</green> - In modular programming, a defined layer of APIs protects things that 
			use it from making changes inside the library. Unless there is a change in the API, 
			there is a low risk for someone's code-breaking. For example, if you didn't have 
			explicit APIs and someone changed a function they thought was only used within that 
			same library (but it was used elsewhere), they could accidentally break something.<br></br><br></br>
			
			
			<green>Easy collaboration</green> - Different developers work on a single piece of code in the team. 
			There are chances of conflicts when there's a git merge. This conflict can be reduced 
			if the code is split between more functions, files, repos, etc. We can also provide 
			ownership to specific code modules, where a team member can break them down into 
			smaller tasks.<br></br><br></br><br></br>
			
			
			<red>Disadvantages of modular programming:</red>
			<br></br><br></br>
			There is a need for extra time and budget for a product in modular programming.<br></br><br></br>
			It is a challenging task to combine all the modules.<br></br><br></br>
			Careful documentation is required so that other program modules are not affected.<br></br><br></br>
			Some modules may partly repeat the task performed by other modules. Hence, 
			Modular programs need more memory space and extra time for execution.<br></br><br></br>
			Integrating various modules into a single program may not be a task because 
			different people working on the design of different modules may not have the 
			same style.<br></br><br></br>
			It reduces the program's efficiency because testing and debugging are 
			time-consuming, where each function contains a thousand lines of code.<br></br><br></br>
		</modular-programming>
		<datatype-conversions>
			Generally there are two types of conversion:<br></br>
			- implicit conversion (done automatically by the compiler)<br></br>
			- explicit conversion (done manually by the developer)<br></br>
			<br></br><br></br>
			Implicit conversion is done automatically by the compiler when you assign a value 
			of one type to another.<br></br><br></br>
			Explicit conversion is done manually by placing the type in parentheses () in front 
			of the value. Also knows as typecasting. 
			<br></br><br></br>
		</datatype-conversions>
		<operators>
			An operator is a symbol that tells the compiler to perform specific mathematical or 
			logical functions. By definition, an operator performs a certain operation on 
			operands. An operator needs one or more operands for the operation to be performed.<br></br>
			<br></br>
			Depending on how many operands are required to perform the operation, operands are called as 
			unary, binary or ternary operators. They need one, two or three operands respectively.<br></br>
			<br></br>
			Unary operators − <code>++</code> (increment), <code>--</code> (decrement), <code>!</code> (NOT), <code>~</code> (compliment), <code>&#38;</code> (address of), <code>*</code> (dereference)
			<br></br><br></br>
			Binary operators − arithmetic, logical and relational operators except !
			<br></br><br></br>
			Ternary operators − The <code>?</code> operator.
			<br></br><br></br>
			C language is rich in built-in operators and provides the following types of operators −
			<br></br><br></br>
			Assume variable <code>A = 10</code> and variable <code>B = 20 </code> then: <br></br><br></br>
			<green>Arithmetic Operators: <br></br></green>
<code>
+ <red>it adds two operands.</red>
A + B = 30

− <red>it subtracts second operand from the first.</red>
A − B = -10

* <red>it multiplies both operands.</red>
A * B = 200

/ <red>it divides numerator by de-numerator.</red>
B / A = 2

% <red>is the Modulus Operator it gives the remainder after an integer division.</red>
B % A = 0

++ <red>is the Increment operator, it increases the integer value by one.</red>
A++ = 11
<red>++ IS NOT AVAILABLE IN PYTHON.</red>

-- <red>is the Decrement operator, it decreases the integer value by one.</red>
A-- = 9
<red>-- IS NOT AVAILABLE IN PYTHON.</red>
</code>
		<green><br></br>Relational Operators<br></br></green>
<code>
== <red>it checks if the values of two operands are equal or not. 
If yes, then the condition becomes true.</red>
(A == B) is not true.

!= <red>it checks if the values of two operands are equal or not.
If the values are not equal, then the condition becomes true.</red>
(A != B) is true.

&gt; <red>it checks if the value of left operand is greater than the value of right operand.
If yes, then the condition becomes true.</red>
(A &gt; B) is not true.

&lt; <red>it checks if the value of left operand is less than the value of right operand.
If yes, then the condition becomes true.</red>
(A &lt; B) is true.

&gt;= <red>it checks if the value of left operand is greater than or equal to the value of right operand.
If yes, then the condition becomes true.</red>
(A &gt;= B) is not true.

&lt;= <red>it checks if the value of left operand is less than or equal to the value of right operand. 
If yes, then the condition becomes true.</red>
(A &lt;= B) is true.
</code>
		<green><br></br>Logical Operators<br></br></green>
<code>
	
&#38;&#38; <red>it's called Logical AND operator. Results in TRUE if both the operands are non-zero, 
then the condition becomes true.</red>
(A &#38;&#38; B) is false.

|| <red>it's called Logical OR Operator.  Results in TRUE if any of the two operands is non-zero, 
then the condition becomes true.</red>
(A || B) is true.

! <red>it's called Logical NOT Operator. It is used to reverse the logical state of its operand. 
If a condition is true, then Logical NOT operator will make it false.</red>
!(A &#38;&#38; B) is true.
</code>
		<br></br>Bitwise Operators<br></br>
<code>
&#38; <red>binary AND Operator copies a bit to the result if it exists in both operands.</red>	
(A &#38; B) = 12, i.e., 0000 1100

| <red>binary OR Operator copies a bit if it exists in either operand.</red>
(A | B) = 61, i.e., 0011 1101

^ <red>binary XOR Operator copies the bit if it is set in one operand but not both.</red>	
(A ^ B) = 49, i.e., 0011 0001

~ <red>binary One's Complement Operator is unary and has the effect of 'flipping' bits.</red>	
(~A ) = ~(60), i.e,. -0111101

&lt;&lt; <red>binary Left Shift Operator. 
The left operands value is moved left by the number of bits specified by the right operand.</red>
A &lt;&lt; 2 = 240 i.e., 1111 0000

&gt;&gt; <red>binary Right Shift Operator. 
The left operands value is moved right by the number of bits specified by the right operand.</red>
A &gt;&gt; 2 = 15 i.e., 0000 1111
</code>
		<green><br></br>Assignment Operators<br></br></green>
<code>
= <red>is the assignment operator. 
Assigns values from right side operands to left side operand.</red>
C = A + B will assign the value of A + B to C

+= <red>the add AND assign operator. 
It adds the right operand to the left operand and assign the result to the left operand.</red>	
C += A is equivalent to C = C + A

-= <red>Subtract AND assignment operator. 
It subtracts the right operand from the left operand and assigns the result to the left operand.</red>	
C -= A is equivalent to C = C - A

*= <red>Multiply AND assignment operator. 
It multiplies the right operand with the left operand and assigns the result to the left operand.</red>	
C *= A is equivalent to C = C * A

/= <red>the divide AND assign operator. 
It divides the left operand with the right operand and assigns the result to the left operand.</red>
C /= A is equivalent to C = C / A

%= <red>the modulus AND assign operator. 
It takes modulus using two operands and assigns the result to the left operand.</red>
C %= A is equivalent to C = C % A

&lt;&lt;= <red>the Left shift AND assign operator.
It takes the value stored in variable C shifts it to the left by the number of bits specified after the equal sign and then assigns the result of the operation back to C variable</red>
C &lt;&lt;= 2 is same as C = C &lt;&lt; 2

&gt;&gt;= <red>the Right shift AND assign operator.
It takes the value stored in variable C shifts it to the right by the number of bits specified after the equal sign and then assigns the result of the operation back to C variable.</red>
C &gt;&gt;= 2 is same as C = C &gt;&gt; 2

&#38;= <red>the bitwise AND assign operator.
It takes the value stored in variable C performs bitwise AND with the value specified after the equal sign and then assigns the result of the operation back to C variable.</red>
C &#38;= 2 is same as C = C &#38; 2

^= <red>the bitwise exclusive OR and assign operator.
It takes the value stored in variable C performs bitwise XOR with the value specified after the equal sign and then assigns the result of the operation back to C variable.</red>
C ^= 2 is same as C = C ^ 2

|= <red>the bitwise inclusive OR and assign operator.
It takes the value stored in variable C performs bitwise OR with the value specified after the equal sign and then assign the result of the operation back to C variable.</red>
C |= 2 is same as C = C | 2
</code>
		</operators>
		<pre-post-incrementation>
			Increment operators are used to increase the value of a variable by 1.<br></br>
			This operator is represented by the ++ symbol. The increment operator can either
			increase the value of the variable by 1 before assigning it to the variable or 
			can increase the value of the variable by 1 after assigning the variable. 
			Thus it can be classified into two types:
			<br></br><br></br>
			<blue>
			Pre-Increment Operator<br></br>
			Post-Increment Operator<br></br>
			</blue>
		</pre-post-incrementation>
		<constructors>
			A constructor in C++ is a special method that is automatically called when an object 
			of a class is created.
			<br></br><br></br>
			Constructors can also take parameters (just like regular functions), which can be 
			useful for setting initial values for attributes.<br></br>
		</constructors>
		<instantiation>
			In object-oriented programming, an instance is a concrete realization of a class. <br></br>
			When you define a class, you're essentially creating a blueprint. <br></br>
			An instance, then, is an object built from that blueprint. <br></br>
			It has all the characteristics defined in the class, but with specific values.<br></br>
		</instantiation>
		<destructors>
			Destructor is an instance member function that is invoked automatically whenever an object is 
			going to be destroyed. 
			Meaning, a destructor is the last function that is going to be called before an object is destroyed.
			<br></br><br></br>
			- A destructor is also a special member function like a constructor.
			Destructor destroys the class objects created by the constructor. <br></br>
			- Destructor has the same name as their class name preceded by a tilde (~) symbol.<br></br>
			- It is not possible to define more than one destructor. <br></br>
			- The destructor is only one way to destroy the object created by the constructor. 
			Hence destructor can-not be overloaded.<br></br>
			- Destructor neither requires any argument nor returns any value.<br></br>
			- It is automatically called when an object goes out of scope. <br></br>
			- Destructor release memory space occupied by the objects created by the constructor.<br></br>
			- In destructor, objects are destroyed in the reverse of an object creation.<br></br>
		</destructors>
		<function-overloading>
			Function overloading is a feature of object-oriented programming where two or more 
			functions can have the same name but different parameters. <br></br>
			Function overloading can be considered as an example of a polymorphism feature.<br></br>
			<br></br><br></br>
			If multiple functions having same name but parameters of the functions should be different is 
			known as Function Overloading.<br></br>
			If we have to perform only one operation and having same name of the functions increases 
			the readability of the program.<br></br><br></br>
			Overloaded functions can be defined both outside and inside classes.<br></br>
		</function-overloading>
		<operator-overloading>
			Operator overloading is a compile-time polymorphism. <br></br>
			It is an idea of giving special meaning to an existing operator 
			without changing its original meaning. <br></br>
		</operator-overloading>
		<namespaces>
			A namespace is a feature which can be defined as a
			declarative region that provides a scope to the identifiers (names of functions, 
			variables or other user-defined data types) inside it. <br></br>
		</namespaces>
		<exception-handling>
			In computer programming exceptions are runtime anomalies or abnormal conditions that a program 
			encounters during its execution. The process of handling these exceptions is 
			called exception handling. <br></br>
			Using the exception handling mechanism, the control 
			from one part of the program where the exception occurred can be transferred 
			to another part of the code.
			<br></br><br></br>
			By using exception handling we can handle the anomalies so that our 
			program keeps running.<br></br>
		</exception-handling>
		<default-parameters>
			A default parameter/argument is a value provided in a function declaration that is 
			automatically assigned by the compiler if the calling function doesn’t provide 
			a value for the argument. In case any value is passed, the default value is 
			overridden. <br></br>
		</default-parameters>
		<interfaces>
			In programming: an interface describes the behavior or capabilities of a class without 
			committing to a particular implementation of that class.
			<br></br><br></br>
			The interfaces are implemented using abstract classes and these abstract classes 
			should not be confused with data abstraction which is a concept of keeping 
			implementation details separate from associated data.<br></br>
		</interfaces>
		<abstract-classes>
			The purpose of an abstract class (often referred to as an ABC) is to provide an 
			appropriate base class from which other classes can inherit. <br></br>
			Abstract classes cannot be used to instantiate objects and serves only as an 
			interface. <br></br>
			Attempting to instantiate an object of an abstract class causes a 
			compilation error. <br></br>
			<br></br>
			Thus, if a subclass of an ABC needs to be instantiated, it has to implement each of 
			the virtual functions, which means that it supports the interface declared by the 
			ABC. Failure to override a pure virtual function in a derived class, 
			then attempting to instantiate objects of that class, is a compilation error.
			<br></br><br></br>
			An object-oriented system might use an abstract base class to provide a common and 
			standardized interface appropriate for all the external applications. <br></br>
			Then, through inheritance from that abstract base class, derived classes are 
			formed that operate similarly.
			<br></br><br></br>
			The capabilities (i.e., the public functions) offered by the external applications 
			are provided as pure virtual functions in the abstract base class. <br></br>
			The implementations of these pure virtual functions are provided in the derived 
			classes that correspond to the specific types of the application.<br></br>
		</abstract-classes>
		<optional-parameters>
			A parameter with a default value, is often known as an "optional parameter".
			<br></br><br></br> 
			For more information see the <blue>default-parameters</blue> section.
		</optional-parameters>
		<decorators>
			Decorator is a structural pattern that allows adding new behaviors to objects 
			dynamically by placing them inside special wrapper objects, called decorators. 
			<br></br>
			Using decorators you can wrap objects countless number of times since both target 
			objects and decorators follow the same interface.<br></br>
		</decorators>
		<generic-programming>
			Generic programming is a style of computer programming in which algorithms are 
			written in terms of data types to-be-specified-later that are then instantiated 
			when needed for specific types provided as parameters.<br></br>
		</generic-programming>
	</programming_language>
	
	<programming_language>
		<name>C</name>
		<description>
			C is a general-purpose computer programming language.<br></br><br></br>
			It was created in the 1970s by Dennis Ritchie, and remains very widely used and 
			influential. <br></br><br></br>
			By design, C's features cleanly reflect the 
			capabilities of the targeted CPUs. It has found lasting use in operating 
			systems, device drivers, and protocol stacks, but its use in application 
			software has been decreasing. <br></br><br></br>
			C is commonly used on computer architectures that range from the largest 
			supercomputers to the smallest microcontrollers 
			and embedded systems.
		</description>
		<generic-programming>
			*General-Programming-Knowledge*
			<br></br>
			In C Language generic programming can be achieved using:<br></br><br></br>
			Variable argument lists;<br></br>
			Using <code>void *</code> and function pointers to write generic code;<br></br>
			Using libraries to reuse code without copying and recompiling;<br></br>
			Using plugins to get run-time overriding and more;
		</generic-programming>
		<variable-arguments-lists>
			C allows a function call to have a variable number of
			arguments with the variable argument list mechanism.<br></br>
			Use ellipsis <code>...</code> to denote a variable number of arguments to
			the compiler. The ellipsis can only occur at the end of an
			argument list.<br></br><br></br>
			Here are some standard function calls that use variable
			argument lists:<br></br><br></br>
			<code>int printf(const char *format, ...);</code><br></br>
			<code>int scanf(const char *format, ...);</code><br></br>
			<code>int execlp(const char *file, const char *arg, ...);</code><br></br>
		</variable-arguments-lists>
		<simple-data-types>*General-Programming-Knowledge*</simple-data-types>
		<complex-data-types>*General-Programming-Knowledge*</complex-data-types>
		<loops>*General-Programming-Knowledge*</loops>
		<collections>
			<code>Arrays</code>: Are collections of elements of the same data type with fixed size. 
			<br></br>Once the <code>array</code> is defined, its size cannot be changed.<br></br><br></br>
			
			The <code>linked list</code> is a complex data type, which consists of a structure with at least 2 elements: value and pointer
			to the next element. <br></br>
			The memory can be allocated dynamically for each element added to the list. 
			<br></br><br></br>
			<green>
			The main benefit of a linked-list
			consists in the possibility of adding a variable number of elements, being able to delete or add an element without making copies
			or exchanges, but only by changing the addresses of the assigned pointers for the next / previous element.
			</green>
			<br></br><br></br>
			
<code>
<red>/*Declaring arrays and initializing arrays*/</red>

int arr[5];
int array_initialized[7] = [1,2,3,4,5,6,7];
float array_floats[3] = [2.0f, 3.0f, 2.11f];
</code>
<code>
<red>//Declaring and initializing a Linked List</red>

//Linked list definition:
struct LinkedList{
	int value; // this will store the value
	struct LinkedList * previous; // this will store the address of the previous block of memory
	struct LinkedList * next; // this will store the address of the next block of memory
};

struct LinkedList* list = NULL; // creating a linked list

int counter = 0;
while(counter &lt; 10)
{
	if(list == NULL) // if this is the first element to be introduced on the linked list
	{
		list = (struct LinkedList* )malloc(sizeof(struct LinkedList)); // allocate memory.
		list->value = counter; // add value
		list->previous = NULL; // there is no previous element.
		list->next = NULL; // we don't know if there will be a next element.
	}

	else //enter here after the first element was added.
	{

		list->next = (struct LinkedList* ) malloc(sizeof(struct LinkedList)); // allocate space for the next element
		list->next->previous = list; // we're still on the previous element, so assign the link to the next element.previous
		list = list->next; // next element become current element
		list->value = counter; // add value
		list->next = NULL;  // we don't know if there will be a next element.
	}
	counter++;
}

//printing the linked list
while(list != NULL) // list is currently pointing to the last element. So we will display it from last to first.
{
	printf("%d ", list->value);
	list = list->previous; // go to the previous
}
</code>
		</collections>
		<collection-methods>There are no built in functions for working with collections.</collection-methods>
		<dynamic-memory-allocation>*General-Programming-Knowledge*</dynamic-memory-allocation>
		<read-from-file>
			C programming language supports four pre-defined functions to read contents from a file, defined in <code>stdio.h</code> header file:
			<br></br><br></br>
			<blue>fgetc()</blue>– This function is used to read a single character from the file.<br></br>
			<blue>fgets()</blue>– This function is used to read strings from files.<br></br>
			<blue>fscanf()</blue>– This function is used to read formatted input from a file.<br></br>
			<blue>fread()</blue>– This function is used to read the block of raw bytes from files. This is used 
			to read binary files.
			<br></br><br></br>
			To open a file use: <code>fopen(filename, mode)</code>;
			<br></br><br></br>
			Where:<br></br><br></br>
			filename	The name of the actual file you want to open (or create), like filename.txt<br></br>
			mode	A single character, which represents what you want to do with the file 
			(read, write or append):<br></br><br></br>
			<blue>w</blue> - Writes to a file<br></br>
			<blue>a</blue> - Appends new data to a file<br></br>
			<blue>r</blue> - Reads from a file<br></br>
	
<code>
<red>/*Read file char by char*/</red>

FILE* ptr; //FILE is basically a data type, and we need to create a pointer variable to work with it 
char ch;

// Opening file in reading mode
ptr = fopen("test.txt", "r");

if (NULL == ptr) {
	printf("file can't be opened \n");
}

printf("content of this file are \n");

// Printing what is written in file
// character by character using loop.
do {
	ch = fgetc(ptr);
	printf("%c", ch);

	// Checking if character is not EOF.
	// If it is EOF stop reading.
} while (ch != EOF); 

</code>

<code>
/*

<red>Alternatively feof function can be used:</red>
feof() function takes file pointer as argument and returns true if pointer reaches the end of the file. 

while (!feof(ptr)) {
	ch = fgetc(ptr);
	printf("%c", ch);
}

*/
</code>

<code>
<red>//Reading whole content of the file as string:</red>

//fgets() reads one string at a time from the file. fgets() returns a string if it is
//successfully read by function or returns NULL if can not read. 

//Prototype: char * fgets(char *str, int size, FILE * ptr);

while (fgets(str, 50, ptr) != NULL) {
	printf("%s", str);
}
</code>

<code>
/*
fscanf() reads formatted input from a stream.

Approach:

fscanf reads formatted data from the files and stores it in variables.
The data in the buffer is printed on the console till the end of the file is reached.

*/

char buf[100];
while (fscanf(ptr, "%*s %*s %s ", buf) == 1)
	printf("%s\n", buf);
</code>
		
		</read-from-file>
		<write-to-file>
			To create a file, or write to a file you can use the w mode inside the fopen() function.<br></br>
			Function Prototype: fopen(filename, mode);
			<br></br><br></br>
			Where:<br></br><br></br>
			filename	The name of the actual file you want to open (or create), like filename.txt<br></br>
			mode	A single character, which represents what you want to do with the file 
			(read, write or append):<br></br><br></br>
			<blue>w</blue> - Writes to a file<br></br>
			<blue>a</blue> - Appends new data to a file<br></br>
			<blue>r</blue> - Reads from a file<br></br><br></br>
			
			The w mode means that the file is opened for writing. To insert content to it, you can 
			use the fprintf() function and add the pointer variable (fptr in our example) and some text:
			<br></br><br></br>
			If you write to a file that already exists, the old content is deleted, and the new content 
			is inserted. This is important to know, as you might accidentally erase existing content.
<code>
FILE *fptr; //FILE is basically a data type, and we need to create a pointer variable to work with it 

// Open a file in writing mode
fptr = fopen("filename.txt", "w");

// Write some text to the file using fprintf
fprintf(fptr, "Some text");

// Write some other text to the file fputs
fputs("Line wrote with fputs.", fp); 

// Close the file
fclose(fptr); // this will close the file when we are done with it.
</code>		
		Closing the file:
		<br></br><br></br>
		It is considered as good practice, because it makes sure that:
		<br></br><br></br>
		<blue>
		Changes are saved properly. <br></br>
		Other programs can use the file (if you want). <br></br>
		Clean up unnecessary memory space. <br></br><br></br>
		</blue>
		If you want to add content to a file without deleting the old content, 
		you can use the a mode. <br></br>
		The a mode appends content at the end of the file:<br></br>
		
<code>
/*Example*/

FILE *fptr;

// Open a file in append mode
fptr = fopen("filename.txt", "a"); 

/*Just like with the w mode; if the file does not exist, the a mode will create a 
new file with the "appended" content.*/

// Append some text to the file
fprintf(fptr, "\nHi everybody!");

// Close the file
fclose(fptr);
</code>
		</write-to-file>
		<serialization>*General-Programming-Knowledge*</serialization>
		<deserialization>*General-Programming-Knowledge*</deserialization>
		<enums>
			*General-Programming-Knowledge*
<code>
/*Examples*/
//Syntax: enum flag{constant1, constant2, constant3, ....... };

// An example program to demonstrate working
// of enum in C
#include &lt;stdio.h&gt;
 
enum week{Mon, Tue, Wed, Thur, Fri, Sat, Sun};
 
int main()
{
    enum week day;
    day = Wed;
    printf("%d",day);
    return 0;
} 
</code>
		</enums>
		<multi-threading>
<code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt; //Header file for sleep(). man 3 sleep for details. 
#include &lt;pthread.h&gt;
  
// A normal C function that is executed as a thread  
// when its name is specified in pthread_create() 

void *myThreadFun(void *vargp) 
{ 
    sleep(1); 
    printf("Printing GeeksQuiz from Thread \n"); 
    return NULL; 
} 
   
int main() 
{ 
    pthread_t thread_id; 
    printf("Before Thread\n"); 
    pthread_create(&#38;thread_id, NULL, myThreadFun, NULL); 
    pthread_join(thread_id, NULL); 
    printf("After Thread\n"); 
    exit(0); 
}
</code>
		</multi-threading>
		<exception-handling>C does not provide direct support to error handling (or exception handling).</exception-handling>
		<bitwise-operators>
<code>
// Example on how to use the bitwise operators:
#include &lt;stdio.h&gt;
int main()
{
    // a = 5(00000101), b = 9(00001001)
    unsigned char a = 5, b = 9;
 
    // The result is 00000001
    printf("a = %d, b = %d\n", a, b);
    printf("a &#38; b = %d\n", a &#38; b);
 
    // The result is 00001101
    printf("a|b = %d\n", a | b);
 
    // The result is 00001100
    printf("a^b = %d\n", a ^ b);
 
    // The result is 11111010
    printf("~a = %d\n", a = ~a);
 
    // The result is 00010010
    printf("b&lt;&lt;1 = %d\n", b &lt;&lt; 1);
 
    // The result is 00000100
    printf("b&gt;&gt;1 = %d\n", b &gt;&gt; 1);
 
    return 0;
	
	/*
	OUTPUT: 
	
	a = 5, b = 9
	a&#38;b = 1
	a|b = 13
	a^b = 12
	~a = 250
	b&lt;&lt;1 = 18
	b&gt;&gt;1 = 4
	
	*/
}
</code>
			*General-Programming-Knowledge*
		</bitwise-operators>
		<default-parameters>
			*General-Programming-Knowledge*
			<br></br>
			There are no default parameters in C. <br></br><br></br>
			One way to achieve this is by passing NULL pointers and 
			then set the values to the default if NULL is passed.
		</default-parameters>
		<interfaces>
			*General-Programming-Knowledge*
			<br></br>
			In C: an interface can be implemented as a set of function declarations without 
			any implementation details. <br></br>
			It defines a contract that concrete implementations must adhere to by providing 
			definitions for all the functions declared in the interface.
<code>
// Declare an interface for a shape
struct shape_interface {
  // Function pointers for the interface functions
  double (*area)(void*);
  double (*perimeter)(void*);
}; 

/*
In OOP there are classes that store to both variables and methods of an object.

In C we can have structs that store variables and structs that hold function pointers to defined behaviours
Both of them are close to forming a class.

*/
</code>
		</interfaces>
		<macros>*General-Programming-Knowledge*</macros>
		<defines>*General-Programming-Knowledge*</defines>
		<random-generators>
			The <code>rand()</code> function returns the random integers whose range from <code>0</code> to 
			<code>RAND_MAX</code>. <br></br>
			The <code>RAND_MAX</code> is a symbolic constant that defines in <code>stdlib.h</code> header file, whose value 
			is greater but less than 32767 depending on the C libraries.<br></br><br></br>
<code>
#include &lt;stdio.h&gt;    
#include &lt;conio.h&gt;  
#include &lt;stdlib.h&gt;  
void main()  
{     
    // use rand() function to generate the number  
    printf (" The random number is: %d", rand());  
    printf ("\n The random number is: %d", rand());  
      
    printf (" \n The random number is: %d", rand());  
    printf ("\n The random number is: %d", rand());  
    getch();  
}  		
</code>
			The <code>srand()</code> function is a C library function that determines the initial 
			point to generate 
			different series of pseudo-random numbers. <br></br>
			
			A <code>srand()</code> function cannot be used without 
			using a rand() function. <br></br>
			The <code>srand()</code> function is required to set the value of the seed 
			only once in a program to generate the different results of random integers before 
			calling the <code>rand()</code> function. <br></br><br></br>
<code>
#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;time.h&gt;  // use time.h header file to use time  
      
int main()  
{  
    int num, i;  
    time_t t1; // declare time variable  
      
    printf(" Enter a number to set the limit for a random number \n");  
    scanf (" %d", &#38;num);  
      
    /* define the random number generator */  
    srand ( (unsigned) time (&#38;t1)); // pass the srand() parameter  
    printf("\n"); // print the space
    /* generate random number between 0 to 50 */  
}  
</code>
		</random-generators>
		<command-line-arguments>
			*General-Programming-Knowledge*
<code>
/*Example*/
int main(int argc, char *argv[]) { /* ... */ }

//OR
int main(int argc, char **argv) { /* ... */ }
</code>
		</command-line-arguments>
		<ternary-operator>
			*General-Programming-Knowledge*
<code>
/*Using IF ELSE statements:*/

int a = 10, b = 20, c;

if (a &lt; b) 
{
    c = a;
}
else 
{
    c = b;
}

printf("%d", c);
<code>
</code>
/*Using TERNARY operator:*/

int a = 10, b = 20, c;

c = (a &lt; b) ? a : b;

printf("%d", c);

/*The output of both samples of code from above will result in: c = 3*/
</code>
		</ternary-operator>
		<modular-programming>
			*General-Programming-Knowledge*
			<br></br>
			In C this is achieved by placing 
			the interface definition in a header file and the implementation in a source 
			file. Disciplined use of static is used to hide implementation details.
			<br></br>
<code>
/*FILE module.h*/
 extern unsigned int Calculate_NoOfChars_In_string(char* str);

/*FILE module.c*/
unsigned int Calculate_NoOfChars_In_string(char* str)
{
	unsigned int counter = 0;
	while(str[counter]!="\0")
	{
		counter++;
	}
	return counter;
}

/*FILE main.c*/
#include &lt;module.h&gt;  
#include &lt;stdio.h&gt;  

int main()
{
	char strA[10] = "Some text.";
	unsigned int length = Calculate_NoOfChars_In_string(strA);
	print("String length is: %d\n", length);
}
</code>
		</modular-programming>
		<string-methods>
			C has many useful string functions, which can be used to perform certain operations 
			on strings.<br></br>
			To use them, you must include the <code>&lt;string.h&gt;</code> header file in your program.
			<br></br>
<code>
/* GET THE SIZE (IN CHARACTERS) OF STRINGS */
char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
printf("%d", strlen(alphabet));

/* Note that sizeof and strlen behaves differently, as sizeof also includes t
he \0 character when counting.*/

/* CONCATENATE STRINGS */

char str1[20] = "Hello ";
char str2[] = "World!";

// Concatenate str2 to str1 (result is stored in str1)
strcat(str1, str2);

// Print str1
printf("%s", str1);

/* COPY STRINGS */
char str1[20] = "Hello World!";
char str2[20];

// Copy str1 to str2
strcpy(str2, str1);

// Print str2
printf("%s", str2);

/* COMPARE STRINGS */

char str1[] = "Hello";
char str2[] = "Hello";
char str3[] = "Hi";

// Compare str1 and str2, and print the result
printf("%d\n", strcmp(str1, str2));  // Returns 0 (the strings are equal)

// Compare str1 and str3, and print the result
printf("%d\n", strcmp(str1, str3));  // Returns -4 (the strings are not equal)
</code>
		</string-methods>
		<datatype-conversions>
			*General-Programming-Knowledge*
			<br></br>
			It is one of the important concepts introduced in 'C' 
			programming.<br></br>
<code>
// Automatic conversion: int to float
float myFloat = 9;

printf("%f", myFloat); // 9.000000

// the compiler automatically converts the int value 9 to a float value of 9.000000.

// Automatic conversion: float to int
int myInt = 9.99;

printf("%d", myInt); // 9

// the compiler automatically converts the float value of 9.99 to int value 9.
</code>

<code>
//Calculate the percentage of a user's score in relation to the maximum score in a game:

// Set the maximum possible score in the game to 500
int maxScore = 500;

// The actual score of the user
int userScore = 420;

/* Calculate the percentage of the user's score in relation to the maximum available score.
Convert userScore to float to make sure that the division is accurate */
float percentage = (float) userScore / maxScore * 100.0;

// Print the percentage
printf("User's percentage is %.2f", percentage);
</code>
		</datatype-conversions>
		<optional-parameters>*General-Programming-Knowledge*</optional-parameters>
		<operators>
			*General-Programming-Knowledge*
			<green><br></br>Misc Operators<br></br></green>
<code>
sizeof() <red>it returns the size of a variable. sizeof(a), where a is integer, will return 4.</red>
&#38;  <red>it returns the address of a variable. &#38;a; returns the actual address of the variable.</red>
* <red>Pointer to a variable. *a;</red>
? : <red>Conditional Expression. If Condition is true ? then value X : otherwise value Y; </red>
</code>
		</operators>
		<pre-post-incrementation>
			*General-Programming-Knowledge*
<code>
//pre increment operator

#include &lt;stdio.h&gt;  
 
int main()
{
    int x = 10, a;
 
    a = ++x; // x will be incremented to 11 then value of x is assigned to a;
 
    printf("a = %d\n", a);
 
    printf("x = %d\n", x);
    return 0;
	
	/*
	OUTPUT: 
	a = 11
	x = 11
	*/
</code>
<code>
//post increment operator

#include &lt;stdio.h&gt;  
 
int main()
{
    int x = 10, a;
 
    a = x++; // x value is assined to a, then x value gets incremented to 11;

    printf("a = %d\n", a);
 
    printf("x = %d\n", x);
    return 0;
	
	/*
	OUTPUT: 
	a = 10
	x = 11
	*/

}
</code>
		</pre-post-incrementation>
	</programming_language>
	
	<programming_language>
		<name>C++</name>
		<description>
			C++ is a high-level, general-purpose programming language created by 
			Danish computer scientist Bjarne Stroustrup. <br></br><br></br>
			First released in 1985 as an extension of the C programming language, 
			it has since expanded significantly over time; as of 1997, C++ has object-oriented, 
			generic, and functional features. <br></br>
			In addition to facilities for low-level memory 
			manipulation for making things like microcomputers or to make operating systems 
			like Linux or Windows. <br></br><br></br>
			
			It is almost always implemented as a compiled language, 
			and many vendors provide C++ compilers, including the Free Software Foundation, 
			LLVM, Microsoft, Intel, Embarcadero, Oracle, and IBM.
		</description>
		<oop>*General-Programming-Knowledge*</oop>
		<encapsulation>
			*General-Programming-Knowledge*
<code>
#include &lt;iostream&gt;  
using namespace std;

class Employee {
  private:
    // Private attribute
    int salary;

  public:
    // Setter
    void setSalary(int s) {
      salary = s;
    }
    // Getter
    int getSalary() {
      return salary;
    }
};

int main() {
  Employee myObj;
  myObj.setSalary(50000);
  cout &lt;&lt; myObj.getSalary();
  return 0;
}
</code>
		</encapsulation>
		<polymorphism>
			*General-Programming-Knowledge*
<code>
#include &lt;iostream&gt;  

/*

The word polymorphism means having many forms. 
Typically, polymorphism occurs when there is a hierarchy of classes and they are related by inheritance.

C++ polymorphism means that a call to a member function will cause a different function to be executed depending on the type of object that invokes the function. 
Example if a parent class function is set to be override-able, then a parent class pointer can have functionality of the a child class object.

A pure virtual function is a function that is declared in the parent class and it really needs to be defined in
each one of the child classes.

Syntax: virtual void DisplayFunction () = 0;

*/
using namespace std;

class Shape{
    //By default a member without access-specifier is set to private.

	protected:
	int length;
	int height;

	public:
	virtual void DisplayInfo() //Each child class has to provide its own definition of this method.
	{
		cout &lt;&lt; "This is the parent class." &lt;&lt; endl;
	}
};

class Square: public Shape
{

	private:
	int area;
	void CalcArea()
	{
		area=length*height;
	}

	public:
	Square (int len, int hg)
	{
		length=len;
		height=hg;
		CalcArea();
	};
	void DisplayArea()
	{
		cout &lt;&lt; "Area: " &lt;&lt; area &lt;&lt; endl;
	}
	
	//This function overrides the parent class function
	void DisplayInfo()
	{
		cout &lt;&lt; "This is the child class." &lt;&lt; endl;
	}
};

class Circle: public Shape
{

	private:
	int radius;
	
	public:
	Circle(int len)
	{
		radius=len/2;
	}
	void DisplayRadius()
	{
		cout &lt;&lt; "Radius: " &lt;&lt; radius &lt;&lt; endl;
	}
};

int main()
{
    Shape *p;
    Circle circle_object(22);
    Square square_object(4,3);
	
    /*
    The pointer of type Shape can reference any of the Shape class children, but having only the functionality of Shape
    Class.
    */
	
    p=&#38;circle_object;
    p-&gt;DisplayInfo();
    p=&#38;square_object;
    p-&gt;DisplayInfo();
	
    int a;
    cin &gt;&gt; a;
    return 0;
	
	/*
	Using same variable we accessed different behaviour for each child class.
	*/
}
</code>	
		</polymorphism>
		<inheritance>
			In C++, it is possible to inherit attributes and methods from one class to another. 
			We group the "inheritance concept" into two categories:
			<br></br><br></br>
			<green>
			- derived class (child) - the class that inherits from another class;<br></br>
			- base class (parent) - the class being inherited from;<br></br><br></br>
			</green>
			To inherit from a class, use the : symbol.<br></br>
<code>
#include &lt;iostream&gt;  
#include &lt;conio.h&gt;  

using namespace std;

//BASE CLASS
class Shape{

    protected: 
	//protected variables are visible into this class and the other classes that are inherited to this.

	string name;
		
    public:
	Shape(string newname)
	{
		name=newname;
	}
	string getName() const
	{
		return name;
	}
};

//CHILD CLASS ONE
class Circle : public Shape //making Circle class derive from the Shape class (setting the inheritance).
{
    //inheritance is a way to make 2 classes share the same variables between each other

    double radius; //this variable can be private, or protected or public (anything).

    public:
	Circle(string inheritedName, double newradius) : Shape (inheritedName)//this will call the Shape constructor
	//which will set a value into it's string variable called 'name', in this way, a variable will be used in 2 classes.
	{
		radius=newradius;
	}
	double getCircleRadius() const
	{
		return radius;
	}

};

//CHILD CLASS TWO
class Rectangle : public Shape // making the Rectangle class derive from Shape Class, let the Rectangle Class, use the
//protected variables of the Shape Class.
{
    double length, width;

    public:
	Rectangle (string inheritedName2, double newlength, double newwidth): Shape (inheritedName2)
	{
		length=newlength;
		width=newwidth;
	}
	double getRectangleLength() const
	{
		return length;
	}
	double getRectangleWidth () const
	{
		return width;
	}
};

int main()
{
    Shape object("Shape Class String"); //create object
    cout &lt;&lt; object.getName() &lt;&lt; endl; //calling a function from the class

    cout &lt;&lt; endl &lt;&lt; "CHILD ONE CLASS: " &lt;&lt; endl;
	
    Circle objectchild ("Circle (stored in Shape Class String)", 3.0); //create object
    cout &lt;&lt; objectchild.getName() &lt;&lt; endl; //calling a function from Shape Class using the object from Circle Class.
    cout &lt;&lt; objectchild.getCircleRadius() &lt;&lt; endl;

    cout &lt;&lt; endl &lt;&lt; "CHILD TWO CLASS: " &lt;&lt; endl;
	
    Rectangle objectchild2("Rectangle (stored in Shape Class String)", 20.0, 65.0); //create object
    cout &lt;&lt; objectchild2.getName() &lt;&lt; endl; //calling a function from Shape Class using the object from Rectangle Class.
	cout &lt;&lt; objectchild2.getRectangleLength() &lt;&lt; endl;
    cout &lt;&lt; objectchild2.getRectangleWidth() &lt;&lt; endl;

    getch();
    return 0;
}
</code>
		</inheritance>
		<abstraction>
			Data abstraction is one of the most essential and important features of object-oriented 
			programming in C++. <br></br><br></br>
			Abstraction means displaying only essential information and hiding the 
			details. Data abstraction refers to providing only essential information about the 
			data to the outside world, hiding the background details or implementation. 
			<br></br><br></br>

<code>
#include &lt;iostream&gt;  
using namespace std;
 
class implementAbstraction {
private:
    int a, b;
 
public:
    // method to set values of
    // private members
    void set(int x, int y)
    {
        a = x;
        b = y;
    }
 
    void display()
    {
        cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;
        cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;
    }
};
 
int main()
{
    implementAbstraction obj;
    obj.set(10, 20);
    obj.display();
    return 0;
	
	/*
	OUTPUT:
	a = 10
	b = 20
	*/
}
</code>
		We are not allowed to access the variables a and b directly, however, one can call 
		the function set() to set the values in a and b and the function display() to 
		display the values of a and b. 
		<br></br><br></br>
		
		<red>Advantages of Data Abstraction:</red>
		<br></br><br></br>
		<green>
		Helps the user to avoid writing the low-level code;<br></br>
		Avoids code duplication and increases reusability.<br></br>
		Can change the internal implementation of the class independently without 
		affecting the user.<br></br>
		Helps to increase the security of an application or program as only important 
		details are provided to the user.<br></br>
		It reduces the complexity as well as the redundancy of the code, therefore 
		increasing the readability.
		<br></br>
		</green>
		</abstraction>
		<generic-programming>
			In C++ the templates generalize the algorithm to make it data type-independent.
			<br></br>		
			The functions and classes which are data type independent are called generics, 
			and this concept is called generic programming. 
			<br></br>
			Generic Programming reduces code 
			repetition and in-demand compilation; hence efficient.
			<br></br>

<code>
#include &lt;iostream&gt;  

// Template Function with a Type T
// During instantiation, this T will be replaced by the data type of argument.
template &lt;class T&gt;  
T maxNum (T a, T b) {
 return (a &gt;   b ? a : b); //ternary operator
}

int main()
{
    int x = 5, y = 2;
    float a = 4.5, b = 1.3;
    
    std::cout &lt;&lt; maxNum&lt;int&gt;(x, y) &lt;&lt; "\n";
    std::cout &lt;&lt; maxNum&lt;float&gt;(a, b);
    return 0;
}
</code>
		</generic-programming>
		<variable-arguments-lists>
			The variable number of arguments in C++ is a feature that permits a function to 
			accept any number of arguments. This type of function is called variadic functions.
			<br></br><br></br>
			Functions with a variable number of arguments in C++ can be easily implemented using 
			a vector or an array if all the arguments are the same type.
			<br></br><br></br>
			If all arguments are of different types, then we need to use the cstdarg header file 
			to implement variadic functions.
			<br></br><br></br>
			Variadic functions do not put restrictions on the types of arguments. They also do not perform 
			integer and floating-point enhancements.
			<br></br>
<code>
<red>// Implementation of variable arguments using vector.</red>
#include &lt;iostream&gt; 
#include &lt;vector&gt; 
using namespace std;

// Using vector of string as a parameter to store a variable number of strings.
void printNames(vector&lt;string&gt;  nameVector) {
    for (string &#38;name : nameVector) {
        cout &lt;&lt; name &lt;&lt; " ";
    }
    cout &lt;&lt; '\n';
}

int main() {
    printNames({"Scaler", "Topics"});
    printNames({"Technopedia", "for", "your", "mastermind!"});
    return 0;
}
</code>

<code>
<red>// Implementation of variable arguments using cstdarg variadic functons.</red>
#include &lt;iostream&gt; 
#include &lt;cstdarg&gt; 

using namespace std;

void printDeveloperData(const char* fmt...) {
    va_list args;
    va_start(args, fmt);
 
    while (*fmt != '\0') {
        if (*fmt == 'd') {
            int version = va_arg(args, int);
            std::cout &lt;&lt; "C++ Version: " &lt;&lt; version;
        } else if (*fmt == 'c') {
            int name = va_arg(args, int);
            std::cout &lt;&lt; "Name: " &lt;&lt; static_cast&lt;char&gt; (name);
        } else if (*fmt == 'f') {
            double stability_percentage = va_arg(args, double);
            std::cout &lt;&lt; "Stability Percentage: " &lt;&lt; stability_percentage &lt;&lt; "%";
        }
        ++fmt;
        cout &lt;&lt; '\n';
    }
 
    va_end(args);
}
 
int main() {
    printDeveloperData("cdf", 'B', 20, 94.7);
    
    return 0;

}
</code>

<code>
<red>// Implementation of variable arguments using variadic templates. </red>
#include &lt;iostream&gt; 
using namespace std;

template &lt;typename T&gt; 
void printDeveloperData(T t) {
    cout &lt;&lt; t &lt;&lt; '\n' ;
}

template&lt;typename T, typename... Args&gt; 
void printDeveloperData(T t, Args... args) {
    cout &lt;&lt; t &lt;&lt; '\n';
    printDeveloperData(args...) ;
}

int main() {
    printDeveloperData("Bjarne", 20, 94.7);
}
</code>
		</variable-arguments-lists>
		<simple-data-types>
			All variables use data type during declaration to restrict the type of data to 
			be stored. Therefore, we can say that data types are used to tell the variables 
			the type of data they can store. <br></br>
			Whenever a variable is defined in C++, 
			the compiler allocates some memory for that variable based on the data type 
			with which it is declared. Every data type requires a different amount of memory.
			<br></br><br></br>
			The datatypes presented on C Language are still available in C++:
			<br></br><br></br>
			*General-Programming-Knowledge*
			<br></br><br></br>
			<green>Primitive Datatypes:</green><br></br>
			<blue>
			Integer<br></br>
			Character<br></br>
			Boolean<br></br>
			Floating Point<br></br>
			Double Floating Point<br></br>
			Valueless or Void<br></br>
			Wide Character<br></br>
			</blue>
			<br></br>
		</simple-data-types>
		<complex-data-types>
			*General-Programming-Knowledge*
			Aditional to the C Language, C++ introduced classes as a user-defined datatype.
			<br></br><br></br>
			<green>Derived Datatypes:</green><br></br>
			<blue>
			Function<br></br>
			Array<br></br>
			Pointer<br></br>
			Reference<br></br>
			</blue>
			<br></br>
			<green>User-defined Datatypes:</green><br></br>
			<blue>
			Class<br></br>
			Structure<br></br>
			Union<br></br>
			Enumeration<br></br>
			Typedef defined Datatype<br></br>
			</blue>
		</complex-data-types>
		<loops>
			*General-Programming-Knowledge*
			<br></br><br></br>
			Additional to the loops presented in C language, there is also a "for-each loop" 
			(introduced in C++ version 11 (2011), which is used exclusively to loop through 
			elements in an array (or other data sets):
<code>
/*Example of foreach loop in C++*/

int myNumbers[5] = {10, 20, 30, 40, 50};
for (int i : myNumbers) {
  cout &lt;&lt;  i &lt;&lt;  "\n";
}
</code>
		</loops>
		<collections>
			*General-Programming-Knowledge*<br></br><br></br>
			Additional to C Language: C++ introduced several new collection classes datatypes:
			<br></br><br></br>
			<blue>
			Vector: The C++ Standard Library vector class is a class template for sequence containers.<br></br>
			</blue>
			<br></br>
			<green>
			Vector is a type of dynamic array which has the ability to resize 
			automatically after insertion or deletion of elements. The elements in vector 
			are placed in contiguous storage so that they can be accessed and traversed using 
			iterators. Element is inserted at the end of the vector.<br></br><br></br>
			</green>
<code>
#include &lt;iostream&gt; 
#include &lt;vector&gt; 
 
int main()
{
    // Create a vector containing integers
    std::vector&lt;int&gt;  v = {8, 4, 5, 9};
 
    // Add two more integers to vector
    v.push_back(6);
    v.push_back(9);
 
    // Overwrite element at position 2
    v[2] = -1;
 
    // Print out the vector
    for (int n : v)
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
</code>	
		<green>
		List: List is a double linked sequence that supports both forward and backward 
		traversal. The time taken in the insertion and deletion in the beginning, end 
		and middle is constant. It has the non-contiguous memory and there is no 
		pre-allocated memory.<br></br>
		</green>
<code>
// C++ program to demonstrate the use of list containers
#include &lt;iostream&gt; 
#include &lt;list&gt; 
using namespace std;
 
int main()
{
    // defining list
    list&lt;int&gt;  gqlist{12,45,8,6};
 
    for (auto i : gqlist) {
        cout &lt;&lt; i &lt;&lt; ' ';
    }
    return 0;
}
</code>
		</collections>
		<collection-methods>
			Some of the methods available in C++ for the Collection Type Classes: Vector or List are:
			<br></br><br></br>
			<red>Capacity:</red><br></br>
			<code>size()	</code><br></br>Return size<br></br><br></br>
			<code>max_size()</code><br></br>Return maximum size<br></br><br></br>
			<code>resize()	</code><br></br>Change size<br></br><br></br>
			<code>capacity()</code><br></br>Return size of allocated storage capacity<br></br><br></br>
			<code>empty()	</code><br></br>Test whether vector is empty<br></br><br></br>
			<code>reserve()	</code><br></br>Request a change in capacity<br></br><br></br>
			<code>shrink_to_fit()</code><br></br>Shrink to fit<br></br><br></br>
			<br></br>
			<red>Element access:</red><br></br>
			<code>operator[]</code><br></br>Access element<br></br><br></br>
			<code>at()</code><br></br>Access element<br></br><br></br>
			<code>front()</code><br></br>Access first element<br></br><br></br>
			<code>back()</code><br></br>Access last element<br></br><br></br>
			<code>data()</code><br></br>Access data<br></br><br></br>
			<br></br>
			<red>Modifiers:</red><br></br>
			<code>assign()</code><br></br>Assign vector content<br></br><br></br>
			<code>push_back()</code><br></br>Add element at the end<br></br><br></br>
			<code>pop_back()</code><br></br>Delete last element<br></br><br></br>
			<code>insert()</code><br></br>Insert elements<br></br><br></br>
			<code>erase()</code><br></br>Erase elements<br></br><br></br>
			<code>swap()</code><br></br>Swap content<br></br><br></br>
			<code>clear()</code><br></br>Clear content<br></br><br></br>
			<code>emplace()</code><br></br>Construct and insert element<br></br><br></br>
			<code>emplace_back()</code><br></br>Construct and insert element at the end<br></br><br></br>
		</collection-methods>
		<dynamic-memory-allocation>
			*General-Programming-Knowledge*
			Additional to the C language: 
			<br></br><br></br>
			C++ integrates the operators <code>new</code> and <code>delete</code> for allocating dynamic memory. 
			But these were not available in the C language; instead, it used a library solution, 
			with the functions <code>malloc</code>, <code>calloc</code>, <code>realloc</code> and <code>free</code>, 
			defined in the header <code>&lt;cstdlib&gt;</code> (known as <code>&lt;stdlib.h&gt;</code>  in C). 
			<br></br>
			The functions are also available in C++ and can also be 
			used to allocate and deallocate dynamic memory.
			<br></br><br></br>
			<red>Operators new and new[]: </red>
			<br></br>
			Dynamic memory is allocated using operator new. new is followed by a data 
			type specifier and, if a sequence of more than one element is required, 
			the number of these within brackets []. <br></br>
			It returns a pointer to the beginning of the new block of memory allocated. <br></br>
<code>
//Example:
int * foo;
foo = new int [5];
</code>
		In this case, the system dynamically allocates space for five elements of type int 
		and returns a pointer to the first element of the sequence, which is assigned to 
		foo (a pointer). <br></br>
		Therefore, foo now points to a valid block of memory with space 
		for five elements of type int.<br></br>
		<br></br>
		<red>Operators delete and delete[]: </red>
		<br></br>
		In most cases, memory allocated dynamically is only needed during specific periods 
		of time within a program; once it is no longer needed, it can be freed so that 
		the memory becomes available again for other requests of dynamic memory. <br></br>
		<br></br>
		This is the purpose of operator delete, whose syntax is: <br></br>
<code>
// Example of dynamic allocation
// and deallocation of memory using new and delete
#include &lt;iostream&gt; 
using namespace std;

int main()
{
    // Pointer initialization to null
    int* p = NULL;

    // Request memory for the variable
    // using new operator
    p = new (nothrow) int;
    if (!p)
        cout &lt;&lt; "allocation of memory failed\n";
    else {
        // Store value at allocated address
        *p = 29;
        cout &lt;&lt; "Value of p: " &lt;&lt; *p &lt;&lt; endl;
    }

    // Request block of memory
    // using new operator
    float* r = new float(75.25);

    cout &lt;&lt; "Value of r: " &lt;&lt; *r &lt;&lt; endl;

    // Request block of memory of size n
    int n = 5;
    int* q = new (nothrow) int[n];

    if (!q)
        cout &lt;&lt; "allocation of memory failed\n";
    else {
        for (int i = 0; i &lt; n; i++)
            q[i] = i + 1;

        cout &lt;&lt; "Value store in block of memory: ";
        for (int i = 0; i &lt; n; i++)
            cout &lt;&lt; q[i] &lt;&lt; " ";
    }

    // freed the allocated memory
    delete p;
    delete r;

    // freed the block of allocated memory
    delete[] q;

    return 0;
	
	/*
	OUTPUT:
	Value of p: 29
	Value of r: 75.25
	Value store in block of memory: 1 2 3 4 5 
	*/
}
</code>
		</dynamic-memory-allocation>
		<read-from-file>
			The fstream library can be used in C++ to work with files.
			<br></br><br></br>
			There are three classes included in the fstream library, which are used to create, write or read files:
			<br></br><br></br>
			Class		Description<br></br>
			<red>ofstream</red>	Creates and writes to files<br></br>
			<red>ifstream</red>	Reads from files<br></br>
			<red>fstream</red>		A combination of ofstream and ifstream: creates, reads, and writes to files
			<br></br><br></br>
			To read from a file, use either the ifstream or fstream class, and the name of the file.
			<br></br><br></br>
			<green>Note: we also use a while loop together with the getline() function 
			(which belongs to the ifstream class) to read the file line by line, and to print 
			the content of the file:</green>
			<br></br>
<code>
// Create a text string, which is used to output the text file

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;

int main() 
{
	string myText;

	// Read from the text file
	ifstream MyReadFile("filename.txt");

	// Use a while loop together with the getline() function to read the file line by line
	while (getline (MyReadFile, myText)) {
	  // Output the text from the file
	  cout &lt;&lt; myText;
	}

	// Close the file
	MyReadFile.close(); //It is considered good practice to close the file, 
	//and it can clean up unnecessary memory space.
}
</code>
		</read-from-file>
		<write-to-file>
			The fstream library can be used in C++ to work with files.
			<br></br><br></br>
			There are three classes included in the fstream library, which are used to create, 
			write or read files:
			<br></br><br></br>
			Class		Description<br></br>
			<red>ofstream</red>	Creates and writes to files<br></br>
			<red>ifstream</red>	Reads from files<br></br>
			<red>fstream</red>		A combination of ofstream and ifstream: creates, reads, and writes to files
			<br></br><br></br>
			Create and Write To a File:<br></br>
			To create a file, use either the ofstream or fstream class, and specify 
			the name of the file.
			<br></br><br></br>
			To write to the file, use the insertion operator (&lt;&lt;).<br></br>
<code>
//Example of writing to file using fstream in C++

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;

int main() 
{
	// Create and open a text file
	ofstream MyFile("filename.txt");

	// Write to the file
	MyFile &lt;&lt; "Files can be tricky, but it is fun enough!";

	// Close the file
	MyFile.close(); //It is considered good practice to close the file, 
	//and it can clean up unnecessary memory space.
}
</code>
		</write-to-file>
		<serialization>
			*General-Programming-Knowledge*
			<br></br><br></br>
			Serialization is the process of storing the state of an object to a file.<br></br>
<code>
/*Example of C++ object.field serialization and deserialization*/

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;

class Student 
{
    public:
	
	string name;
	int rollno;
	string branch;

	Student () // default constructor
	{
	} 
	
	Student (string n, int r, string b) // overloading constructor
	{
		name = n;
		rollno = r;
		branch = b;
	}
	
	//override the insertion operator for object.field serialization
    friend ofstream &#38; operator &lt;&lt; (ofstream &#38; ofs, Student s);
	//now we can write individually every class field member to the file. Example: ofs &lt;&lt; s1.name; 
	
	//override the extraction for object.field deserialization
    friend ifstream &#38; operator &gt;&gt; (ifstream &#38; ifs, Student &#38; s);
	//now we can read individually every class field member from the file. Example: ifs &gt;&gt; s1.name; 
};

int main() 
{
	Student s1 ("James", 28, "IT");

	//Open the output stream
	ofstream ofs ("Student.txt", ios::trunc);

	//writing to the file
	ofs &lt;&lt; s1.name &lt;&lt; endl;
	ofs &lt;&lt; s1.rollno &lt;&lt; endl;
	ofs &lt;&lt; s1.branch &lt;&lt; endl;
	ofs.close();

	Student s2; //empty object

	//Open the input stream
	ifstream ifs("Student.txt");

	//reading from the file
	ifs &gt;&gt; s2.name;
	ifs &gt;&gt; s2.rollno;
	ifs &gt;&gt; s2.branch;
	ifs.close();

	cout &lt;&lt; s2.name &lt;&lt; endl;
	cout &lt;&lt; s2.rollno &lt;&lt; endl;
	cout &lt;&lt; s2.branch &lt;&lt; endl;

	/*
	
	OUTPUT: 
	James 
	28 
	IT
	
	*/
}
</code>
		</serialization>
		<deserialization>
			*General-Programming-Knowledge*
			<br></br><br></br>
			Deserialization is the reverse process of Serialization, 
			where the byte stream is used to reconstruct the original object.<br></br>
<code>
/*Example of C++ whole-object serialization and deserialization*/

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;
class Student
{
    public:
	
	string name;
	int rollno;
	string branch;
	Student () // default constructor
	{
	}
	
	Student (string n, int r, string b) // overloading constructor
	{
		name = n;
		rollno = r;
		branch = b;
	}

	//override the insertion operator for object.field serialization
    friend ofstream &#38; operator &lt;&lt; (ofstream &#38; ofs, Student s);
	//now we can write individually every class field member to the file. Example: ofs &lt;&lt; s1.name; 
	
	//override the extraction for object.field deserialization
    friend ifstream &#38; operator &gt;&gt; (ifstream &#38; ifs, Student &#38; s);
	//now we can read individually every class field member from the file. Example: ifs &gt;&gt; s1.name; 
};

//Overriding the operators for whole-object serialization and deserialization
ofstream &#38;  operator &lt;&lt; (ofstream &#38; ofs, Student s)
{
    ofs &lt;&lt; s.name &lt;&lt; endl;
    ofs &lt;&lt; s.rollno &lt;&lt; endl;
    ofs &lt;&lt; s.branch &lt;&lt; endl;
    return ofs;
}
ifstream &#38; operator &gt;&gt; (ifstream &#38; ifs, Student &#38; s)
{
    ifs &gt;&gt; s.name &gt;&gt; s.rollno &gt;&gt; s.branch;
    return ifs;
}

/*
now we can read/write the whole object to and from the file. 

Example: 
ofs &lt;&lt; s1; 
ifs &gt;&gt; s2; 

*/

int main()
{
	Student s1("James", 28, "IT");

	//Open the output stream
	ofstream ofs("Student.txt", ios::trunc);
	ofs &lt;&lt;  s1;
	ofs.close();

	Student s2; // empty object

	//Open the input stream
	ifstream ifs("Student.txt");
	ifs &gt;&gt; s2;
	ifs.close();
		
	cout &lt;&lt; s2.name &lt;&lt; " " &lt;&lt; s2.rollno &lt;&lt; " " &lt;&lt; s2.branch &lt;&lt; endl;

	/*
	
	OUTPUT:
	James 28 IT
	
	*/
}
</code>
		</deserialization>
		<constructors>
			*General-Programming-Knowledge*
<code>
/*Example*/
#include &lt;iostream&gt; 

using namespace std;

class MyClass {     // The class
  public:           // Access specifier
    MyClass() {     // Constructor
	
	/*
	The constructor has the same name as the class, it is always public, and it does not have any return value.
	*/
	
      cout &lt;&lt; "Hello World!";
    }
};

int main() {
  MyClass myObj;    // Create an object of MyClass (this will call the constructor)
  return 0;
}
</code>

<code>
/*Example*/
#include &lt;iostream&gt; 
#include &lt;string&gt; 

using namespace std;

class MyClass {     // The class
  public:           // Access specifier
    MyClass(string message) {     // Constructor with parameter
	
      cout &lt;&lt; message;
    }
};

int main() {
  MyClass myObj("Hello World!");    // Create an object of MyClass (this will call the constructor)
  return 0;
}
</code>
		</constructors>
		<instantiation>
			*General-Programming-Knowledge*
<code>
/*Example of instantiation*/

#include &lt;stdio.h&gt; 

class MyClass{

public:
    MyClass(){}
    void PrintMessage()
    {
        printf("Message from class member.\n");
    }
};

int main()
{
    //Instantiating the class:
    MyClass obj; 
    obj.PrintMessage();

    return 0;
}
</code>
		</instantiation>
		<destructors>
			*General-Programming-Knowledge*
<code>
class Test {
public:
    // User-Defined Constructor
    Test() { cout &lt;&lt; "\n Constructor executed"; }
 
    // User-Defined Destructor
    ~Test() { cout &lt;&lt; "\n Destructor executed"; }
};
</code>
		</destructors>
		<function-overloading>
			*General-Programming-Knowledge*
<code>
/*Example of function overloading*/

#include &lt;iostream&gt; 
using namespace std;
 
 
void add(int a, int b)
{
  cout &lt;&lt; "sum = " &lt;&lt; (a + b);
}
 
void add(double a, double b)
{
    cout &lt;&lt; endl &lt;&lt; "sum = " &lt;&lt; (a + b);
}
 
int main()
{
    add(10, 2); //calling function with ints
    add(5.3, 6.2); //calling function with floats
 
    return 0;
}
</code>
		</function-overloading>
		<operator-overloading>
			*General-Programming-Knowledge*
<code>
// Example of Operator Overloading

#include &lt;iostream&gt; 
using namespace std;
 
class Complex {
private:
    int real, imag;
 
public:
    Complex(int r = 0, int i = 0)
    {
        real = r;
        imag = i;
    }
 
    // This is automatically called when '+' is used with
    // between two Complex objects
    Complex operator+(Complex const	&#38; obj)
    {
        Complex res;
        res.real = real + obj.real;
        res.imag = imag + obj.imag;
        return res;
    }
    void print() { cout &lt;&lt; real &lt;&lt; " + i" &lt;&lt; imag &lt;&lt; '\n'; }
};
 
int main()
{
    Complex c1(10, 5), c2(2, 4);
    Complex c3 = c1 + c2;
    c3.print();
	
	/*
	OUTPUT:
	12 + i9
	*/
}
</code>
		</operator-overloading>
		<enums>
			*General-Programming-Knowledge*
			<br></br>
			Comparison to C Language: <br></br><br></br>
			In C, an enum is basically a way to alias names to integers. This does not lead to 
			improved type checking. In C++, an enum defines an actual type, which results in 
			strong type checking.<br></br>
<code>
#include &lt;iostream&gt; 
#include &lt;conio.h&gt; 

using namespace std;

/*
While processing a game loop, there are lots of statements to be checked, so in order to use those statements, variables
that will hold a certain value will be created. Example:
int GamePlay =1;
int PauseGame = 2;
int ExitGame = 3;

So in this way the statements can be checked, to see when the game should be paused, should run, or should exit. As you see
above, the variables that are used needs to have different values.

An ENUM is a way to enclose a bunch of constants, an ENUM guarantees that every variable inside it, will have different values.
Example: an ENUM with the variables above, can be created as follows:
enum GameStates {GamePlay, PauseGame, ExitGame};
So the synthax is:
enum &lt;name&gt; {states/members};
*/

//Creating a GLOBAL enum:
enum GameStates {GamePlay, PauseGame, ExitGame}; //the elements will take as constant value the position inside the enum;
//In this case: GamePlay = 0; PauseGame=1; ExitGame=2;

/*

ENUM Members cannot be initialized with values: 
Example GamePlay = 5, this will give compilation error.

Instead the ENUM can be initialized only as follows:
GameStates=ExitGame;

In this case the active value of the ENUM will be ExitGame;
The syntax is : &lt;enum name&gt; = &lt;enum member&gt;;

An ENUM Class is an ENUM that will use the scope resolution and an object of the ENUM class for assignments as above.

Example:
GameStates gameStates=GameStates::ExitGame;

An ENUM Class will make possible that you can have multiple ENUMS with the same MEMBERS. 

So we could have for example:
enum class GameState {Exit, MainMenu};
enum class SoftwareState (Exit, MainMenu);

Without using an ENUM Class this could not be possible because, the TWO MEMBERS will conflict to each other
(compilation error).

Syntax to create an ENUM Class:

enum class &lt;name&gt; { member1, member2...}
An ENUM cannot be forward declared, unless it's an ENUM Class. 
So only ENUM Classes can be forward declared.

To change the default value of an ENUM Member which consist in it's position on the ENUM, you can do as follows:

enum GameState {MainMenu=5, GamePlay=7, GameExit, GamePaused}; //the two uninitialized members follow gets the value of the
previous member+1; so GameExit will be 8, GamePause will be 9;

*/

int main()
{
    cout &lt;&lt; "GamePlay value: " &lt;&lt; GamePlay &lt;&lt; endl; // this is 0;
    cout &lt;&lt; "PauseGame value: " &lt;&lt; PauseGame &lt;&lt; endl; // this is 1;
    cout &lt;&lt; "ExitGame value: " &lt;&lt; ExitGame &lt;&lt; endl; // this is 2;
    getch();
    return 0;
}
</code>
		</enums>
		<multi-threading>
			*General-Programming-Knowledge*
			<br></br>
			C++ multithreading involves creating and using thread objects, seen as std::thread 
			in code, to carry out delegated sub-tasks independently. <br></br>
			New threads are passed a 
			function to complete, and optionally some parameters for that function.
			<br></br>
<code>
#include &lt;iostream&gt; 
#include &lt;cstdlib&gt; 
#include &lt;pthread.h&gt; 

using namespace std;

#define NUM_THREADS 5

void *PrintHello(void *threadid) {
   long tid;
   tid = (long)threadid;
   cout &lt;&lt; "Hello World! Thread ID, " &lt;&lt; tid &lt;&lt; endl;
   pthread_exit(NULL);
}

int main () {
   pthread_t threads[NUM_THREADS];
   int rc;
   int i;
   
   for( i = 0; i &lt; NUM_THREADS; i++ ) {
      cout &lt;&lt; "main() : creating thread, " &lt;&lt; i &lt;&lt; endl;
      rc = pthread_create(&#38;threads[i], NULL, PrintHello, (void *)i);
      
      if (rc) {
         cout &lt;&lt; "Error:unable to create thread," &lt;&lt; rc &lt;&lt; endl;
         exit(-1);
      }
   }
   pthread_exit(NULL);
}
</code>
		</multi-threading>
		<namespaces>
			*General-Programming-Knowledge*
			<br></br><br></br>
			In C++ multiple namespace blocks 
			with the same name are allowed.<br></br>
<code>
namespace Data
{
    class ObjectManager
    {
    public:
        void DoSomething() {}
    };
    void Func(ObjectManager) {}
}
</code>
		</namespaces>
		<exception-handling>
			*General-Programming-Knowledge*
			<br></br><br></br>
<code>
// C++ example on how to use of try,catch and throw
// for exception handling.
 
#include &lt;iostream&gt; 
#include &lt;stdexcept&gt; 
using namespace std;
 
int main()
{
 
    // try block
    try {
        int numerator = 10;
        int denominator = 0;
        int res;
 
        // check if denominator is 0 then throw runtime
        // error.
        if (denominator == 0) {
            throw runtime_error(
                "Division by zero not allowed!");
        }
 
        // calculate result if no exception occurs
        res = numerator / denominator;
        //[printing result after division
        cout &lt;&lt; "Result after division: " &lt;&lt; res &lt;&lt; endl;
    }
    // catch block to catch the thrown exception
    catch (const exception&#38; e) {
        // print the exception
        cout &lt;&lt; "Exception " &lt;&lt; e.what() &lt;&lt; endl;
    }
 
    return 0;
}
</code>
		</exception-handling>
		<bitwise-operators>
			*General-Programming-Knowledge*
			<br></br><br></br>
			Bitwise operators in C/C++ are 
			tools for working with individual bits in data. They might not be as famous as other 
			operators, but they’re essential for tasks like making code more efficient or 
			controlling hardware.
		</bitwise-operators>
		<default-parameters>
			*General-Programming-Knowledge*
<code>
// Example of Default Parameters/Arguments in C++.

#include &lt;iostream&gt; 
using namespace std;
 
// A function with default arguments,
// it can be called with
// 2 arguments or 3 arguments or 4 arguments.

int sum(int x, int y, int z = 0, int w = 0) //assigning default values to z,w as 0
{
    return (x + y + z + w);
}
 
int main()
{
    // Statement 1
    cout &lt;&lt; sum(10, 15) &lt;&lt; endl;
   
    // Statement 2
    cout &lt;&lt; sum(10, 15, 25) &lt;&lt; endl;
   
    // Statement 3
    cout &lt;&lt; sum(10, 15, 25, 30) &lt;&lt; endl;
    return 0;
}
</code>
		</default-parameters>
		<interfaces>
			*General-Programming-Knowledge*
<code>
/*Example of an interface implementation*/
class Box {
   public:
      // pure virtual function
      virtual double getVolume() = 0;
      
   private:
      double length;      // Length of a box
      double breadth;     // Breadth of a box
      double height;      // Height of a box
};
</code>
		</interfaces>
		<abstract-classes>
			*General-Programming-Knowledge*
<code>
/*Example of abstract class*/

#include &lt;iostream&gt; 
 
using namespace std;
 
// Base class
class Shape {
   public:
      // pure virtual function providing interface framework.
      virtual int getArea() = 0;
      void setWidth(int w) {
         width = w;
      }
   
      void setHeight(int h) {
         height = h;
      }
   
   protected:
      int width;
      int height;
};
 
// Derived classes
class Rectangle: public Shape {
   public:
      int getArea() { 
         return (width * height); 
      }
};

class Triangle: public Shape {
   public:
      int getArea() { 
         return (width * height)/2; 
      }
};
 
int main(void) {
   Rectangle Rect;
   Triangle  Tri;
 
   Rect.setWidth(5);
   Rect.setHeight(7);
   
   // Print the area of the object.
   cout &lt;&lt; "Total Rectangle area: " &lt;&lt; Rect.getArea() &lt;&lt; endl;

   Tri.setWidth(5);
   Tri.setHeight(7);
   
   // Print the area of the object.
   cout &lt;&lt; "Total Triangle area: " &lt;&lt; Tri.getArea() &lt;&lt; endl; 

   return 0;
}
</code>
		
		</abstract-classes>
		<macros>
			*General-Programming-Knowledge*
			Similar to C Language: 
			<br></br><br></br>
			A C++ macro is defined as a section of code that that particular macro value can 
			replace. <br></br>
			We can define the macro by using a #define directive. 
			When the compiler goes to the macros while program compilation, 
			the macro's name is replaced by the definition of the macro. 
			<br></br>
			The termination of the C++ Macros does not need a 
			semi-colon (;).
			<br></br><br></br>
			Aditionally to the C Language: the header file: &lt;limits.h&gt; is defined to help finding 
			the range of fundamental data-types. <br></br>
			Unsigned modifiers have minimum value is zero. So, no macro constants are defined for the unsigned minimum value.
			<br></br><br></br>
			<red>
			Macro Constants<br></br><br></br>
			</red>
			<green>
			<blue>CHAR_MIN</blue>  - The minimum value for an object of type char <br></br><br></br>	
			<blue>CHAR_MAX</blue>  - Maximum value for an object of type char <br></br><br></br>		
			<blue>SCHAR_MIN</blue>  - The minimum value for an object of type Signed char <br></br><br></br>	
			<blue>SCHAR_MAX</blue>  - Maximum value for an object of type Signed char <br></br><br></br>		
			<blue>UCHAR_MAX</blue>  - Maximum value for an object of type Unsigned char <br></br><br></br>		
			<blue>CHAR_BIT</blue>  - Number of bits in a char object <br></br><br></br>		
			<blue>MB_LEN_MAX</blue>  - Maximum number of bytes in a multi-byte character <br></br><br></br>		
			<blue>SHRT_MIN</blue>  - The minimum value for an object of type short int <br></br><br></br>		
			<blue>SHRT_MAX</blue>  - Maximum value for an object of type short int <br></br><br></br>		
			<blue>USHRT_MAX</blue>  - Maximum value for an object of type Unsigned short int <br></br><br></br>		
			<blue>INT_MIN</blue>  - The minimum value for an object of type int <br></br><br></br>		
			<blue>INT_MAX</blue>  - Maximum value for an object of type int <br></br><br></br>		
			<blue>UINT_MAX</blue>  - Maximum value for an object of type Unsigned int <br></br><br></br>	
			<blue>LONG_MIN</blue>  - The minimum value for an object of type long int <br></br><br></br>		
			<blue>LONG_MAX</blue>  - Maximum value for an object of type long int <br></br><br></br>		
			<blue>ULONG_MAX</blue>  - Maximum value for an object of type Unsigned long int <br></br><br></br>		
			<blue>LLONG_MIN</blue>  - The minimum value for an object of type long long int <br></br><br></br>		
			<blue>LLONG_MAX</blue>  - Maximum value for an object of type long long int <br></br><br></br>	
			<blue>ULLONG_MAX</blue> - Maximum value for an object of type Unsigned long long int		
			</green>
<code>
/*An example of defining a C++ macro:*/

using namespace std;
 
// Here is the definition of macro.
#define AREA(l, b) (l * b)

int main() {
    // The given lengths are l1 and l2.
    int l1 = 20, l2 = 2, area;
 
    // Here, finding the area using macro.
    area = AREA(l1, l2);
 
    return 0;
}
</code>
		</macros>
		<random-generators>
			*General-Programming-Knowledge*
			<br></br>
			For C++:
			<br></br><br></br>
			<code>rand()</code> function is an inbuilt function in C++ STL, which is defined in 
			header file <code>&lt;cstdlib&gt;</code>. <code>rand()</code> is used to generate a 
			series of random numbers. <br></br>
			The random number is generated by using an algorithm that gives a series of 
			non-related numbers whenever this function is called. <br></br>
			The <code>rand()</code> function is 
			used in C++ to generate random numbers in the range <code>[0, RAND_MAX)</code>.
			<br></br><br></br>
			<red>Syntax of rand()</red>:
<code>
int rand(void);
</code>
			<red>Parameters of rand():</red><br></br>
			This function does not take any parameters.<br></br><br></br>
			<red>Return Value of rand():</red><br></br>
			rand() returns a pseudo-random number in the range of [0, RAND_MAX).<br></br>
		</random-generators>
		<command-line-arguments>*General-Programming-Knowledge*</command-line-arguments>
		<ternary-operator>*General-Programming-Knowledge*</ternary-operator>
		<modular-programming>*General-Programming-Knowledge*</modular-programming>
		<string-methods>
			The <code>std::string</code> is a class in C++ since C++98. This class is the standard 
			representation for a text string. It includes some typical string operations 
			like find, replace, concatenate, compare etc. It is present in &lt;string&gt; 
			header file. <br></br><br></br>
			Commonly Used String Functions in C++:<br></br>
			<br></br>
			<blue>length() or size()</blue><br></br>
			It will return the length of the string.<br></br>
			<br></br>
			<blue>array[index]</blue><br></br>
			To access individual characters using array indexing.<br></br>
			<br></br>
			<blue>at()</blue><br></br>
			Used to access a character at a specified index.<br></br>
			<br></br>
			<blue>+ Operator</blue><br></br>
			<code>+</code> operator is used to concatenate two strings.<br></br>
			<br></br>
			<blue>append()</blue><br></br>
			The <code>append()</code> function adds one string to the end of another.<br></br>
			<br></br>
			<blue>== Operator</blue><br></br>
			You can compare strings using the <code>==</code> operator.<br></br>
			<br></br>
			<blue>compare()</blue><br></br>
			The <code>compare()</code> function returns an integer value indicating the 
			comparison result.<br></br>
			<br></br>
			<blue>substr()</blue><br></br>
			Use the substr() function to extract a substring from a string.<br></br>
			<br></br>
			<blue>find()</blue><br></br>
			The find() function returns the position of the first occurrence of a substring.<br></br>
			<br></br>
			<blue>replace()</blue><br></br>
			Use the replace() function to modify a part of the string.<br></br>
			<br></br>
			<blue>insert()</blue><br></br>
			The insert() function adds a substring at a specified position.<br></br>
			<br></br>
			<blue>erase()</blue><br></br>
			Use the erase() function to remove a part of the string.<br></br>
			<br></br>
			<blue>c_str()</blue><br></br>
			To obtain a C-style string from a <code>std::string</code>, you can use the 
			<code>c_str()</code> function.<br></br>
		</string-methods>
		<datatype-conversions>*General-Programming-Knowledge*</datatype-conversions>
		<optional-parameters>*General-Programming-Knowledge*</optional-parameters>
		<decorators>
			*General-Programming-Knowledge*
<code>
/*Example*/

#include &lt;iostream&gt; 
using namespace std;

class Computer
{
public:
    virtual void display()
    {
        cout &lt;&lt; "I am a computer..." &lt;&lt; endl;
    }
};

class CDDrive : public Computer
{
private:
    Computer* c;
public:
    CDDrive(Computer* _c)
    {
        c = _c;
    }
    void display()
    {
        c-&gt;display();
        cout &lt;&lt; "with a CD Drive..." &lt;&lt; endl;
    }
};

class Printer : public Computer
{
private:
    CDDrive* d;
public:
    Printer(CDDrive* _d)
    {
        d = _d;
    }
    void display()
    {
        d-&gt;display();
        cout &lt;&lt; "with a printer..." &lt;&lt; endl;
    }
};

int main()
{
    Computer* c = new Computer();
    CDDrive* d = new CDDrive(c);
    Printer* p = new Printer(d);

    p-&gt;display();
}
</code>
		</decorators>
		<operators>*General-Programming-Knowledge*</operators>
		<pre-post-incrementation>*General-Programming-Knowledge*</pre-post-incrementation>
	</programming_language>
	
	<programming_language>
		<name>C#</name>
		<description>
			C# is a general-purpose high-level programming language supporting multiple 
			paradigms. C# encompasses static typing, strong typing, lexically scoped, 
			imperative, declarative, functional, generic, object-oriented (class-based), 
			and component-oriented programming disciplines. <br></br><br></br>

			The C# programming language was designed by Anders Hejlsberg from Microsoft in 
			2000. <br></br><br></br>

			Microsoft introduced C# along with .NET Framework and Visual Studio, both of 
			which were closed-source. At the time, Microsoft had no open-source products. 
			<br></br><br></br>

			Four years later, in 2004, a free and open-source project called Mono began, 
			providing a cross-platform compiler and runtime environment for the C# 
			programming language. <br></br><br></br>

			A decade later, Microsoft released Visual Studio Code (code editor), 
			Roslyn (compiler), and the unified .NET platform (software framework), 
			all of which support C# and are free, open-source, and cross-platform. 
			Mono also joined Microsoft but was not merged into .NET.<br></br><br></br>
		</description>
		<oop>*General-Programming-Knowledge*</oop>
		<encapsulation>*General-Programming-Knowledge*
<code>
using System;

/*Members of the class should never be set to public, because public means that anyone who works at that program
 *is able to change the variable's value, so to avoid that, all the members (sometimes called proprieties), should
 * be private, (or protected for inheritance purposes).
 * Encapsulation - is the use of getter functions for getting the value of private member of the class.
 * and setter function for setting the value of a private member of the class.
 */
namespace project27_classes_encaptulation_and_exceptions_throwing
{
	class Program
	{
		public static void Main(string[] args)
		{
			Encapsulation_Example pobject = new Encapsulation_Example();
			pobject.SetAge(15);
			pobject.SetName("Ellias Mustellar");
			Console.WriteLine("Name: {0}\nAge: {1}", pobject.GetName(), pobject.GetAge());
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
	}
	class Encapsulation_Example
	{
		//Members: (sometimes called proprieties)
		private int _age; //as good programming habbit the private variables in a function should start with 
		//underscore/underline.
		private string _Name;
		
		//Setters:
		public void SetAge(int NewAge)
		{
			if(NewAge&lt;=0)
			{
				//An exception is an error message, that occures and terminates the program in case that
				//something goes wrong.
				//Sinthax for throwing exception
				throw new Exception("A person cannot have NULL or NEGATIVE age.");
			}
			_age=NewAge;
		}
		public void SetName(string NewName)
		{
			//string.IsNullOrEmpty (string_name) -> function that checks if a string is null or empty
			if(string.IsNullOrEmpty(NewName))
			{
				throw new Exception("The name cannot be NULL or EMPTY.");
			}
			_Name = NewName;
		}
		
		//Getters:
		public int GetAge()
		{
			return this._age;
		}
		public string GetName()
		{
			return this._Name;
		}
	}
}
</code>
		</encapsulation>
		<polymorphism>*General-Programming-Knowledge*
<code>
using System;

namespace project25_polymorphism
{
	class Program
	{
		public static void Main(string[] args)
		{
			/*The idea of polymorphism is creating an array of type parent class, to which you can assign
			 any object of type child classes.*/
			Parent [] objarray = new Parent[4];
			objarray[0]=new Parent();
			objarray[1]=new Child1();
			objarray[2]=new Child2();
			objarray[3]=new Child3();
			foreach(Parent k in objarray)
			{
				k.DisplayInfo(); //each child has the proprieties of the parent class
				
				/*To see the information of each child class we could make a function which will hide the parent
				 * class function, and contain the updated information of the child class. But a better way doing
				 * that is marking the parent class you'd wish to hide with virtual keyword, which will allow
				 * every child class overide the method by their own needs.
				 */
			}
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
	}
	class Parent
	{
		protected string FirstName, LastName;
		public Parent()
		{
			FirstName="FN";
			LastName="LN";
		}
		public virtual void DisplayInfo()
			//The virtual keyword will make this function overidable for each child class.
		{
			Console.WriteLine("This is parent class");
		}
	}
	class Child1:Parent
	{
		//This is the sinthax: for overriding (overwriting) a function.
		public override void DisplayInfo()
		{
			Console.WriteLine("This is a child 1 class.");
		}
	}
	class Child2:Parent
	{
		//This is the sinthax: for overriding (overwriting) a function.
		public override void DisplayInfo()
		{
			Console.WriteLine("This is a child 2 class.");
		}
	}
	class Child3:Parent
	{
		//This is the sinthax: for overriding (overwriting) a function.
		public override void DisplayInfo()
		{
			Console.WriteLine("This is a child 3 class.");
		}
	}
}
</code>
		</polymorphism>
		<inheritance>*General-Programming-Knowledge*
<code>
//FILE: MyClass.cs

using System;
using System.Collections.Generic;

/*

In C# for an inherited class can be only one parent class (only single class inheritance is allowed).
 IN CASE OF INHERITED CLASSES: the parent class constructor gets automatically executed before the child class 
constructor if the parent class constructor has no arguments.
Otherwise if the parent class has a constructors with multiple arguments/parameters it must be specified
at the child class constructor declaration a sinthax:
	:base()
and specify the arguments of the constructor that you want to be executed inside the pharanteses.
 
 IMPORTANT: To prevent a class of having children (inheritance), you can use the sealed keyword.
 A sealed class cannot have children (cannot be base class).
 
 */
namespace inherited_classes
{
	//These are called XML Comments:
	/// &lt;summary&gt;
	/// Inherited Classes
	/// &lt;/summary&gt;
	//This is the parent class.
	public class MyClass
	{
		protected string FirstName;
		protected string LastName;
		protected uint ?age;
		protected MyClass(string FSS)
		{
			Console.WriteLine(FSS);
		}
		public void DisplayInfo()
		{
			Console.WriteLine("Name: {0} {1}",FirstName, LastName);
			if(age==null)
			{
				Console.WriteLine("Age: No Age Provided");
			}
			else
			{
				Console.WriteLine("Age: {0}", age);
			}
		}
	}
	//This is the inherited class.
	public class Mates:MyClass
	{
		char Grades;
		//THIS IS DEFAULT CONSTRUCTOR
		public Mates(): base("CHILD CLASS CONTROLS THE PARENTS CLASS") //this needs to be public.
			//AS YOU SEE THE :base () sinthax appears here too.
		{
			FirstName="No First Name Provided";
			LastName="No Last Name Provided";
			age = null;
		}
		//THIS IS OVERLOADED CONSTRUCTOR
		public Mates(string FS, string LS, uint AGE_m, char GRD) : base("CHILD CLASS CONTROLS THE PARENTS CLASS")
			//the constructor needs to be public
			//:base () -> it's used to explicitely specify which constructor should be used for the parent class
			//THE SINTHAX must be used for each constructor of the child class.
			//if the parent class constructor takes no arguments, then the sinthax is optional.
		{
			FirstName=FS;
			LastName=LS;
			age=AGE_m;
			Grades=GRD;
		}
		public void DisplayGrades()
		{
			///&lt;summary&gt;Displays the grades of the objects in this class.&lt;/summary&gt;
			Console.WriteLine("Grade: {0}", Grades);
		}
	}
}
</code>

<code>
</code>
		</inheritance>
		<abstraction>*General-Programming-Knowledge*
<code>
using System;

/*

An abstract class is similar to an interface, dispite that it can contain variable_members (field members), and
 an abstract class it's acting like a class when it comes to inheritance. An abstract class can have implementation
 for some or even for all its members/field, while the interface cannot. An abstract class can use the (public) 
access modifiers while an interface cannot. An abstract class member is private by default while an interface
member is public by default. An interface can be inherited ONLY from another interface, while an abstract class
can be inherited either from an interface or abstract class. A class can be inherited from multiple interfaces in the
same time whereas a class cannot be inherited from multiple classes.

RULES FOR ABSTRACT CLASSES:
 1.An abstract class cannot be instanciated (an instance of the class cannot be created).
 2.An abstract class can contain abstract members, and the abstract members are not allowed to be implemented in
 that class.
 3.An abstract class can inherit (can have children classes), and every child of the class must provide its
 own implementations for the abstract members of the parent class.
 4.Any class provides single inheritance (the child of the class can have only one parent/base class).
 5.An abstract class can only be used as a base class. SO an abstract class cannot be SEALED.
 6.An abstract class CAN HAVE NO ABSTRACT MEMBERS, so it can provide implementation for all its fields and members.
 7.If a class that's inherited from an abstract class doesn't wish to provide implementation for the parent class
 abstract members, then that class can be also set as abstract.
 
 */

namespace project32_abstract_classes
{
	class Program: AbsClass //A class can inherit only from a single class. (multiple class inheritance is not allowed)
	{
		public static void Main(string[] args)
		{
			Program p1 = new Program();
			p1.MessageShow();
			p1.Print();
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
		//IN order to provide implementation for an abstract member of the parent class the override keyword 
		//must be used.
		protected override void Print()
		{
			Console.WriteLine("Providing implementation for the parent abstract class member.");
		}
	}
	//Creating an abstract class:
	public abstract class AbsClass
	{
		protected abstract void Print(); //this function is abstract
		public void MessageShow() //this is a normal function
		{
			Console.WriteLine("This is not an abstract member.");
		}
	}
}
</code>
		</abstraction>
		<generic-programming>*General-Programming-Knowledge*
<code>
using System;
/* The generic is a specification that allows to a function/method or class to operate without depending on the data type that's been taking 
 * as parameters, and without losing the strong typed property of the function, and the performance.
 * Generics were introduced in C# 2.0, and they are used especially for class collections.
 * 
 * The conversion from value type to reference type is called boxing. When we talk about performance provided by generics, we mean that
 * no boxing will be effectuated. Boxing are weak in performance.
 */

namespace project45_generics
{
	class Program
	{
		public static void Main(string[] args)
		{
			Program aProg = new Program();
			//Using the generic function:
			bool result = aProg.IsEqual&lt;int&gt; (21,44); //the function works for any data type.
			Console.WriteLine("Result of the comparison: {0}", result);
			result = aProg.IsEqual&lt;string&gt; ("Adam", "Exit"); //the function works for any data type.
			Console.WriteLine("Result of the comparison: {0}", result);
			result = aProg.IsEqual&lt;char&gt;('a', 'a'); //the function works for any data type.
			Console.WriteLine("Result of the comparison: {0}", result);
			
			//Working with the generic class:
			MyClass&lt;int&gt; GenCls = new MyClass&lt;int&gt;();
			GenCls.printStuff(12,3);
			MyClass&lt;string> GenCls2 = new MyClass&lt;string&gt;();
			GenCls2.printStuff("Deady", "Online");
			//End of program.
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
		//Creating a generic function:
		public bool IsEqual &lt;T&gt; (T value1, T value2) //the parameters are of type T, into that type could be encapsulated any data type.
		{
			return value1.Equals(value2);
		}
		//The sinthax to create a generic function is: access_modifier return_type function_name &lt;variable_type_name&gt; (arguments of 
		//variable_type_name).
	}
	//Creating a generic class
	#region GenericClass //this is how you can structure your code using regions
	class MyClass &lt;A&gt; //the sinthax is class Class_Name &lt;variable_type_name&gt;
	{
		//Creating a function for the generic class.
		public void printStuff(A value1, A value2)
		{
			Console.WriteLine("The stuff sent is: {0} &#38;&#38; {1}", value1, value2);
		}
	}
	#endregion //end of the region
}
</code>
		</generic-programming>
		<variable-arguments-lists>*General-Programming-Knowledge*
		<br></br>
		Use the param keyword to get the variable arguments in C#.
<code>
using System;

class Program {
   static void Main() {
      int mulVal1 = Multiply(5);
      int mulVal2 = Multiply(5, 10);

      Console.WriteLine(mulVal1);
      Console.WriteLine(mulVal2);
   }

   static int Multiply(params int[] b) {
      int mul =1;
      foreach (int a in b) {
         mul = mul*a;
      }
      return mul;
   }
}
</code>
		</variable-arguments-lists>
		<simple-data-types>*General-Programming-Knowledge*
<code>
using System;

namespace project1_introduction 
{
	class Program
	{
		public static void Main(string[] args) //the main function starts here;
		{ 
			//string[] args is an optional argument;
			
			//function to print on the screen;
			Console.WriteLine("Hello World!");
			//Data types:
			int numb_one = 5;
			float numb_two = 6.034f;
			double numb_three = 3.0;
			bool istrue = false;
			string name = "Black";
			object ANYTHING = "A variable that can be initialized with anything!";
			char character = 'X';
			
			//Printing the result on the screen;
			Console.Write("The result of addition is: " + (numb_one+numb_two) + "\n");
			Console.WriteLine("An object is: " + "\"" + ANYTHING + "\"");
			/*
 			Console.WriteLine - automatically puts '\n' at the end of the line, because it is a function
			designed to be used only for writing a line.
			 */
			
			Console.Write(character + "\n");
			Console.WriteLine("Processing data!\n\n");
			while (numb_one>0)
			{
				if(numb_one==1)
				{
					Console.WriteLine("The program will end.\n\n");
				}
				numb_one--;
			}
			Console.Write("Press any key to continue . . . ");
			//function to read keys;
			Console.ReadKey(true);
		}
	}
}
</code>
		</simple-data-types>
		<complex-data-types>*General-Programming-Knowledge*</complex-data-types>
		<loops>*General-Programming-Knowledge*
<code>
using System;

namespace project6_foreach_loop
{
	class Program
	{
		public static void Main(string[] args)
		{
			int [] myarray = new int[10];
			for (int i=0;i&lt;10;i++)
			{
				myarray[i]=3*i;
			}
			Console.WriteLine("\nDisplaying elements using FOR LOOP: ");
			for (int i=0;i&lt;10;i++)
			{
				Console.WriteLine("myarray[" + i + "]=" +myarray[i]);
			}
			Console.WriteLine("\nDisplaying elements using FOREACH LOOP: ");
			/*FOREACH LOOP is used especially when trying to iterrate into a list which has dinamic size, or 
			 * an array with unknown size.
			 * FOREACH is very similar to a FOR loop. FOREACH is used only for Collection of data.
			 * The difference between FOR LOOP and FOREACH LOOP is that in FOREACH LOOP there is no access to
			 * the index.
			 */
			foreach(int iter in myarray) // synthax forech (datatype iterator_name in data_collection)
			{
					Console.WriteLine("myarray[" + iter/3 + "]=" +iter);
			}
			Console.WriteLine("\nSimple task for FOREACH LOOP");
			foreach(int iter in myarray) // synthax forech (datatype iterator_name in data_collection)
			{
				if(iter%5==0 &#38;&#38; iter>0)
				{
					Console.WriteLine (iter + " is divisible with five.");
				}
			}
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
	}
}
</code>
		</loops>
		<collections>*General-Programming-Knowledge*
<code>
using System;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic;

/*A queue is a collection type just like a list or dictionary, dispite that once an object is retrieved from Queue (Dequeue), that object gets
 automatically deleted from the beggining of the Queue.*/
 
/*You can thing of a Queue just like an RAR archieve, because to use an object from the Queue, that object needs to be Dequeued into an another
  object, otherwise it will affect the entire content of the Queue, unless an foreach loop it's used.
  To prevent an object be deleted from the Queue, you have to use a foreach loop or the .Peak function, also you can iterate through the Queue using foreach loop, 
  and effect changes without affecting the content of the Queue.
 */

namespace queue_collection_type
{
	class Program
	{
		public static void Main(string[] args)
		{
			people p1 = new people ("Black", 22);
			people p2 = new people ("Mark", 24);
			
			//Creating Queue
			Queue &lt;people&gt; FirstQueue = new Queue &lt;people&gt; ();
			FirstQueue.Enqueue(p1);
			FirstQueue.Enqueue(p2);
			//Printing Information:
			Console.WriteLine("Number of objects in Queue: {0}\n", FirstQueue.Count());
			
			// Console.WriteLine ("Name: {0}, Age: {1}", FirstQueue.Dequeue().name, FirstQueue.Dequeue().Age); //this is wrong, unless it is
			//moved into a foreach loop:
			
			//A Queue is like an archieve, you need to extract the object from it, before using that object.
			Queue&lt;people&gt; SecondQueue = new Queue&lt;people&gt; ();
			SecondQueue.Enqueue(p1);
			SecondQueue.Enqueue(p2);
			people deq1 = FirstQueue.Dequeue();
			people deq2 = FirstQueue.Dequeue();
			
			/*SecondQueue=FirstQueue // these two Queues become highly connected one to another in the way that, SecondQueue take all the objects
			 from the FirstQueue, but if in FirstQueue an object is removed so it is in the SecondQueue.*/
			
			Console.WriteLine("Name: {0}, Age: {1}", deq1.name, deq1.Age);
			Console.WriteLine("Name: {0}, Age: {1}", deq2.name, deq2.Age);
			Console.WriteLine();
			//Auxiliar way -> Iteration:
			foreach (people p in SecondQueue)
			{
				Console.WriteLine("Name: {0}, Age: {1}", p.name, p.Age);
				Console.WriteLine ("Number of objects in Queue: {0}", FirstQueue.Count());
				Console.WriteLine("In the foreach loop the content of the Queue is it not affected, \n(Dequeue is made without removal).\n");
			}
			
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
	}
	class people 
	{
		public int Age {get; set;}
		public string name {get; set;}
		public people (string GivenName, int GivenAge) 
		{
			this.Age = GivenAge; 
			this.name = GivenName;
		}
	}
}
</code>

<code>
using System;
using System.Collections.Generic;

/*
 * A stack uses the principle LIFO - Last In First Out, it is just like a list.
 * Once an element gets retrieved from the Stack that object will be removed, unless a foreach loop, or the Peek function it's used.
 */
namespace project61_stack_collection_type
{
	class Program
	{
		public static void Main(string[] args)
		{
			people p1 = new people ("Dragos", 22);
			people p2 = new people ("Adrian", 21);
			Stack&lt;people&gt; FirstStack = new Stack&lt;people&gt;();
			FirstStack.Push(p1);
			FirstStack.Push(p2);
			//The first will be the last:
			foreach (people p in FirstStack)
			{
				Console.WriteLine("Name: {0}	Age: {1}", p.Name, p.Age);
				Console.WriteLine("Number of elements on Stack: {0}", FirstStack.Count);
			}
			Console.WriteLine();
			Console.WriteLine("Outside the forech loop:");
			Console.WriteLine("Name: {0}", FirstStack.Pop().Name);
			Console.WriteLine("Number of elements on Stack: {0}", FirstStack.Count);
			Console.WriteLine("Name: {0}", FirstStack.Pop().Name);
			Console.WriteLine("Number of elements on Stack: {0}", FirstStack.Count);
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
	}
	class people
	{
		public string Name {get; set;}
		public int Age {get; set;}
		public people (string NewName, int NewAge) {Name=NewName; Age=NewAge;}
	}
}
</code>
		</collections>
		<collection-methods>*General-Programming-Knowledge*</collection-methods>
		<dynamic-memory-allocation>
			In C#, objects are dynamically allocated on the heap using the new keyword.
			<br></br><br></br>
			When an object is no longer needed, it is the responsibility of the garbage 
			collector to deallocate the memory and reclaim it for future use.
		</dynamic-memory-allocation>
		<read-from-file>*General-Programming-Knowledge*
<code>
using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;

namespace read_from_file
{
	class Program
	{
		public static void Main(string[] args)
		{
			string textFromFile = System.IO.File.ReadAllText("textfile.txt"); // in this case location of the file is in project folder/debug.
			if(textFromFile!=string.Empty)
			{
				Console.WriteLine("Text From File: \n\n{0}", textFromFile);
			}
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
	}
}
</code>
		</read-from-file>
		<write-to-file>*General-Programming-Knowledge*
<code>
// Write file using StreamWriter
using (StreamWriter writer = new StreamWriter(fullPath))
{
   writer.WriteLine("Monica Rathbun");
   writer.WriteLine("Vidya Agarwal");
   writer.WriteLine("Mahesh Chand");
   writer.WriteLine("Vijay Anand");
   writer.WriteLine("Jignesh Trivedi");
}
// Read a file
string readText = File.ReadAllText(fullPath);
Console.WriteLine(readText);
</code>
		</write-to-file>
		<serialization>*General-Programming-Knowledge*
<code>
using System;  
using System.IO;  
using System.Runtime.Serialization.Formatters.Binary;  
[Serializable]  
class Student  
{  
    int rollno;  
    string name;  
    public Student(int rollno, string name)  
    {  
        this.rollno = rollno;  
        this.name = name;  
    }  
}  
public class SerializeExample  
{  
    public static void Main(string[] args)  
    {  
        FileStream stream = new FileStream("e:\\sss.txt", FileMode.OpenOrCreate);  
        BinaryFormatter formatter=new BinaryFormatter();  
          
        Student s = new Student(101, "sonoo");  
        formatter.Serialize(stream, s);  
  
        stream.Close();  
    }  
}  
</code>
		</serialization>
		<deserialization>*General-Programming-Knowledge*
<code>
using System;  
using System.IO;  
using System.Runtime.Serialization.Formatters.Binary;  
[Serializable]  
class Student  
{  
    public int rollno;  
    public string name;  
    public Student(int rollno, string name)  
    {  
        this.rollno = rollno;  
        this.name = name;  
    }  
}  
public class DeserializeExample  
{  
    public static void Main(string[] args)  
    {  
        FileStream stream = new FileStream("e:\\sss.txt", FileMode.OpenOrCreate);  
        BinaryFormatter formatter=new BinaryFormatter();  
  
        Student s=(Student)formatter.Deserialize(stream);  
        Console.WriteLine("Rollno: " + s.rollno);  
        Console.WriteLine("Name: " + s.name);  
  
        stream.Close();  
    }  
}  
</code>
		</deserialization>
		<constructors>*General-Programming-Knowledge*
<code>
using System;

/*A struct is a similar data type with a class, but structs works with values, while classes works as reference
 	FOR A STRUCT:
 	if we create 2 objects:
 	object1 = object2, in this case object1 will have all the values that object2 has.
 	
 	FOR A CLASS:
 	if we create 2 objects:
 	object1 = object2, in this case object1, will be poiting to the object2's values which are stored on the heap.
 */

namespace project5_structs_with_constructors
{
	class Program
	{
		struct MyStr
			{
				//Variables of the struct:
				public int posx, posy;
				//Constructor of the struct:
				public MyStr (int newposx, int newposy)
				{
					posx = newposx;
					posy = newposy;
				}
			}
		public static void Main(string[] args)
		{
			//Creating the instances/objects of the struct
			MyStr structure1 = new MyStr (4, 5);
			MyStr structure2 = new MyStr (10, 12);
			//Printing the values:
			Console.WriteLine("The first structure has: X=" +structure1.posx +" and Y=" +structure1.posy);
			Console.WriteLine("The second structure has: X=" +structure2.posx +" and Y=" +structure2.posy);
			structure1 = structure2;
			//Printing the values:
			Console.WriteLine("\nAfter setting structure1 = structure2.\n");
			Console.WriteLine("The first structure has: X=" +structure1.posx +" and Y=" +structure1.posy);
			Console.WriteLine("The second structure has: X=" +structure2.posx +" and Y=" +structure2.posy);
			//End of program:
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
	}
}
</code>
		</constructors>
		<instantiation>*General-Programming-Knowledge*
		<br></br>
		When you create a new object in C# for a class using the new keyword, then it is called instantiation.
		<br></br>
<code>
Student s1 = new Student();
</code>
		</instantiation>
		<destructors>*General-Programming-Knowledge*
<code>
class Example
{ 
    // Rest of the class
    // members and methods.

   // Destructor
   ~Example()
    {
        // Your code
    }

} 
</code>
		</destructors>
		<function-overloading>*General-Programming-Knowledge*
<code>
using System;

namespace project26_methods_and_functions_overloading
{
	class Program
	{
		public static void Main(string[] args)
		{
			int outsider;
			Program p = new Program();
			p.Add(10,12);
			p.Add(1,102,34);
			p.Add(0.2f,3.3f);
			p.Add(1,33, out outsider);
			Console.WriteLine("Func4 Result: {0}", outsider);
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
		/*A function or method can be overloaded using different number of parameters, different types of 
		parameters or different kind of parameters.
		Kinds of parameters are: input parameters, output parameters, reference parameters
		Types of parameters are: float, int, double, char, etc...
		Overloading means that you can have multiple functions with the same name, but respecting at least one of
		the criteria above (also it can respect all of the criteria above). This means that the signature of the
		overloaded function must be different from the primary function.
		Signature consist in number, type and kind of parameters, and also in the code inside the brackets. But
		a signature does not consist in the return type of the function, the access modifier of the function, or
		the optional parameters (params) of the function.
		So a function CANNOT be overloaded ONLY by using different return types, access modifiers, or optional
		params, there must be respected the criteria above.
		
		Examples:*/
		public void Add(int numb1, int numb2)
		{
			Console.WriteLine("Func1\nThe Sum: {0}\n", numb1+numb2);
		}
		public void Add(int numb1, int numb2, int numb3) //method overloaded
		{
			Console.WriteLine("Func2\nThe Sum: {0}\n", numb1+numb2+numb3);
		}
		public void Add(float numb1, float numb2) //method overloaded
		{
			Console.WriteLine("Func3\nThe Sum: {0}\n", numb1+numb2);
		}
		public void Add (int numb1, int numb2, out int sum) //method overloaded
		{
			sum=numb1+numb2;
		}
	}
}
</code>
		</function-overloading>
		<operator-overloading>*General-Programming-Knowledge*
<code>
// C# program to illustrate the
// unary operator overloading
using System;
namespace Calculator 
{
     
	class Calculator {
		 
		public int number1 , number2;
		public Calculator(int num1 , int num2)
		{
			number1 = num1;
			number2 = num2;
		}
		 
	// Function to perform operation
	// By changing sign of integers
	public static Calculator operator -(Calculator c1)
	{
		c1.number1 = -c1.number1;
		c1.number2 = -c1.number2;
		return c1;
	}
	 
	// Function to print the numbers
	public void Print()
	{
		Console.WriteLine ("Number1 = " + number1);
		Console.WriteLine ("Number2 = " + number2);
	}
	}
	 
	class EntryPoint
	{
		 
		// Driver Code
		static void Main(String []args)
		{ 
			 
			// using overloaded - operator 
			// with the class object
			Calculator calc = new Calculator(15, -25);
			 
			calc = -calc;
			 
			// To display the result
			calc.Print();
		}
	}
}
</code>
		</operator-overloading>
		<enums>*General-Programming-Knowledge*
<code>
using System;
using System.Threading.Tasks;
using System.Text;
using System.Linq;
using System.Collections.Generic;

namespace Software
{
	class Software{
		/*
		 NOTE: Enums cannot be declared inside a function, or method. NOT EVEN the Main function.
		 */
		enum Gamestate {Playing, Menu, Pause=6}; //from now on, Gamestate is like a datatype.
		/*From the moment of declaration the enum is initializing to true the first state. In this case
		 * Playing = true, until the programmer sets it otherwise.
		 * The elements of the enum can also hold values, as it sets above, Pause = 6, Playing = 0, Menu = 1 
			(by default the	value set for each element is its index).
		 */
		public static int Main()
		{
			//Creating an object/instance for the enum;
			Gamestate gamestate;
			Console.WriteLine("Gamestate: " + Convert.ToInt32(Gamestate.Pause));
			Console.WriteLine("Gamestate: " + Convert.ToInt32(Gamestate.Playing));
			//Changing the state of the Gamestate enum;
			gamestate=Gamestate.Menu;
			/*Equivalence for this case:
			 * bool Playing = false;
			 * bool Menu = true;
			 * bool Pause = false;
			 * 
			 * As denoted, the enum is like an array of boolean values, in which only one can be true at a time.
			 * This is useful while creating game engines, or software engines, to know when a certain option is
			 * available. Also this is used to control and interract the states in a certain application.
			 */
			Console.WriteLine("Gamestate: " + gamestate);		
			gamestate=Gamestate.Playing;
			/*Equivalence:
			 * bool Playing = true;
			 * bool Menu = false;
			 * bool Pause = false;
			 */
			Console.WriteLine("Gamestate: " + gamestate);
			
			//Interraction of the user:
			int input=9;
			while(input>0 &#38;&#38; input&lt;10)
			{
				Console.WriteLine("Enter the option: ");
				input = Convert.ToInt16 (Console.ReadLine());
				switch(input)
				{
						case 1:
						{
							gamestate = Gamestate.Menu;
							Console.WriteLine("The active state: " + gamestate);
							break;
						}
						case 2:
						{
							gamestate = Gamestate.Pause;
							Console.WriteLine("The active state: " + gamestate);
							break;
						}
						case 3:
						{
							gamestate = Gamestate.Playing;
							Console.WriteLine("The active state: " + gamestate);
							break;
						}
						default:
						{
							Console.WriteLine("This is not a gamestate");
							break;
						}
				}
			}
			Console.WriteLine("Out of the loop!");
			Console.ReadLine();
			return 0;
		}
	}
}
</code>
		</enums>
		<multi-threading>*General-Programming-Knowledge*
<code>
using System;
using System.Threading;

namespace MultithreadingApplication {
   class ThreadCreationProgram {
      public static void CallToChildThread() {
         try {
            Console.WriteLine("Child thread starts");
            
            // do some work, like counting to 10
            for (int counter = 0; counter &lt;= 10; counter++) {
               Thread.Sleep(500);
               Console.WriteLine(counter);
            }
            
            Console.WriteLine("Child Thread Completed");
         } catch (ThreadAbortException e) {
            Console.WriteLine("Thread Abort Exception");
         } finally {
            Console.WriteLine("Couldn't catch the Thread Exception");
         }
      }
      static void Main(string[] args) {
         ThreadStart childref = new ThreadStart(CallToChildThread);
         Console.WriteLine("In Main: Creating the Child thread");
         
         Thread childThread = new Thread(childref);
         childThread.Start();
         
         //stop the main thread for some time
         Thread.Sleep(2000);
         
         //now abort the child
         Console.WriteLine("In Main: Aborting the Child thread");
         
         childThread.Abort();
         Console.ReadKey();
      }
   }
}
</code>
		</multi-threading>
		<namespaces>*General-Programming-Knowledge*
<code>
//FILE: MyClass.cs

using System;

//The namespace need to be declared in here
using Project20.DeadyOnline; //declaration of the namespace.
using PATA = Project20.DeadyOnline; //Creating a namespace alias called PATA.
//Namespace ALIASES can be used to avoid ambiguity errors. An ambiguity erros is when declaring 2 namespaces which
//may contains some classes or functions with the same name, so when trying to call the function, the compiler
//will not know to which one are you refering to.

//THIS IS AN EXTERNAL CLASS PROJECT
using ProjectA.TeamB; // in order to use this you need to right click on this project and add the ProjectA.TeamB
//as reference to the main project (in this case this is the main project).

namespace project20_namespaces
{
	class Program
	{
		public static void Main(string[] args)
		{
			//Creating an instance for the Class that's inside the namespace Project20.DeadyOnline
			//A namespace is using much like a path to a file, or a directory(folder).
			
			Project20.DeadyOnline.FirstClass p = new Project20.DeadyOnline.FirstClass();
			//If the namespace is declared above, an object of the class can be created as follows:
			FirstClass p2 = new FirstClass();
			
			//Calling the function that's inside the namespace below.
			Project20.DeadyOnline.FirstClass.PrintingMethod(); //calling the STATIC function, which needs to be
			PATA.FirstClass.PrintingMethod();//calling the function using the namespace alias PATA.
			//called using the qualify name of the class
			
			//Also the function can be called like this if the namespace is declared above.
			FirstClass.PrintingMethod();
			p.AnotherMessage();//calling the INSTANCE (non-static) function.
			p2.AnotherMessage(); //calling the INSTANCE (non-static function) using the object 2.
			
			//Calling a function from external namespace and class.
			MyClass ms = new MyClass(); //creating an instance of the class.
			ms.PrintName();//the function is INSTANCE function (so it needs to be called with and instance of
			//the class that it belongs to).
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
	}
}

//Namespaces are used to organize the code/programs, and to avoid name clashes.
//Creating a namespace: (this is internal namespace because it's written into the same file.)
namespace Project20
{
	namespace DeadyOnline
	{
		class FirstClass
		{
			public static void PrintingMethod()
			{
				Console.WriteLine("This is a function from a SELF-CREATED namespace.");
			}
			public void AnotherMessage()
			{
				Console.WriteLine("This function is INSTANCE function.");
			}
		}
	}
}
</code>

<code>
//FILE: Program.cs

using System;
using System.Collections.Generic;

namespace ProjectA.TeamB
{
	//This are called XML Coments, and are used to create descriptions.
	/// &lt;summary&gt;
	/// This is an Outside Class Project that contains a PrintName Function.
	/// &lt;/summary&gt;
	public class MyClass
	{
		public void PrintName()
		{
			Console.WriteLine("This is an external Class Project called ProjectA.TeamA");
		}
	}
}
/*The code above is equivalent to this:
 * 
 * namespace ProjectA
{
	namespace TeamB
	{
		public class MyClass
		{
			public void PrintName()
			{
				Console.WriteLine("This is an external Class Project called ProjectA.TeamA");
			}
		}
	}
}
 //THIS IS CALLED NASTED NAMESPACE (or a namespace inside of another).
 */
</code>
		</namespaces>
		<exception-handling>*General-Programming-Knowledge*
<code>
using System;
using System.IO; //namespace for files.

/*DISADVANTAGES OF UNHANDLING EXCEPTION:
 An unhandled exception would provide annoying error message to a user, which could make the program be devoid
 using.
 An unhandled exception could also provide important information to a hacker.
 */
 //While handling the exceptions the catch block containing the specific Classes must be above 
 //the general Class which should be the last one at the bottom.
namespace project37_read_write_to_files_handling_exceptions
{
	class Program
	{
		public static void Main(string[] args)
		{
			
			//Creating a file read streamer:
			StreamReader readFromFile = new StreamReader(@"D:\error.txt"); // @ -> using the escape sequence
			//EXCEPTION HANDLING:
			try //try to do this without exception
			{
				Console.WriteLine(readFromFile.ReadToEnd()); //ReadToEnd will read all the content of the file (until the end).
			}
			//If there was an exception come to this catch statement
			//THIS IS A SPECIFIC CATCH, this is the child of EXCEPTION CLASS
			catch(FileNotFoundException fNotFound) //try to handle the exception with this object.
				//This object is mostly for FileNotFoundException.
			{
				//AN object of type FileNotFoundException contain more information about the file that could 
				//not be found then an object of type Exception (as we use in our case).
				Console.WriteLine(fNotFound.Message);
				Console.WriteLine("Check for the file: {0}", fNotFound.FileName);
			}
			//If the catch above was not able to handle the exception try this one:
			//THIS IS THE GENERAL CATCH (Exception class is the parent of all the other classes above.)
			catch(Exception ex) //this can handle also the DirectoryNotFoundException.
			{
				Console.WriteLine(ex.Message);
			}
			//THIS BLOCK IS ALWAYS EXECUTED while for the catch blocks is not a certainty which one is going to
			//be executed.
			finally //the finally block contain the code that should be executed by all means necessary
			{
				if(readFromFile!=null) //if the file is null then it cannot be closed.
				{
					readFromFile.Close();
				}
			}
			//END OF EXCEPTION HANDLING.
			StreamWriter writeToFile = new StreamWriter(@"D:\writeToFile.txt");
			writeToFile.WriteLine("Project37 Read write to files, exeption handling Finally!");
			writeToFile.Close(); //the filestream needs to be closed for the writing to work.
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
	}
}
</code>
		</exception-handling>
		<bitwise-operators>*General-Programming-Knowledge*</bitwise-operators>
		<default-parameters>*General-Programming-Knowledge*
<code>
//Example:

static void MyMethod(string country = "Norway") 
{
  Console.WriteLine(country);
}

static void Main(string[] args)
{
  MyMethod("Sweden");
  MyMethod("India");
  MyMethod();
  MyMethod("USA");
}

//OUTPUT:
// Sweden
// India
// Norway
// USA
</code>
		</default-parameters>
		<interfaces>*General-Programming-Knowledge*
<code>
using System;

/*An interface is mostly like a class but with some differences:
 1.An interface cannot have field members/variable members (can have only functions/methods, delegates, events or
proprieties).
 2.An interface cannot contain implementations for the functions/methods(an implementation of a function/method
is the code between the brackets).
 3.An interface has public fields set by default, so inside an interface you cannot use the public acces-modifier
for its members.
 4.A class CAN inherit from an interface. BUT with the condition of providing the implementation for all the
 interface function/method members.
 5.When a class provides implementation of an interface function member, it also needs to make the member function
 public. (The public access modifier must be used.)
 6.A class or struct can inherit from MORE interfaces in the same time. Whereas a class or struct cannot inherit from
 more then one class.
 7.An interface cannot be instanciated (an instance, object of the interface cannot be created), because doing this
 it would mean that you would be able to call a function from the interface, and the interface cannot contain
 implemented members.
 */

namespace project30_interfaces
{
	//Creating an interface:
	public interface Ifirst_interface //an interface name usually starts with I (capital i).
	{
		//int age; -> an interface cannot have such fields (variable fields).
		//public void Print(); -> an interface cannot contain public access modifier.
		void Print(); //this is a function of the interface.
	}
	public interface Isecond_interface : Ithird_interface
	{
		void Print2();
	}
	public interface Ithird_interface
	{
		void Print3();
	}
	class Program
	{
		public static void Main(string[] args)
		{
			Inherited_from_interface Iobject = new Inherited_from_interface();
			Iobject.Print();
			Iobject.Print3(); //calling the grandpa's function.
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
	}
	class Inherited_from_interface : Ifirst_interface, Isecond_interface
	{
		/*A class that inherits from an interface HAS to provide implementations for all the interface methods
		 * members.
		 */
		public void Print() //providing implementation for the interface function.
		{
			/*IMPORTANT: when providing implementation for an interface function/method member you have
			 * to specify it to be public. (YOU need to use the public access modifier.)
			 IF A CLASS inherits from multiple interfaces,  then the class has to provide implementation for all
			 the interface members.
			 IF A CLASS inherits from an interface which inherits from another interface, then the class has to
			 provide implementation for both the parent interface and grandparent interface as well.
			 */
			Console.WriteLine("Class inherited from an interface.");
		}
		public void Print2() //A method can be implemented like this. (The brackets can be empty.)
		{
			//By implementing a function inherited from an interface, you have to assure that the function
			//is public, and there exists the brackets (where the implementation should be made).
		}
		public void Print3() //this function is inherited from an interface which inherits from another interface.
		{
			Console.WriteLine("This is the grandpa's function!");
		}
	}
}
</code>
		</interfaces>
		<random-generators>*General-Programming-Knowledge*
<code>
using System;

namespace project68_random_numbers
{
	class Program
	{
		public static void Main(string[] args)
		{
			Random i = new Random();
			int nr;
			nr=i.Next(1,5);
			Console.WriteLine("Value: {0}",nr);
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
	}
}
</code>
		</random-generators>
		<command-line-arguments>*General-Programming-Knowledge*</command-line-arguments>
		<ternary-operator>*General-Programming-Knowledge*
<code>
using System;

namespace project11_ternary_operator
{
	class Program
	{
		public static void Main(string[] args)
		{
			bool istrue;
			int simpletest;
			int number = 10;
			//Ternary Operator "?"
			istrue = number==10 ? true : false;
			//sinthax: boolean variable = condition ? value for true : value for false
			
			/*Equivalence of that:
			 * if(number==10)
			 * {
			 * 		istrue=true;
			 * }
			 * else
			 * {
			 * 		istrue=false;
			 * }
			 */
			Console.WriteLine("The value of istrue is: {0}", istrue);
			//Other example:
			simpletest = number==10 ? 10+2 : 10-2;
			Console.WriteLine("The value of simpletest is: {0}", simpletest);
			
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
	}
}
</code>
		</ternary-operator>
		<modular-programming>*General-Programming-Knowledge*</modular-programming>
		<string-methods>*General-Programming-Knowledge*
<code>
using System;
using System.Text; // using this for StringBuilder.
/*A stringbuilder is a data type just like string. The main difference between them is that the stringbuilder is mutable.
 Mutable means that once that is created the string can be changed, whereas System.string is not mutable, once created
 cannot be change. If you try to change a string after it was been initialized, the system will create another object of the string in
 memory and pass the new value of the string to that object, but the old object which holds the old value of the string will not be cleaned
 until the end of the program, when the garbage collector does its work.
 A stringbuilder should be used everytime when a string that's created tends to change its value, in this way, only a single object will
 be created in memory no matter how many times its value it will change, because it's mutable.
 */

namespace project46_working_with_string_builder
{
	class Program
	{
		public static void Main(string[] args)
		{
			//Creating a stringbuilder:
			StringBuilder stringbuiler = new StringBuilder("Adam"); //this is how a stringbuilder gets created and initialized
			//To concatenate string builders, there is a function called .Append();
			stringbuiler.Append(" has");
			stringbuiler.Append(" C#");
			stringbuiler.Append(" skills!");
			//Printing the stringbuilder:
			Console.WriteLine("{0}", stringbuiler);
			Console.WriteLine("{0}", stringbuiler.ToString()); //this is a better way to print the stringbuilder
			//Other stringbuilder operations:
			stringbuiler.Clear(); //clear the stringbuiler's content
			Console.WriteLine("{0}", stringbuiler);
			Console.WriteLine("Stringbuilder Capacity: {0}", stringbuiler.Capacity); //stringbuilder.Capacity returns the capacity of the
			//stringbuilder
			Console.WriteLine("Stingbuilder Max Capacity: {0}",stringbuiler.MaxCapacity);
			
			//End of program:
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
	}
}
</code>
		</string-methods>
		<datatype-conversions>*General-Programming-Knowledge*
<code>
using System;

namespace project13_implicit__explicit__data_type_conversions
{
	class Program
	{
		public static void Main(string[] args)
		{
			/*An implicit conversion is done by the compiler when there are no loss of information. Also there is
			 * no possibility of throwing exceptions during the conversion.
			 * Example:
			 */
			int numb1 = 100;
			float numb2 = numb1; //implicit conversion (done by the compiler).
			Console.WriteLine("The value of numb2 is: {0}", numb2);
			/*An explicit conversion is done by the programmer using type cast operators or predefined classes, 
 			* data-conversion classes.
			 Example:
			 */
			float numb3=123.543f;
			numb1 = (int) numb3; //explicit conversion using type cast.
			Console.WriteLine("The value of numb1 is: {0}", numb1);
			numb1 = Convert.ToInt32(numb3); //explicit conversion using Conversion Class.
			Console.WriteLine("The value of numb1 is: {0}", numb1);
			/* Conversion Class - will throw an exception/message when the conversion fails because one variable
			 * can't hold the value of the converted one.
			 * Type Cast - will not throw any exception, will just print the minimum value that the variable 
			 * can hold. 
			 */
			
			//Parse Methods of converting string to int.
			string valueN = "199";
			numb1 = int.Parse(valueN); //parsing sinthax
			//in case if the string does not contain a valid number, an exception will be thrown. SO the program
			//will be terminated.
			Console.WriteLine("The value of numb1 after parsing is: {0}", numb1);
			
			//TryParse Methods of converting string to int.
			string valueB = "221a";
			int Result = 0;
			bool Success = int.TryParse(valueB, out Result); //sinthax of TryParse.	
			//if int.TryParsing is succesfull the bool Success will become true, else it will become false.
			//TryParse takes 2 arguments: the string to be converted and the variable that will stored the
			//converted result (if it is successful). If the TryParse is not successful the Result will not be 
			//changed.
			if(Success)
			{
				Console.WriteLine("The value of numb1 after tryparsing is: {0}", Result );
			}
			else
			{
				Console.WriteLine("The number is invalid. The conversion was unsuccesful!");
			}
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
	}
}
</code>
<code>
using System;

namespace project30_explicit_vs_implicit_implementation
{
	interface I1
	{
		void Print(); //when there are 2 interfaces with identical function, which inherits into the same child
		//the explicit implementation must be used to avoid ambiguity.
	}
	interface I2
	{
		void Print();
	}
	interface I3
	{
		void MessageShow();
	}
	interface I4
	{
		void MessageShow();
	}
	class Program: I1,I2,I3,I4
	{
		public static void Main(string[] args)
		{
			Program soft = new Program(); //soft is reference variable for an object type Program stored in heap.
			soft.Print(); //calling the implicit implemented function
			
			//By TYPE CASTING - calling the explicit implemented functions.
			((I3)soft).MessageShow(); //calling the explicit implemented function
			((I4)soft).MessageShow(); //calling the explicit implemented function
			
			//By OBJECT REFERENCE - calling the explicit implemented functions.
			I3 explicit1 = new Program();
			I4 explicit2 = new Program();
			explicit1.MessageShow();
			explicit2.MessageShow();
			//END OF PROGRAM;
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
		//This is implicit implementation, the compilation and the runtime is fine, dispite that there is
		//a simple implementation for the both functions.
		public void Print()
		{
			Console.WriteLine("Implicit Implemetation!");
		}
		//Explicit Implementation:
		void I3.MessageShow() //when explicitly implementing a function the access modifiers are not allowed
		{
			Console.WriteLine("This is I3 function!");
		}
		void I4.MessageShow() //when explicitly implementing a function the access modifiers are not allowed
		{
			Console.WriteLine("This is I4 function!");
		}
	}
}
</code>
		</datatype-conversions>
		<optional-parameters>*General-Programming-Knowledge*
<code>
using System;
using System.Runtime.InteropServices; //using this for the [Optional] or [OptionalAttribute] attribute

/*WAYS OF ADDING OPTIONAL PARAMETERS:
 * 1.Using params arrays (optional arrays creating using params keyword as prefix).
 * 2.Methods overloading (overloading a method/function to provide many versions with different number of parameters);
 * 3.Methods with default parameter values.
 * 4.Methods that are using optional attribute.
 */

namespace project50_optional_parameters
{
	class Program
	{
		public static void Main(string[] args)
		{
			Program pr = new Program();
			Console.WriteLine("The result of adding 10, 3, 4, 6 is: {0}", pr.AddNumbers(10,3, new int[]{4,6}));
			Console.WriteLine("The result of adding 2 and 5 is: {0}", pr.AddNumbers(2,5));
			//Calling the second function:
			pr.PrintNrs(12);
			//To use the default value only for b (the second argument):
			pr.PrintNrs(1,c:22); //the value of b will be the default value (10);
			//To use default value only for c:
			pr.PrintNrs(1,2); //the value of c will be the default value (2);
			
			//CALLING THE OPTIONAL ATTRIBUTE FUNCTIONS:
			pr.DisplayArgs(1,3);
			pr.DisplayArgs(12,3,11);
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
		//Creating functions with default values:
		public int AddNumbers(int num1, int num2, int [] array = null) //sinthax is just like in C++;
		{
			int result=num1+num2;
			if(array!=null)
			{
				foreach (int i in array)
				{
					result+=i;
				}
			}
			return result;
		}
		public void PrintNrs(int a, int b=10, int c=2) //for a function with default parameters, the parameters initialized with
			//default values must be the last in the list of parameters (just like in case of params arrays).
		{
			Console.WriteLine("Nr1= {0}\nNr2= {1}\nNr3= {2}", a, b, c);
		}
		
		//Creating functions with [Optional] attributes
		public void DisplayArgs(int num1, int num2, [Optional] int num3) //this can also be done with [OptionalAttribute].
		{
			//In case that num3 is not specified by the user, it's value will be 0.
			Console.WriteLine("The numbers are: {0}, {1}, {2}", num1,num2,num3);
		}
	}
}
</code>
		</optional-parameters>
		<partial-classes>*General-Programming-Knowledge*
<code>
using System;

/*A partial class its used to separate/split a class into two or more parts, across different files.
 If the part of the class are in different files, those files must be contained in the same assembly (directory of project), otherwise
 the compilation will fail. 
 A partial class can also be used in techniques of splitting an interface into more parts successfully.
 
 IMPORTANT: Without the partial keyword into the class declaration, the compiler will not know the intention of creating a partial class.
 All the parts of a partial class needs to be contained by the same namespace and assembly.
 All the parts must use the partial keyword in their declaration.
 All the parts must use the same access modifier in their declaration.
 If any of the parts is declared as abstract, the entire class will be abstract (even if only a part was declared abstract).
 If any of the parts is declared as sealed, the entire class will be sealed.
 If any of the parts is declared to be inherited from a a class, the entire class will be inherited from that class. IMPORTANT, different
 parts of the partial class cannot specify that they are inherited from different classes. (IN C# MULTIPLE CLASS INHERITANCE IS NOT ALLOWED).
 Different parts of the partial class can specify that they inherits from different interfaces, so after the compilation the partial class
 will be inherited from all the specified interfaces (even if they were specified in different parts of the class).
 The members declared to a part of the partial class are available to all the part of the partial class (available in the entire class).
 */


namespace project47_partial_classes
{
	class Program
	{
		public static void Main(string[] args)
		{
			//A partial class its used like a normal class.
			MyClass obj = new MyClass();
			obj.Age = 16;
			obj.Name = "Ellias";
			obj.PrintInfo();
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
	}
	//Example of partial class:
	partial class MyClass //the partial keyword must be used for all the parts of the class.
	{
		private string _Name;
		private int _Age;
		public int Age
		{
			get {
				return _Age;
			}
			set
			{
				_Age=value;
			}
		}
		public string Name
		{
			get {
				return _Name;
			}
			set
			{
				_Name=value;
			}
		}
		//THE SECOND PART OF THE CLASS IS IN THE ASSEMBLY DIRECTORY (PROJECT DIRECTORY), WITH THE NAME PartialClassPartTwo, AND
		//CONTAINS A METHOD CALLED PrintInfo().
	}
	
}
</code>
		</partial-classes>
		<decorators>*General-Programming-Knowledge*</decorators>
		<operators>*General-Programming-Knowledge*
<code>
using System;

namespace project12_new_types_null_coalescing_operator
{
	class Program
	{
		public static void Main(string[] args)
		{
			/*Non-Nullable type: Are Value TYPES: integers, boolean, double, float, long, long long, char...etc
			 * Nullable type: Are Reference TYPES: classes, interface, delegates, arrays... etc
			 * 
			 * A Non-Nullable type can become Nullable type by using ? in their declaration.
			 * Examples:
			 */
			bool major = false; //non-nullable value type.
			bool ?minor = null; //nullable value type. 
			/*A nullable boolean type can hold on to 3 values: true, false or null.
			 */
			Console.WriteLine("Are you a minor? Press Y/N to answear or anything else to skip.");
			char answear=Convert.ToChar(Console.ReadLine());
			switch(answear)
			{
				case 'y':  minor = true; break;
				case 'Y': minor = true; break;
				case 'n':  minor = false; break;
				case 'N': minor = false; break;
				default: minor = null; break;
			}
			if(minor==true)
			{
				Console.WriteLine("You are minor!");
			}
			else if(minor==false)
			{
				Console.WriteLine("You are not minor!");
			}
			else
			{	
				Console.WriteLine("You did not answear the question!");
			}
			//NULL COALESCING OPERATOR:
			int? TicketsOnSale = 100;
			int availableTickets=TicketsOnSale??0; //if TicketsOnSale is null, availableTickets will be 0, otherwise
			//availableTickets = (int)TicketsOnSale.
			/*Equivalent method:
			 * if(TicketsOnSale==null)
			 * {
			 * 		availableTickets=0;
			 * }
			 * else
			 * {
			 * 		availableTickets=(int)TicketsOnSale; //TicketsOnSale is a nullable int, so it must be
			 * 		//casted to normal int.
			 * 		
			 * 		//Other method of casting:
			 * 		//available Tickets=TicketsOnSale.value;
			 * }
			 */
			Console.WriteLine("Available Tickets: {0}", availableTickets);
			Console.Write("Press any key to continue . . . ");
			Console.ReadKey(true);
		}
	}
}
</code>
		</operators>
		<pre-post-incrementation>*General-Programming-Knowledge*</pre-post-incrementation>
	</programming_language>
	
	<programming_language>
		<name>JavaScript</name>
		<description>
			JavaScript often abbreviated as JS, is a programming language and core 
			technology of the Web, alongside HTML and CSS. 99% of websites use JavaScript 
			on the client side for webpage behavior.<br></br><br></br>

			Web browsers have a dedicated JavaScript engine that executes the client code. 
			These engines are also utilized in some servers and a variety of apps. The most 
			popular runtime system for non-browser usage is Node.js.<br></br><br></br>

			JavaScript is a high-level, often just-in-time compiled language that conforms 
			to the ECMAScript standard. It has dynamic typing, prototype-based 
			object-orientation, and first-class functions. It is multi-paradigm, 
			supporting event-driven, functional, and imperative programming styles. 
			It has application programming interfaces (APIs) for working with text, dates, 
			regular expressions, standard data structures, and the Document Object Model (DOM).
			<br></br><br></br>
			
			Difference between JavaScript and PHP is that JavaScript is running in the client computer's browser, and its performance
			depends only on the client computer's specifications. Whereas PHP is a programming language that runs on a server so when 
			the client is using a PHP script its computer will make a request to the server with the purpose of getting the compilation
			result and transfer that information back to the client computer. 
			<br></br><br></br>
			
			This action is significantly slower that the javascript
			because in case that the server is busy, that action might take place in a matter of seconds, or minutes. While in case of
			JavaScript the action completes almost instantaneos.
			<br></br><br></br>
			
			PHP is a back-end development language (related to the server), JavaScript is a front-end development language
			related to the client computer/machine.
		</description>
		<oop>*General-Programming-Knowledge*
			JavaScript is an object oriented programming language, having the 4 concept that any OOP language has:<br></br><br></br>
			1.Inheritance<br></br>
			2.Polymorphism<br></br>
			3.Encapsulation<br></br>
			4.Abstraction<br></br>
			<br></br><br></br>
			The objects can be classifed in 2 categories:<br></br>
			- standard built-in objects;<br></br>
			- custom objects;<br></br>
			<br></br><br></br>
			In Javascript there is no concept called "class", so an object will not be built based on classes, but based on 
			functions or literal notations (or singletons).<br></br>
<code>
//Creating an object using a function:

function Employee (firstName, lastName) //This will be the constructor;
{
	this.firstName=firstName;
	this.LastName=lastName;
	
	//This is an object method:
	this.getFullName = function () {
		return this.firstName + " " + this.LastName;
	}
}
//Creating an instance of the object:

var emp = new Employee("Black", "Yd");
document.write("First Name: " + emp.firstName + "&lt;br&gt;");
document.write("Last Name: " + emp.LastName + "&lt;br&gt;");
document.write("Full Name: " + emp.getFullName() + "&lt;br&gt;");

//Creating an object using a variable/literal notation or singleton:

var objct = { //in this case we already create an object.

//Here we are now describing the functionality of the object:

	firstName: "Alan", // In this case instead of equal sign we use colon operator and coma afterwards;
 	lastName: "Walker",
	
	getFullName: function ()
	{
		return this.firstName + " " + this.lastName;
	}
} 

//Displaying the information about this objct:

document.write("&lt;br&gt;First Name: " + objct.firstName + "&lt;br&gt;");
document.write("Last Name: " + objct.lastName + "&lt;br&gt;");
document.write("Full Name: " + objct.getFullName() + "&lt;br&gt;");

/*
Differences between the 2 ways:

In the constructor case the properties are separed by their values using = operator, whereas in case
of literal notation we use : operator;

In contructor case we use ; to separate the properties, in literal notation we use , instead.

With the constructor method, you first need to create an object to can access its properties, but with literal
notation the object is already created and you can simply access it. 

Objects created using literal notation are singletons, this mean that when a value is changed for an object, it 
affects all the objects created. This is happening because all the objects created from literal notation will
reference the same set of values, so if any of them make a change, that change will affect the whole set of objects.
Whereas this is not the case using constructor objects.
*/

document.write("&lt;br&gt;Why singletons?&lt;br&gt;");
var a = { //Creating an object out of a;
	value:20,
}

var b = a; //Creating an object using the variable a;
document.write("&lt;br&gt;Before Changing value of obj2: &lt;br&gt;");
document.write("Object1: " + a.value + "&lt;br&gt;");
document.write("Object2: " + b.value + "&lt;br&gt;");
b.value=32;
document.write("&lt;br&gt;After Changing value of obj2: &lt;br&gt;");
document.write("Object1: " + a.value + "&lt;br&gt;");
document.write("Object2: " + b.value + "&lt;br&gt;");

/*
When to use Object Constructor or Object Literal

When multiple instances of an object are needed the object contructor will be used.
When single instance of an object is needed the object literal can be used.

Singleton means that the object cannot have multiple instances without affecting one another. That's why object literal
is a singleton.

The common used way of creating object in all the OOP languages is by using Object Constructor.
*/
</code>

<code>
/*
Reflection allows the inspection of meta data, assemblies, modules and type. If the object is derived from a base class than
reflection can also inspect the parent/base class data.
*/

var Class = function (objName, objID, objType) {
	//These are public fields:
	this.ObjectName = objName;
	this.ObjectID= objID;
	this.ObjectType = objType;
}

//These are public methods:
Class.prototype.getObjectName = function () {
	return this.ObjectName + "&lt;br&gt;";
}

Class.prototype.getObjectID = function () {
	return this.ObjectID + "&lt;br&gt;";
}

Class.prototype.getObjectType = function () {
	return this.ObjectType + "&lt;br&gt;";
}

var Class = new Class ("Car", "2", "Base Class");

//Creating a foreach loop:
for (var property in Class)
{
	//Checking if the property is a variable:
	if(typeof Class[property] != "function")
	{
		document.write(property + " : " + Class[property] + "&lt;br&gt;");
		//A property of class can be accessed using ClassName[foreach_variable].
	}
}

document.write("&lt;br&gt;");
//Another foreach loop:
for (var p in Class)
{
	//Checking if a property is not inherited:
	if( Class.hasOwnProperty(p) )
	{
		document.write(p + " : " + Class[p] + "&lt;br&gt;");
	}
	
	//Checking if a property is inherited:
	if( !Class.hasOwnProperty(p) )
	{
		document.write(p + " : " + Class[p] + "&lt;br&gt;");
	}
}
</code>
		</oop>
		<encapsulation>*General-Programming-Knowledge*
<code>

function Car ()
{
	//Creating private fields using the naming convention.
	var _speed;
	var _acceleration;
	
	//Creating properties: getters and setters
	Object.defineProperty(this, "speed", {
		get: function () {
			return _speed;
		} 
		, //using the coma operator to separate between get and set properties:
		set: function (value){
			_speed = value;
		}
	})
	
	/*
	This concept of using fields (getters and setter or get and set functions) is called encapsulation, being on of the
	4 OOP concepts. Encapsulation is used to control the methods in which private fields get initialized or return value.
	Private variables limit the access to data, and encapsulation provides a way of working with that data.
	*/
	
	//The second way of creating getters and setters
	
	//Private methods:
	function getAccel()
	{
		return _acceleration;
	}
	function setAccel(value)
	{
		_acceleration = value;
	}
	
	//Privileged methods;
	this.getAcceleration = function() //this is a get function
	{
		return getAccel();
	}
	this.setAcceleration = function (value) //this is a set function
	{
		setAccel(value);
	}
	
	/*
	Remember that privileged methods can be accessed from anywhere, and apart of public methods, privileged methods
	are the only methods that can access directly private fields and functions. In the case of public methods this is
	not possible.
	*/
	
}

var c = new Car();

//Now we can use this syntax for initializing the private fields:
c.speed = 12; //using the set:

document.write ("The car speed is " + c.speed + "&lt;br&gt;"); //using the get;

//Using the second way of encapsulation:

c.setAcceleration(22); //using the setter
document.write ("The car acceleration is " + c.getAcceleration() + "&lt;br&gt;"); //using the getter;
</code>
		</encapsulation>
		<polymorphism>*General-Programming-Knowledge*
<code>
/*
Polymorphism is the act of creating a collection of different object types (also called as an interface) which are inherited from the same base class. 
 A polymorphic type is one whose operations can also be applied to values of some other type, or types. When calling a virtual function from any derived
 class the method overrided will be invoked.
 
There are several fundamentally different kinds of polymorphism:
Ad hoc polymorphism: when a function has different implementations depending on a limited range of individually specified types and combinations. 
	Ad hoc polymorphism is supported in many languages using function overloading.
Parametric polymorphism: when code is written without mention of any specific type and thus can be used transparently with any number of new types. 
	In the object-oriented programming community, this is often known as generics or generic programming. In the functional programming community, 
	this is often shortened to polymorphism. 
Subtyping (also called subtype polymorphism or inclusion polymorphism): when a name denotes instances of 
	many different classes related by some common superclass
*/

//Creating polymorphism in javascript:

//Creating a base class;
var Shape = function() { }
//Adding a function to the class:
Shape.prototype.draw = function () {
	return "I am a generic shape.";
}

//Creating another class
var Circle = function () {}

//Doing the inheritance:
Circle.prototype = Object.create(Shape.prototype);

//Overriding the base class function:
Circle.prototype.draw = function ()
{
	return "I am a circle shape.";
}

//Doing the same thing again:

var Square = function () {}
Square.prototype = Object.create(Shape.prototype);
Square.prototype.draw = function () 
{
	return "I am a square shape.";
}

//Creating a collection of objects:

var collection = [new Shape(), new Circle(), new Square()];

//Iterating through the collection / Creating a foreach loop:
collection.forEach(function (shape) {
	document.write(shape.draw() + "&lt;br&gt;");
})
</code>
		</polymorphism>
		<inheritance>*General-Programming-Knowledge*
<code>
/*
Inheritance is one of the 4 OOP concepts aside: encapsulation, abstraction, polymorphism.

Inheritance consist in classes that can inherit other classes behaviour and functionality. Example: A class that inherits
from another class can have access to its variables and methods as if it were its own.

In other programming languages a class inherits from another class, since in Javascript there is no classes, an object will
only inherit from another object (this is called prototype based inheritance). Also there is NOT possible for a constructor to
inherit from another constructor. A constructor can inherit only from an instance of another (also called object.)
*/

//Creating a singleton object constructor:

var Vehicle = function (Name, Traction)
{
	this.name = Name;
	this.traction = Traction;
}

/*
Creating a function object constructor will work as well:

function Vehicle(Name, Traction)
{
	this.name = Name;
	this.traction = Traction;
}
*/

//Creating a function using the prototype object:
Vehicle.prototype.getName = function ()
{
	return this.name;
}
Vehicle.prototype.getTraction = function()
{
	return this.traction;
}

//Creating another singleton object:

var car = function (speed, acceleration) 
//Inheritance can also be made using the first singleton object(var Vehicle), as well, but the main 
//fields should be initialized first, the example is below:
{
 //this keyword refers to the current instance's field.
	this.speed = speed;
	this.acceleration = acceleration;
}

//Creating an object from the singleton constructor:
var vehicle = new Vehicle("Bike", "2 wheels");

//Creating the inheritance:
car.prototype = vehicle; //Now the any object of the car constructor is a child of the "vehicle" object.

//Creating an object of the constructor "car".
var c = new car(22, 109); 

document.write("The following fields are inherited: &lt;br&gt;");
document.write("Name: " + c.getName() + "&lt;br&gt;"); //calling the function inherited from parent object.
document.write("Traction: " + c.getTraction() + "&lt;br&gt;"); //calling the function inherited from parent object.

/*Adding a new method to the parent object will automatically be available to the child object as well.

.hasOwnProperty() - this method will check whether a property/field/variable is defined on the actual 
object or prototype. By that it can be found all the inherited properties.
*/

document.write("Is Name a Property of c Object: " + c.hasOwnProperty("name") + "&lt;br&gt;");
document.write("Is Speed a Property of c Object: " + c.hasOwnProperty("speed") + "&lt;br&gt;");

/*
Another Example. Inheritance from the first object of the singleton:
*/
document.write("Singleton Nume: " + Vehicle.name + "&lt;br&gt;");
Vehicle.name = "Something";
Vehicle.traction = "4 wheels";
document.write("Singleton Nume: " + Vehicle.name + "&lt;br&gt;");

function Class (num)
{
	this.number = num;
}
Class.prototype = Vehicle;
var clas = new Class(4)

document.write("Inherited From Singleton: " + clas.name + "&lt;br&gt;");

/*
Inheritance can be realized without singletons as well:
function Class (num)
{
	this.number = num;
}

var cl = new Class(7);

function B (name)
{
	this.name = name;
}
B.prototype = cl;

var bb = new B("Alan");

document.write(bb.number + " is perfectly valid" + "&lt;br&gt;");
*/
</code>
		</inheritance>
		<abstraction>*General-Programming-Knowledge*
<code>
/*
Abstraction is one of the 4 OOP concepts, and it is regarded to abstract objects, which are the objects
that contain fields and methods to be inherited by their children. An abstract object is like a dead parent
which has to allow inheritance to their children and nothing more.

Abstract object constructors are those constructors that cannot be instantiated. That means 
that no object can be created out of them. 
The purpose of using such constructors is to provide inheritance to other prototypes. In this way
the functionality can be shared amongst the objects without needing any instances.

To block a constructor from being instantiated, an error will be thrown in such case.
*/

function House ()
{
	this.personName = "";
	
	//This will block anyone from creating an instance with this constructor.
	throw Error ("Cannot instantiate an abstract object.");
	
}

//This is a public-static method of House object;
House.prototype.printMsg = function()
{
	document.write("Printing a message!" + "&lt;br&gt;");
}

function Home(pn)
{
	//Using the base object (Home) field named personName;
	personName = pn;
	
	this.getHomeOwnerName = function ()
	{
		return personName;
	}
}

//Creating the inheritance:
Home.prototype = Object.create(House.prototype); //House is gonna be the base class for Home constructor
/*
Object.create - will create an object without using the constructor.
*/

//Creating an instance of the child object:
var h = new Home("Adrian");

//Using the child object method and parent object field:
document.write("Owner's name: " + h.getHomeOwnerName() + "&lt;br&gt;");
document.write("Is name owned by this class: " + h.hasOwnProperty("personName") + "&lt;br&gt;");
document.write("Is h instance of House: " + (h instanceof House) + "&lt;br&gt;")
document.write("Is h instance of Home: " + (h instanceof Home) + "&lt;br&gt;")

//Calling the base object method;
h.printMsg();
</code>
		</abstraction>
		<generic-programming>*General-Programming-Knowledge*</generic-programming>
		<variable-arguments-lists>
<code>
/*The argument object is used to store the value of arguments of a function.
Accessing the argument object outside a function will result in undefined error.
The argument object is not an array, but it only has one property of the array, and that is .length
*/

function Myfct(a,b,c)
{
	document.write("The function has: " + arguments.length + " arguments.&lt;br&gt;");
	//arguments.length will return the number of arguments that was passed to the function. Not the number
	//of parameters that the function has. 
	
	/*
	Example: the function has 3 parameters: a,b,c but it was called using 5 arguments: 0,1,3,4,5.
	*/
	
	document.write("&lt;br&gt;The arguments are: &lt;br&gt;");
	for (var i =0; i&lt;arguments.length; i++)
	{
		document.write(" " + arguments[i] + " ");
	}
	document.write("&lt;br&gt;");
	
}; //Don't forget the semicolon here

Myfct(0,1,3,4,5); //In JavaScript a function can be called using any number of arguments. The unnecessary ones
//will be ignored.

//Creating a function with various number of arguments;

function getSum() //See how the function is declared without any parameters but it is called with aLinkcolor
//various number of arguments each time.
{
	var sum=0;
	for (var i=0; i&lt;arguments.length; i++)
	{
		sum+=arguments[i];
	}
	return sum;
	
}; //Don't forget the semicolon here.

document.write("&lt;br&gt;The sum of all the arguments is: " + getSum(1,12,3,22,1,3,4,22) + "&lt;br&gt;");
document.write("The sum of all the arguments is: " + getSum(-2,10,4,21) + "&lt;br&gt;"); 
//the function was called with different number of arguments each time and it worked fine.
</code>
		</variable-arguments-lists>
		<simple-data-types>
<code>
	Javascript is a dynamical type language this means that any variable can store any data type: 
	Example: 
	var A = 22;
	A="My string";
	This is perfectly valid, because the var size and type will be automatically converted as needed.

	Variables and function as in other programming languages they are case sensitive this means that var A is different
	from var a; and function A () {} is different from function a() {};

	Data Types: 
	Numbers: 22, 22.4, 44;
	Strings: "me", "you" //they can also be like single quoted: 
	'me', 'you'
	boolean: true, false; 
	All the variables are declared using the var keyword.
</code>
		</simple-data-types>
		<loops>*General-Programming-Knowledge*
<code>
/*Recursion is a programming concept available to all programming languages including JavaScript.

A recursive function, is a function that calls itself.
A recursive function needs to have a condition or break statement in order to stop the recursion and 
to avoid infinite loops and stack overflow.

Recursion is a method where the solution to a problem depends on solutions to smaller instances 
of the same problem (as opposed to iteration). Example: 5! = (4!*5) = (3! * 4 * 5) = (2! *3 *4 *5) etc.
*/

function RecursiveFunc(num)
{
	if (num &lt;= 1)
	{
		return 1;
	}
	else
	{
		return num * RecursiveFunc(num-1);
		//This will be equivalent to n* n-1* n-2* n-3* ...... *1; when it reaches 
		//1 all the functions will end
		
	}
	
	/*
	Using the loop the whole code above is equivalent to:
		var result=1;
		while(num > 1)
		{
			result*=num;
			num-=1;
		}
	*/
};

document.write("This was a recursive function: " + RecursiveFunc(5) + "&lt;br&gt;");

/*
Recursion vs Loops:

Use the loop. It's easier to read and understand (reading code is always a lot harder than writing it), 
and is generally a lot faster.

Recursion is useful when it is the natural way of viewing the problem, but you must be sure that there 
is a manageable number of stack frames involved. A stack frame is a bunch of memory assigned to the stack 
memory when a function is called, if the stack frames exceeds the stack memory capacity, the stack overflow
error will terminate the program.
*/

document.write("&lt;br&gt;With Loops&lt;br&gt;");
var i;
for(i=0;i&lt;10;i++)
	document.write(i+" ");
	
//The equivalent recursive function is:

document.write("&lt;br&gt;With Recursion&lt;br&gt;");

function Rec(a)
{
	if(a&lt;10)
	{
		document.write(a + " ");
		Rec(a+1);
	}
};

Rec(0);
</code>		
		</loops>
		<collections>*General-Programming-Knowledge*</collections>
		<collection-methods>*General-Programming-Knowledge*
<code>
//Creating an array without a constructor:

var arr = ["James", 10, 2];
/*
An array is a collection of variable, and in JavaScript a variable can take any type of values. So
that's why the array above has a string and 2 integers in it.
*/

document.write("The length of arr is: " + arr.length + "&lt;br&gt;");
for (var i=0;i&lt;arr.length; i++)
{
	document.write(arr[i] + " ");
}
document.write("&lt;br&gt;&lt;br&gt;");

//Creating an array using the constructor

var arr2 = new Array(5); // the 5 between the parenthesis specifies the length.
//The elements of arr2 are not initialized

document.write("The length of arr2 is: " + arr2.length + "&lt;br&gt;");
for (var i=0;i&lt;arr2.length; i++)
{
	document.write(arr2[i] + " ");
}
document.write("&lt;br&gt;&lt;br&gt;");

//Another ways to create an array:
var arr3 = []; //Creating an array (without constructor), the size is not specified.

/*
Dispite the other C-like languages, creating an array using this syntax make it resizeable.
*/
arr3[0]= 22; //the array length is now 1.
arr3[4]= 44; //the array length is now 2.

document.write("The length of arr3 is: " + arr3.length + "&lt;br&gt;");
for (var i=0;i&lt;arr3.length; i++)
{
	document.write(arr3[i] + " ");
}
document.write("&lt;br&gt;&lt;br&gt;");

var arr4 = new Array(26,8,1994); //Creating an array using constructor, the elements are specified.

/*
The elements can be specified while creating an array using a constructor, by using multiple arguments when
calling it. So, you cannot create and initialize an array with a single element, using this syntax. 
*/

document.write("The length of arr4 is: " + arr4.length + "&lt;br&gt;");
document.write("This element was returned using pop method: " + arr4.pop() + "&lt;br&gt;");
document.write("The new length of arr4 is: " + arr4.length + "&lt;br&gt;");
document.write("This element was returned using shift method: " + arr4.shift() + "&lt;br&gt;");
document.write("The new length of arr4 is: " + arr4.length + "&lt;br&gt;");
for (var i=0;i&lt;arr4.length; i++)
{
	document.write(arr4[i] + " ");
}
document.write("&lt;br&gt;&lt;br&gt;");

/*
OTHER METHODS:

These are Mutator methods:
.push() - This method adds a new item at the end of the array.
.pop() - This method removes and returns the last item from the array.
.unshift() - This method adds a new item at the beginning of the array.
.shift() - This method removes and returns the first element of the array.

All the methods above change the size of the array. In JavaScript an Array is much like a Vector or a 
List, being dynamic in length (resizeable).

.reverse() - This method reverse the element order of an Array Object (the last element becomes the first, etc).
.sort() - This method sorts the items of an array (alphabetical, descending or ascending, etc).
.slice() - This method returns a shallow copy of a portion of an array into a new array object selected 
from begin to end (end not included). The original array will not be modified. It can be used for adding
or removing a group of item after the specified index. It takes 3 parameters:
	.splice(index, deleteCount, item1,.... itemX)
	where:
	index - specifies at what position to add or remove items;
	deleteCount - specified the number of elements to be removed, if 0 no elements will be removed.
	item1...itemX - optional, specifies the elements to be added at specified index in the array.

The 3 methods above change the content of the array object.

A mutator method is a method that change or modify the array object (in size or content).

Non-mutator methods:
.contains() - This method returns a boolean value specifying if the searched value is present in the array or not.
.lastIndexOf() - This method returns the position of the last occurrence of a specified value.
.indexOf() - This method returns the position of the first occurrence of a specified value.

*/
</code>
		</collection-methods>
		<serialization>*General-Programming-Knowledge*</serialization>
		<deserialization>*General-Programming-Knowledge*</deserialization>
		<constructors>*General-Programming-Knowledge*</constructors>
		<instantiation>*General-Programming-Knowledge*</instantiation>
		<destructors>*General-Programming-Knowledge*</destructors>
		<function-overloading>*General-Programming-Knowledge*
<code>
/*
Prototype object of a constructor function it is used for creating static methods or methods 
which share their code between all of the instances.

Advantages of using Prototype object for adding functions:

-no matter how many objects are created, functions are loaded only once into the memory. Every instance sharing the same code.
-it allows function overriding, if necessary.

Syntax for creating function using prototype:
ConstructorName.prototype.FunctionName = function () { function definition }
*/


//Creating a constructor for an object:
function Computer (ProcessorSpeed, Memory)
{
	this.CPU_core = ProcessorSpeed;
	var Memory = Memory;
}

var pc = new Computer (3.2, 200);
var pc2 = new Computer (3.4, 2000);

//Adding a function only to an instance of the object:
pc.getName = function ()
{
	//This function is public and can access only with the public fields:
	return this.CPU_core;
}

//Adding a private function to all the instances of the object:
Computer.printMessage = function () //this function will be private.
{
	return "this is a message";
}

document.write("Instance function: " + pc.getName() + "&lt;br&gt;");
//document.write("Instance function2: " + pc2.getName() + "&lt;br&gt;"); //this will throw an error
//because getName() method is define only for pc instance.


//document.write("Function Inst1: " + pc.printMessage() + "&lt;br&gt;"); //this will throw an error, because the function is private
//document.write("Function Inst2: " + pc2.printMessage() + "&lt;br&gt;"); //this will throw an error, because the function is private


//Adding a function using the prototype object:
Computer.prototype.printMsg = function () //this code will be executed until the function will be overrided.
{
	alert("This function is created using prototype object.");
}

//Calling the function:
pc.printMsg();
pc2.printMsg();

//Function Overriding:

Computer.prototype.printMsg = function () //from this moment on, when calling printMsg() method, this code will be executed.
{
	alert("This function war overrided.");
}

//Calling the overrided function:
pc.printMsg();

/*
Similarly built-in functions can be overrided as well:

Example:
var alert = function(msg)
{
	document.write (msg + "&lt;br&gt;")
}
*/

</code>
		</function-overloading>
		<operator-overloading>*General-Programming-Knowledge*</operator-overloading>
		<multi-threading>*General-Programming-Knowledge*
		<br></br><br></br>
		JavaScript is a single threaded language which does not support multithreading. <br></br>
		All the operations in JavaScript are non-blocking and are executed in the event loop. <br></br>
		This single-threaded nature along with event loop allows JavaScript to handle concurrent operations at once.<br></br>
		</multi-threading>
		<namespaces>*General-Programming-Knowledge*
<code>
/*
In JavaScript there is no concept called function overriding. So when creating 2 functions with the same name and different
number of arguments, the function declared later will replace the function declared sooner, in the global namespace. This
process is called namespace pollution (or name collision). Also if the scripts are written in different files, the file 
which is loaded last will replace the function declared into the file which was loaded first.

It is possible to declare 2 functions with the same name, but not in the same namespace. Similarly with creating 2 
variables with the same name but in different scope (global and local).

The global namespace in JavaScript can be accessed using window.Object - where object is an item in the global 
namespace "window".
*/

//Example of namespace pollution

function PrintSomething()
{
	alert("This is the first function.");
}

function PrintSomething() //this function will replace the first function declared above;
{
	alert("This is the second function.");
}

//Creating a namespace;

var NameSpace = NameSpace || {} // Create a variable named NameSpace if such an object already exists, than my variable will
//take its value, otherwise my variable will be an empty object {};

//Creating a nested namespace/object;

NameSpace.a = NameSpace.a || {} //If NameSpace.a exists than my variable NameSpace.a will take its value otherwise 
//it will be an empty object {}.

//Creating an object into the nested namespace:
NameSpace.a.print = function () 
{
	this.PrintMessage = function ()
	{
		alert("Message from the nested object.");
	}
}

//Creating an instance of the nested namespace object.
var a = new NameSpace.a.print;
//Setting the object method for the onclick button.
document.getElementById("but2").onclick = a.PrintMessage;

/*
Another example of creating a namespace:
	var yourNamespace = {

		foo: function() {
		},

		bar: function() {
		}
	};

	...

	yourNamespace.foo();
*/
</code>
		</namespaces>
		<exception-handling>*General-Programming-Knowledge*
<code>
/*
Exceptions handling can be used to handle runtime errors:

try/catch blocks can catch exceptions but not syntax errors.
*/

try{
	//The code that can produce exception will be put here:
	document.write(sayHello()); //calling undefined function will cause an exception;
	
	document.write("This line will be skipped, once the exception was caught.&lt;br&gt;");
}
catch(e) //e is the type of exception to be caught;
{
	document.write("Error. Calling undefined function.&lt;br&gt;&lt;br&gt;");
	document.write(e.description+"&lt;br&gt;");
	document.write(e.message+"&lt;br&gt;");
	document.write(e.stack+"&lt;br&gt;");
}
finally //this will be executed no matter what.
{
	/*The code in this block will be executed regardless if there was an exception or no.*/
	document.write("&lt;br&gt;Finished. &lt;br&gt;");
}

//This line will create an execution error and because it's not caught the script execution will crash.
//document.write(sayHello()); //calling undefined function;
//document.write("Nothing happens here. Since the script crashed because of the error above.");



//Throwing customized exceptions:

function Fraction(a,b)
{
	try
	{
		if (b==0)
		{
			throw { //creating a custom exception.
				//Completing the exception properties:
				
				error: "Divide by zero error." ,  //here is coma not semicolon
				message: "Denominator cannot be ZERO."
			}
		}
		else{
			return a/b;
		}
	}
	catch(e) //catching the custom exception
	{
		document.write("Exception caught. " + e.error + "&lt;br&gt;");
		document.write(e.message + "&lt;br&gt;");
	}
};

var a = parseInt(prompt("Enter a number for nominator: "));
var b = parseInt(prompt("Enter a number for denominator: "));

document.write("&lt;br&gt;The result a/b is: " + Fraction(a,b) + "&lt;br&gt;");


//Using window.onerror for handling errors:
/*
Once the window.onerror is initialized with a function which takes 3 arguments: msg, url, line. Any error
that will occur will execute that code.
*/

window.onerror = function (msg, url, line){
	//This code will be executed each time an error occur, without the need of try/catch blocks.
	alert("Message: " + msg + "\nURL: " + url + "\nLine: " + line);
	return true;
}

//Raising window.onerror by calling undefined function:
UndefinedFunction();

/*
window.onerror is not displayed if it's places in a try/catch block, instead of that the try/catch will
handle it by itself.

window.onerror is raised only when there is an unhandled exception.
*/

//Handling an html element error:
function ImageErrorHandler() //this function will be executed when the html image will have an error.
{
	alert("The image is not present.");
}
</code>
		</exception-handling>
		<bitwise-operators>*General-Programming-Knowledge*</bitwise-operators>
		<default-parameters>*General-Programming-Knowledge*</default-parameters>
		<interfaces>*General-Programming-Knowledge*</interfaces>
		<random-generators>*General-Programming-Knowledge*<br></br>
			Generate a random whole number between 1 and 10 (inclusive):
			<br></br><br></br>
			<code>let x = Math.floor((Math.random() * 10) + 1);</code>
		</random-generators>
		<ternary-operator>*General-Programming-Knowledge*
<code>
function Funct()
{
	var a = document.getElementById('textBox').value;
	//Using if statement (if statement is used to execute code when a particular condition is true)
	if(isNaN(a))
	{
		document.getElementById('textBox').value+= " 'is not a number.'";
	}
	else //if the condition above is not true, then it will execute this code.
	{
		document.getElementById('textBox').value+= " is a number.";
	}

	//using ternary operator to change the color of the textbox:
	(isNaN(a)==true) ? alert("Entered ternary if.") //this part will be executed if the condition
	//in pharanteses is evaluated to true. 
					: alert("Entered ternary else.") //this part is executed otherwise.
					
	/*
	Ternary operator is also called the short if, and has the same functionality as an if statement, the only thing that
	differs is that ternary operator sinthax is shorter, and yet harder to be read, that way is much better to use if
	else if statements instead.
	*/

	//using switch()
	if(isNaN(a) == false)
	{
		a = parseInt(a);
		switch(a) //switch works only with constant values, integer, long, chars values. switch cannot be used with floats
		//or doubles or strings just like in other programming languages.
		{
			case 1: {alert("you have entered 1."); break} // the break statement will break out of the switch.
			case 2: {alert("you have entered 2."); break}
			case 3: {alert("you have entered 3."); break}
			default : {alert("you have entered a number above 3 or below 1."); break}
			//the default case is equivalent to else statement, it will be executed only of the cases above do not match.
		}	
	}
	/*
	switch is very similar to an if, else if, else block, and even better a switch statement is faster in execution.
	*/
}
</code>
		</ternary-operator>
		<modular-programming>*General-Programming-Knowledge*
			Minification of Javascript consists in reducing the amount of JavaScript files used in a webpage as well as reducing
			the size of each file, in order to optimize the server amount of requests from the client machine.
			<br></br><br></br>
			Instead of using 4 JavaScript files, it will be used a single file, and instead of arranging the code in that file to
			be readable, it will be arranged in such a way that the size will be reduced by removing unnecessary characters such used
			spaces, newline characters and comments.
		</modular-programming>
		<string-methods>*General-Programming-Knowledge*
<code>
	/*
	Example of global replacements in a string:
	var string1 = "Blue bottle on a blue table."
	var result = string1.replace(/blue/g , "green") // result will be: Blue bottle on a green table.
	result = string1.replace(/blue/gi, "green") // result will be: green bottle on a green table.
	
	Regular Expresions:
	// g - > comes from global, which will replace each occurance of the specified word, or expression in the string1
	// i -> come from insesitive, which won't take in count if it's blue, or Blue or bLuE, or whatever.
	//string.replace won't change the original string it will just return a string with the replacements made, but
	//the original string will still hold the same value.
	
	Substring methods:
	string1.substring(1, 4); will return the string: Blu, the forth character it won't be included:
	string1.substring(4, 1); will produce the same result as above, because the function will swap the values 4 with 1, 
	because the start value needs to be smaller than the end value. The value at the second parameter is not included
	in the returned result.
	
	string1.substring(4); will return a string containing all the character from 4th character until the end of the 
	string. so that will be: "e bottle on a blue table."
	
	string1.substr(1,4): has the same functionality as the function above, But it doesn't swap the parameters, and the 
	second parameter specifies the last caracter to be returned.
	
	string1.slice(1,4): has the same functionality as the functions above, except that slice method won't swap the 
	parameters, no matter if the start is greater than the end. (in that case it will return an empty string)
	
	string1.indexOf("B") : this function will return the index of "B" which is 0;
	string1.lastIndexOf(b) : this will return the last index of specified value "b" which is: 17
	*/
</code>
		</string-methods>
		<datatype-conversions>*General-Programming-Knowledge*
			<br></br><br></br>
			JavaScript variables can be converted to a new variable and another data type - 
			the following functions can help with that: <br></br><br></br>
			Number()		Returns a number, converted from its argument<br></br>
			parseFloat()	Parses a string and returns a floating point number<br></br>
			parseInt()		Parses a string and returns an integer<br></br>
			String()		Converts to string<br></br>
		</datatype-conversions>
		<operators>*General-Programming-Knowledge*
<code>
Plus operator:
var a = 10;
var b = 20;
a + b will result 30;

var a = "10";
var b = 20;
a + b will result 1020;  //b will be converted to string and then concatenated with a.

Minus operator:
var a = "10";
var b = 20;
a-b will result -10, becausse the string a will be automatically converted to a number.
</code>
		</operators>
		<pre-post-incrementation>*General-Programming-Knowledge*</pre-post-incrementation>
	</programming_language>
	
	<programming_language>
		<name>Java</name>
		<description>
			Java is a high-level, class-based, object-oriented programming language that is 
			designed to have as few implementation dependencies as possible.<br></br><br></br>
			It is a general-purpose programming language intended to let programmers write once, 
			run anywhere meaning that compiled Java code can run on all platforms that support 
			Java without the need to recompile. <br></br><br></br>
			
			Java applications are typically compiled to bytecode that can run on any 
			Java virtual machine (JVM) regardless of the 
			underlying computer architecture. The syntax of Java is similar to C and C++, 
			but has fewer low-level facilities than either of them. The Java runtime provides 
			dynamic capabilities (such as reflection and runtime code modification) that are 
			typically not available in traditional compiled languages.
		</description>
		<oop>*General-Programming-Knowledge*</oop>
		<encapsulation>*General-Programming-Knowledge*
<code>
/*
The can be multiple classes in the same package. A package is actually the folder/directory
that contains the .java files. All the packages are actually created inside the directory: \project6\src
SO every folder inside the src directory is a package.

In java each class must have its own .java file. There cannot be multiple classes in the same file,
unless some of them are inner classes (class inside another class).

Encapsulation is one of the four fundamental OOP concepts. The other three are inheritance, polymorphism, and abstraction.

Encapsulation in Java is a mechanism of wrapping the data (variables) and code acting on the data (methods) together as a 
single unit. In encapsulation, the variables of a class will be hidden from other classes, and can be accessed only through 
the methods of their current class. Therefore, it is also known as data hiding.
*/

//PACKAGE needs to be written before the IMPORTS;
package project6;
import java.util.Random;
import java.util.Scanner;

public class DiceClass {
    int Faces;
    int StartingValue;
    //Creating a constructor for the class;
    public DiceClass(int numberOfFaces, int FirstValueOnDie) //A constructor is like a method/functions that is used
            //to initialized all the ValueType Variables inside the class. A constructor has the same name as
            //the class, and it doesn't need a return type, because it's not meant to return anything.
    {
        Faces = numberOfFaces;
        StartingValue = FirstValueOnDie;
    }
    //Public Functions/Methods:
    private int RollTheDice()
    {
        //Creating a random generator seeded with time (by default);
        Random newRandomGenerator = new Random(); // seeded by time;
        //Get a random number between 0 and Faces's Value;
        int ShownValue = newRandomGenerator.nextInt(Faces);
        //Increase that value with the StartingValue
        ShownValue+=StartingValue;
        //Return the result
        return ShownValue;
    }
    public void PrintTheDieValue()
    {
        Scanner myscanner = new Scanner(System.in);
        String UserInput = "DEFAULT";
        while(UserInput.toUpperCase().compareTo("X")!=0)
        {
            if(UserInput.toUpperCase().compareTo("DEFAULT")!=0 && UserInput.toUpperCase().compareTo("A")!=0)
            {
                System.out.printf("Please enter only \"A\" or \"X\n");
            }
            else
            {
              System.out.printf("Press \"A\" to roll the dice, OR press \"X\" to quit!\n");
            }
            UserInput = myscanner.next();
            if(UserInput.toUpperCase().compareTo("A")==0)
            {
                System.out.printf("The value from dice is: %d\n", RollTheDice());
            }
        }
    }
    //ENCAPSULATIONS IS THE GOOD USE OF GETTERS AND SETTERS FOR GETTING OR SETTING THE VALUE OF
    //A FIELD INSIDE THE CLASS.
    /*
    CONVETIONS:
    -good programmer use private fields for a class. (A field is a variable declared in the class)
    -good programmers use at least a constructor for a class. (And that constructor is used to initialize the
    fields.)
    -good programmers use encapsulation for controling the value that get in or get out from the fields
    -a method inside a class is also called property of the class, there can be public or private properties
    */
}

</code>
		</encapsulation>
		<polymorphism>*General-Programming-Knowledge*</polymorphism>
		<inheritance>*General-Programming-Knowledge*
<code>
package project25;

public class Product {
    private String name;
    private double Price;
    public Product(String NewName, double NewPrice)
    {
        this.name = NewName;
        this.Price = NewPrice;
    }
    //Getters:
    public String GetName()
    {
        return this.name;
    }
    public double GetPrice()
    {
        return this.Price;
    }
    public String GetType()
    {
        return "Product";
    }
}

</code>
<code>
package project25;

public class Books extends Product {
    private String Author;
    private int NrOfPages;
    public Books(String NewAuthor, int NewNrOfPages, String NewName, double NewPrice)
    {
        super(NewName, NewPrice); 
        //super refers to the parent class, so it will call the constructor of the parent class, and it will
        //initialize the two fields Price and Name.
        this.Author = NewAuthor;
        this.NrOfPages = NewNrOfPages;
    }
    //Getters:
    public String GetAuthor()
    {
        return this.Author;
    }
    public int GetNrOfPages()
    {
        return this.NrOfPages;
    }
    //Overriding the function of the parent class
    @Override
    public String GetType()
    {
        return "Book";
    }
}
</code>
		</inheritance>
		<abstraction>*General-Programming-Knowledge*
<code>
/*
As per dictionary, abstraction is the quality of dealing with ideas rather than events. 
For example, when you consider the case of e-mail, complex details such as what happens as soon as you send 
an e-mail, the protocol your e-mail server uses are hidden from the user. Therefore, to send an e-mail you 
just need to type the content, mention the address of the receiver, and click send.

Likewise in Object-oriented programming, abstraction is a process of hiding the implementation details from 
the user, only the functionality will be provided to the user. In other words, the user will have the 
information on what the object does instead of how it does it.

In Java, abstraction is achieved using Abstract classes and interfaces.
A class which contains the abstract keyword in its declaration is known as abstract class.

Abstract classes may or may not contain abstract methods, i.e., methods without body ( public void get(); )
But, if a class has at least one abstract method, then the class must be declared abstract.
If a class is declared abstract, it cannot be instantiated.
To use an abstract class, you have to inherit it from another class, provide implementations to the abstract 
methods in it.
If you inherit an abstract class, you have to provide implementations to all the abstract methods in it.

 */
package project26;

/**
 *
 * @author Black2
 */
public abstract class AbstractClass {
    private String PersonName;
    private int PersonAge;
    public abstract void PrintMessage(); //abstract functions can only be public.
    //Getters:
    public String GetPersonName()
    {
        return this.PersonName;
    }
    public int GetAge()
    {
        return this.PersonAge;
    }
    public AbstractClass(String Name, int Age)
    {
        this.PersonName = Name;
        this.PersonAge = Age;
    }
    //Setters:
    public void SetAge(int Age)
    {
        this.PersonAge = Age;
    }
    public void SetName(String Name)
    {
        this.PersonName = Name;
    }
    
}

</code>
		</abstraction>
		<generic-programming>*General-Programming-Knowledge*
<code>
/*
A generic class declaration looks like a non-generic class declaration, except that the class name is 
followed by a type parameter section.

As with generic methods, the type parameter section of a generic class can have one or more type parameters 
separated by commas. These classes are known as parameterized classes or parameterized types because they 
accept one or more parameters.
 */
package project29;
//The sinthax for a generic class is just like a basic class dispite that it contains: &lt;T&gt;, which is the type
//object, for the parameter.
public class GenericClass &lt;T&gt; {
   private T t;

   public void set(T t) {
      this.t = t;
   }

   public T get() {
      return t;
   }
}

</code>

<code>
/*
Generics is related to using the correspondant object of a primitive data type as it is for int (primitive) -> 
-> Integer(object), for double(primitive) -> Double(object) etc.

Generic methods are methods that can be called with arguments of different types.
Based on the types of the arguments passed to the generic method, the compiler handles each method 
call appropriately. Following are the rules to define Generic Methods.

This is possible only by using objects, but in Java each data type has an object correspondant. 

The java.lang.Integer class wraps a value of the primitive type int in an object. An object of type Integer 
contains a single field whose type is int.
*/
package project29;

import java.util.Scanner;

/**
 *
 * @author Black2
 */
public class Project29 {

    public static void main(String[] args) {
        Integer [] myArray = new Integer[] {1,42,13,24,5};
        Character [] myCharArray = new Character[] {'D', 'N', 'C', 'A'};
        printArray(myArray);
        printArray(myCharArray);
        //Using the GenericClass:
        GenericClass &lt;Integer&gt; FirstGeneric_Class = new GenericClass&lt;Integer&gt;();
        FirstGeneric_Class.set(2);
        System.out.printf("Value of GenericClass object: %d\n", FirstGeneric_Class.get());
        //Keep the window opened until a key is pressed:
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    //Creating a generic function:
    public static &lt; E &gt; void printArray( E[] inputArray ) {
      // Display array elements
      for(E element : inputArray) {
         System.out.printf("%s ", element);
      }
      System.out.println();
    }
}
/*
Another example of using generics:
public final class Integer extends Number implements Comparable&lt;Integer&gt;
*/
</code>
		</generic-programming>
		<variable-arguments-lists>*General-Programming-Knowledge*</variable-arguments-lists>
		<simple-data-types>*General-Programming-Knowledge*
<code>
package project2;
//This import here, is like an include directive in C/C++, or like an using directive in C#
//It has the purpose of telling the compiler which functioning you use, and where to find them.

import java.util.Scanner;
public class Project2 { //just like in C# it is mandatory that the main function be contained by a class.
    public static void main(String[] args) {
        //Creating a scanner in order to take the input;
        Scanner myscanner = new Scanner(System.in);
        String Name; //in Java strings needs to be declared using String keyword (with capital S);
        int Age;
        double height=11.1;
        boolean IsFemale; //In Java the bool type got renamed to boolean.
        //In Java a variable cannot be displayed if it doesn't get initialized.
        String gender;
        System.out.printf("Enter you name: ");
        //Creating a scanner for inputting;
        Name = myscanner.nextLine();
        System.out.printf("Enter you age: ");
        Age = myscanner.nextInt(); //if any other data it's entered that cannot be converted into a integer
        //an exception will be thrown.
        System.out.printf("Enter your height: ");
        //if any other type it's entered that cannot be converted into a float, an exception will be thrown.
        height = myscanner.nextDouble();
        //Printing the stored information:
        System.out.printf("Are you a female? (True or False)\n");
        IsFemale = myscanner.nextBoolean();
        
        //Using the ternary operator:
        gender = IsFemale? "Female" : "Male";
        //Printing the information:
        System.out.printf("Hello %s. Your age is %d, and you're %f tall. \n", Name, Age, height);
        System.out.printf("%s, you are a %s!\n", Name, gender);
        //System.out.print(MyByte); => this code is not valid, because the variable MyByte is never
        //initialized so it cannot be displayed.
        System.out.printf("Press any key to terminate!\n");
        myscanner.next();
    }
    
}
/*
DOCUMENTATION ABOUT DATATYPE IN JAVA:
Data Type 	Default Value (for fields)
byte                    0
short                   0
int                     0
long                    0L
float                   0.0f
double          	0.0d
char                    '\u0000'
String (or any object)   null
boolean                 false
*/
</code>
		</simple-data-types>
		<complex-data-types>*General-Programming-Knowledge*</complex-data-types>
		<loops>*General-Programming-Knowledge*
<code>
package project7;

import java.util.Scanner;

/*
Loops: a loop is a sequence of instructions that is continually repeated until a certain condition is reached.
*/
public class Project7 {
    public static void main(String[] args) {
        //Using FOR LOOP for multiplication table:
        System.out.printf("USING FOR LOOP:\n");
        for (int i = 1; i&lt;4; i++) // SINTHAX: for (initialization, condition, incrementation) just like in c, c++, c#
        {
            System.out.printf("Multiplication Table with %d:\n", i);
            for (int j = 1; j&lt;11; j++)
            {
                System.out.printf("%d * %d = %d\n", i, j, i*j);
            }
            System.out.println();
        }
        //Using WHILE LOOP for multiplication table:
        int i=4,j=1;
        System.out.printf("USING WHILE LOOP:\n");
        while(i&lt;7) //SINTHAX: while (condition) just like in c, c++, c#
        {
            System.out.printf("Multiplication Table with %d:\n", i);
            while(j&lt;11)
            {
                System.out.printf("%d * %d = %d\n", i, j, i*j);
                j++;
            }
            System.out.println();
            j=1;
            i++;
        }
        i=7; j=1;
        System.out.printf("USING DO WHILE LOOP:\n");
        do{ //SINTHAX DO{this stuff} while(condition);
            System.out.printf("Multiplication Table with %d:\n", i);
            do{
                System.out.printf("%d * %d = %d\n", i, j, i*j);
                j++;
            }while(j&lt;11);
            System.out.println();
            j=1;
            i++;
        }while(i&lt;10);
        /*
        Nested LOOPS is a term used for one loop inside another.
        */
        int [] arrayC = {1,2,3,4,5,6,7,8,9,10};
        System.out.printf("USING FOREACH LOOP:\nMultiplication Table with 10:\n");
        for (int k : arrayC)
        {
            System.out.printf("10 * %d = %d\n", k, 10*k);
        }
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
}
/*
DIFFERENCES: WHILE LOOP AND FOR LOOP ARE VERY SIMILAR, DISPITE THAT FOR LOOP USES INITIALIZATION, AND
INCREMENTATION WITHIN ITS DECLARATION, WHILE LOOP DOESN'T
as while sinthax is this: while (condition) {do stuff}, for can be written just the same way
ignoring the initialization part, and incrementation part for(condition){do stuff}

DO WHILE DISPITE FOR AND WHILE LOOPS IT GUARENTEES THAT THE CERTAIN LOOP WILL BE EXECUTED AT LEAST
ONCE, BECAUSE THE EVALUATION OF THE CONDITION IT IS MADE AFTER THE LOOP  CODE BLOCK.

FOREACH LOOP it's used exclusively for collection like arrays, vectors, lists and so on, with
a FOREACH LOOP you can iterate through all the items in that collection and to access them as well.
SINTHAX: for(collection_data_type ITERATOR_NAME : COLLECTION_NAME);
EXAMPLE: if we have an int [] arrayDATA, a foreach loop for that would be: for(int NAME : arrayDATA);
so ITERATOR_NAME can have any name, and it doesn't need to be declared, you just put a name in there
and then you use that name to access each element.
*/
</code>
		</loops>
		<collections>
<code>
package project11;
import java.util.Scanner;
import java.util.Vector; //using this for Vector class.
/**
 * AN ARRAY IS A COLLECTION OF DATA OF THE SAME TYPE, WITH FIXED SIZE AND CAPACITY.
 A VECTOR IS A DYNAMIC ARRAY, THAT CAN CHANGE IT's SIZE/CAPACITY, and ITS AUTOMATICALLY CHANGING IT's CAPACITY
 * IN JAVA A VECTOR CAN STORE ANY TYPE OF DATA/OBJECT.
 * A VECTOR OF OBJECTS CAN MIX DIFFERENT TYPES TOGETHER, LIKE INTEGERS AND STRINGS.
 */
public class Project11 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Vector myVector = new Vector(3); //creating a vector (of objects by default) of size 3;
        //Creating a vector of integers:
	Vector &lt;Integer&gt; Vector2 = new Vector(); //using the default constructor, this vector will have
        //by default the size 10;
        System.out.printf("The capacity of the myVector before adding elements: %d\n", myVector.capacity());
        System.out.printf("The size of myVector before adding elements: %d\n", myVector.size());
	//A Vector of object can mix different types of data together.
        myVector.add(21);
        myVector.add(55);
        myVector.add(77);
        myVector.add(192);
        myVector.add("Name");
        System.out.printf("The capacity of the myVector after adding 5 elements: %d\n", myVector.capacity());
        System.out.printf("The size of myVector after adding 5 elements: %d\n", myVector.size());
        System.out.printf("The capacity of the Vector2 is: %d\n", Vector2.capacity());
        /*
        THE CAPACITY INCREASES AUTOMATICALLY WHEN IT's EXCEEDING ITS INITIAL VALUE.
        */
        System.out.printf("The index of NAME is: %d\n", myVector.indexOf("Name"));
        //Displaying elements:
        int i = 0;
        //USING FOREACH LOOP TO ITERATE THROUGH THE VECTOR:
        for(Object k : myVector)
        {
           if(i&lt;myVector.indexOf("Name"))
           {
               System.out.printf("vector [%d] = %d\n", i, Integer.parseInt(k.toString()));
           }
           else
           {
               System.out.printf("vector [%d] = %s\n", i, k.toString());
           }
           i++;
        }
        //SOME VECTOR FUNCTIONS:
        Object [] array = myVector.toArray(); //converting vector into array;
        //ITERATE THROUGH ARRAY:
        for(i=0;i&lt;array.length; i++)
        {
            System.out.printf("array[%d] = %s\n", i, array[i].toString());
        }
        myVector.insertElementAt("NAME2", 3); //insert element at index 3;
        myVector.removeElementAt(4); // remove element at index 4;
        i=0;
        //USING WHILE TO ITERATE THROUGH VECTOR:
        while(i&lt;myVector.size())
        {
            System.out.printf("myVector[%d] = %s\n", i, myVector.elementAt(i).toString());
            i++;
        }
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
}
</code>

<code>
package project16;
/*
Stack is a subclass of Vector that implements a standard last-in, first-out.
Stack only defines the default constructor, which creates an empty stack. Stack includes all the methods 
defined by Vector, and adds several of its own.
A stack has the same properties as a vector, it's dynamic in size, can store objects, so it can hold
any type of data... they get automatically resized to fit the objects pushed in.
*/
import java.util.Scanner; //used for Scanner class;
import java.util.Stack; //used for stack collection;

/**
 *
 * @author Black2
 */
public class Project16 {

    public static void main(String[] args) {
        Stack newStack = new Stack(); //Stack of objects
	Stack&lt;Integer&gt; intStack; //Stack of integers;
        //Adding object on stack...
        newStack.add(5);
        newStack.add(5);
        newStack.add(33);
        newStack.add(135);
        newStack.add(25);
        System.out.printf("The element on top of stack is: %d\n", newStack.peek());
        System.out.printf("The element on bottom of the stack is: %d\n", newStack.firstElement());
        //Stacks have the same methods, fields and functionality as vectors.
        Scanner myscanner = new Scanner (System.in);
        myscanner.next();
    }
    
}
</code>

<code>
/*
The Dictionary class is an abstract class that defines a data structure for mapping keys to values.
This is useful in cases where you want to be able to access data via a particular key rather than an 
integer index.
Since the Dictionary class is abstract, it provides only the framework for a key-mapped data structure 
rather than a specific implementation.
Given a key and value, you can store the value in a Dictionary object. Once the value is stored, you can 
retrieve it by using its key. Thus, like a map, a dictionary can be thought of as a list of key/value pairs.
The Dictionary class is obsolete. You should implement the Map interface to obtain key/value storage 
functionality.
*/
package project17;

import java.util.Dictionary; //used for dictionary;
import java.util.Scanner; //used for Scanner class;
import java.util.Hashtable; //used for the hashtable;
import java.util.Enumeration; //used for enumeration;

/**
 *
 * @author Black2
 */
public class Project17 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        //It can be constructed like this also: Dictionary myDict = new Hashtable();
        Dictionary &lt;Integer, String&gt; myDict = new Hashtable(); //creating a dictionary with Integer Keys, and
        //String Content.
        myDict.put(1, "Alan Walker");
        myDict.put(2, "Adam Lambert");
        myDict.put(3, "Tokio Hotel");
        myDict.put(4, "Deryck Whibley");
        myDict.put(5, "Avril Lavigne");
        Enumeration&lt;Integer&gt; MyKeys = myDict.keys();
        Enumeration&lt;String&gt; MyNames = myDict.elements();
        System.out.printf("Size of Dictionary: %d\n", myDict.size());
        //Using for loop to access dictionary:
        for(int i=0; i&lt;myDict.size(); i++)
        {
            System.out.printf("Name: %s     Key: %s\n", MyNames.nextElement(), MyKeys.nextElement());
        }
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
}
</code>

<code>
/*
The ArrayList class extends AbstractList and implements the List interface. 
ArrayList supports dynamic arrays that can grow as needed. This gives us a new collection data type that
can be used exactly as Vectors, Lists, Stacks, Dictionaries etc. 
Array lists are created with an initial size. When this size is exceeded, the collection is automatically 
enlarged. When objects are removed, the array may be shrunk.

SINTHAX: (all these sintaxes are correct)
ArrayList al = new ArrayList(); //creates an array list;
ArrayList&lt;Integer&gt; al = new ArrayList(); // creates an int arraylist;
ArrayList&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;(); // creates an int arraylist;

NOTE: TO create an int, double, float arraylist there must be used an object of that class, and for int
the object is Integer, for double the object is Double.

Functions of an ArrayList are similar to functions of a Vector or List, or Stack, or Dictionary, you can 
call Add() function, Remove(), RemoveAt() etc.
*/
package project20;

import java.util.ArrayList; //including this here for ArrayList Collection type.
import java.util.Scanner;

/**
 *
 * @author Black2
 */
public class Project20 {
    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; al = new ArrayList();
        al.add(22);
        al.add(44);
        al.add(59);
        //Accessing the elements:
        for(int i: al)
        {
            System.out.printf("%d ", i);
        }
        System.out.println();
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
}

</code>
		</collections>
		<collection-methods>No information present in the database.</collection-methods>
		<dynamic-memory-allocation>
			Heap space is used for the dynamic memory allocation of Java objects and JRE classes 
			at runtime. <br></br>
			New objects are always created in heap space, and the references to these objects 
			are stored in stack memory. <br></br>
			These objects have global access and we can access them from anywhere in the 
			application.<br></br>
		</dynamic-memory-allocation>
		<read-from-file>No information present in the database.</read-from-file>
		<write-to-file>No information present in the database.</write-to-file>
		<serialization>*General-Programming-Knowledge*
<code>
package project23;

import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Scanner;

/**
 *
 * @author Black2
 */
public class Project23 {

    /**
     * @param args the command line arguments
     */
    //Making main function able to throw IOException, such that I don't need to use try catch blocks.
    public static void main(String[] args) throws IOException {
        File myfile = new File ("textFile.txt");
        try{
            
            //THESE STATEMENTS NEEDS TO BE PLACED INSIDE A TRY CATCH BLOCK:
            PrintWriter myPrintWriter = new PrintWriter(myfile);
            myPrintWriter.println("This is a TEXT File!");
            System.out.println("File has been successfully created!");
            //Closing the file:
            myPrintWriter.close(); //if the file doesn't get closed the modifications made to it 
            //won't get saved.
        }
        catch(IOException e)
        {
            System.out.printf("File: %s\n", e);
        }
        //Reading from the file:
        try{
            Scanner readerfile = new Scanner(myfile);
            String Message = readerfile.nextLine();
            //If this line is reached it means that there is no exception thrown.
            System.out.printf("FILE MESSAGE: %s\n", Message);
        }
        catch(IOException e)
        {
            System.out.println(e);
        }
        //Creating a collection of HumanClass objects:
        ArrayList&lt;HumanClass&gt; myList = new ArrayList();
        myList.add(new HumanClass(22, "Adam Lambert"));
        myList.add(new HumanClass(44, "Jackie Chan"));
        //Creating a file to store these objects:
        File myObjectsFile = new File ("objectFile.txt");
        //Serializing an object:
        try{
            FileOutputStream fo = new FileOutputStream(myObjectsFile);
            ObjectOutputStream os = new ObjectOutputStream(fo);
            for(HumanClass s:myList)
            {
                //Writing objects to a file ca be made only using binary mode. So that file will not contain
                //readable text.
                os.writeObject(s);
            }
        }
        catch(FileNotFoundException e)
        {
            System.out.printf("File not found: %s", e);
        }
        //Deserializing an object from the file:
        ArrayList&lt;HumanClass&gt; ObjectRead = new ArrayList();
        FileInputStream fi = new FileInputStream(myObjectsFile);
        ObjectInputStream oi = new ObjectInputStream(fi);
        try{
            while(true) //this loop will terminate when the catch block will terminate, and the catch block will
                //terminate then EOFException will be thrown.
            {
               HumanClass e = (HumanClass) oi.readObject(); //this will read until the file ends. 
               //When it cannot read any more object from the file it will throw an EOFException that needs
              //to be catched, and handled, otherwise the program will terminate.
              ObjectRead.add(e);
            }
        }
        catch(ClassNotFoundException e)
        {
             System.out.printf("File not found: %s", e);
        }
        catch(EOFException b) //Once the file was done reading, it will catch this exception.
        {
            System.out.println("\nDone reading the objects:\n");
            //Let's print the objects now:
            for(HumanClass s:ObjectRead)
            {
                System.out.printf("Name: %s, Age: %d\n", s.GetName(), s.GetAge());
            }
        }
        //Keep the console opened until I press a key.
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
}

</code>
		</serialization>
		<deserialization>*General-Programming-Knowledge*
		<br></br>
		For a concrete example - see the sample from Serialiation.
		</deserialization>
		<constructors>*General-Programming-Knowledge*</constructors>
		<instantiation>*General-Programming-Knowledge*</instantiation>
		<destructors>*General-Programming-Knowledge*</destructors>
		<function-overloading>*General-Programming-Knowledge*</function-overloading>
		<operator-overloading>*General-Programming-Knowledge*</operator-overloading>
		<enums>*General-Programming-Knowledge*
<code>
/*
Enums can have constructors, and it needs to have contructors if they are provided with values.
 */
package project18;

public enum Directions {
    //Defining the fields:
    South(0), West(180), North(90), East(260);
    private final int Degrees; // a place to store the value for each field.
    
    //This constructor has the role of initializing the above fields with their values:
    Directions(int degreesNew)
    {
        this.Degrees = degreesNew;
    }
    public int GetDegrees()
    {
        return this.Degrees;
    }
}
/*
Enums make the code more readable, and instead of providing value and later on trying to convert values
from int to string, enums provides both string values and int values in the same patch.
*/
</code>

<code>
/*
The Enumeration interface defines the methods by which you can enumerate (obtain one at a time) the elements 
in a collection of objects.
Enumerations must not be confused with enums. They are different types, different objects, with different
utility.
 */
package project15;

import java.util.Enumeration; //used for enumerations;
import java.util.Scanner; // used for scanner class;
import java.util.Vector; //used for vectors;

/**
 *
 * @author Black2
 */
public class Project15 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
	//Creating an enumeration of objects;
        Enumeration Days; //enumerations cannot be initialized with an object of type enumeration;
	//because enumeration is abstract interface.
	Enumeration &lt;Integer&gt; intEnumeration; //enumeration of integers;
        Vector myVect = new Vector (3); //vector of objects
        myVect.add("Sunday");
        myVect.add("Monday");
        myVect.add("Friday");
        Days = myVect.elements(); //the elements from vector gets transfered to enumeration.
        while(Days.hasMoreElements())
        {
            System.out.println(Days.nextElement());
        }
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
}
</code>
		</enums>
		<multi-threading>*General-Programming-Knowledge*</multi-threading>
		<namespaces>*General-Programming-Knowledge*</namespaces>
		<exception-handling>*General-Programming-Knowledge*
<code>
/*
try{} catch{} finally{} blocks is a way that you can trace errors and instead of doing the default exit from
the program you could follow another path.
SINTHAX:
try{ //doing the code that can throw an exception}
catch(//this kind of exception) {//if the exception has been caught, do this code here}
finally{//no matter if there was thrown an exception or not, just do this code here. THIS WILL ALWAYS BE EXECUTED}
 
the finally block is not mandatory. It is possible to have only try and catch blocks.
*/
package project22;
import java.util.InputMismatchException;
import java.util.Scanner;
/**
 *
 * @author Black2
 */
public class Project22 {
    public static void main(String[] args) {
        Scanner myscanner = new Scanner(System.in);
        try{
            System.out.println("Enter an integer: ");
            int number = myscanner.nextInt();
            //This code will run only if the line above doesn't produce an exception.
            System.out.printf("You entered: %d\n\n", number);
            //Throwing a Custom Exception:
            if(number>10||number&lt;0)
            {
                throw new CustomExceptionOutRange();
            }
        }
        //Handle the input mismatch exception:
        catch(InputMismatchException e)
        {
            System.out.println("You didn't entered an integer!\n");
        }
        //Handle the custom exception:
        catch(CustomExceptionOutRange r)
        {
            System.out.println("Your number is out of range!\n");
        }
        //This code gets executed anyhow.
        finally
        {
            System.out.println("Thank you for running this!");
        }
        myscanner.next();
    }
    
}

</code>
<code>
/*
This is the way of creating Custom Exceptions. You just create a class of the name you want and it make it
extends the Exception class.

IMPLEMENTS vs EXTENDS:
extends is for extending a class, for inheritance from another class.
implements is for implementing an interface.

Inheritance, extends the functionality of a class into another.
Interfaces, exhibits the same characteristics to multiple classes.

The difference between an interface and a regular class is that in an interface you can not implement any 
of the declared methods. Only the class that "implements" the interface can implement the methods. 
The C++ equivalent of an interface would be an abstract class (not EXACTLY the same but pretty much).

Also java doesn't support multiple inheritance for classes. This is solved by using multiple interfaces.
*/
package project22;

/**
 Making this class inherits from Exception class.
 */
public class CustomExceptionOutRange extends Exception{
    
}
</code>
		</exception-handling>
		<bitwise-operators>*General-Programming-Knowledge*</bitwise-operators>
		<default-parameters>*General-Programming-Knowledge*</default-parameters>
		<interfaces>*General-Programming-Knowledge*
<code>
/*
Just like classes, there can be only one interface in a .JAVA file. Java does not allow that interfaces and
classes to be defined in the same file.
There can be inner interfaces also, this is the only way to write 2 interfaces in the same .JAVA file.

 */
package project13;

/**
 *
 * @author DrVa
 */
public interface ToDoListInterface { //this is the outer interface
    public interface Numbers{ //this is the inner interface
        int findMax(int a, int b, int c);
    }
    void PrintMessage(String message);
}
</code>

<code>
/*
An interface is a reference type in Java. It is similar to class. It is a collection of abstract methods. 
A class implements an interface, thereby inheriting the abstract methods of the interface.

Along with abstract methods, an interface may also contain constants, default methods, static methods, and 
nested types. Method bodies exist only for default methods and static methods.

Writing an interface is similar to writing a class. But a class describes the attributes and behaviors of 
an object. And an interface contains behaviors that a class implements
 */
package project13;

//ONCE THAT A CLASS implement AN INTERFACE THAT CLASS IS OBLIGED TO PROVIDE IMPLEMENTATIONS FOR ALL THE
//METHODS IN THE INTERFACE:
import java.util.Scanner;

//THIS CLASS IS OBLIGED TO PROVIDE IMPLEMENTATIONS FOR ToDoListInterface and ToDoListInterface.Numbers
public class Project13 implements ToDoListInterface, ToDoListInterface.Numbers {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        //Creating an object of the class:
        Project13 InstanceOfClass = new Project13();
        InstanceOfClass.PrintMessage("This is a function that came from an interface!");
        System.out.printf("Max number is: %d\n", InstanceOfClass.findMax(12, 33, 21));
        Scanner myscanner = new Scanner (System.in);
        myscanner.next();
    }
    
    //IF Project13 class WILL NOT PROVIDE IMPLEMENTATIONS FOR THIS... THE PROGRAM WOULD NOT COMPILE.
    public void PrintMessage(String Message){
        System.out.println(Message);
    }
    public int findMax(int a, int b, int c)
    {
        //USING TERNARY OPERATOR:
        return a>b? a>c? a : c : b>c? b : c;
    }
}
/*
PROPERTIES OF INTERFACES:
An interface is implicitly abstract. You do not need to use the abstract keyword while declaring an 
interface.
Each method in an interface is also implicitly abstract, so the abstract keyword is not needed.
Methods in an interface are implicitly public.

SIMILARITIES BETWEEN INTERFACES AND CLASSES:
An interface can contain any number of methods.
An interface is written in a file with a .JAVA extension, with the name of the interface matching the name 
of the file.
The byte code of an interface appears in a .class file.
Interfaces appear in packages, and their corresponding bytecode file must be in a directory structure that 
matches the package name.

DIFFERENCES BETWEEN INTERFACES AND CLASSES:
You cannot instantiate an interface.
An interface does not contain any constructors.
All of the methods in an interface are abstract.
An interface cannot contain instance fields. The only fields that can appear in an interface must be declared 
both static and final.
An interface is not extended by a class; it is implemented by a class.
An interface can extend multiple interfaces.


*/
</code>
		</interfaces>
		<random-generators>*General-Programming-Knowledge*
<code>
package project37;

import java.util.Random;
import java.util.Scanner;

/**
 *
 * @author Black2
 */
public class Project37 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner myscanner = new Scanner(System.in);
        System.out.printf("Thinking of a number between 0 and 100:\n\n");
        Random rand = new Random();
        int Number = rand.nextInt(101);
        int choice = 101;
        int NrOfTries=0;
        while(Number!=choice)
        {
            System.out.printf("What is the number?\n");
            do{
                System.out.printf("Number = ");
                choice = myscanner.nextInt();
            }while(choice&lt;0 || choice>100);
            if(Number==choice)
            {
                System.out.printf("Congratulations, the number was: %d\n", Number);
            }
            else if(Number&lt;choice)
            {
               System.out.printf("Your number is too high, try a lower one!\n");
            }
            else
            {
                System.out.printf("Your number is too low, try a higher one!\n");
            }
            System.out.println();
            NrOfTries++;
        }
        System.out.printf("You required %d tries to guess the number!\n", NrOfTries);
        //Keep the console opened.
        myscanner.next();
    }
    
}
</code>
		</random-generators>
		<command-line-arguments>*General-Programming-Knowledge*
<code>
package Args_main;

//Working with command prompts arguments.

//IMPORTING PACKAGE:
import java.util.Scanner;

public class Args_main{
    public static void main(String[] args) { //args will store the command prompt arguments -- if any
        //Supposingly we have some arguments in args[]
        
        int [] lenNrs = Args_main.NumberOrNo(args); //convert them to numbers or get their string length
        Sorting(lenNrs, args); //sort the numbers of lenghts
        
        System.out.printf("Sorting by length or value: \n\n");
        for (int i=0; i&lt;args.length; i++)
        {
            System.out.printf("%d &lt;--&gt; %s\n", lenNrs[i], args[i]); //print results
        }
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
        //cursor to the next line.
        
    }
    public static int[] NumberOrNo(String[] arguments) //we shall return an array
    {
        int[] someArray = new int[arguments.length]; //lets build an array of the same length as arguments array
        for (int i=0; i&lt;arguments.length; i++)
        {
            try{
                someArray[i] = Integer.parseInt(arguments[i]); //try to convert to int
            }
            catch (Exception e){
                someArray[i] = arguments[i].length(); // if not succesfull then we are having a letter string / word
                //take out it's length
            }
        }
        return someArray;
    }
    
    public static void Sorting (int[] nrsOrNo, String[] arguments) //no need to return anything, lists/arrays are always passed by reference
    {
        //DO the sorting thing
        for (int i=0; i &lt; nrsOrNo.length; i++)
        {
            for (int j=0; j&lt;nrsOrNo.length; j++ )
                if (nrsOrNo[j] &lt; nrsOrNo[i])
                {
                    int temp = nrsOrNo[i];
                    nrsOrNo[i] = nrsOrNo[j];
                    nrsOrNo[j] = temp;
                    String argTmp = arguments[i];
                    arguments[i] = arguments [j];
                    arguments [j] = argTmp;
                }
        }
    }
}

</code>
		</command-line-arguments>
		<ternary-operator>*General-Programming-Knowledge*</ternary-operator>
		<modular-programming>No information present in the database.</modular-programming>
		<string-methods>No information present in the database.</string-methods>
		<datatype-conversions>*General-Programming-Knowledge*
<code>
package project3;
import java.util.Scanner;

public class Project3 {

    public static void main (String[] args) {
       String ValueOne = "1";
       String ValueTwo = "2";
       System.out.printf("ValueOne + ValueTwo = %s\n", ValueOne+ValueTwo);
       //Converting Strings to int:
       int a = Integer.parseInt(ValueOne);
       int b = Integer.parseInt(ValueTwo);
       System.out.printf("a + b = %d\n", a+b);
       float val1 = 22.1f, val2 = 25.4f;
       //TypeCasting:
       a = (int)val1; // a gets the integer part of the floating number val1;
       b = (int)val2; // b gets the integer part of the floating number val2;
       System.out.printf("The value of a is: %d\nThe value of b is: %d\n", a, b);
       //Implicitly casting = casting that is made automatically by the compiler:
       val2 = 15; // so in this case the integer value 15 will be casted into a floating point
       //value, 15.00000, this is done automatically by the compiler, so it's implicit casting.
       
       //Explicitly casting = casting that is done by the programmer, because it cannot be done, 
       //automatically by the compiler.
       a = (int) 22.5; // in this case 22.5 will became 22, (only the integer part of the floating value will
       //be stored to int a);
       
       //INTERESTING STUFF:
       val2 = 20 / 15; // integer / integer will result an integer.
       System.out.printf("The value of division is: %f\n", val2); // this will output the value: 1, even if
       //20/15 is 1.33333333, and even if it is stored in a float.
       
       //FOR THE RESULT TO BE A FLOAT AT LEAST ONE OF THOSE NUMBERS NEEDS TO BE CASTED OR CONVERTED TO FLOAT:
       val2 = 20 / (1.0f * 15); // solution one for casting (1.0 * 15 will be converted to float implicitly).
       System.out.printf("The value of division after casting is: %f\n", val2);
       val2 = 25 / (float) a; // a is explicitly casted to float, so int divided by float will generate a float.
       System.out.printf("The value after explicitly casting is: %f\n", val2);
       System.out.printf("Press any key to terminate!\n");
       Scanner myscanner = new Scanner(System.in);
       myscanner.next();
    }
    
}

</code>
		</datatype-conversions>
		<partial-classes>*General-Programming-Knowledge*</partial-classes>
		<decorators>*General-Programming-Knowledge*</decorators>
		<operators>*General-Programming-Knowledge*</operators>
		<pre-post-incrementation>*General-Programming-Knowledge*</pre-post-incrementation>
	</programming_language>
	
	<programming_language>
		<name>Python</name>
		<description>
			Python is a high-level, general-purpose programming language. Its design 
			philosophy emphasizes code readability with the use of significant indentation.
			<br></br><br></br>

			Python is dynamically typed and garbage-collected. It supports multiple 
			programming paradigms, including structured (particularly procedural), 
			object-oriented and functional programming. It is often described as a 
			"batteries included" language due to its comprehensive standard library.
		
		</description>
		<oop>*General-Programming-Knowledge*</oop>
		<encapsulation>*General-Programming-Knowledge*</encapsulation>
		<polymorphism>*General-Programming-Knowledge*</polymorphism>
		<inheritance>*General-Programming-Knowledge*</inheritance>
		<abstraction>*General-Programming-Knowledge*</abstraction>
		<generic-programming>*General-Programming-Knowledge*</generic-programming>
		<variable-arguments-lists>*General-Programming-Knowledge*</variable-arguments-lists>
		<simple-data-types>*General-Programming-Knowledge*</simple-data-types>
		<complex-data-types>*General-Programming-Knowledge*</complex-data-types>
		<loops>No information present in the database.</loops>
		<collections>*General-Programming-Knowledge*</collections>
		<collection-methods>No information present in the database.</collection-methods>
		<dynamic-memory-allocation>
			Memory is allocated to the objects at the run time. <br></br>
			We use the Heap for implement dynamic memory management. <br></br>
			We can use the memory throughout the program. <br></br><br></br>
			As we know, everything in Python is an object means dynamic memory 
			allocation inspires the Python memory management.<br></br>
		</dynamic-memory-allocation>
		<read-from-file>No information present in the database.</read-from-file>
		<write-to-file>No information present in the database.</write-to-file>
		<serialization>*General-Programming-Knowledge*</serialization>
		<deserialization>*General-Programming-Knowledge*</deserialization>
		<constructors>*General-Programming-Knowledge*</constructors>
		<instantiation>*General-Programming-Knowledge*</instantiation>
		<destructors>*General-Programming-Knowledge*</destructors>
		<function-overloading>*General-Programming-Knowledge*</function-overloading>
		<operator-overloading>*General-Programming-Knowledge*</operator-overloading>
		<enums>*General-Programming-Knowledge*</enums>
		<multi-threading>*General-Programming-Knowledge*</multi-threading>
		<namespaces>*General-Programming-Knowledge*</namespaces>
		<exception-handling>*General-Programming-Knowledge*</exception-handling>
		<bitwise-operators>*General-Programming-Knowledge*</bitwise-operators>
		<default-parameters>*General-Programming-Knowledge*</default-parameters>
		<interfaces>*General-Programming-Knowledge*</interfaces>
		<random-generators>*General-Programming-Knowledge*</random-generators>
		<command-line-arguments>*General-Programming-Knowledge*</command-line-arguments>
		<ternary-operator>*General-Programming-Knowledge*</ternary-operator>
		<modular-programming>*General-Programming-Knowledge*</modular-programming>
		<string-methods>No information present in the database.</string-methods>
		<datatype-conversions>No information present in the database.</datatype-conversions>
		<partial-classes>*General-Programming-Knowledge*</partial-classes>
		<decorators>*General-Programming-Knowledge*</decorators>
		<operators>*General-Programming-Knowledge*</operators>
		<pre-post-incrementation>*General-Programming-Knowledge*</pre-post-incrementation>
	</programming_language>
	
</content>
