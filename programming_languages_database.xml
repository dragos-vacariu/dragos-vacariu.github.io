<?xml version="1.0" encoding="UTF-8"?>

<content>
	<programming_language>
		<name>C</name>
		<description>
			C is a general-purpose computer programming language.<br></br><br></br>
			It was created in the 1970s by Dennis Ritchie, and remains very widely used and 
			influential. <br></br><br></br>
			By design, C's features cleanly reflect the 
			capabilities of the targeted CPUs. It has found lasting use in operating 
			systems, device drivers, and protocol stacks, but its use in application 
			software has been decreasing. <br></br><br></br>
			C is commonly used on computer architectures that range from the largest 
			supercomputers to the smallest microcontrollers 
			and embedded systems.
		</description>
		<generic-programming>
			In C Language generic programming can be achieved using:<br></br><br></br>
			Variable argument lists;<br></br>
			Using <code>void *</code> and function pointers to write generic code;<br></br>
			Using libraries to reuse code without copying and recompiling;<br></br>
			Using plugins to get run-time overriding and more;
		</generic-programming>
		<variable-arguments-lists>
			C allows a function call to have a variable number of
			arguments with the variable argument list mechanism.<br></br>
			Use ellipsis <code>...</code> to denote a variable number of arguments to
			the compiler. the ellipsis can only occur at the end of an
			argument list.<br></br><br></br>
			Here are some standard function calls that use variable
			argument lists:<br></br><br></br>
			<code>int printf(const char *format, ...);</code><br></br>
			<code>int scanf(const char *format, ...);</code><br></br>
			<code>int execlp(const char *file, const char *arg, ...);</code><br></br>
		</variable-arguments-lists>
		<simple-data-types>
			<code>short int</code> - has value range <red>[-32,768 to 32,767]</red> - format specifier <code>%hd</code> - 
			occupies 2 bytes memory
			<br></br><br></br>
			<code>unsigned short int</code> - has value range <red>[-32,768 to 65,535]</red> - format specifier <code>%hu</code> - 
			occupies 2 bytes memory
			<br></br><br></br>
			<code>unsigned int</code> - has value range <red>[0 to 4,294,967,295]</red> - format specifier <code>%u</code> - 
			occupies 4 bytes memory
			<br></br><br></br>
			<code>int</code> - has value range <red>[-2,147,483,648 to 2,147,483,647]</red> - format specifier <code>%d</code> - 
			occupies 4 bytes memory
			<br></br><br></br>
			<code>long int</code> - has value range <red>[-2,147,483,648 to 2,147,483,647]</red> - 
			format specifier <code>%ld</code> - occupies 4 bytes memory
			<br></br><br></br>
			<code>unsigned long int</code> - has value range <red>[0 to 4,294,967,295 ]</red> - format specifier <code>%lu</code> -
			occupies 4 bytes memory
			<br></br><br></br>
			<code>long long int</code> - has value range <red>[-(2^63) to (2^63)-1]</red> - format specifier <code>%lld</code> - 
			occupies 8 bytes memory
			<br></br><br></br>
			<code>unsigned long long int</code> - has value range <red>[-(2^63) to 18,446,744,073,709,551,615 ]</red> - 
			format specifier <code>%llu</code>  - occupies 8 bytes memory
			<br></br><br></br>
			<code>signed char</code> - has value range <red>[-128 to 127]</red> - format specifier <code>%c</code> - occupies 1 
			byte memory
			<br></br><br></br>
			<code>unsigned char</code> - has value range <red>[0 to 255]</red> - format specifier <code>%c</code> - occupies 1 
			byte memory
			<br></br><br></br>
			<code>float</code> - has value range <red>[1.2E-38 to 3.4E+38]</red> - format specifier <code>%f</code> - occupies 
			4 byte memory
			<br></br><br></br>
			<code>double</code> - has value range <red>[1.7E-308 to 1.7E+308]</red> - format specifier <code>%lf</code> - 
			occupies 8 byte memory
			<br></br><br></br>
			<code>long double</code> - has value range <red>[3.4E-4932 to 1.1E+4932]</red> - format specifier <code>%Lf</code>  - 
			occupies 16 byte memory
		</simple-data-types>
		<complex-data-types>
			Data types that are derived from fundamental data types:<br></br><br></br>
			<code>bool type</code><br></br><br></br>
			<code>Enumerated type / Enums</code> - An enum is a special type that represents a group of constants (unchangeable values).<br></br><br></br>
			<code>Complex types</code> - The C programming language, as of C99, supports complex number math with the three built-in types 
			<code>double _Complex</code>, <code>float _Complex</code>, and <code>long double _Complex</code>.
			<br></br>
			When the header <code>complex.h</code> is 
			included, the three complex number types are also accessible as double complex, 
			float complex, long double complex.<br></br><br></br>
			<code>Arrays</code>: A collection of elements of the same data type. <br></br>
			An array in C can be defined as a method of clubbing multiple entities of similar type into a larger group. <br></br>
			These entities or elements can be of int, float, char, or double data type or can be of user-defined data types too
			like structures.<br></br><br></br>
			<code>Pointers</code>: A variable that stores the memory address of another variable. 
			The size of a pointer in C programming language varies depending on factors such as the operating system and CPU 
			architecture.<br></br>
			Typically, on a 32-bit computer system, the size of pointer is 4 bytes,	
			while on a 64-bit computer system, it is 8 bytes.<br></br><br></br>
			<code>Structures</code>: A collection of variables of different data types grouped 
			together under a single name. <br></br><br></br>
			<code>Unions</code>: A special type of structure that can store only one value at a time.<br></br><br></br>
			<code>Typedefs</code>: A way to create a new name for an existing data type to improve code 
			readability and maintainability.<br></br><br></br>
			<code>void</code> - used to indicate an empty data type, usually used with pointers.<br></br>
		</complex-data-types>
		<loops>
			In computer programming, a loop is a sequence of instruction s that is 
			continually repeated until a certain condition is reached. <br></br>
			Typically, a certain process is done, such as getting an item of data 
			and changing it, and then some condition is checked such as whether a 
			counter has reached a prescribed number.<br></br><br></br>
			<br></br>
			For, while, do-while loops:<br></br><br></br>
			
			<red>
			While loop does not depend upon the number of iterations. In for loop the number 
			of iterations was previously known to us but in the While loop, the execution 
			is terminated on the basis of the test condition. If the test condition will 
			become false then it will break from the while loop else body will be executed.<br></br><br></br>
			<br></br>
			</red>	
			
			<green>
			In for loop, a loop variable is used to control the loop. Firstly we initialize 
			the loop variable with some value, then check its test condition. If the 
			statement is true then control will move to the body and the body of for 
			loop will be executed. Steps will be repeated till the exit condition 
			becomes true. If the test condition will be false then it will stop.
			<br></br><br></br>
			
			Initialization Expression: In this expression, we assign a loop variable 
			or loop counter to some value. for example: <code>int i=1;</code>
			Test Expression: In this expression, test conditions are performed. 
			If the condition evaluates to true then the loop body will be executed and 
			then an update of the loop variable is done. If the test expression becomes 
			false then the control will exit from the loop. for example, <code>counter&lt;5;</code>
			<br></br><br></br>
			
			Update Expression: After execution of the loop body loop variable is updated 
			by some value it could be incremented, decremented, multiplied, or divided by 
			any value.<br></br><br></br>
			</green>
			
			<blue>
			<br></br>		
			The do-while loop is similar to a while loop but the only difference 
			lies in the do-while loop test condition which is tested at the end of 
			the body. In the do-while loop, the loop body will execute at least once 
			irrespective of the test condition.<br></br>
			</blue>
<code>

<red>/*While loop syntax: */</red>
int counter = 0;
while(counter &lt; 5)
{
	/*code goes here*/
	 counter++;
}

/*---------------------------------*/
<red>/*For loop syntax: */</red>
for(int counter = 0; counter &lt; 5; counter++)
{
	/*code goes here*/
	 counter++;
}

/*---------------------------------*/
<red>/*Do while loop syntax: */</red>
do
{
	/*code goes here*/
	 counter++;
}
while(counter &lt; 5)
</code>
		</loops>
		<collections>
			<code>Arrays</code>: Are collections of elements of the same data type with fixed size. 
			<br></br>Once the <code>array</code> is defined, its size cannot be changed.<br></br><br></br>
			
			The <code>linked list</code> is a complex data type, which consists of a structure with at least 2 elements: value and pointer
			to the next element. <br></br>
			The memory can be allocated dynamically for each element added to the list. 
			<br></br><br></br>
			<green>
			The main benefit of a linked-list
			consists in the possibility of adding a variable number of elements, being able to delete or add an element without making copies
			or exchanges, but only by changing the addresses of the assigned pointers for the next / previous element.
			</green>
			<br></br><br></br>
			
<code>
<red>/*Declaring arrays and initializing arrays*/</red>

int arr[5];
int array_initialized[7] = [1,2,3,4,5,6,7];
float array_floats[3] = [2.0f, 3.0f, 2.11f];

/*---------------------------------------------*/

<red>//Declaring and initializing a Linked List</red>

//Linked list definition:
struct LinkedList{
	int value; // this will store the value
	struct LinkedList * previous; // this will store the address of the previous block of memory
	struct LinkedList * next; // this will store the address of the next block of memory
};

struct LinkedList* list = NULL; // creating a linked list

int counter = 0;
while(counter &lt; 10)
{
	if(list == NULL) // if this is the first element to be introduced on the linked list
	{
		list = (struct LinkedList* )malloc(sizeof(struct LinkedList)); // allocate memory.
		list->value = counter; // add value
		list->previous = NULL; // there is no previous element.
		list->next = NULL; // we don't know if there will be a next element.
	}

	else //enter here after the first element was added.
	{

		list->next = (struct LinkedList* ) malloc(sizeof(struct LinkedList)); // allocate space for the next element
		list->next->previous = list; // we're still on the previous element, so assign the link to the next element.previous
		list = list->next; // next element become current element
		list->value = counter; // add value
		list->next = NULL;  // we don't know if there will be a next element.
	}
	counter++;
}

//printing the linked list
while(list != NULL) // list is currently pointing to the last element. So we will display it from last to first.
{
	printf("%d ", list->value);
	list = list->previous; // go to the previous
}

</code>
		</collections>
		<collection-methods>There are no built in functions for working with collections.</collection-methods>
		<dynamic-memory-allocation>
		Dynamic memory is allocated from the heap using some standard library functions. 
		The two dynamic memory key functions are <code>malloc()</code> and <code>free()</code>. <br></br>
		The <code>malloc()</code> function takes a single parameter, which is the size of the requested memory 
		area in bytes. <br></br>
		It returns a pointer to the allocated memory.
		<br></br><br></br>
		<red>C malloc() method:</red>
		<br></br><br></br>
		The “malloc” or “memory allocation” method in C is used to dynamically allocate a single 
		large block of memory with the specified size. <br></br><br></br>
		It returns a pointer of type void which 
		can be cast into a pointer of any form. 
		<br></br>
		It doesn’t Initialize memory at execution time 
		so that it has initialized each block with the default garbage value initially. <br></br><br></br>
<code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;conio.h&gt;

int main()
{
	int *A;
	int i;
	
	/*
	Prototype: void *malloc(size_t size);
	*/

	A=(int *)malloc(20*sizeof(int)); // malloc return a void pointer that needs to be converted
	//into a pointer to however the type of the variable that uses it has. (int *) - is the type of pointer A
	//20 = the number of memory cells allocated;
	
	for (i=0;i&lt;20;i++)
		printf("A[%d]=%d\n", i, A[i]); //the value in each memory cell can be anything
	free(A);
}

</code>
			Calloc function allocates the requested memory and returns a pointer to it similarly to malloc. 
			<br></br><br></br>
			The <code>malloc()</code> and <code>calloc()</code> do differentiate in how the functions are used when allocating 
			memory at runtime. <br></br><br></br>
			The <code>malloc()</code> function only returns the starting address, <red>it doesn't zero it.</red>
			<br></br>			
			On the other hand, the <code>calloc()</code> function returns the starting address, <green>zeroing it.</green>
<code>

/*Prototype void *calloc(size_t nitems, size_t size)*/

A=(int *)calloc(20, sizeof(int)); //calloc does the same as malloc while initializing all elements to 0:
	
for (i=0;i&lt;20;i++)
	printf("A[%d]=%d\n", i ,A[i]); //the value in each memory cell is 0
	
free(A); //free is used to free the allocated memory. There is no delete() in C language.
	
</code>
		
		</dynamic-memory-allocation>
		<read-from-file>
		C programming language supports four pre-defined functions to read contents from a file, defined in <code>stdio.h</code> header file:
		<br></br><br></br>
		<blue>fgetc()</blue>– This function is used to read a single character from the file.<br></br>
		<blue>fgets()</blue>– This function is used to read strings from files.<br></br>
		<blue>fscanf()</blue>– This function is used to read formatted input from a file.<br></br>
		<blue>fread()</blue>– This function is used to read the block of raw bytes from files. This is used 
		to read binary files.
		<br></br><br></br>
		To open a file use: <code>fopen(filename, mode)</code>;
		<br></br><br></br>
		Where:<br></br><br></br>
		filename	The name of the actual file you want to open (or create), like filename.txt<br></br>
		mode	A single character, which represents what you want to do with the file 
		(read, write or append):<br></br><br></br>
		<blue>w</blue> - Writes to a file<br></br>
		<blue>a</blue> - Appends new data to a file<br></br>
		<blue>r</blue> - Reads from a file<br></br>
	
<code>

<red>/*Read file char by char*/</red>

FILE* ptr; //FILE is basically a data type, and we need to create a pointer variable to work with it 
char ch;

// Opening file in reading mode
ptr = fopen("test.txt", "r");

if (NULL == ptr) {
	printf("file can't be opened \n");
}

printf("content of this file are \n");

// Printing what is written in file
// character by character using loop.
do {
	ch = fgetc(ptr);
	printf("%c", ch);

	// Checking if character is not EOF.
	// If it is EOF stop reading.
} while (ch != EOF); 


//---------------------------------

/*

<red>Alternatively feof function can be used:</red>
feof() function takes file pointer as argument and returns true if pointer reaches the end of the file. 

while (!feof(ptr)) {
	ch = fgetc(ptr);
	printf("%c", ch);
}

*/
//---------------------------------

<red>//Reading whole content of the file as string:</red>

//fgets() reads one string at a time from the file. fgets() returns a string if it is
//successfully read by function or returns NULL if can not read. 

//Prototype: char * fgets(char *str, int size, FILE * ptr);

while (fgets(str, 50, ptr) != NULL) {
	printf("%s", str);
}

//---------------------------------


/*
fscanf() reads formatted input from a stream.

Approach:

fscanf reads formatted data from the files and stores it in variables.
The data in the buffer is printed on the console till the end of the file is reached.

*/

char buf[100];
while (fscanf(ptr, "%*s %*s %s ", buf) == 1)
	printf("%s\n", buf);

</code>
		
		</read-from-file>
		<write-to-file>
		To create a file, or write to a file you can use the w mode inside the fopen() function.<br></br>
		Function Prototype: fopen(filename, mode);
		<br></br><br></br>
		Where:<br></br><br></br>
		filename	The name of the actual file you want to open (or create), like filename.txt<br></br>
		mode	A single character, which represents what you want to do with the file 
		(read, write or append):<br></br><br></br>
		<blue>w</blue> - Writes to a file<br></br>
		<blue>a</blue> - Appends new data to a file<br></br>
		<blue>r</blue> - Reads from a file<br></br><br></br>
		
		The w mode means that the file is opened for writing. To insert content to it, you can 
		use the fprintf() function and add the pointer variable (fptr in our example) and some text:
		<br></br><br></br>
		If you write to a file that already exists, the old content is deleted, and the new content 
		is inserted. This is important to know, as you might accidentally erase existing content.
<code>

FILE *fptr; //FILE is basically a data type, and we need to create a pointer variable to work with it 

// Open a file in writing mode
fptr = fopen("filename.txt", "w");

// Write some text to the file using fprintf
fprintf(fptr, "Some text");

// Write some other text to the file fputs
fputs("Line wrote with fputs.", fp); 

// Close the file
fclose(fptr); // this will close the file when we are done with it.

</code>		
		Closing the file:
		<br></br><br></br>
		It is considered as good practice, because it makes sure that:
		<br></br><br></br>
		<blue>
		Changes are saved properly. <br></br>
		Other programs can use the file (if you want). <br></br>
		Clean up unnecessary memory space. <br></br><br></br>
		</blue>
		If you want to add content to a file without deleting the old content, 
		you can use the a mode. <br></br>
		The a mode appends content at the end of the file:<br></br>
		
<code>
/*Example*/

FILE *fptr;

// Open a file in append mode
fptr = fopen("filename.txt", "a"); 

/*Just like with the w mode; if the file does not exist, the a mode will create a 
new file with the "appended" content.*/

// Append some text to the file
fprintf(fptr, "\nHi everybody!");

// Close the file
fclose(fptr);

</code>
		</write-to-file>
		<serialization>
		Serialization is the process of converting a data object—a combination of code and data 
		represented within a region of data storage—into a series of bytes that saves the state 
		of the object in an easily transmittable form.<br></br><br></br>
		</serialization>
		<deserialization>
		Deserialization is the process of reconstructing a data structure or object from a series 
		of bytes or a string in order to instantiate the object for consumption. 
		<br></br><br></br>
		This is the 
		reverse process of serialization, i.e., converting a data structure or object into a 
		series of bytes for storage or transmission across devices.<br></br><br></br>
		</deserialization>
		<enums>
		Enumeration (or enum) is a user defined data type in C. <br></br>
		It is mainly used to 
		assign names to integral constants, the names make a program easy to read and maintain.
		<br></br><br></br>
		
<code>
/*Examples*/
//Syntax: enum flag{constant1, constant2, constant3, ....... };

// An example program to demonstrate working
// of enum in C
#include &lt;stdio.h&gt;
 
enum week{Mon, Tue, Wed, Thur, Fri, Sat, Sun};
 
int main()
{
    enum week day;
    day = Wed;
    printf("%d",day);
    return 0;
} 

</code>
		</enums>
		<multi-threading>
		A thread is a single sequence stream within a process. Because threads have some of 
		the properties of processes, they are sometimes called lightweight processes. 
		<br></br><br></br>
		Threads are not independent from each other unlike processes. As a result, 
		threads shares with other threads their code section, data section and OS resources 
		like open files and signals. 
		<br></br>
		But, like processes, a thread has its own program 
		counter (PC), a register set, and a stack space. 
		<br></br><br></br>
		Why Multithreading? Threads are popular way to improve application through parallelism. 
		<br></br>
		For example, in a browser, multiple tabs can be different threads. MS word uses 
		multiple threads, one thread to format the text, other thread to process inputs, etc. 
		<br></br><br></br>
		Threads operate faster than processes due to following reasons: <br></br><br></br>
		<blue>
		1) Thread creation is much faster. <br></br>
		2) Context switching between threads is much faster. <br></br>
		3) Threads can be terminated easily <br></br>
		4) Communication between threads is faster.<br></br>
		</blue>
<code>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt; //Header file for sleep(). man 3 sleep for details. 
#include &lt;pthread.h&gt;
  
// A normal C function that is executed as a thread  
// when its name is specified in pthread_create() 

void *myThreadFun(void *vargp) 
{ 
    sleep(1); 
    printf("Printing GeeksQuiz from Thread \n"); 
    return NULL; 
} 
   
int main() 
{ 
    pthread_t thread_id; 
    printf("Before Thread\n"); 
    pthread_create(&#38;thread_id, NULL, myThreadFun, NULL); 
    pthread_join(thread_id, NULL); 
    printf("After Thread\n"); 
    exit(0); 
}

</code>
		</multi-threading>
		<exception-handling>C does not provide direct support to error handling (or exception handling).</exception-handling>
		<bitwise-operators>
		The <code>&#38;</code> (bitwise AND) in C takes two numbers as operands and does AND on every bit 
		of two numbers. The result of AND is 1 only if both bits are 1.  
		<br></br><br></br>
		The <code>|</code> (bitwise OR) in C takes two numbers as operands and does OR on every bit 
		of two numbers. The result of OR is 1 if any of the two bits is 1. 
		<br></br><br></br>
		The <code>^</code> (bitwise XOR) in C takes two numbers as operands and does XOR on every 
		bit of two numbers. The result of XOR is 1 if the two bits are different. 
		<br></br><br></br>
		The <code>&lt;&lt;</code> (left shift) in C takes two numbers, the left shifts the bits of the 
		first operand, and the second operand decides the number of places to shift. 
		<br></br><br></br>
		The <code>&gt;&gt;</code> (right shift) in C takes two numbers, right shifts the bits of the 
		first operand, and the second operand decides the number of places to shift.
		<br></br><br></br>
		The <code>~</code> (bitwise NOT) in C takes one number and inverts all bits of it.
		
<code>

// Example on how to use the bitwise operators:
#include &lt;stdio.h&gt;
int main()
{
    // a = 5(00000101), b = 9(00001001)
    unsigned char a = 5, b = 9;
 
    // The result is 00000001
    printf("a = %d, b = %d\n", a, b);
    printf("a &#38; b = %d\n", a &#38; b);
 
    // The result is 00001101
    printf("a|b = %d\n", a | b);
 
    // The result is 00001100
    printf("a^b = %d\n", a ^ b);
 
    // The result is 11111010
    printf("~a = %d\n", a = ~a);
 
    // The result is 00010010
    printf("b&lt;&lt;1 = %d\n", b &lt;&lt; 1);
 
    // The result is 00000100
    printf("b&gt;&gt;1 = %d\n", b &gt;&gt; 1);
 
    return 0;
	
	/*
	OUTPUT: 
	
	a = 5, b = 9
	a&#38;b = 1
	a|b = 13
	a^b = 12
	~a = 250
	b&lt;&lt;1 = 18
	b&gt;&gt;1 = 4
	
	*/
}

</code>
		The left-shift and right-shift operators should not be used for negative numbers.<br></br>
		The left-shift and right-shift operators are equivalent to multiplication and division by 
		2 respectively.<br></br><br></br>
		
		The bitwise OR of two numbers is just the sum of those two numbers if there is no carry 
		involved, otherwise, you just add their bitwise AND.
		<br></br><br></br>
		Let’s say, we have <code>a=5(101)</code> and <code>b=2(010)</code>, since there is no carry involved, 
		their sum is just <code>a|b</code>. <br></br>
		Now, if we change ‘a’ to 6 which is 110 in binary, their sum would change 
		to <code>a|b + a&#38;b</code> since there is a carry involved. 
		<br></br><br></br>
		The bitwise XOR operator is the most useful operator from a technical interview perspective.
		<br></br><br></br>
		It is used in many problems. <br></br>
		A simple example could be: “Given a set of numbers where all 
		elements occur an even number of times except one number, find the odd occurring number.”
		<br></br>
		This problem can be efficiently solved by doing XOR to all numbers. 
		<br></br><br></br>
		
		The <code>&#38;</code> operator can be used to quickly check if a number is odd or even.<br></br>

		The value of the expression <code>(x &#38; 1)</code> would be non-zero only if x is odd, otherwise, 
		the value would be zero. <br></br><br></br>
		
		The <code>~</code> operator should be used carefully.
		<br></br><br></br>
		The result of the <code>~</code> operator on a small number can be a big number if the result 
		is stored in an unsigned variable. <br></br>
		The result may be a negative number if the result 
		is stored in a signed variable (assuming that the negative numbers are stored in 2’s 
		complement form where the leftmost bit is the sign bit).<br></br>
		</bitwise-operators>
		<default-parameters>
		There are no default parameters in C. <br></br><br></br>
		One way to achieve this is by passing NULL pointers and 
		then set the values to the default if NULL is passed.
		</default-parameters>
		<interfaces>
		In C: an interface is a set of function declarations without any implementation 
		details. <br></br>
		It defines a contract that concrete implementations must adhere to by providing 
		definitions for all the functions declared in the interface.
<code>

// Declare an interface for a shape
struct shape_interface {
  // Function pointers for the interface functions
  double (*area)(void*);
  double (*perimeter)(void*);
}; 

/*
In OOP there are classes that store to both variables and methods of an object.

In C we can have structs that store variables and structs that hold function pointers to defined behaviours
Both of them are close to forming a class.

*/

</code>
		</interfaces>
		<macros>
		Macros in C are powerful tools that allow developers to define reusable code snippets. 
		<br></br>
		They are defined using preprocessor directives and primarily used for code substitution 
		and generation. 
		<br></br>
		Macros provide a convenient way to write concise and efficient code, 
		improving the readability and maintainability of C programs.<br></br>
<code>

// C program to illustrate macros
#include &lt;stdio.h&gt;
 
// Macro definition
#define AREA(l, b) (l * b)
 
// Driver Code
int main()
{
    // Given lengths l1 and l2
    int l1 = 10, l2 = 5, area;
 
    // Find the area using macros
    area = AREA(l1, l2);
 
    // Print the area
    printf("Area of rectangle"
           " is: %d",
           area);
 
    return 0;
}
</code>		
		<br></br><br></br>
		Object-Like Macros:<br></br><br></br>
		An object-like macro is a simple identifier that will be replaced by a code fragment. 
		<br></br>
		It is called object-like because it looks like an object in code that uses it. 
		<br></br>
		It is popularly used to replace a symbolic name with a numerical/variable represented 
		as a constant.
		<br></br>
<code>
//Chain Macros
  
// Macro definition
#define INSTAGRAM FOLLOWERS
#define FOLLOWERS 138 

/*
Both macros INSTAGRAM and FOLLOWERS have same value - 138
*/


Multi-line macros
#include &lt;stdio.h&gt;
 
// Multi-line Macro definition
#define ELE 1, \
            2, \
            3
 
// Driver Code
int main()
{
 
    // Array arr[] with elements
    // defined in macros
    int arr[] = { ELE };
 
    // Print elements
    printf("Elements of Array are:\n");
 
    for (int i = 0; i &lt; 3; i++) {
        printf("%d  ", arr[i]);
    }
    return 0;
}
  
</code>
		</macros>
		<defines>
		In C programming, <code>#define</code> is a preprocessor directive that is used to define macros. 
		The macros are the identifiers defined by #define which are replaced by their value before 
		compilation. <br></br><br></br>
		We can define constants and functions like macros using <code>#define</code>.
		</defines>
		<random-generators>
		The <code>rand()</code> function returns the random integers whose range from <code>0</code> to 
		<code>RAND_MAX</code>. <br></br>
		The <code>RAND_MAX</code> is a symbolic constant that defines in <code>stdlib.h</code> header file, whose value 
		is greater but less than 32767 depending on the C libraries.<br></br><br></br>
<code>
#include &lt;stdio.h&gt;    
#include &lt;conio.h&gt;  
#include &lt;stdlib.h&gt;  
void main()  
{     
    // use rand() function to generate the number  
    printf (" The random number is: %d", rand());  
    printf ("\n The random number is: %d", rand());  
      
    printf (" \n The random number is: %d", rand());  
    printf ("\n The random number is: %d", rand());  
    getch();  
}  		

</code>
		The <code>srand()</code> function is a C library function that determines the initial 
		point to generate 
		different series of pseudo-random numbers. <br></br>
		
		A <code>srand()</code> function cannot be used without 
		using a rand() function. <br></br>
		The <code>srand()</code> function is required to set the value of the seed 
		only once in a program to generate the different results of random integers before 
		calling the <code>rand()</code> function. <br></br><br></br>
<code>
#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;time.h&gt;  // use time.h header file to use time  
      
int main()  
{  
    int num, i;  
    time_t t1; // declare time variable  
      
    printf(" Enter a number to set the limit for a random number \n");  
    scanf (" %d", &#38;num);  
      
    /* define the random number generator */  
    srand ( (unsigned) time (&#38;t1)); // pass the srand() parameter  
    printf("\n"); // print the space
    /* generate random number between 0 to 50 */  
}  
</code>
		</random-generators>
		<command-line-arguments>
		Command line arguments in C are passed to the main function 
		as <code>argc</code> and <code>argv</code>. <br></br>
		Command line arguments are used to control the program from 
		the outside. <code>argv[argc]</code> is a Null pointer. <br></br>
		The name of the program is 
		stored in <code>argv[0]</code>, the first command-line parameter in <code>argv[1]</code>, 
		and the	last argument in <code>argv[n]</code>.
		<br></br>
<code>

/*Example*/
int main(int argc, char *argv[]) { /* ... */ }

//OR
int main(int argc, char **argv) { /* ... */ }

</code>
		<code>argc (ARGument Count)</code> is an integer variable that stores the number of 
		command-line 
		arguments passed by the user including the name of the program. 
		<br></br>
		So if we pass a 
		value to a program, the value of argc would be 2 (one for argument and one for 
		program name). <br></br>
		The value of argc should be non-negative.<br></br><br></br>
		<code>argv (ARGument Vector)</code> is an array of character pointers listing all the arguments.
		<br></br>
		If <code>argc</code> is greater than zero, the array elements from <code>argv[0]</code> 
		to <code>argv[argc-1]</code> will 
		contain pointers to strings.<br></br>
		<code>argv[0]</code> is the name of the program. 
		<br></br>
		After that until <code>argv[argc-1]</code> every element 
		is command -line arguments.<br></br><br></br>
		
		<red>Properties of Command Line Arguments in C:<br></br><br></br></red>
		<green>
		They are passed to the main() function.<br></br>
		They are parameters/arguments supplied to the program when it is invoked.<br></br>
		They are used to control programs from outside instead of hard coding those values 
		inside the code.<br></br><br></br>
		argv[argc] is a NULL pointer.<br></br>
		argv[0] holds the name of the program.<br></br>
		argv[1] points to the first command line argument and argv[argc-1] points to 
		the last argument.<br></br>
		</green>
		</command-line-arguments>
		<ternary-operator>
		Ternary operator is used for decision making instead of placing longer if and else 
		conditional statements:<br></br>
<code>

/*Using IF ELSE statements:*/

int a = 10, b = 20, c;

if (a &lt; b) 
{
    c = a;
}
else 
{
    c = b;
}

printf("%d", c);

/*=============================*/
/*Using TERNARY operator:*/

int a = 10, b = 20, c;

c = (a &lt; b) ? a : b;

printf("%d", c);

/*The output of both samples of code from above will result in: c = 3*/

</code>
		Syntax:
		<code>condition ? value_if_true : value_if_false</code>
		<br></br>
		The statement evaluates to <code>value_if_true</code> if condition is met, and <code>value_if_false</code> 
		otherwise.<br></br><br></br>
		
		<red>The ternary operator take three arguments:</red>
		<br></br><br></br>
		<green>
		The first is a comparison argument;<br></br>
		The second is the result upon a true comparison;<br></br>
		The third is the result upon a false comparison;<br></br>
		</green>
		</ternary-operator>
		<modular-programming>
		Modular programming consists of separating implementation from interface and 
		hiding information in the implementation. <br></br>
		In C this is achieved by placing 
		the interface definition in a header file and the implementation in a source 
		file. Disciplined use of static is used to hide implementation details.
		<br></br><br></br>
		<red>Advantages of modular programming:</red>
		<br></br><br></br>
		
		<green>Code is easier to read</green> - Working on modular programming makes code easier to read 
		because functions perform different tasks as compared to monolithic codes. 
		Sometimes modular programming can be a bit messy if we pass arguments and 
		variables in different functions. The use of modules should be done in a 
		sensible manner so as to avoid any problem. Functions should be neat, clean, 
		and descriptive.<br></br><br></br>
		
		<green>Code is easier to test</green> - In software, some functions perform fewer tasks and 
		also functions that perform numerous tasks. If the software is easily split 
		using modules, it becomes easier to test. We can also focus on the riskier 
		functions during testing and need more test cases to make it bug-free.<br></br><br></br>
		
		<green>Reusability</green> - There are times where a piece of code is implemented everywhere in 
		our program. Instead of copying and pasting it, again and again, modularity 
		gives us the advantage of reusability so that we can pull our code from 
		anywhere using interfaces or libraries. The concept of reusability also 
		reduces the size of our program.<br></br><br></br>
		
		<green>Faster fixes</green> - Suppose there is an error in the payment options in any 
		application, and the bug needs to be removed. Modularity can be a great help 
		because we know that there will be a separate function that will contain the 
		code of payments, and only that function will only be rectified. Thus using 
		modules to find and fixing bugs becomes much more smooth and maintainable.<br></br><br></br>
		
		<green>Low-risk update</green> - In modular programming, a defined layer of APIs protects things that 
		use it from making changes inside the library. Unless there is a change in the API, 
		there is a low risk for someone's code-breaking. For example, if you didn't have 
		explicit APIs and someone changed a function they thought was only used within that 
		same library (but it was used elsewhere), they could accidentally break something.<br></br><br></br>
		
		
		<green>Easy collaboration</green> - Different developers work on a single piece of code in the team. 
		There are chances of conflicts when there's a git merge. This conflict can be reduced 
		if the code is split between more functions, files, repos, etc. We can also provide 
		ownership to specific code modules, where a team member can break them down into 
		smaller tasks.<br></br><br></br><br></br>
		
		
		<red>Disadvantages of modular programming:</red>
		<br></br><br></br>
		There is a need for extra time and budget for a product in modular programming.<br></br><br></br>
		It is a challenging task to combine all the modules.<br></br><br></br>
		Careful documentation is required so that other program modules are not affected.<br></br><br></br>
		Some modules may partly repeat the task performed by other modules. Hence, 
		Modular programs need more memory space and extra time for execution.<br></br><br></br>
		Integrating various modules into a single program may not be a task because 
		different people working on the design of different modules may not have the 
		same style.<br></br><br></br>
		It reduces the program's efficiency because testing and debugging are 
		time-consuming, where each function contains a thousand lines of code.<br></br><br></br>
<code>
/*FILE module.h*/
 extern unsigned int Calculate_NoOfChars_In_string(char* str);

/*FILE module.c*/
unsigned int Calculate_NoOfChars_In_string(char* str)
{
	unsigned int counter = 0;
	while(str[counter]!="\0")
	{
		counter++;
	}
	return counter;
}

/*FILE main.c*/
#include &lt;module.h&gt;  
#include &lt;stdio.h&gt;  

int main()
{
	char strA[10] = "Some text.";
	unsigned int length = Calculate_NoOfChars_In_string(strA);
	print("String length is: %d\n", length);
}

</code>
		</modular-programming>
		<string-methods>
		C has many useful string functions, which can be used to perform certain operations 
		on strings.<br></br>
		To use them, you must include the <code>&lt;string.h&gt;</code> header file in your program.<br></br>
<code>
/* GET THE SIZE (IN CHARACTERS) OF STRINGS */
char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
printf("%d", strlen(alphabet));

/* Note that sizeof and strlen behaves differently, as sizeof also includes t
he \0 character when counting.*/

/* CONCATENATE STRINGS */

char str1[20] = "Hello ";
char str2[] = "World!";

// Concatenate str2 to str1 (result is stored in str1)
strcat(str1, str2);

// Print str1
printf("%s", str1);

/* COPY STRINGS */
char str1[20] = "Hello World!";
char str2[20];

// Copy str1 to str2
strcpy(str2, str1);

// Print str2
printf("%s", str2);

/* COMPARE STRINGS */

char str1[] = "Hello";
char str2[] = "Hello";
char str3[] = "Hi";

// Compare str1 and str2, and print the result
printf("%d\n", strcmp(str1, str2));  // Returns 0 (the strings are equal)

// Compare str1 and str3, and print the result
printf("%d\n", strcmp(str1, str3));  // Returns -4 (the strings are not equal)
</code>
		</string-methods>
		<datatype-conversions>
		There are two types of conversion in C:<br></br>
			- implicit conversion (done automatically by the compiler)<br></br>
			- explicit conversion (done manually by the developer)<br></br>
			<br></br><br></br>
			Implicit conversion is done automatically by the compiler when you assign a value 
			of one type to another.<br></br><br></br>
<code>
// Automatic conversion: int to float
float myFloat = 9;

printf("%f", myFloat); // 9.000000

// the compiler automatically converts the int value 9 to a float value of 9.000000.

// Automatic conversion: float to int
int myInt = 9.99;

printf("%d", myInt); // 9

// the compiler automatically converts the float value of 9.99 to int value 9.

</code>
		Explicit conversion is done manually by placing the type in parentheses () in front 
		of the value. Also knows as typecasting. 
		<br></br>
		It is one of the important concepts introduced in 'C' 
		programming.<br></br>
<code>
//Calculate the percentage of a user's score in relation to the maximum score in a game:

// Set the maximum possible score in the game to 500
int maxScore = 500;

// The actual score of the user
int userScore = 420;

/* Calculate the percentage of the user's score in relation to the maximum available score.
Convert userScore to float to make sure that the division is accurate */
float percentage = (float) userScore / maxScore * 100.0;

// Print the percentage
printf("User's percentage is %.2f", percentage);
</code>
		</datatype-conversions>
		<optional-parameters>C does not support optional parameters.</optional-parameters>
		<operators>
		An operator is a symbol that tells the compiler to perform specific mathematical or 
		logical functions. By definition, an operator performs a certain operation on 
		operands. An operator needs one or more operands for the operation to be performed.<br></br>
		<br></br>
		Depending on how many operands are required to perform the operation, operands are called as 
		unary, binary or ternary operators. They need one, two or three operands respectively.<br></br>
		<br></br>
		Unary operators − <code>++</code> (increment), <code>--</code> (decrement), <code>!</code> (NOT), <code>~</code> (compliment), <code>&#38;</code> (address of), <code>*</code> (dereference)
		<br></br><br></br>
		Binary operators − arithmetic, logical and relational operators except !
		<br></br><br></br>
		Ternary operators − The <code>?</code> operator.
		<br></br><br></br>
		C language is rich in built-in operators and provides the following types of operators −
		<br></br><br></br>
		Assume variable <code>A = 10</code> and variable <code>B = 20 </code> then: <br></br><br></br>
		<green>Arithmetic Operators: <br></br></green>
<code>
+ <red>it adds two operands.</red>
A + B = 30

− <red>it subtracts second operand from the first.</red>
A − B = -10

* <red>it multiplies both operands.</red>
A * B = 200

/ <red>it divides numerator by de-numerator.</red>
B / A = 2

% <red>is the Modulus Operator it gives the remainder after an integer division.</red>
B % A = 0

++ <red>is the Increment operator, it increases the integer value by one.</red>
A++ = 11

-- <red>is the Decrement operator, it decreases the integer value by one.</red>
A-- = 9

</code>
		<green><br></br>Relational Operators<br></br></green>
<code>
== <red>it checks if the values of two operands are equal or not. 
If yes, then the condition becomes true.</red>
(A == B) is not true.

!= <red>it checks if the values of two operands are equal or not.
If the values are not equal, then the condition becomes true.</red>
(A != B) is true.

&gt; <red>it checks if the value of left operand is greater than the value of right operand.
If yes, then the condition becomes true.</red>
(A &gt; B) is not true.

&lt; <red>it checks if the value of left operand is less than the value of right operand.
If yes, then the condition becomes true.</red>
(A &lt; B) is true.

&gt;= <red>it checks if the value of left operand is greater than or equal to the value of right operand.
If yes, then the condition becomes true.</red>
(A &gt;= B) is not true.

&lt;= <red>it checks if the value of left operand is less than or equal to the value of right operand. 
If yes, then the condition becomes true.</red>
(A &lt;= B) is true.
</code>
		<green><br></br>Logical Operators<br></br></green>
<code>
	
&#38;&#38; <red>it's called Logical AND operator. Results in TRUE if both the operands are non-zero, 
then the condition becomes true.</red>
(A &#38;&#38; B) is false.

|| <red>it's called Logical OR Operator.  Results in TRUE if any of the two operands is non-zero, 
then the condition becomes true.</red>
(A || B) is true.

! <red>it's called Logical NOT Operator. It is used to reverse the logical state of its operand. 
If a condition is true, then Logical NOT operator will make it false.</red>
!(A &#38;&#38; B) is true.
</code>
		<br></br>Bitwise Operators<br></br>
<code>
&#38; <red>binary AND Operator copies a bit to the result if it exists in both operands.</red>	
(A &#38; B) = 12, i.e., 0000 1100

| <red>binary OR Operator copies a bit if it exists in either operand.</red>
(A | B) = 61, i.e., 0011 1101

^ <red>binary XOR Operator copies the bit if it is set in one operand but not both.</red>	
(A ^ B) = 49, i.e., 0011 0001

~ <red>binary One's Complement Operator is unary and has the effect of 'flipping' bits.</red>	
(~A ) = ~(60), i.e,. -0111101

&lt;&lt; <red>binary Left Shift Operator. 
The left operands value is moved left by the number of bits specified by the right operand.</red>
A &lt;&lt; 2 = 240 i.e., 1111 0000

&gt;&gt; <red>binary Right Shift Operator. 
The left operands value is moved right by the number of bits specified by the right operand.</red>
A &gt;&gt; 2 = 15 i.e., 0000 1111

</code>
		<green><br></br>Assignment Operators<br></br></green>
<code>
= <red>is the assignment operator. 
Assigns values from right side operands to left side operand.</red>
C = A + B will assign the value of A + B to C

+= <red>the add AND assign operator. 
It adds the right operand to the left operand and assign the result to the left operand.</red>	
C += A is equivalent to C = C + A

-= <red>Subtract AND assignment operator. 
It subtracts the right operand from the left operand and assigns the result to the left operand.</red>	
C -= A is equivalent to C = C - A

*= <red>Multiply AND assignment operator. 
It multiplies the right operand with the left operand and assigns the result to the left operand.</red>	
C *= A is equivalent to C = C * A

/= <red>the divide AND assign operator. 
It divides the left operand with the right operand and assigns the result to the left operand.</red>
C /= A is equivalent to C = C / A

%= <red>the modulus AND assign operator. 
It takes modulus using two operands and assigns the result to the left operand.</red>
C %= A is equivalent to C = C % A

&lt;&lt;= <red>the Left shift AND assign operator.
It takes the value stored in variable C shifts it to the left by the number of bits specified after the equal sign and then assigns the result of the operation back to C variable</red>
C &lt;&lt;= 2 is same as C = C &lt;&lt; 2

&gt;&gt;= <red>the Right shift AND assign operator.
It takes the value stored in variable C shifts it to the right by the number of bits specified after the equal sign and then assigns the result of the operation back to C variable.</red>
C &gt;&gt;= 2 is same as C = C &gt;&gt; 2

&#38;= <red>the bitwise AND assign operator.
It takes the value stored in variable C performs bitwise AND with the value specified after the equal sign and then assigns the result of the operation back to C variable.</red>
C &#38;= 2 is same as C = C &#38; 2

^= <red>the bitwise exclusive OR and assign operator.
It takes the value stored in variable C performs bitwise XOR with the value specified after the equal sign and then assigns the result of the operation back to C variable.</red>
C ^= 2 is same as C = C ^ 2

|= <red>the bitwise inclusive OR and assign operator.
It takes the value stored in variable C performs bitwise OR with the value specified after the equal sign and then assign the result of the operation back to C variable.</red>
C |= 2 is same as C = C | 2

</code>
		<green><br></br>Misc Operators<br></br></green>
<code>
sizeof() <red>it returns the size of a variable. sizeof(a), where a is integer, will return 4.</red>
&#38;  <red>it returns the address of a variable. &#38;a; returns the actual address of the variable.</red>
* <red>Pointer to a variable. *a;</red>
? : <red>Conditional Expression. If Condition is true ? then value X : otherwise value Y; </red>
</code>
		</operators>
		<pre-post-incrementation>
		Increment operators are used to increase the value of a variable by 1.<br></br>
		This operator is represented by the ++ symbol. The increment operator can either
		increase the value of the variable by 1 before assigning it to the variable or 
		can increase the value of the variable by 1 after assigning the variable. 
		Thus it can be classified into two types:
		<br></br><br></br>
		<blue>
		Pre-Increment Operator<br></br>
		Post-Increment Operator<br></br>
		</blue>
<code>

//pre increment operator

#include &lt;stdio.h&gt;  
 
int main()
{
    int x = 10, a;
 
    a = ++x; // x will be incremented to 11 then value of x is assigned to a;
 
    printf("a = %d\n", a);
 
    printf("x = %d\n", x);
    return 0;
	
	/*
	OUTPUT: 
	a = 11
	x = 11
	*/

/*====================================*/

//post increment operator

#include &lt;stdio.h&gt;  
 
int main()
{
    int x = 10, a;
 
    a = x++; // x value is assined to a, then x value gets incremented to 11;

    printf("a = %d\n", a);
 
    printf("x = %d\n", x);
    return 0;
	
	/*
	OUTPUT: 
	a = 10
	x = 11
	*/

}

</code>
		</pre-post-incrementation>
	</programming_language>
	
	<programming_language>
		<name>C++</name>
		<description>
			C++ is a high-level, general-purpose programming language created by 
			Danish computer scientist Bjarne Stroustrup. <br></br><br></br>
			First released in 1985 as an extension of the C programming language, 
			it has since expanded significantly over time; as of 1997, C++ has object-oriented, 
			generic, and functional features. <br></br>
			In addition to facilities for low-level memory 
			manipulation for making things like microcomputers or to make operating systems 
			like Linux or Windows. <br></br><br></br>
			
			It is almost always implemented as a compiled language, 
			and many vendors provide C++ compilers, including the Free Software Foundation, 
			LLVM, Microsoft, Intel, Embarcadero, Oracle, and IBM.
		</description>
		<oop>
		OOP stands for Object-Oriented Programming.
		<br></br><br></br>
		Procedural programming is about writing procedures or functions that perform operations on the data, while object-oriented programming is about creating objects that contain both data and functions.
		<br></br><br></br>
		Object-oriented programming has several advantages over procedural programming:
		<br></br><br></br>
		<green>
		OOP is faster and easier to execute;<br></br>
		OOP provides a clear structure for the programs;<br></br>
		OOP helps to keep the C++ code DRY "Don't Repeat Yourself", and makes the code 
		easier to maintain, modify and debug;<br></br>
		OOP makes it possible to create full reusable applications with less code and 
		shorter development time;
		</green>
		<br></br><br></br>
		<red>
		Tip: The "Don't Repeat Yourself" (DRY) principle is about reducing the repetition 
		of code. You should extract out the codes that are common for the application, 
		and place them at a single place and reuse them instead of repeating it.
		</red>
		<br></br>
		</oop>
		<encapsulation>
		The meaning of Encapsulation, is to make sure that "sensitive" data is hidden from 
		users.<br></br><br></br> 
		To achieve this, you must declare class variables/attributes as private 
		(cannot be accessed from outside the class). <br></br><br></br>
		If you want others to read or modify 
		the value of a private member, you can provide public get and set methods.<br></br>
<code>

#include &lt;iostream&gt;  
using namespace std;

class Employee {
  private:
    // Private attribute
    int salary;

  public:
    // Setter
    void setSalary(int s) {
      salary = s;
    }
    // Getter
    int getSalary() {
      return salary;
    }
};

int main() {
  Employee myObj;
  myObj.setSalary(50000);
  cout &lt;&lt; myObj.getSalary();
  return 0;
}

</code>
		</encapsulation>
		<polymorphism>
		Polymorphism means "many forms", and it occurs when we have many 
		classes that are related to each other by inheritance.<br></br>
<code>

#include &lt;iostream&gt;  

/*

The word polymorphism means having many forms. 
Typically, polymorphism occurs when there is a hierarchy of classes and they are related by inheritance.

C++ polymorphism means that a call to a member function will cause a different function to be executed depending on the type of object that invokes the function. 
Example if a parent class function is set to be override-able, then a parent class pointer can have functionality of the a child class object.

A pure virtual function is a function that is declared in the parent class and it really needs to be defined in
each one of the child classes.

Syntax: virtual void DisplayFunction () = 0;

*/
using namespace std;

class Shape{
    //By default a member without access-specifier is set to private.

	protected:
		int length;
		int height;

	public:
		virtual void DisplayInfo() //Each child class has to provide its own definition of this method.
		{
			cout &lt;&lt; "This is the parent class." &lt;&lt; endl;
		}
};

class Square: public Shape
{

	private:
		int area;
		void CalcArea()
		{
			area=length*height;
		}

	public:
		Square (int len, int hg)
		{
			length=len;
			height=hg;
			CalcArea();
		};
		void DisplayArea()
		{
			cout &lt;&lt; "Area: " &lt;&lt; area &lt;&lt; endl;
		}
		
		//This function overrides the parent class function
		void DisplayInfo()
		{
			cout &lt;&lt; "This is the child class." &lt;&lt; endl;
		}
};

class Circle: public Shape
{

	private:
		int radius;
	public:
		Circle(int len)
		{
			radius=len/2;
		}
		void DisplayRadius()
		{
			cout &lt;&lt; "Radius: " &lt;&lt; radius &lt;&lt; endl;
		}
};

int main()
{
    Shape *p;
    Circle circle_object(22);
    Square square_object(4,3);
	
    /*
    The pointer of type Shape can reference any of the Shape class children, but having only the functionality of Shape
    Class.
    */
	
    p=&#38;circle_object;
    p-&gt;DisplayInfo();
    p=&#38;square_object;
    p-&gt;DisplayInfo();
	
    int a;
    cin &gt;&gt; a;
    return 0;
	
	/*
	Using same variable we accessed different behaviour for each child class.
	*/
}
</code>	
		</polymorphism>
		<inheritance>
		In C++, it is possible to inherit attributes and methods from one class to another. 
		We group the "inheritance concept" into two categories:
		<br></br><br></br>
		<green>
		- derived class (child) - the class that inherits from another class;<br></br>
		- base class (parent) - the class being inherited from;<br></br><br></br>
		</green>
		To inherit from a class, use the : symbol.<br></br>
<code>

#include &lt;iostream&gt;  
#include &lt;conio.h&gt;  

using namespace std;

//BASE CLASS
class Shape{

    protected: 
		//protected variables are visible into this class and the other classes that are inherited to this.

		string name;
		
    public:
        Shape(string newname)
        {
            name=newname;
        }
        string getName() const
        {
            return name;
        }
};

//CHILD CLASS ONE
class Circle : public Shape //making Circle class derive from the Shape class (setting the inheritance).
{
    //inheritance is a way to make 2 classes share the same variables between each other

    double radius; //this variable can be private, or protected or public (anything).

    public:
        Circle(string inheritedName, double newradius) : Shape (inheritedName)//this will call the Shape constructor
        //which will set a value into it's string variable called 'name', in this way, a variable will be used in 2 classes.
        {
            radius=newradius;
        }
        double getCircleRadius() const
        {
            return radius;
        }

};

//CHILD CLASS TWO
class Rectangle : public Shape // making the Rectangle class derive from Shape Class, let the Rectangle Class, use the
//protected variables of the Shape Class.
{
    double length, width;

    public:
        Rectangle (string inheritedName2, double newlength, double newwidth): Shape (inheritedName2)
        {
            length=newlength;
            width=newwidth;
        }
        double getRectangleLength() const
        {
            return length;
        }
        double getRectangleWidth () const
        {
            return width;
        }
};

int main()
{
    Shape object("Shape Class String"); //create object
    cout &lt;&lt; object.getName() &lt;&lt; endl; //calling a function from the class

    cout &lt;&lt; endl &lt;&lt; "CHILD ONE CLASS: " &lt;&lt; endl;
	
    Circle objectchild ("Circle (stored in Shape Class String)", 3.0); //create object
    cout &lt;&lt; objectchild.getName() &lt;&lt; endl; //calling a function from Shape Class using the object from Circle Class.
    cout &lt;&lt; objectchild.getCircleRadius() &lt;&lt; endl;

    cout &lt;&lt; endl &lt;&lt; "CHILD TWO CLASS: " &lt;&lt; endl;
	
    Rectangle objectchild2("Rectangle (stored in Shape Class String)", 20.0, 65.0); //create object
    cout &lt;&lt; objectchild2.getName() &lt;&lt; endl; //calling a function from Shape Class using the object from Rectangle Class.
	cout &lt;&lt; objectchild2.getRectangleLength() &lt;&lt; endl;
    cout &lt;&lt; objectchild2.getRectangleWidth() &lt;&lt; endl;

    getch();
    return 0;
}

</code>
		</inheritance>
		<abstraction>
		Data abstraction is one of the most essential and important features of object-oriented 
		programming in C++. <br></br><br></br>
		Abstraction means displaying only essential information and hiding the 
		details. Data abstraction refers to providing only essential information about the 
		data to the outside world, hiding the background details or implementation. 
		<br></br><br></br>

<code>

#include &lt;iostream&gt;  
using namespace std;
 
class implementAbstraction {
private:
    int a, b;
 
public:
    // method to set values of
    // private members
    void set(int x, int y)
    {
        a = x;
        b = y;
    }
 
    void display()
    {
        cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;
        cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;
    }
};
 
int main()
{
    implementAbstraction obj;
    obj.set(10, 20);
    obj.display();
    return 0;
	
	/*
	OUTPUT:
	a = 10
	b = 20
	*/
}

</code>
		We are not allowed to access the variables a and b directly, however, one can call 
		the function set() to set the values in a and b and the function display() to 
		display the values of a and b. 
		<br></br><br></br>
		
		<red>Advantages of Data Abstraction:</red>
		<br></br><br></br>
		<green>
		Helps the user to avoid writing the low-level code;<br></br>
		Avoids code duplication and increases reusability.<br></br>
		Can change the internal implementation of the class independently without 
		affecting the user.<br></br>
		Helps to increase the security of an application or program as only important 
		details are provided to the user.<br></br>
		It reduces the complexity as well as the redundancy of the code, therefore 
		increasing the readability.
		<br></br>
		</green>
		</abstraction>
		<generic-programming>
		In C++ the templates generalize the algorithm to make it data type-independent.
		<br></br>		
		The functions and classes which are data type independent are called generics, 
		and this concept is called generic programming. 
		<br></br>
		Generic Programming reduces code 
		repetition and in-demand compilation; hence efficient.
		<br></br>

<code>

#include &lt;iostream&gt;  

// Template Function with a Type T
// During instantiation, this T will be replaced by the data type of argument.
template &lt;class T&gt;  
T maxNum (T a, T b) {
 return (a &gt;   b ? a : b); //ternary operator
}

int main()
{
    int x = 5, y = 2;
    float a = 4.5, b = 1.3;
    
    std::cout &lt;&lt; maxNum&lt;int&gt;(x, y) &lt;&lt; "\n";
    std::cout &lt;&lt; maxNum&lt;float&gt;(a, b);
    return 0;
}

</code>
		</generic-programming>
		<variable-arguments-lists>
		The variable number of arguments in C++ is a feature that permits a function to 
		accept any number of arguments. This type of function is called variadic functions.
		<br></br><br></br>
		Functions with a variable number of arguments in C++ can be easily implemented using 
		a vector or an array if all the arguments are the same type.
		<br></br><br></br>
		If all arguments are of different types, then we need to use the cstdarg header file 
		to implement variadic functions.
		<br></br><br></br>
		Variadic functions do not put restrictions on the types of arguments. They also do not perform 
		integer and floating-point enhancements.
		<br></br>
<code>

<red>// Implementation of variable arguments using vector.</red>
#include &lt;iostream&gt; 
#include &lt;vector&gt; 
using namespace std;

// Using vector of string as a parameter to store a variable number of strings.
void printNames(vector&lt;string&gt;  nameVector) {
    for (string &#38;name : nameVector) {
        cout &lt;&lt; name &lt;&lt; " ";
    }
    cout &lt;&lt; '\n';
}

int main() {
    printNames({"Scaler", "Topics"});
    printNames({"Technopedia", "for", "your", "mastermind!"});
    return 0;
}


/*-------------------------------------------------------*/

<red>// Implementation of variable arguments using cstdarg variadic functons.</red>
#include &lt;iostream&gt; 
#include &lt;cstdarg&gt; 

using namespace std;

void printDeveloperData(const char* fmt...) {
    va_list args;
    va_start(args, fmt);
 
    while (*fmt != '\0') {
        if (*fmt == 'd') {
            int version = va_arg(args, int);
            std::cout &lt;&lt; "C++ Version: " &lt;&lt; version;
        } else if (*fmt == 'c') {
            int name = va_arg(args, int);
            std::cout &lt;&lt; "Name: " &lt;&lt; static_cast&lt;char&gt; (name);
        } else if (*fmt == 'f') {
            double stability_percentage = va_arg(args, double);
            std::cout &lt;&lt; "Stability Percentage: " &lt;&lt; stability_percentage &lt;&lt; "%";
        }
        ++fmt;
        cout &lt;&lt; '\n';
    }
 
    va_end(args);
}
 
int main() {
    printDeveloperData("cdf", 'B', 20, 94.7);
    
    return 0;

}

/*-------------------------------------------------*/

<red>// Implementation of variable arguments using variadic templates. </red>
#include &lt;iostream&gt; 
using namespace std;

template &lt;typename T&gt; 
void printDeveloperData(T t) {
    cout &lt;&lt; t &lt;&lt; '\n' ;
}

template&lt;typename T, typename... Args&gt; 
void printDeveloperData(T t, Args... args) {
    cout &lt;&lt; t &lt;&lt; '\n';
    printDeveloperData(args...) ;
}

int main() {
    printDeveloperData("Bjarne", 20, 94.7);
}

</code>
		</variable-arguments-lists>
		<simple-data-types>
		All variables use data type during declaration to restrict the type of data to 
		be stored. Therefore, we can say that data types are used to tell the variables 
		the type of data they can store. <br></br>
		Whenever a variable is defined in C++, 
		the compiler allocates some memory for that variable based on the data type 
		with which it is declared. Every data type requires a different amount of memory.
		<br></br><br></br>
		The datatypes presented on C Language are still available in C++:
		<br></br><br></br>
		<green>Primitive Datatypes:</green><br></br>
		<blue>
		Integer<br></br>
		Character<br></br>
		Boolean<br></br>
		Floating Point<br></br>
		Double Floating Point<br></br>
		Valueless or Void<br></br>
		Wide Character<br></br>
		</blue>
		<br></br>
		</simple-data-types>
		<complex-data-types>
		Aditional to the C Language, C++ introduced classes as a user-defined datatype.
		<br></br><br></br>
		<green>Derived Datatypes:</green><br></br>
		<blue>
		Function<br></br>
		Array<br></br>
		Pointer<br></br>
		Reference<br></br>
		</blue>
		<br></br>
		<green>User-defined Datatypes:</green><br></br>
		<blue>
		Class<br></br>
		Structure<br></br>
		Union<br></br>
		Enumeration<br></br>
		Typedef defined Datatype<br></br>
		</blue>
		</complex-data-types>
		<loops>
		Additional to the loops presented in C language, there is also a "for-each loop" 
		(introduced in C++ version 11 (2011), which is used exclusively to loop through 
		elements in an array (or other data sets):
<code>

/*Example of foreach loop in C++*/

int myNumbers[5] = {10, 20, 30, 40, 50};
for (int i : myNumbers) {
  cout &lt;&lt;  i &lt;&lt;  "\n";
}
</code>
		</loops>
		<collections>
		Additional to C Language: C++ introduced several new collection classes datatypes:
		<br></br><br></br>
		<blue>
		Vector: The C++ Standard Library vector class is a class template for sequence containers.<br></br>
		</blue>
		<br></br>
		<green>
		Vector is a type of dynamic array which has the ability to resize 
		automatically after insertion or deletion of elements. The elements in vector 
		are placed in contiguous storage so that they can be accessed and traversed using 
		iterators. Element is inserted at the end of the vector.<br></br><br></br>
		</green>
<code>
#include &lt;iostream&gt; 
#include &lt;vector&gt; 
 
int main()
{
    // Create a vector containing integers
    std::vector&lt;int&gt;  v = {8, 4, 5, 9};
 
    // Add two more integers to vector
    v.push_back(6);
    v.push_back(9);
 
    // Overwrite element at position 2
    v[2] = -1;
 
    // Print out the vector
    for (int n : v)
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

</code>	
		<green>
		List: List is a double linked sequence that supports both forward and backward 
		traversal. The time taken in the insertion and deletion in the beginning, end 
		and middle is constant. It has the non-contiguous memory and there is no 
		pre-allocated memory.<br></br>
		</green>
<code>

// C++ program to demonstrate the use of list containers
#include &lt;iostream&gt; 
#include &lt;list&gt; 
using namespace std;
 
int main()
{
    // defining list
    list&lt;int&gt;  gqlist{12,45,8,6};
 
    for (auto i : gqlist) {
        cout &lt;&lt; i &lt;&lt; ' ';
    }
    return 0;
}
</code>
		</collections>
		<collection-methods>No information present in the database.</collection-methods>
		<dynamic-memory-allocation>
		Additional to the C language: 
		<br></br><br></br>
		C++ integrates the operators <code>new</code> and <code>delete</code> for allocating dynamic memory. 
		But these were not available in the C language; instead, it used a library solution, 
		with the functions <code>malloc</code>, <code>calloc</code>, <code>realloc</code> and <code>free</code>, 
		defined in the header <code>&lt;cstdlib&gt;</code> (known as <code>&lt;stdlib.h&gt;</code>  in C). 
		<br></br>
		The functions are also available in C++ and can also be 
		used to allocate and deallocate dynamic memory.
		<br></br><br></br>
		<red>Operators new and new[]: </red>
		<br></br>
		Dynamic memory is allocated using operator new. new is followed by a data 
		type specifier and, if a sequence of more than one element is required, 
		the number of these within brackets []. <br></br>
		It returns a pointer to the beginning of the new block of memory allocated. <br></br>
<code>

//Example:
int * foo;
foo = new int [5];

</code>
		In this case, the system dynamically allocates space for five elements of type int 
		and returns a pointer to the first element of the sequence, which is assigned to 
		foo (a pointer). <br></br>
		Therefore, foo now points to a valid block of memory with space 
		for five elements of type int.<br></br>
		<br></br>
		<red>Operators delete and delete[]: </red>
		<br></br>
		In most cases, memory allocated dynamically is only needed during specific periods 
		of time within a program; once it is no longer needed, it can be freed so that 
		the memory becomes available again for other requests of dynamic memory. <br></br>
		<br></br>
		This is the purpose of operator delete, whose syntax is: <br></br>
<code>

// Example of dynamic allocation
// and deallocation of memory using new and delete
#include &lt;iostream&gt; 
using namespace std;

int main()
{
    // Pointer initialization to null
    int* p = NULL;

    // Request memory for the variable
    // using new operator
    p = new (nothrow) int;
    if (!p)
        cout &lt;&lt; "allocation of memory failed\n";
    else {
        // Store value at allocated address
        *p = 29;
        cout &lt;&lt; "Value of p: " &lt;&lt; *p &lt;&lt; endl;
    }

    // Request block of memory
    // using new operator
    float* r = new float(75.25);

    cout &lt;&lt; "Value of r: " &lt;&lt; *r &lt;&lt; endl;

    // Request block of memory of size n
    int n = 5;
    int* q = new (nothrow) int[n];

    if (!q)
        cout &lt;&lt; "allocation of memory failed\n";
    else {
        for (int i = 0; i &lt; n; i++)
            q[i] = i + 1;

        cout &lt;&lt; "Value store in block of memory: ";
        for (int i = 0; i &lt; n; i++)
            cout &lt;&lt; q[i] &lt;&lt; " ";
    }

    // freed the allocated memory
    delete p;
    delete r;

    // freed the block of allocated memory
    delete[] q;

    return 0;
	
	/*
	OUTPUT:
	Value of p: 29
	Value of r: 75.25
	Value store in block of memory: 1 2 3 4 5 
	*/
}

</code>
		</dynamic-memory-allocation>
		<read-from-file>
		The fstream library can be used in C++ to work with files.
		<br></br><br></br>
		There are three classes included in the fstream library, which are used to create, write or read files:
		<br></br><br></br>
		Class		Description<br></br>
		<red>ofstream</red>	Creates and writes to files<br></br>
		<red>ifstream</red>	Reads from files<br></br>
		<red>fstream</red>		A combination of ofstream and ifstream: creates, reads, and writes to files
		<br></br><br></br>
		To read from a file, use either the ifstream or fstream class, and the name of the file.
		<br></br><br></br>
		<green>Note: we also use a while loop together with the getline() function 
		(which belongs to the ifstream class) to read the file line by line, and to print 
		the content of the file:</green>
		<br></br>
<code>

// Create a text string, which is used to output the text file

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;

int main() 
{
	string myText;

	// Read from the text file
	ifstream MyReadFile("filename.txt");

	// Use a while loop together with the getline() function to read the file line by line
	while (getline (MyReadFile, myText)) {
	  // Output the text from the file
	  cout &lt;&lt; myText;
	}

	// Close the file
	MyReadFile.close(); //It is considered good practice to close the file, 
	//and it can clean up unnecessary memory space.
}

</code>
		</read-from-file>
		<write-to-file>
		The fstream library can be used in C++ to work with files.
		<br></br><br></br>
		There are three classes included in the fstream library, which are used to create, 
		write or read files:
		<br></br><br></br>
		Class		Description<br></br>
		<red>ofstream</red>	Creates and writes to files<br></br>
		<red>ifstream</red>	Reads from files<br></br>
		<red>fstream</red>		A combination of ofstream and ifstream: creates, reads, and writes to files
		<br></br><br></br>
		Create and Write To a File:<br></br>
		To create a file, use either the ofstream or fstream class, and specify 
		the name of the file.
		<br></br><br></br>
		To write to the file, use the insertion operator (&lt;&lt;).<br></br>
<code>

//Example of writing to file using fstream in C++

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;

int main() 
{
	// Create and open a text file
	ofstream MyFile("filename.txt");

	// Write to the file
	MyFile &lt;&lt; "Files can be tricky, but it is fun enough!";

	// Close the file
	MyFile.close(); //It is considered good practice to close the file, 
	//and it can clean up unnecessary memory space.
}

</code>
		</write-to-file>
		<serialization>
		Serialization is the process of storing the state of an object to a file.<br></br>
<code>

/*Example of C++ object.field serialization and deserialization*/

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;

class Student 
{
    public:
    string name;
    int rollno;
    string branch;
	
    Student ()
    {
    } 
	
    Student (string n, int r, string b) // overloading constructor
    {
        name = n;
        rollno = r;
        branch = b;
    } 
	//override the insertion operator for object.field serialization
    friend ofstream &#38; operator &lt;&lt; (ofstream &#38; ofs, Student s);
	//now we can write individually every class field member to the file. Example: ofs &lt;&lt; s1.name; 
	
	//override the extraction for object.field deserialization
    friend ifstream &#38; operator &gt; &gt;  (ifstream &#38; ifs, Student &#38; s);
	//now we can read individually every class field member from the file. Example: ifs &gt;&gt; s1.name; 
};

int main() 
{
    Student s1 ("James", 28, "IT");
	
	//Open the output stream
    ofstream ofs ("Student.txt", ios::trunc);
	
	//writing to the file
    ofs &lt;&lt;  s1.name &lt;&lt; endl;
    ofs &lt;&lt;  s1.rollno &lt;&lt; endl;
    ofs &lt;&lt;  s1.branch &lt;&lt; endl;
	ofs.close();
	
	Student s2; //empty object
	
	//Open the input stream
    ifstream ifs("Student.txt");
	
	//reading from the file
	ifs &gt;&gt; s2.name;
    ifs &gt;&gt;  s2.rollno;
    ifs &gt;&gt;  s2.branch;
    ifs.close();

    cout &lt;&lt; s2.name &lt;&lt; endl;
    cout &lt;&lt; s2.rollno &lt;&lt; endl;
    cout &lt;&lt; s2.branch &lt;&lt; endl;
	
	/*
	OUTPUT: 
	James 
	28 
	IT
	*/
}

</code>
		</serialization>
		<deserialization>
		Deserialization is the reverse process of Serialization, 
		where the byte stream is used to reconstruct the original object.<br></br>
<code>

/*Example of C++ whole-object serialization and deserialization*/

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;
class Student
{
    public:
    string name;
    int rollno;
    string branch;
    Student ()
    {
    }
    Student (string n, int r, string b)
    {
        name = n;
        rollno = r;
        branch = b;
    }
	//override the insertion operator for object.field serialization
    friend ofstream &#38; operator &lt;&lt; (ofstream &#38; ofs, Student s);
	//now we can write individually every class field member to the file. Example: ofs &lt;&lt; s1.name; 
	
	//override the extraction for object.field deserialization
    friend ifstream &#38; operator &gt;&gt;  (ifstream &#38; ifs, Student &#38; s);
	//now we can read individually every class field member from the file. Example: ifs &gt;&gt; s1.name; 
};

//Overriding the operators for whole-object serialization and deserialization
ofstream &#38;  operator &lt;&lt; (ofstream & ofs, Student s)
{
    ofs &lt;&lt; s.name &lt;&lt; endl;
    ofs &lt;&lt; s.rollno &lt;&lt; endl;
    ofs &lt;&lt; s.branch &lt;&lt; endl;
    return ofs;
}
ifstream &#38;  operator &gt;&gt;  (ifstream & ifs, Student & s)
{
    ifs &gt;&gt;  s.name &gt;&gt;  s.rollno &gt;&gt;  s.branch;
    return ifs;
}
/*

now we can read/write the whole object to and from the file. 

Example: 
ofs &lt;&lt; s1; 
ifs &gt;&gt; s2; 

*/

int main()
{
    Student s1("James", 28, "IT");
    ofstream ofs("Student.txt", ios::trunc);
    ofs &lt;&lt;  s1;
    ofs.close();
    Student s2;
    ifstream ifs("Student.txt");
    ifs &gt;&gt; s2;
    cout &lt;&lt;  s2.name &lt;&lt;  " " &lt;&lt;  s2.rollno &lt;&lt;  " " &lt;&lt;  s2.branch &lt;&lt;  endl;
    ifs.close();
	
	/*
	OUTPUT:
	James 28 IT
	*/
}

</code>
		</deserialization>
		<constructors>
		A constructor in C++ is a special method that is automatically called when an object 
		of a class is created.
<code>

#include &lt;iostream&gt; 

using namespace std;

/*Example*/
class MyClass {     // The class
  public:           // Access specifier
    MyClass() {     // Constructor
	
	/*
	The constructor has the same name as the class, it is always public, and it does not have any return value.
	*/
	
      cout &lt;&lt; "Hello World!";
    }
};

int main() {
  MyClass myObj;    // Create an object of MyClass (this will call the constructor)
  return 0;
}

</code>
		Constructors can also take parameters (just like regular functions), which can be 
		useful for setting initial values for attributes.<br></br>

<code>

#include &lt;iostream&gt; 
#include &lt;string&gt; 

using namespace std;

/*Example*/
class MyClass {     // The class
  public:           // Access specifier
    MyClass(string message) {     // Constructor with parameter
	
      cout &lt;&lt; message;
    }
};

int main() {
  MyClass myObj("Hello World!");    // Create an object of MyClass (this will call the constructor)
  return 0;
}

</code>
		</constructors>
		<instantiation>No information present in the database.</instantiation>
		<destructors>No information present in the database.</destructors>
		<function-overloading>No information present in the database.</function-overloading>
		<operator-overloading>No information present in the database.</operator-overloading>
		<enums>
		Comparison to C Language: <br></br><br></br>
		In C, an enum is basically a way to alias names to integers. This does not lead to 
		improved type checking. In C++, an enum defines an actual type, which results in 
		strong type checking.<br></br>
<code>

#include &lt;iostream&gt; 
#include &lt;conio.h&gt; 

using namespace std;

/*
While processing a game loop, there are lots of statements to be checked, so in order to use those statements, variables
that will hold a certain value will be created. Example:
int GamePlay =1;
int PauseGame = 2;
int ExitGame = 3;

So in this way the statements can be checked, to see when the game should be paused, should run, or should exit. As you see
above, the variables that are used needs to have different values.

An ENUM is a way to enclose a bunch of constants, an ENUM guarantees that every variable inside it, will have different values.
Example: an ENUM with the variables above, can be created as follows:
enum GameStates {GamePlay, PauseGame, ExitGame};
So the synthax is:
enum &lt;name&gt; {states/members};
*/

//Creating a GLOBAL enum:
enum GameStates {GamePlay, PauseGame, ExitGame}; //the elements will take as constant value the position inside the enum;
//In this case: GamePlay = 0; PauseGame=1; ExitGame=2;

/*

ENUM Members cannot be initialized with values: 
Example GamePlay = 5, this will give compilation error.

Instead the ENUM can be initialized only as follows:
GameStates=ExitGame;

In this case the active value of the ENUM will be ExitGame;
The syntax is : &lt;enum name&gt; = &lt;enum member&gt;;

An ENUM Class is an ENUM that will use the scope resolution and an object of the ENUM class for assignments as above.

Example:
GameStates gameStates=GameStates::ExitGame;

An ENUM Class will make possible that you can have multiple ENUMS with the same MEMBERS. 

So we could have for example:
enum class GameState {Exit, MainMenu};
enum class SoftwareState (Exit, MainMenu);

Without using an ENUM Class this could not be possible because, the TWO MEMBERS will conflict to each other
(compilation error).

Syntax to create an ENUM Class:

enum class &lt;name&gt; { member1, member2...}
An ENUM cannot be forward declared, unless it's an ENUM Class. 
So only ENUM Classes can be forward declared.

To change the default value of an ENUM Member which consist in it's position on the ENUM, you can do as follows:

enum GameState {MainMenu=5, GamePlay=7, GameExit, GamePaused}; //the two uninitialized members follow gets the value of the
previous member+1; so GameExit will be 8, GamePause will be 9;

*/

int main()
{
    cout &lt;&lt; "GamePlay value: " &lt;&lt; GamePlay &lt;&lt; endl; // this is 0;
    cout &lt;&lt; "PauseGame value: " &lt;&lt; PauseGame &lt;&lt; endl; // this is 1;
    cout &lt;&lt; "ExitGame value: " &lt;&lt; ExitGame &lt;&lt; endl; // this is 2;
    getch();
    return 0;
}

</code>
		</enums>
		<multi-threading>
		C++ multithreading involves creating and using thread objects, seen as std::thread 
		in code, to carry out delegated sub-tasks independently. <br></br>
		New threads are passed a 
		function to complete, and optionally some parameters for that function.
		<br></br>
<code>

#include &lt;iostream&gt; 
#include &lt;cstdlib&gt; 
#include &lt;pthread.h&gt; 

using namespace std;

#define NUM_THREADS 5

void *PrintHello(void *threadid) {
   long tid;
   tid = (long)threadid;
   cout &lt;&lt; "Hello World! Thread ID, " &lt;&lt; tid &lt;&lt; endl;
   pthread_exit(NULL);
}

int main () {
   pthread_t threads[NUM_THREADS];
   int rc;
   int i;
   
   for( i = 0; i &lt; NUM_THREADS; i++ ) {
      cout &lt;&lt; "main() : creating thread, " &lt;&lt; i &lt;&lt; endl;
      rc = pthread_create(&#38;threads[i], NULL, PrintHello, (void *)i);
      
      if (rc) {
         cout &lt;&lt; "Error:unable to create thread," &lt;&lt; rc &lt;&lt; endl;
         exit(-1);
      }
   }
   pthread_exit(NULL);
}

</code>
		</multi-threading>
		<namespaces>
		A namespace is a feature added in C++ and is No information present in the database. in C. <br></br>
		A namespace is a 
		declarative region that provides a scope to the identifiers (names of functions, 
		variables or other user-defined data types) inside it. <br></br>
		Multiple namespace blocks 
		with the same name are allowed.<br></br>
<code>

namespace Data
{
    class ObjectManager
    {
    public:
        void DoSomething() {}
    };
    void Func(ObjectManager) {}
}

</code>
		</namespaces>
		<exception-handling>
		In C++, exceptions are runtime anomalies or abnormal conditions that a program 
		encounters during its execution. The process of handling these exceptions is 
		called exception handling. <br></br>
		Using the exception handling mechanism, the control 
		from one part of the program where the exception occurred can be transferred 
		to another part of the code.
		<br></br><br></br>
		By using exception handling in C++, we can handle the exceptions so that our 
		program keeps running.<br></br>
<code>

// C++ example on how to use of try,catch and throw
// for exception handling.
 
#include &lt;iostream&gt; 
#include &lt;stdexcept&gt; 
using namespace std;
 
int main()
{
 
    // try block
    try {
        int numerator = 10;
        int denominator = 0;
        int res;
 
        // check if denominator is 0 then throw runtime
        // error.
        if (denominator == 0) {
            throw runtime_error(
                "Division by zero not allowed!");
        }
 
        // calculate result if no exception occurs
        res = numerator / denominator;
        //[printing result after division
        cout &lt;&lt; "Result after division: " &lt;&lt; res &lt;&lt; endl;
    }
    // catch block to catch the thrown exception
    catch (const exception&#38; e) {
        // print the exception
        cout &lt;&lt; "Exception " &lt;&lt; e.what() &lt;&lt; endl;
    }
 
    return 0;
}

</code>
		</exception-handling>
		<bitwise-operators>
		Same as presented in C Language.
		<br></br><br></br>
		Bitwise operators in C/C++ are 
		tools for working with individual bits in data. They might not be as famous as other 
		operators, but they’re essential for tasks like making code more efficient or 
		controlling hardware.
		</bitwise-operators>
		<default-parameters>
		A default parameter/argument is a value provided in a function declaration that is 
		automatically assigned by the compiler if the calling function doesn’t provide 
		a value for the argument. In case any value is passed, the default value is 
		overridden. <br></br>
<code>

// Example of Default Parameters/Arguments in C++.

#include &lt;iostream&gt; 
using namespace std;
 
// A function with default arguments,
// it can be called with
// 2 arguments or 3 arguments or 4 arguments.

int sum(int x, int y, int z = 0, int w = 0) //assigning default values to z,w as 0
{
    return (x + y + z + w);
}
 
int main()
{
    // Statement 1
    cout &lt;&lt; sum(10, 15) &lt;&lt; endl;
   
    // Statement 2
    cout &lt;&lt; sum(10, 15, 25) &lt;&lt; endl;
   
    // Statement 3
    cout &lt;&lt; sum(10, 15, 25, 30) &lt;&lt; endl;
    return 0;
}

</code>
		</default-parameters>
		<interfaces>
		An interface describes the behavior or capabilities of a C++ class without committing 
		to a particular implementation of that class.
		<br></br><br></br>
		The C++ interfaces are implemented using abstract classes and these abstract classes 
		should not be confused with data abstraction which is a concept of keeping 
		implementation details separate from associated data.<br></br>
<code>

/*Example of an interface implementation*/
class Box {
   public:
      // pure virtual function
      virtual double getVolume() = 0;
      
   private:
      double length;      // Length of a box
      double breadth;     // Breadth of a box
      double height;      // Height of a box
};

</code>
		</interfaces>
		<abstract-classes>
		The purpose of an abstract class (often referred to as an ABC) is to provide an 
		appropriate base class from which other classes can inherit. <br></br>
		Abstract classes cannot be used to instantiate objects and serves only as an 
		interface. <br></br>
		Attempting to instantiate an object of an abstract class causes a 
		compilation error. <br></br>
		<br></br>
		Thus, if a subclass of an ABC needs to be instantiated, it has to implement each of 
		the virtual functions, which means that it supports the interface declared by the 
		ABC. Failure to override a pure virtual function in a derived class, 
		then attempting to instantiate objects of that class, is a compilation error.
<code>

#include &lt;iostream&gt; 
 
using namespace std;
 
// Base class
class Shape {
   public:
      // pure virtual function providing interface framework.
      virtual int getArea() = 0;
      void setWidth(int w) {
         width = w;
      }
   
      void setHeight(int h) {
         height = h;
      }
   
   protected:
      int width;
      int height;
};
 
// Derived classes
class Rectangle: public Shape {
   public:
      int getArea() { 
         return (width * height); 
      }
};

class Triangle: public Shape {
   public:
      int getArea() { 
         return (width * height)/2; 
      }
};
 
int main(void) {
   Rectangle Rect;
   Triangle  Tri;
 
   Rect.setWidth(5);
   Rect.setHeight(7);
   
   // Print the area of the object.
   cout &lt;&lt; "Total Rectangle area: " &lt;&lt; Rect.getArea() &lt;&lt; endl;

   Tri.setWidth(5);
   Tri.setHeight(7);
   
   // Print the area of the object.
   cout &lt;&lt; "Total Triangle area: " &lt;&lt; Tri.getArea() &lt;&lt; endl; 

   return 0;
}

</code>
		An object-oriented system might use an abstract base class to provide a common and 
		standardized interface appropriate for all the external applications. <br></br>
		Then, through inheritance from that abstract base class, derived classes are 
		formed that operate similarly.
		<br></br><br></br>
		The capabilities (i.e., the public functions) offered by the external applications 
		are provided as pure virtual functions in the abstract base class. <br></br>
		The implementations of these pure virtual functions are provided in the derived 
		classes that correspond to the specific types of the application.<br></br>
		</abstract-classes>
		<macros>
		Similar to C Language: 
		<br></br><br></br>
		A C++ macro is defined as a section of code that that particular macro value can 
		replace. <br></br>
		We can define the macro by using a #define directive. 
		When the compiler goes to the macros while program compilation, 
		the macro's name is replaced by the definition of the macro. 
		<br></br>
		The termination of the C++ Macros does not need a 
		semi-colon (;).
		<br></br><br></br>
		Aditionally to the C Language: the header file: &lt;limits.h&gt; is defined to help finding 
		the range of fundamental data-types. <br></br>
		Unsigned modifiers have minimum value is zero. So, no macro constants are defined for the unsigned minimum value.
		<br></br><br></br>
		<red>
		Macro Constants<br></br><br></br>
		</red>
		<green>
		<blue>CHAR_MIN</blue>  - The minimum value for an object of type char <br></br><br></br>	
		<blue>CHAR_MAX</blue>  - Maximum value for an object of type char <br></br><br></br>		
		<blue>SCHAR_MIN</blue>  - The minimum value for an object of type Signed char <br></br><br></br>	
		<blue>SCHAR_MAX</blue>  - Maximum value for an object of type Signed char <br></br><br></br>		
		<blue>UCHAR_MAX</blue>  - Maximum value for an object of type Unsigned char <br></br><br></br>		
		<blue>CHAR_BIT</blue>  - Number of bits in a char object <br></br><br></br>		
		<blue>MB_LEN_MAX</blue>  - Maximum number of bytes in a multi-byte character <br></br><br></br>		
		<blue>SHRT_MIN</blue>  - The minimum value for an object of type short int <br></br><br></br>		
		<blue>SHRT_MAX</blue>  - Maximum value for an object of type short int <br></br><br></br>		
		<blue>USHRT_MAX</blue>  - Maximum value for an object of type Unsigned short int <br></br><br></br>		
		<blue>INT_MIN</blue>  - The minimum value for an object of type int <br></br><br></br>		
		<blue>INT_MAX</blue>  - Maximum value for an object of type int <br></br><br></br>		
		<blue>UINT_MAX</blue>  - Maximum value for an object of type Unsigned int <br></br><br></br>	
		<blue>LONG_MIN</blue>  - The minimum value for an object of type long int <br></br><br></br>		
		<blue>LONG_MAX</blue>  - Maximum value for an object of type long int <br></br><br></br>		
		<blue>ULONG_MAX</blue>  - Maximum value for an object of type Unsigned long int <br></br><br></br>		
		<blue>LLONG_MIN</blue>  - The minimum value for an object of type long long int <br></br><br></br>		
		<blue>LLONG_MAX</blue>  - Maximum value for an object of type long long int <br></br><br></br>	
		<blue>ULLONG_MAX</blue> - Maximum value for an object of type Unsigned long long int		
		</green>
<code>

/*An example of defining a C++ macro:*/

using namespace std;
 
// Here is the definition of macro.
#define AREA(l, b) (l * b)

int main() {
    // The given lengths are l1 and l2.
    int l1 = 20, l2 = 2, area;
 
    // Here, finding the area using macro.
    area = AREA(l1, l2);
 
    return 0;
}

</code>
		</macros>
		<random-generators>
		Same as presented in C Language:
		<br></br><br></br>
		<code>rand()</code> function is an inbuilt function in C++ STL, which is defined in 
		header file <code>&lt;cstdlib&gt;</code>. <code>rand()</code> is used to generate a 
		series of random numbers. <br></br>
		The random number is generated by using an algorithm that gives a series of 
		non-related numbers whenever this function is called. <br></br>
		The <code>rand()</code> function is 
		used in C++ to generate random numbers in the range <code>[0, RAND_MAX)</code>.
		<br></br><br></br>
		<red>Syntax of rand()</red>:
<code>

int rand(void);

</code>
		<red>Parameters of rand():</red><br></br>
		This function does not take any parameters.<br></br><br></br>
		<red>Return Value of rand():</red><br></br>
		rand() returns a pseudo-random number in the range of [0, RAND_MAX).<br></br>
		</random-generators>
		<command-line-arguments>Same as presented in C Language.</command-line-arguments>
		<ternary-operator>Same as presented in C Language.</ternary-operator>
		<modular-programming>Same as presented in C Language.</modular-programming>
		<string-methods>
		The <code>std::string</code> is a class in C++ since C++98. This class is the standard 
		representation for a text string. It includes some typical string operations 
		like find, replace, concatenate, compare etc. It is present in &lt;string&gt; 
		header file. <br></br><br></br>
		Commonly Used String Functions in C++:<br></br>
		<br></br>
		<blue>length() or size()</blue><br></br>
		It will return the length of the string.<br></br>
		<br></br>
		<blue>array[index]</blue><br></br>
		To access individual characters using array indexing.<br></br>
		<br></br>
		<blue>at()</blue><br></br>
		Used to access a character at a specified index.<br></br>
		<br></br>
		<blue>+ Operator</blue><br></br>
		<code>+</code> operator is used to concatenate two strings.<br></br>
		<br></br>
		<blue>append()</blue><br></br>
		The <code>append()</code> function adds one string to the end of another.<br></br>
		<br></br>
		<blue>== Operator</blue><br></br>
		You can compare strings using the <code>==</code> operator.<br></br>
		<br></br>
		<blue>compare()</blue><br></br>
		The <code>compare()</code> function returns an integer value indicating the 
		comparison result.<br></br>
		<br></br>
		<blue>substr()</blue><br></br>
		Use the substr() function to extract a substring from a string.<br></br>
		<br></br>
		<blue>find()</blue><br></br>
		The find() function returns the position of the first occurrence of a substring.<br></br>
		<br></br>
		<blue>replace()</blue><br></br>
		Use the replace() function to modify a part of the string.<br></br>
		<br></br>
		<blue>insert()</blue><br></br>
		The insert() function adds a substring at a specified position.<br></br>
		<br></br>
		<blue>erase()</blue><br></br>
		Use the erase() function to remove a part of the string.<br></br>
		<br></br>
		<blue>c_str()</blue><br></br>
		To obtain a C-style string from a <code>std::string</code>, you can use the 
		<code>c_str()</code> function.<br></br>
		
		</string-methods>
		<datatype-conversions>
		Same as presented in C Language.
		<br></br><br></br>
		Type conversion in C++ is of two types - implicit and explicit. Implicit type 
		conversion is done automatically by the compiler, while explicit type conversion 
		is done manually by the programmer.<br></br>
		</datatype-conversions>
		<optional-parameters>
		A parameter with a default value, is often known as an "optional parameter".
		<br></br><br></br> 
		For more information see the <blue>default-parameters</blue> section.
		</optional-parameters>
		<decorators>
		Decorator is a structural pattern that allows adding new behaviors to objects 
		dynamically by placing them inside special wrapper objects, called decorators. 
		<br></br>
		Using decorators you can wrap objects countless number of times since both target 
		objects and decorators follow the same interface.<br></br>
<code>

/*Example*/

#include &lt;iostream&gt; 
using namespace std;

class Computer
{
public:
    virtual void display()
    {
        cout &lt;&lt; "I am a computer..." &lt;&lt; endl;
    }
};

class CDDrive : public Computer
{
private:
    Computer* c;
public:
    CDDrive(Computer* _c)
    {
        c = _c;
    }
    void display()
    {
        c-&gt;display();
        cout &lt;&lt; "with a CD Drive..." &lt;&lt; endl;
    }
};

class Printer : public Computer
{
private:
    CDDrive* d;
public:
    Printer(CDDrive* _d)
    {
        d = _d;
    }
    void display()
    {
        d-&gt;display();
        cout &lt;&lt; "with a printer..." &lt;&lt; endl;
    }
};

int main()
{
    Computer* c = new Computer();
    CDDrive* d = new CDDrive(c);
    Printer* p = new Printer(d);

    p-&gt;display();
}

</code>
		</decorators>
		<operators>Same as presented in C Language.</operators>
		<pre-post-incrementation>Same as presented in C Language.</pre-post-incrementation>
	</programming_language>
	
	<programming_language>
		<name>C#</name>
		<description>
			C# is a general-purpose high-level programming language supporting multiple 
			paradigms. C# encompasses static typing, strong typing, lexically scoped, 
			imperative, declarative, functional, generic, object-oriented (class-based), 
			and component-oriented programming disciplines. <br></br><br></br>

			The C# programming language was designed by Anders Hejlsberg from Microsoft in 
			2000. <br></br><br></br>

			Microsoft introduced C# along with .NET Framework and Visual Studio, both of 
			which were closed-source. At the time, Microsoft had no open-source products. 
			<br></br><br></br>

			Four years later, in 2004, a free and open-source project called Mono began, 
			providing a cross-platform compiler and runtime environment for the C# 
			programming language. <br></br><br></br>

			A decade later, Microsoft released Visual Studio Code (code editor), 
			Roslyn (compiler), and the unified .NET platform (software framework), 
			all of which support C# and are free, open-source, and cross-platform. 
			Mono also joined Microsoft but was not merged into .NET.<br></br><br></br>
		</description>
		<oop>No information present in the database.</oop>
		<encapsulation>No information present in the database.</encapsulation>
		<polymorphism>No information present in the database.</polymorphism>
		<inheritance>No information present in the database.</inheritance>
		<abstraction>No information present in the database.</abstraction>
		<generic-programming>No information present in the database.</generic-programming>
		<variable-arguments-lists>No information present in the database.</variable-arguments-lists>
		<simple-data-types>No information present in the database.</simple-data-types>
		<complex-data-types>No information present in the database.</complex-data-types>
		<loops>No information present in the database.</loops>
		<collections>No information present in the database.</collections>
		<collection-methods>No information present in the database.</collection-methods>
		<dynamic-memory-allocation>
		In C#, objects are dynamically allocated on the heap using the new keyword.
		<br></br><br></br>
		When an object is no longer needed, it is the responsibility of the garbage 
		collector to deallocate the memory and reclaim it for future use.
		</dynamic-memory-allocation>
		<read-from-file>No information present in the database.</read-from-file>
		<write-to-file>No information present in the database.</write-to-file>
		<serialization>No information present in the database.</serialization>
		<deserialization>No information present in the database.</deserialization>
		<constructors>No information present in the database.</constructors>
		<instantiation>No information present in the database.</instantiation>
		<destructors>No information present in the database.</destructors>
		<function-overloading>No information present in the database.</function-overloading>
		<operator-overloading>No information present in the database.</operator-overloading>
		<enums>No information present in the database.</enums>
		<multi-threading>No information present in the database.</multi-threading>
		<namespaces>No information present in the database.</namespaces>
		<exception-handling>No information present in the database.</exception-handling>
		<bitwise-operators>No information present in the database.</bitwise-operators>
		<default-parameters>No information present in the database.</default-parameters>
		<interfaces>No information present in the database.</interfaces>
		<random-generators>No information present in the database.</random-generators>
		<command-line-arguments>No information present in the database.</command-line-arguments>
		<ternary-operator>No information present in the database.</ternary-operator>
		<modular-programming>No information present in the database.</modular-programming>
		<string-methods>No information present in the database.</string-methods>
		<datatype-conversions>No information present in the database.</datatype-conversions>
		<optional-parameters>No information present in the database.</optional-parameters>
		<partial-classes>No information present in the database.</partial-classes>
		<decorators>No information present in the database.</decorators>
		<operators>No information present in the database.</operators>
		<pre-post-incrementation>No information present in the database.</pre-post-incrementation>
	</programming_language>
	
	<programming_language>
		<name>JavaScript</name>
		<description>
			JavaScript often abbreviated as JS, is a programming language and core 
			technology of the Web, alongside HTML and CSS. 99% of websites use JavaScript 
			on the client side for webpage behavior.<br></br><br></br>

			Web browsers have a dedicated JavaScript engine that executes the client code. 
			These engines are also utilized in some servers and a variety of apps. The most 
			popular runtime system for non-browser usage is Node.js.<br></br><br></br>

			JavaScript is a high-level, often just-in-time compiled language that conforms 
			to the ECMAScript standard. It has dynamic typing, prototype-based 
			object-orientation, and first-class functions. It is multi-paradigm, 
			supporting event-driven, functional, and imperative programming styles. 
			It has application programming interfaces (APIs) for working with text, dates, 
			regular expressions, standard data structures, and the Document Object Model (DOM).
		</description>
		<oop>No information present in the database.</oop>
		<encapsulation>No information present in the database.</encapsulation>
		<polymorphism>No information present in the database.</polymorphism>
		<inheritance>No information present in the database.</inheritance>
		<abstraction>No information present in the database.</abstraction>
		<generic-programming>No information present in the database.</generic-programming>
		<variable-arguments-lists>No information present in the database.</variable-arguments-lists>
		<simple-data-types>No information present in the database.</simple-data-types>
		<complex-data-types>No information present in the database.</complex-data-types>
		<loops>No information present in the database.</loops>
		<collections>No information present in the database.</collections>
		<collection-methods>No information present in the database.</collection-methods>
		<read-from-file>No information present in the database.</read-from-file>
		<write-to-file>No information present in the database.</write-to-file>
		<serialization>No information present in the database.</serialization>
		<deserialization>No information present in the database.</deserialization>
		<constructors>No information present in the database.</constructors>
		<instantiation>No information present in the database.</instantiation>
		<destructors>No information present in the database.</destructors>
		<function-overloading>No information present in the database.</function-overloading>
		<operator-overloading>No information present in the database.</operator-overloading>
		<enums>No information present in the database.</enums>
		<multi-threading>No information present in the database.</multi-threading>
		<namespaces>No information present in the database.</namespaces>
		<exception-handling>No information present in the database.</exception-handling>
		<bitwise-operators>No information present in the database.</bitwise-operators>
		<default-parameters>No information present in the database.</default-parameters>
		<interfaces>No information present in the database.</interfaces>
		<random-generators>No information present in the database.</random-generators>
		<ternary-operator>No information present in the database.</ternary-operator>
		<modular-programming>No information present in the database.</modular-programming>
		<string-methods>No information present in the database.</string-methods>
		<datatype-conversions>No information present in the database.</datatype-conversions>
		<partial-classes>No information present in the database.</partial-classes>
		<decorators>No information present in the database.</decorators>
		<operators>No information present in the database.</operators>
		<pre-post-incrementation>No information present in the database.</pre-post-incrementation>
	</programming_language>
	
	<programming_language>
		<name>Java</name>
		<description>
			Java is a high-level, class-based, object-oriented programming language that is 
			designed to have as few implementation dependencies as possible.<br></br><br></br>
			It is a general-purpose programming language intended to let programmers write once, 
			run anywhere meaning that compiled Java code can run on all platforms that support 
			Java without the need to recompile. <br></br><br></br>
			
			Java applications are typically compiled to bytecode that can run on any 
			Java virtual machine (JVM) regardless of the 
			underlying computer architecture. The syntax of Java is similar to C and C++, 
			but has fewer low-level facilities than either of them. The Java runtime provides 
			dynamic capabilities (such as reflection and runtime code modification) that are 
			typically not available in traditional compiled languages.
		</description>
		<oop>No information present in the database.</oop>
		<encapsulation>No information present in the database.</encapsulation>
		<polymorphism>No information present in the database.</polymorphism>
		<inheritance>No information present in the database.</inheritance>
		<abstraction>No information present in the database.</abstraction>
		<generic-programming>No information present in the database.</generic-programming>
		<variable-arguments-lists>No information present in the database.</variable-arguments-lists>
		<simple-data-types>No information present in the database.</simple-data-types>
		<complex-data-types>No information present in the database.</complex-data-types>
		<loops>No information present in the database.</loops>
		<collections>No information present in the database.</collections>
		<collection-methods>No information present in the database.</collection-methods>
		<dynamic-memory-allocation>
		Heap space is used for the dynamic memory allocation of Java objects and JRE classes 
		at runtime. <br></br>
		New objects are always created in heap space, and the references to these objects 
		are stored in stack memory. <br></br>
		These objects have global access and we can access them from anywhere in the 
		application.<br></br>
		</dynamic-memory-allocation>
		<read-from-file>No information present in the database.</read-from-file>
		<write-to-file>No information present in the database.</write-to-file>
		<serialization>No information present in the database.</serialization>
		<deserialization>No information present in the database.</deserialization>
		<constructors>No information present in the database.</constructors>
		<instantiation>No information present in the database.</instantiation>
		<destructors>No information present in the database.</destructors>
		<function-overloading>No information present in the database.</function-overloading>
		<operator-overloading>No information present in the database.</operator-overloading>
		<enums>No information present in the database.</enums>
		<multi-threading>No information present in the database.</multi-threading>
		<namespaces>No information present in the database.</namespaces>
		<exception-handling>No information present in the database.</exception-handling>
		<bitwise-operators>No information present in the database.</bitwise-operators>
		<default-parameters>No information present in the database.</default-parameters>
		<interfaces>No information present in the database.</interfaces>
		<random-generators>No information present in the database.</random-generators>
		<command-line-arguments>No information present in the database.</command-line-arguments>
		<ternary-operator>No information present in the database.</ternary-operator>
		<modular-programming>No information present in the database.</modular-programming>
		<string-methods>No information present in the database.</string-methods>
		<datatype-conversions>No information present in the database.</datatype-conversions>
		<partial-classes>No information present in the database.</partial-classes>
		<decorators>No information present in the database.</decorators>
		<operators>No information present in the database.</operators>
		<pre-post-incrementation>No information present in the database.</pre-post-incrementation>
	</programming_language>
	
	<programming_language>
		<name>Python</name>
		<description>
			Python is a high-level, general-purpose programming language. Its design 
			philosophy emphasizes code readability with the use of significant indentation.
			<br></br><br></br>

			Python is dynamically typed and garbage-collected. It supports multiple 
			programming paradigms, including structured (particularly procedural), 
			object-oriented and functional programming. It is often described as a 
			"batteries included" language due to its comprehensive standard library.
		
		</description>
		<oop>No information present in the database.</oop>
		<encapsulation>No information present in the database.</encapsulation>
		<polymorphism>No information present in the database.</polymorphism>
		<inheritance>No information present in the database.</inheritance>
		<abstraction>No information present in the database.</abstraction>
		<generic-programming>No information present in the database.</generic-programming>
		<variable-arguments-lists>No information present in the database.</variable-arguments-lists>
		<simple-data-types>No information present in the database.</simple-data-types>
		<complex-data-types>No information present in the database.</complex-data-types>
		<loops>No information present in the database.</loops>
		<collections>No information present in the database.</collections>
		<collection-methods>No information present in the database.</collection-methods>
		<dynamic-memory-allocation>
		Memory is allocated to the objects at the run time. <br></br>
		We use the Heap for implement dynamic memory management. <br></br>
		We can use the memory throughout the program. <br></br><br></br>
		As we know, everything in Python is an object means dynamic memory 
		allocation inspires the Python memory management.<br></br>
		</dynamic-memory-allocation>
		<read-from-file>No information present in the database.</read-from-file>
		<write-to-file>No information present in the database.</write-to-file>
		<serialization>No information present in the database.</serialization>
		<deserialization>No information present in the database.</deserialization>
		<constructors>No information present in the database.</constructors>
		<instantiation>No information present in the database.</instantiation>
		<destructors>No information present in the database.</destructors>
		<function-overloading>No information present in the database.</function-overloading>
		<operator-overloading>No information present in the database.</operator-overloading>
		<enums>No information present in the database.</enums>
		<multi-threading>No information present in the database.</multi-threading>
		<namespaces>No information present in the database.</namespaces>
		<exception-handling>No information present in the database.</exception-handling>
		<bitwise-operators>No information present in the database.</bitwise-operators>
		<default-parameters>No information present in the database.</default-parameters>
		<interfaces>No information present in the database.</interfaces>
		<random-generators>No information present in the database.</random-generators>
		<command-line-arguments>No information present in the database.</command-line-arguments>
		<ternary-operator>No information present in the database.</ternary-operator>
		<modular-programming>No information present in the database.</modular-programming>
		<string-methods>No information present in the database.</string-methods>
		<datatype-conversions>No information present in the database.</datatype-conversions>
		<partial-classes>No information present in the database.</partial-classes>
		<decorators>No information present in the database.</decorators>
		<operators>No information present in the database.</operators>
		<pre-post-incrementation>No information present in the database.</pre-post-incrementation>
	</programming_language>
	
</content>
