<?xml version="1.0" encoding="UTF-8"?>

<content>
	<programming_language>
		<name>C</name>
		<description>
			C is a general-purpose computer programming language.<br></br><br></br>
			It was created in the 1970s by Dennis Ritchie, and remains very widely used and 
			influential. <br></br><br></br>
			By design, C's features cleanly reflect the 
			capabilities of the targeted CPUs. It has found lasting use in operating 
			systems, device drivers, and protocol stacks, but its use in application 
			software has been decreasing. <br></br><br></br>
			C is commonly used on computer architectures that range from the largest 
			supercomputers to the smallest microcontrollers 
			and embedded systems.
		</description>
		<generic-programming>
			In C Language generic programming can be achieved using:<br></br><br></br>
			Variable argument lists;<br></br>
			Using <code>void *</code> and function pointers to write generic code;<br></br>
			Using libraries to reuse code without copying and recompiling;<br></br>
			Using plugins to get run-time overriding and more;
		</generic-programming>
		<variable-arguments-lists>
			C allows a function call to have a variable number of
			arguments with the variable argument list mechanism.<br></br>
			Use ellipsis <code>...</code> to denote a variable number of arguments to
			the compiler. the ellipsis can only occur at the end of an
			argument list.<br></br><br></br>
			Here are some standard function calls that use variable
			argument lists:<br></br><br></br>
			<code>int printf(const char *format, ...);</code><br></br>
			<code>int scanf(const char *format, ...);</code><br></br>
			<code>int execlp(const char *file, const char *arg, ...);</code><br></br>
		</variable-arguments-lists>
		<simple-data-types>
			<code>short int</code> - has value range <red>[-32,768 to 32,767]</red> - format specifier <code>%hd</code> - 
			occupies 2 bytes memory
			<br></br><br></br>
			<code>unsigned short int</code> - has value range <red>[-32,768 to 65,535]</red> - format specifier <code>%hu</code> - 
			occupies 2 bytes memory
			<br></br><br></br>
			<code>unsigned int</code> - has value range <red>[0 to 4,294,967,295]</red> - format specifier <code>%u</code> - 
			occupies 4 bytes memory
			<br></br><br></br>
			<code>int</code> - has value range <red>[-2,147,483,648 to 2,147,483,647]</red> - format specifier <code>%d</code> - 
			occupies 4 bytes memory
			<br></br><br></br>
			<code>long int</code> - has value range <red>[-2,147,483,648 to 2,147,483,647]</red> - 
			format specifier <code>%ld</code> - occupies 4 bytes memory
			<br></br><br></br>
			<code>unsigned long int</code> - has value range <red>[0 to 4,294,967,295 ]</red> - format specifier <code>%lu</code> -
			occupies 4 bytes memory
			<br></br><br></br>
			<code>long long int</code> - has value range <red>[-(2^63) to (2^63)-1]</red> - format specifier <code>%lld</code> - 
			occupies 8 bytes memory
			<br></br><br></br>
			<code>unsigned long long int</code> - has value range <red>[-(2^63) to 18,446,744,073,709,551,615 ]</red> - 
			format specifier <code>%llu</code>  - occupies 8 bytes memory
			<br></br><br></br>
			<code>signed char</code> - has value range <red>[-128 to 127]</red> - format specifier <code>%c</code> - occupies 1 
			byte memory
			<br></br><br></br>
			<code>unsigned char</code> - has value range <red>[0 to 255]</red> - format specifier <code>%c</code> - occupies 1 
			byte memory
			<br></br><br></br>
			<code>float</code> - has value range <red>[1.2E-38 to 3.4E+38]</red> - format specifier <code>%f</code> - occupies 
			4 byte memory
			<br></br><br></br>
			<code>double</code> - has value range <red>[1.7E-308 to 1.7E+308]</red> - format specifier <code>%lf</code> - 
			occupies 8 byte memory
			<br></br><br></br>
			<code>long double</code> - has value range <red>[3.4E-4932 to 1.1E+4932]</red> - format specifier <code>%Lf</code>  - 
			occupies 16 byte memory
		</simple-data-types>
		<complex-data-types>
			Data types that are derived from fundamental data types:<br></br><br></br>
			<code>bool type</code><br></br><br></br>
			<code>Enumerated type / Enums</code> - An enum is a special type that represents a group of constants (unchangeable values).<br></br><br></br>
			<code>Complex types</code> - The C programming language, as of C99, supports complex number math with the three built-in types 
			<code>double _Complex</code>, <code>float _Complex</code>, and <code>long double _Complex</code> . When the header <code>complex.h</code> is 
			included, the three complex number types are also accessible as double complex, 
			float complex, long double complex.<br></br><br></br>
			<code>Arrays</code>: A collection of elements of the same data type. Array in C can be defined as a method of 
			clubbing multiple entities of similar type into a larger group. These entities or elements 
			can be of int, float, char, or double data type or can be of user-defined data types too 
			like structures.<br></br><br></br>
			<code>Pointers</code>: A variable that stores the memory address of another variable. The size of a pointer in C 
			programming language varies depending on factors such as the operating system and CPU 
			architecture. Typically, on a 32-bit computer system, the size of pointer is 4 bytes, 
			while on a 64-bit computer system, it is 8 bytes.<br></br><br></br>
			<code>Structures</code>: A collection of variables of different data types grouped 
			together under a single name. <br></br><br></br>
			<code>Unions</code>: A special type of structure that can store only one value at a time.<br></br><br></br>
			<code>Typedefs</code>: A way to create a new name for an existing data type to improve code 
			readability and maintainability.<br></br><br></br>
			<code>void</code> - used to indicate an empty data type, usually used with pointers.<br></br>
		</complex-data-types>
		<loops>
			In computer programming, a loop is a sequence of instruction s that is 
			continually repeated until a certain condition is reached. 
			Typically, a certain process is done, such as getting an item of data 
			and changing it, and then some condition is checked such as whether a 
			counter has reached a prescribed number.<br></br><br></br>
			<br></br><br></br>
			For, while, do-while loops:<br></br><br></br>
			
			<red>While loop does not depend upon the number of iterations. In for loop the number 
			of iterations was previously known to us but in the While loop, the execution 
			is terminated on the basis of the test condition. If the test condition will 
			become false then it will break from the while loop else body will be executed.<br></br><br></br>
			<br></br><br></br></red>	
			
			<green>In for loop, a loop variable is used to control the loop. Firstly we initialize 
			the loop variable with some value, then check its test condition. If the 
			statement is true then control will move to the body and the body of for 
			loop will be executed. Steps will be repeated till the exit condition 
			becomes true. If the test condition will be false then it will stop.
			<br></br><br></br>
			
			Initialization Expression: In this expression, we assign a loop variable 
			or loop counter to some value. for example: <code>int i=1;</code>
			Test Expression: In this expression, test conditions are performed. 
			If the condition evaluates to true then the loop body will be executed and 
			then an update of the loop variable is done. If the test expression becomes 
			false then the control will exit from the loop. for example, <code>counter&lt;5;</code>
			<br></br><br></br>
			
			Update Expression: After execution of the loop body loop variable is updated 
			by some value it could be incremented, decremented, multiplied, or divided by 
			any value.<br></br><br></br></green>
			
			<blue><br></br><br></br>			
			The do-while loop is similar to a while loop but the only difference 
			lies in the do-while loop test condition which is tested at the end of 
			the body. In the do-while loop, the loop body will execute at least once 
			irrespective of the test condition.<br></br><br></br></blue>
<code>
/*While loop syntax: */
int counter = 0;
while(counter &lt; 5)
{
	/*code goes here*/
	 counter++;
}

/*For loop syntax: */
for(int counter = 0; counter &lt; 5; counter++)<br></br>
{
	/*code goes here*/
	 counter++;
}

/*Do while loop syntax: */
do
{
	/*code goes here*/
	 counter++;
}
while(counter &lt; 5)
</code>
		</loops>
		<collections>
			<code>Arrays</code>: Are collections of elements of the same data type with fixed size. 
			Once the array is defined its size cannot be changed.<br></br><br></br>
			
			The <code>linked list</code> is a complex data type, which consists of a structure with at least 2 elements: value and pointer
			to the next element. Memory will be allocated dynamically for each element added to the list. The main benefit of a linked-list
			consists in the possibility of adding a variable number of elements, being able to delete or add an element without making copies
			or exchanges, but only by changing the addresses of the assigned pointers for the next / previous element.
			<br></br><br></br>
			
<code>
/*Declaring arrays and initializing arrays*/

int arr[5];
int array_initialized[7] = [1,2,3,4,5,6,7];
float array_floats[3] = [2.0f, 3.0f, 2.11f];

/*---------------------------------------------*/

//Declaring and initializing a Linked List

//Linked list definition:
struct LinkedList{
	int value; // this will store the value
	struct LinkedList * previous; // this will store the address of the previous block of memory
	struct LinkedList * next; // this will store the address of the next block of memory
};

struct LinkedList* list = NULL; // creating a linked list

int counter = 0;
while(counter &lt; 10)
{
	if(list == NULL) // if this is the first element to be introduced on the linked list
	{
		list = (struct LinkedList* )malloc(sizeof(struct LinkedList)); // allocate memory.
		list->value = counter; // add value
		list->previous = NULL; // there is no previous element.
		list->next = NULL; // we don't know if there will be a next element.
	}

	else //enter here after the first element was added.
	{

		list->next = (struct LinkedList* ) malloc(sizeof(struct LinkedList)); // allocate space for the next element
		list->next->previous = list; // we're still on the previous element, so assign the link to the next element.previous
		list = list->next; // next element become current element
		list->value = counter; // add value
		list->next = NULL;  // we don't know if there will be a next element.
	}
	counter++;
}

//printing the linked list
while(list != NULL) // list is currently pointing to the last element. So we will display it from last to first.
{
	printf("%d ", list->value);
	list = list->previous; // go to the previous
}

</code>
		</collections>
		<collection-methods>There are no built in functions for working with collections.</collection-methods>
		<dynamic-memory-allocation>
		Dynamic memory is allocated from the heap using some standard library functions. 
		The two dynamic memory key functions are malloc() and free(). 
		The malloc() function takes a single parameter, which is the size of the requested memory 
		area in bytes. It returns a pointer to the allocated memory.
		
		C malloc() method<br></br><br></br>
		The “malloc” or “memory allocation” method in C is used to dynamically allocate a single 
		large block of memory with the specified size. It returns a pointer of type void which 
		can be cast into a pointer of any form. It doesn’t Initialize memory at execution time 
		so that it has initialized each block with the default garbage value initially. <br></br><br></br>
<code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;conio.h&gt;

int main()
{
	int *A;
	int i;
	
	/*
	Prototype: void *malloc(size_t size);
	*/

	A=(int *)malloc(20*sizeof(int)); // malloc return a void pointer that needs to be converted
	//into a pointer to however the type of the variable that uses it has. (int *) - is the type of pointer A
	//20 = the number of memory cells allocated;
	
	for (i=0;i&lt;20;i++)
		printf("A[%d]=%d\n", i, A[i]); //the value in each memory cell can be anything
	free(A);
}

</code>
			Calloc function allocates the requested memory and returns a pointer to it similarly to malloc. 
			The Malloc () and calloc() functions differ in how the functions are used when allocating 
			memory at runtime. The Malloc () function only returns the starting address, it doesn't 
			zero it. On the other hand, the calloc() function returns the starting address, zeroing it.
<code>

/*Prototype void *calloc(size_t nitems, size_t size)*/

A=(int *)calloc(20, sizeof(int)); //calloc does the same as malloc while initializing all elements to 0:
	
for (i=0;i&lt;20;i++)
	printf("A[%d]=%d\n", i ,A[i]); //the value in each memory cell is 0
	
free(A); //free is used to free the allocated memory. There is no delete() in C language.
	
</code>
		
		</dynamic-memory-allocation>
		<read-from-file>
		C programming language supports four pre-defined functions to read contents from a file, defined in stdio.h header file:
		<br></br><br></br>
		fgetc()– This function is used to read a single character from the file.<br></br>
		fgets()– This function is used to read strings from files.<br></br>
		fscanf()– This function is used to read formatted input from a file.<br></br>
		fread()– This function is used to read the block of raw bytes from files. This is used 
		to read binary files.
		<br></br><br></br>
		To open a file use: fopen(filename, mode);
		<br></br><br></br>
		Where:<br></br><br></br>
		filename	The name of the actual file you want to open (or create), like filename.txt<br></br>
		mode	A single character, which represents what you want to do with the file 
		(read, write or append):<br></br><br></br>
		w - Writes to a file<br></br>
		a - Appends new data to a file<br></br>
		r - Reads from a file<br></br>
	
<code>

/*Read file char by char*/

FILE* ptr; FILE is basically a data type, and we need to create a pointer variable to work with it 
char ch;

// Opening file in reading mode
ptr = fopen("test.txt", "r");

if (NULL == ptr) {
	printf("file can't be opened \n");
}

printf("content of this file are \n");

// Printing what is written in file
// character by character using loop.
do {
	ch = fgetc(ptr);
	printf("%c", ch);

	// Checking if character is not EOF.
	// If it is EOF stop reading.
} while (ch != EOF); 


//---------------------------------

/*

Alternatively feof function can be used
feof() function takes file pointer as argument and returns true if pointer reaches the end of the file. 

while (!feof(ptr)) {
	ch = fgetc(ptr);
	printf("%c", ch);
}

*/
//---------------------------------

//Reading whole content of the file as string

//fgets() reads one string at a time from the file. fgets() returns a string if it is
//successfully read by function or returns NULL if can not read. 

//Prototype: char * fgets(char *str, int size, FILE * ptr);

while (fgets(str, 50, ptr) != NULL) {
	printf("%s", str);
}

//---------------------------------


/*
fscanf() reads formatted input from a stream.

Approach:

fscanf reads formatted data from the files and stores it in variables.
The data in the buffer is printed on the console till the end of the file is reached.

*/

char buf[100];
while (fscanf(ptr, "%*s %*s %s ", buf) == 1)
	printf("%s\n", buf);

</code>
		
		</read-from-file>
		<write-to-file>
		To create a file, or write to a file you can use the w mode inside the fopen() function.<br></br>
		Function Prototype: fopen(filename, mode);
		<br></br><br></br>
		Where:<br></br><br></br>
		filename	The name of the actual file you want to open (or create), like filename.txt<br></br>
		mode	A single character, which represents what you want to do with the file 
		(read, write or append):<br></br><br></br>
		w - Writes to a file<br></br>
		a - Appends new data to a file<br></br>
		r - Reads from a file<br></br><br></br>
		
		The w mode means that the file is opened for writing. To insert content to it, you can 
		use the fprintf() function and add the pointer variable (fptr in our example) and some text:
		<br></br><br></br>
		If you write to a file that already exists, the old content is deleted, and the new content 
		is inserted. This is important to know, as you might accidentally erase existing content.
<code>

FILE *fptr; //FILE is basically a data type, and we need to create a pointer variable to work with it 

// Open a file in writing mode
fptr = fopen("filename.txt", "w");

// Write some text to the file using fprintf
fprintf(fptr, "Some text");

// Write some other text to the file fputs
fputs("Line wrote with fputs.", fp); 

// Close the file
fclose(fptr); // this will close the file when we are done with it.

</code>		
		Closing the file:
		<br></br><br></br>
		It is considered as good practice, because it makes sure that:
		<br></br><br></br>
		Changes are saved properly. <br></br>
		Other programs can use the file (if you want). <br></br>
		Clean up unnecessary memory space. <br></br><br></br>
		
		If you want to add content to a file without deleting the old content, 
		you can use the a mode. <br></br>
		The a mode appends content at the end of the file:<br></br>
		
<code>
/*Example*/

FILE *fptr;

// Open a file in append mode
fptr = fopen("filename.txt", "a"); 

/*Just like with the w mode; if the file does not exist, the a mode will create a 
new file with the "appended" content.*/

// Append some text to the file
fprintf(fptr, "\nHi everybody!");

// Close the file
fclose(fptr);

</code>
		</write-to-file>
		<serialization>
		Serialization is the process of converting a data object—a combination of code and data 
		represented within a region of data storage—into a series of bytes that saves the state 
		of the object in an easily transmittable form.<br></br><br></br>
		</serialization>
		<deserialization>
		Deserialization is the process of reconstructing a data structure or object from a series 
		of bytes or a string in order to instantiate the object for consumption. This is the 
		reverse process of serialization, i.e., converting a data structure or object into a 
		series of bytes for storage or transmission across devices.<br></br><br></br>
		</deserialization>
		<enums>
		Enumeration (or enum) is a user defined data type in C. It is mainly used to 
		assign names to integral constants, the names make a program easy to read and maintain.
		<br></br><br></br>
		
<code>
/*Examples*/
//Syntax: enum flag{constant1, constant2, constant3, ....... };

// An example program to demonstrate working
// of enum in C
#include &lt;stdio.h&gt;
 
enum week{Mon, Tue, Wed, Thur, Fri, Sat, Sun};
 
int main()
{
    enum week day;
    day = Wed;
    printf("%d",day);
    return 0;
} 

</code>
		</enums>
		<multi-threading>
		A thread is a single sequence stream within a process. Because threads have some of 
		the properties of processes, they are sometimes called lightweight processes. 
		<br></br><br></br>
		Threads are not independent from each other unlike processes. As a result, 
		threads shares with other threads their code section, data section and OS resources 
		like open files and signals. But, like processes, a thread has its own program 
		counter (PC), a register set, and a stack space. 
		<br></br><br></br>
		Why Multithreading? Threads are popular way to improve application through parallelism. 
		For example, in a browser, multiple tabs can be different threads. MS word uses 
		multiple threads, one thread to format the text, other thread to process inputs, etc. 
		<br></br><br></br>
		Threads operate faster than processes due to following reasons: <br></br>
		1) Thread creation is much faster. <br></br>
		2) Context switching between threads is much faster. <br></br>
		3) Threads can be terminated easily <br></br>
		4) Communication between threads is faster.<br></br>
<code>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt; //Header file for sleep(). man 3 sleep for details. 
#include &lt;pthread.h&gt;
  
// A normal C function that is executed as a thread  
// when its name is specified in pthread_create() 

void *myThreadFun(void *vargp) 
{ 
    sleep(1); 
    printf("Printing GeeksQuiz from Thread \n"); 
    return NULL; 
} 
   
int main() 
{ 
    pthread_t thread_id; 
    printf("Before Thread\n"); 
    pthread_create(&#38;thread_id, NULL, myThreadFun, NULL); 
    pthread_join(thread_id, NULL); 
    printf("After Thread\n"); 
    exit(0); 
}

</code>
		</multi-threading>
		<exception-handling>C does not provide direct support to error handling (or exception handling).</exception-handling>
		<bitwise-operators>
		The &#38; (bitwise AND) in C takes two numbers as operands and does AND on every bit 
		of two numbers. The result of AND is 1 only if both bits are 1.  
		<br></br><br></br>
		The | (bitwise OR) in C takes two numbers as operands and does OR on every bit 
		of two numbers. The result of OR is 1 if any of the two bits is 1. 
		<br></br><br></br>
		The ^ (bitwise XOR) in C takes two numbers as operands and does XOR on every 
		bit of two numbers. The result of XOR is 1 if the two bits are different. 
		<br></br><br></br>
		The &lt;&lt; (left shift) in C takes two numbers, the left shifts the bits of the 
		first operand, and the second operand decides the number of places to shift. 
		<br></br><br></br>
		The &gt;&gt; (right shift) in C takes two numbers, right shifts the bits of the 
		first operand, and the second operand decides the number of places to shift.
		<br></br><br></br>
		The ~ (bitwise NOT) in C takes one number and inverts all bits of it.
		
<code>

// C Program to demonstrate use of bitwise operators
#include &lt;stdio.h&gt;
int main()
{
    // a = 5(00000101), b = 9(00001001)
    unsigned char a = 5, b = 9;
 
    // The result is 00000001
    printf("a = %d, b = %d\n", a, b);
    printf("a &#38; b = %d\n", a &#38; b);
 
    // The result is 00001101
    printf("a|b = %d\n", a | b);
 
    // The result is 00001100
    printf("a^b = %d\n", a ^ b);
 
    // The result is 11111010
    printf("~a = %d\n", a = ~a);
 
    // The result is 00010010
    printf("b&lt;&lt;1 = %d\n", b &lt;&lt; 1);
 
    // The result is 00000100
    printf("b&gt;&gt;1 = %d\n", b &gt;&gt; 1);
 
    return 0;
	
	/*
	OUTPUT: 
	
	a = 5, b = 9
	a&#38;b = 1
	a|b = 13
	a^b = 12
	~a = 250
	b&lt;&lt;1 = 18
	b&gt;&gt;1 = 4
	
	*/
}

</code>
		The left-shift and right-shift operators should not be used for negative numbers.<br></br>
		The left-shift and right-shift operators are equivalent to multiplication and division by 
		2 respectively.<br></br><br></br>
		
		The bitwise OR of two numbers is just the sum of those two numbers if there is no carry involved, otherwise, you just add their bitwise AND.
		<br></br><br></br>
		Let’s say, we have a=5(101) and b=2(010), since there is no carry involved, their sum is 
		just a|b. Now, if we change ‘a’ to 6 which is 110 in binary, their sum would change 
		to a|b + a&#38;b since there is a carry involved. 
		<br></br><br></br>
		The bitwise XOR operator is the most useful operator from a technical interview perspective.
		<br></br><br></br>
		It is used in many problems. A simple example could be “Given a set of numbers where all 
		elements occur an even number of times except one number, find the odd occurring number” 
		This problem can be efficiently solved by doing XOR to all numbers. 
		<br></br><br></br>
		
		The &#38; operator can be used to quickly check if a number is odd or even.<br></br>

		The value of the expression (x &#38; 1) would be non-zero only if x is odd, otherwise, 
		the value would be zero. <br></br><br></br>
		
		The ~ operator should be used carefully.
		<br></br><br></br>
		The result of the ~ operator on a small number can be a big number if the result 
		is stored in an unsigned variable. The result may be a negative number if the result 
		is stored in a signed variable (assuming that the negative numbers are stored in 2’s 
		complement form where the leftmost bit is the sign bit).<br></br>
		</bitwise-operators>
		<default-parameters>There are no default parameters in C. One way you can get by this is 
		to pass in NULL pointers and then set the values to the default if NULL is passed.</default-parameters>
		<interfaces>
		In C, an interface is a set of function declarations without any implementation 
		details. It defines a contract that concrete implementations must adhere to by providing 
		definitions for all the functions declared in the interface.
<code>

// Declare an interface for a shape
struct shape_interface {
  // Function pointers for the interface functions
  double (*area)(void*);
  double (*perimeter)(void*);
}; 

/*
In OOP there are classes that store to both variables and methods of an object.

In C we can have structs that store variables and structs that hold function pointers to defined behaviours
Both of them are close to forming a class.

*/

</code>
		</interfaces>
		<macros>
		Macros in C are powerful tools that allow developers to define reusable code snippets. 
		They are defined using preprocessor directives and primarily used for code substitution 
		and generation. Macros provide a convenient way to write concise and efficient code, 
		improving the readability and maintainability of C programs.<br></br>
<code>

// C program to illustrate macros
#include &lt;stdio.h&gt;
 
// Macro definition
#define AREA(l, b) (l * b)
 
// Driver Code
int main()
{
    // Given lengths l1 and l2
    int l1 = 10, l2 = 5, area;
 
    // Find the area using macros
    area = AREA(l1, l2);
 
    // Print the area
    printf("Area of rectangle"
           " is: %d",
           area);
 
    return 0;
}
</code>		
		<br></br><br></br>
		Object-Like Macros
		An object-like macro is a simple identifier that will be replaced by a code fragment. 
		It is called object-like because it looks like an object in code that uses it. It is 
		popularly used to replace a symbolic name with a numerical/variable represented 
		as a constant.<br></br>
<code>
//Chain Macros
  
// Macro definition
#define INSTAGRAM FOLLOWERS
#define FOLLOWERS 138 

/*
Both macros INSTAGRAM and FOLLOWERS have same value - 138
*/


Multi-line macros
#include &lt;stdio.h&gt;
 
// Multi-line Macro definition
#define ELE 1, \
            2, \
            3
 
// Driver Code
int main()
{
 
    // Array arr[] with elements
    // defined in macros
    int arr[] = { ELE };
 
    // Print elements
    printf("Elements of Array are:\n");
 
    for (int i = 0; i &lt; 3; i++) {
        printf("%d  ", arr[i]);
    }
    return 0;
}
  
</code>
		</macros>
		<defines>
		In C programming, #define is a preprocessor directive that is used to define macros. 
		The macros are the identifiers defined by #define which are replaced by their value before 
		compilation. We can define constants and functions like macros using #define.
		</defines>
		<random-generators>
		The rand() function returns the random integers whose range from 0 to RAND_MAX. 
		The RAND_MAX is a symbolic constant that defines in stdlib.h header file, whose value 
		is greater but less than 32767 depending on the C libraries.<br></br><br></br>
<code>
#include &lt;stdio.h&gt;    
#include &lt;conio.h&gt;  
#include &lt;stdlib.h&gt;  
void main()  
{     
    // use rand() function to generate the number  
    printf (" The random number is: %d", rand());  
    printf ("\n The random number is: %d", rand());  
      
    printf (" \n The random number is: %d", rand());  
    printf ("\n The random number is: %d", rand());  
    getch();  
}  		

</code>
		The srand() function is a C library function that determines the initial point to generate 
		different series of pseudo-random numbers. A srand() function cannot be used without 
		using a rand() function. The srand() function is required to set the value of the seed 
		only once in a program to generate the different results of random integers before 
		calling the rand() function. <br></br><br></br>
<code>
#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;time.h&gt;  // use time.h header file to use time  
      
int main()  
{  
    int num, i;  
    time_t t1; // declare time variable  
      
    printf(" Enter a number to set the limit for a random number \n");  
    scanf (" %d", &#38;num);  
      
    /* define the random number generator */  
    srand ( (unsigned) time (&#38;t1)); // pass the srand() parameter  
    printf("\n"); // print the space
    /* generate random number between 0 to 50 */  
}  
</code>
		</random-generators>
		<command-line-arguments>
		Command line arguments in C are passed to the main function 
		as argc and argv. Command line arguments are used to control the program from 
		the outside. argv[argc] is a Null pointer. The name of the program is 
		stored in argv[0], the first command-line parameter in argv[1], and the 
		last argument in argv[n]
<code>
/*Example*/
int main(int argc, char *argv[]) { /* ... */ }

//OR
int main(int argc, char **argv) { /* ... */ }
</code>
		argc (ARGument Count) is an integer variable that stores the number of command-line 
		arguments passed by the user including the name of the program. So if we pass a 
		value to a program, the value of argc would be 2 (one for argument and one for 
		program name). <br></br>
		The value of argc should be non-negative.<br></br>
		argv (ARGument Vector) is an array of character pointers listing all the arguments.
		If argc is greater than zero, the array elements from argv[0] to argv[argc-1] will 
		contain pointers to strings.<br></br>
		argv[0] is the name of the program , After that till argv[argc-1] every element 
		is command -line arguments.<br></br><br></br>
		
		Properties of Command Line Arguments in C<br></br>
		They are passed to the main() function.<br></br>
		They are parameters/arguments supplied to the program when it is invoked.<br></br>
		They are used to control programs from outside instead of hard coding those values 
		inside the code.<br></br>
		argv[argc] is a NULL pointer.<br></br>
		argv[0] holds the name of the program.<br></br>
		argv[1] points to the first command line argument and argv[argc-1] points to 
		the last argument.<br></br>
		</command-line-arguments>
		<ternary-operator>
		Ternary operator is used for decision making instead of placing longer if and else 
		conditional statements:
<code>
/*Using IF ELSE statements:*/

int a = 10, b = 20, c;

if (a &lt; b) 
{
    c = a;
}
else 
{
    c = b;
}

printf("%d", c);

/*=============================*/
/*Using TERNARY operator:*/

int a = 10, b = 20, c;

c = (a &lt; b) ? a : b;

printf("%d", c);

/*The output of both samples of code from above will result in: c = 3*/

</code>
		Syntax
		condition ? value_if_true : value_if_false

		The statement evaluates to value_if_true if condition is met, and value_if_false 
		otherwise.
		The ternary operator take three arguments:

		The first is a comparison argument
		The second is the result upon a true comparison
		The third is the result upon a false comparison
		</ternary-operator>
		<modular-programming>
		Modular programming consists of separating implementation from interface and 
		hiding information in the implementation. In C this is achieved by placing 
		the interface definition in a header file and the implementation in a source 
		file. Disciplined use of static is used to hide implementation details.
		<br></br><br></br>
		Advantages of modular programming:<br></br><br></br>

		Code is easier to read - Working on modular programming makes code easier to read 
		because functions perform different tasks as compared to monolithic codes. 
		Sometimes modular programming can be a bit messy if we pass arguments and 
		variables in different functions. The use of modules should be done in a 
		sensible manner so as to avoid any problem. Functions should be neat, clean, 
		and descriptive.<br></br><br></br>
		
		Code is easier to test - In software, some functions perform fewer tasks and 
		also functions that perform numerous tasks. If the software is easily split 
		using modules, it becomes easier to test. We can also focus on the riskier 
		functions during testing and need more test cases to make it bug-free.<br></br><br></br>
		
		Reusability - There are times where a piece of code is implemented everywhere in 
		our program. Instead of copying and pasting it, again and again, modularity 
		gives us the advantage of reusability so that we can pull our code from 
		anywhere using interfaces or libraries. The concept of reusability also 
		reduces the size of our program.<br></br><br></br>
		
		Faster fixes - Suppose there is an error in the payment options in any 
		application, and the bug needs to be removed. Modularity can be a great help 
		because we know that there will be a separate function that will contain the 
		code of payments, and only that function will only be rectified. Thus using 
		modules to find and fixing bugs becomes much more smooth and maintainable.<br></br><br></br>
		
		Low-risk update - In modular programming, a defined layer of APIs protects things that 
		use it from making changes inside the library. Unless there is a change in the API, 
		there is a low risk for someone's code-breaking. For example, if you didn't have 
		explicit APIs and someone changed a function they thought was only used within that 
		same library (but it was used elsewhere), they could accidentally break something.<br></br><br></br>
		
		
		Easy collaboration - Different developers work on a single piece of code in the team. 
		There are chances of conflicts when there's a git merge. This conflict can be reduced 
		if the code is split between more functions, files, repos, etc. We can also provide 
		ownership to specific code modules, where a team member can break them down into 
		smaller tasks.<br></br><br></br><br></br>
		
		Disadvantages of modular programming:

		There is a need for extra time and budget for a product in modular programming.<br></br><br></br>
		It is a challenging task to combine all the modules.<br></br><br></br>
		Careful documentation is required so that other program modules are not affected.<br></br><br></br>
		Some modules may partly repeat the task performed by other modules. Hence, 
		Modular programs need more memory space and extra time for execution.<br></br><br></br>
		Integrating various modules into a single program may not be a task because 
		different people working on the design of different modules may not have the 
		same style.<br></br><br></br>
		It reduces the program's efficiency because testing and debugging are 
		time-consuming, where each function contains a thousand lines of code.<br></br><br></br>
<code>
/*FILE module.h*/
 extern unsigned int Calculate_NoOfChars_In_string(char* str);

/*FILE module.c*/
unsigned int Calculate_NoOfChars_In_string(char* str)
{
	unsigned int counter = 0;
	while(str[counter]!="\0")
	{
		counter++;
	}
	return counter;
}

/*FILE main.c*/
#include &lt;module.h&gt;  
#include &lt;stdio.h&gt;  

int main()
{
	char strA[10] = "Some text.";
	unsigned int length = Calculate_NoOfChars_In_string(strA);
	print("String length is: %d\n", length);
}

</code>
		</modular-programming>
		<string-methods>
		C has many useful string functions, which can be used to perform certain operations 
		on strings.<br></br>
		To use them, you must include the &lt;string.h&gt; header file in your program.<br></br>
<code>
/* GET THE SIZE (IN CHARACTERS) OF STRINGS */
char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
printf("%d", strlen(alphabet));

/* Note that sizeof and strlen behaves differently, as sizeof also includes t
he \0 character when counting.*/

/* CONCATENATE STRINGS */

char str1[20] = "Hello ";
char str2[] = "World!";

// Concatenate str2 to str1 (result is stored in str1)
strcat(str1, str2);

// Print str1
printf("%s", str1);

/* COPY STRINGS */
char str1[20] = "Hello World!";
char str2[20];

// Copy str1 to str2
strcpy(str2, str1);

// Print str2
printf("%s", str2);

/* COMPARE STRINGS */

char str1[] = "Hello";
char str2[] = "Hello";
char str3[] = "Hi";

// Compare str1 and str2, and print the result
printf("%d\n", strcmp(str1, str2));  // Returns 0 (the strings are equal)

// Compare str1 and str3, and print the result
printf("%d\n", strcmp(str1, str3));  // Returns -4 (the strings are not equal)
</code>
		</string-methods>
		<datatype-conversions>
		There are two types of conversion in C:<br></br>
			Implicit Conversion (automatically)<br></br>
			Explicit Conversion (manually)<br></br>
			<br></br><br></br>
			Implicit conversion is done automatically by the compiler when you assign a value 
			of one type to another.<br></br><br></br>
<code>
// Automatic conversion: int to float
float myFloat = 9;

printf("%f", myFloat); // 9.000000

// the compiler automatically converts the int value 9 to a float value of 9.000000.

// Automatic conversion: float to int
int myInt = 9.99;

printf("%d", myInt); // 9

// the compiler automatically converts the float value of 9.99 to int value 9.
</code>
		Explicit conversion is done manually by placing the type in parentheses () in front 
		of the value. Also knows as typecasting. It is one of the important concepts introduced in 'C' 
		programming.<br></br>
<code>
//Calculate the percentage of a user's score in relation to the maximum score in a game:

// Set the maximum possible score in the game to 500
int maxScore = 500;

// The actual score of the user
int userScore = 420;

/* Calculate the percantage of the user's score in relation to the maximum available score.
Convert userScore to float to make sure that the division is accurate */
float percentage = (float) userScore / maxScore * 100.0;

// Print the percentage
printf("User's percentage is %.2f", percentage);
</code>
		</datatype-conversions>
		<optional-parameters>C does not support optional parameters.</optional-parameters>
		<operators>
		An operator is a symbol that tells the compiler to perform specific mathematical or 
		logical functions. By definition, an operator performs a certain operation on 
		operands. An operator needs one or more operands for the operation to be performed.<br></br>
		<br></br>
		Depending on how many operands are required to perform the operation, operands are called as 
		unary, binary or ternary operators. They need one, two or three operands respectively.<br></br>
		<br></br>
		Unary operators − ++ (increment), -- (decrement), ! (NOT), ~ (compliment), &#38; (address of), * (dereference)
		<br></br><br></br>
		Binary operators − arithmetic, logical and relational operators except !
		<br></br><br></br>
		Ternary operators − The ? operator.
		<br></br><br></br>
		C language is rich in built-in operators and provides the following types of operators −
		<br></br><br></br>
		Assume variable A holds 10 and variable B holds 20 then: <br></br>
		Arithmetic Operators: <br></br>
<code>
+	Adds two operands.	A + B = 30
−	Subtracts second operand from the first.	A − B = -10
*	Multiplies both operands.	A * B = 200
/	Divides numerator by de-numerator.	B / A = 2
%	Modulus Operator and remainder of after an integer division.	B % A = 0
++	Increment operator increases the integer value by one.	A++ = 11
--	Decrement operator decreases the integer value by one.	A-- = 9
</code>
		<br></br>Relational Operators<br></br>
<code>
==	Checks if the values of two operands are equal or not. 
If yes, then the condition becomes true.	(A == B) is not true.

!=	Checks if the values of two operands are equal or not. 
If the values are not equal, then the condition becomes true.	(A != B) is true.

&gt; 	Checks if the value of left operand is greater than the value of right operand. 
If yes, then the condition becomes true.	(A &gt; B) is not true.

&lt;	Checks if the value of left operand is less than the value of right operand. 
If yes, then the condition becomes true.	(A &lt; B) is true.

&gt;=	Checks if the value of left operand is greater than or equal to the value of right operand. 
If yes, then the condition becomes true.	(A &gt;= B) is not true.

&lt;=	Checks if the value of left operand is less than or equal to the value of right operand. 
If yes, then the condition becomes true.	(A &lt;= B) is true.
</code>
		<br></br>Logical Operators<br></br>
<code>
	
&#38;&#38; 	Called Logical AND operator. If both the operands are non-zero, 
then the condition becomes true.	(A &#38;&#38; B) is false.

||	Called Logical OR Operator. If any of the two operands is non-zero, 
then the condition becomes true.	(A || B) is true.

!	Called Logical NOT Operator. It is used to reverse the logical state of its operand. 
If a condition is true, then Logical NOT operator will make it false.	!(A &#38;&#38; B) is true
</code>
		<br></br>Bitwise Operators<br></br>
<code>
&#38;	Binary AND Operator copies a bit to the result if it exists in both operands.	
(A &#38; B) = 12, i.e., 0000 1100

|	Binary OR Operator copies a bit if it exists in either operand.	
(A | B) = 61, i.e., 0011 1101

^	Binary XOR Operator copies the bit if it is set in one operand but not both.	
(A ^ B) = 49, i.e., 0011 0001

~	Binary One's Complement Operator is unary and has the effect of 'flipping' bits.	
(~A ) = ~(60), i.e,. -0111101

&lt;&lt;	Binary Left Shift Operator. The left operands value is moved left by the number 
of bits specified by the right operand.	A &lt;&lt; 2 = 240 i.e., 1111 0000

&gt;&gt;	Binary Right Shift Operator. The left operands value is moved right by the number 
of bits specified by the right operand.	A &gt;&gt; 2 = 15 i.e., 0000 1111

</code>
		<br></br>Assignment Operators<br></br>
<code>
=	Simple assignment operator. Assigns values from right side operands to left side operand	C = A + B will assign the value of A + B to C
+=	Add AND assignment operator. It adds the right operand to the left operand and assign the result to the left operand.	C += A is equivalent to C = C + A
-=	Subtract AND assignment operator. It subtracts the right operand from the left operand and assigns the result to the left operand.	C -= A is equivalent to C = C - A
*=	Multiply AND assignment operator. It multiplies the right operand with the left operand and assigns the result to the left operand.	C *= A is equivalent to C = C * A
/=	Divide AND assignment operator. It divides the left operand with the right operand and assigns the result to the left operand.	C /= A is equivalent to C = C / A
%=	Modulus AND assignment operator. It takes modulus using two operands and assigns the result to the left operand.	C %= A is equivalent to C = C % A
&lt;&lt;=	Left shift AND assignment operator.	C &lt;&lt;= 2 is same as C = C &lt;&lt; 2
&gt;&gt;=	Right shift AND assignment operator.	C &gt;&gt;= 2 is same as C = C &gt;&gt; 2
&#38;=	Bitwise AND assignment operator.	C &#38;= 2 is same as C = C &#38; 2
^=	Bitwise exclusive OR and assignment operator.	C ^= 2 is same as C = C ^ 2
|=	Bitwise inclusive OR and assignment operator.	C |= 2 is same as C = C | 2
</code>
		<br></br>Misc Operators<br></br>
<code>
sizeof()	Returns the size of a variable.	sizeof(a), where a is integer, will return 4.
&#38; 	Returns the address of a variable.	&#38;a; returns the actual address of the variable.
*	Pointer to a variable.	*a;
? :	Conditional Expression.	If Condition is true ? then value X : otherwise value Y
</code>
		</operators>
		<pre-post-incrementation>Not present</pre-post-incrementation>
	</programming_language>
	
	<programming_language>
		<name>C++</name>
		<description>
			C++ is a high-level, general-purpose programming language created by 
			Danish computer scientist Bjarne Stroustrup. <br></br><br></br>
			First released in 1985 as an extension of the C programming language, 
			it has since expanded significantly over time; as of 1997, C++ has object-oriented, 
			generic, and functional features, in addition to facilities for low-level memory 
			manipulation for making things like microcomputers or to make operating systems 
			like Linux or Windows. <br></br><br></br>
			
			It is almost always implemented as a compiled language, 
			and many vendors provide C++ compilers, including the Free Software Foundation, 
			LLVM, Microsoft, Intel, Embarcadero, Oracle, and IBM.
		</description>
		<oop>C++ OOP</oop>
		<encapsulation>Not present</encapsulation>
		<polymorphism>Not present</polymorphism>
		<inheritance>Not present</inheritance>
		<abstraction>Not present</abstraction>
		<generic-programming>Not present</generic-programming>
		<variable-arguments-lists>Not present</variable-arguments-lists>
		<simple-data-types>Not present</simple-data-types>
		<complex-data-types>Not present</complex-data-types>
		<loops>Not present</loops>
		<collections>Not present</collections>
		<collection-methods>Not present</collection-methods>
		<dynamic-memory-allocation>Not present</dynamic-memory-allocation>
		<read-from-file>Not present</read-from-file>
		<write-to-file>Not present</write-to-file>
		<serialization>Not present</serialization>
		<deserialization>Not present</deserialization>
		<constructors>Not present</constructors>
		<instantiation>Not present</instantiation>
		<destructors>Not present</destructors>
		<function-overloading>Not present</function-overloading>
		<operator-overloading>Not present</operator-overloading>
		<enums>Not present</enums>
		<multi-threading>Not present</multi-threading>
		<namespaces>
		A namespace is a feature added in C++ and is not present in C. A namespace is a 
		declarative region that provides a scope to the identifiers (names of functions, 
		variables or other user-defined data types) inside it. Multiple namespace blocks 
		with the same name are allowed.
		</namespaces>
		<exception-handling>Not present</exception-handling>
		<bitwise-operators>Not present</bitwise-operators>
		<default-parameters>Not present</default-parameters>
		<interfaces>Not present</interfaces>
		<macros>Not present</macros>
		<defines>Not present</defines>
		<random-generators>Not present</random-generators>
		<command-line-arguments>Not present</command-line-arguments>
		<ternary-operator>Not present</ternary-operator>
		<modular-programming>Not present</modular-programming>
		<string-methods>Not present</string-methods>
		<datatype-conversions>Not present</datatype-conversions>
		<optional-parameters>Not present</optional-parameters>
		<partial-classes>Not present</partial-classes>
		<decorators>Not present</decorators>
		<operators>Not present</operators>
		<pre-post-incrementation>Not present</pre-post-incrementation>
		<datatypes-sizing>Not present</datatypes-sizing>
	</programming_language>
	
	<programming_language>
		<name>C#</name>
		<description>
			C# is a general-purpose high-level programming language supporting multiple 
			paradigms. C# encompasses static typing, strong typing, lexically scoped, 
			imperative, declarative, functional, generic, object-oriented (class-based), 
			and component-oriented programming disciplines. <br></br><br></br>

			The C# programming language was designed by Anders Hejlsberg from Microsoft in 
			2000. <br></br><br></br>

			Microsoft introduced C# along with .NET Framework and Visual Studio, both of 
			which were closed-source. At the time, Microsoft had no open-source products. 
			<br></br><br></br>

			Four years later, in 2004, a free and open-source project called Mono began, 
			providing a cross-platform compiler and runtime environment for the C# 
			programming language. <br></br><br></br>

			A decade later, Microsoft released Visual Studio Code (code editor), 
			Roslyn (compiler), and the unified .NET platform (software framework), 
			all of which support C# and are free, open-source, and cross-platform. 
			Mono also joined Microsoft but was not merged into .NET.<br></br><br></br>
		</description>
		<oop>C# OOP</oop>
		<encapsulation>Not present</encapsulation>
		<polymorphism>Not present</polymorphism>
		<inheritance>Not present</inheritance>
		<abstraction>Not present</abstraction>
		<generic-programming>Not present</generic-programming>
		<variable-arguments-lists>Not present</variable-arguments-lists>
		<simple-data-types>Not present</simple-data-types>
		<complex-data-types>Not present</complex-data-types>
		<loops>Not present</loops>
		<collections>Not present</collections>
		<collection-methods>Not present</collection-methods>
		<dynamic-memory-allocation>Not present</dynamic-memory-allocation>
		<read-from-file>Not present</read-from-file>
		<write-to-file>Not present</write-to-file>
		<serialization>Not present</serialization>
		<deserialization>Not present</deserialization>
		<constructors>Not present</constructors>
		<instantiation>Not present</instantiation>
		<destructors>Not present</destructors>
		<function-overloading>Not present</function-overloading>
		<operator-overloading>Not present</operator-overloading>
		<enums>Not present</enums>
		<multi-threading>Not present</multi-threading>
		<namespaces>Not present</namespaces>
		<exception-handling>Not present</exception-handling>
		<bitwise-operators>Not present</bitwise-operators>
		<default-parameters>Not present</default-parameters>
		<interfaces>Not present</interfaces>
		<macros>Not present</macros>
		<defines>Not present</defines>
		<random-generators>Not present</random-generators>
		<command-line-arguments>Not present</command-line-arguments>
		<ternary-operator>Not present</ternary-operator>
		<modular-programming>Not present</modular-programming>
		<string-methods>Not present</string-methods>
		<datatype-conversions>Not present</datatype-conversions>
		<optional-parameters>Not present</optional-parameters>
		<partial-classes>Not present</partial-classes>
		<decorators>Not present</decorators>
		<operators>Not present</operators>
		<pre-post-incrementation>Not present</pre-post-incrementation>
		<datatypes-sizing>Not present</datatypes-sizing>
	</programming_language>
	
	<programming_language>
		<name>JavaScript</name>
		<description>
			JavaScript often abbreviated as JS, is a programming language and core 
			technology of the Web, alongside HTML and CSS. 99% of websites use JavaScript 
			on the client side for webpage behavior.<br></br><br></br>

			Web browsers have a dedicated JavaScript engine that executes the client code. 
			These engines are also utilized in some servers and a variety of apps. The most 
			popular runtime system for non-browser usage is Node.js.<br></br><br></br>

			JavaScript is a high-level, often just-in-time compiled language that conforms 
			to the ECMAScript standard. It has dynamic typing, prototype-based 
			object-orientation, and first-class functions. It is multi-paradigm, 
			supporting event-driven, functional, and imperative programming styles. 
			It has application programming interfaces (APIs) for working with text, dates, 
			regular expressions, standard data structures, and the Document Object Model (DOM).
		</description>
		<oop>
		</oop>
		<encapsulation>Not present</encapsulation>
		<polymorphism>Not present</polymorphism>
		<inheritance>Not present</inheritance>
		<abstraction>Not present</abstraction>
		<generic-programming>Not present</generic-programming>
		<variable-arguments-lists>Not present</variable-arguments-lists>
		<simple-data-types>Not present</simple-data-types>
		<complex-data-types>Not present</complex-data-types>
		<loops>Not present</loops>
		<collections>Not present</collections>
		<collection-methods>Not present</collection-methods>
		<dynamic-memory-allocation>Not present</dynamic-memory-allocation>
		<read-from-file>Not present</read-from-file>
		<write-to-file>Not present</write-to-file>
		<serialization>Not present</serialization>
		<deserialization>Not present</deserialization>
		<constructors>Not present</constructors>
		<instantiation>Not present</instantiation>
		<destructors>Not present</destructors>
		<function-overloading>Not present</function-overloading>
		<operator-overloading>Not present</operator-overloading>
		<enums>Not present</enums>
		<multi-threading>Not present</multi-threading>
		<namespaces>Not present</namespaces>
		<exception-handling>Not present</exception-handling>
		<bitwise-operators>Not present</bitwise-operators>
		<default-parameters>Not present</default-parameters>
		<interfaces>Not present</interfaces>
		<macros>Not present</macros>
		<defines>Not present</defines>
		<random-generators>Not present</random-generators>
		<command-line-arguments>Not present</command-line-arguments>
		<ternary-operator>Not present</ternary-operator>
		<modular-programming>Not present</modular-programming>
		<string-methods>Not present</string-methods>
		<datatype-conversions>Not present</datatype-conversions>
		<optional-parameters>Not present</optional-parameters>
		<partial-classes>Not present</partial-classes>
		<decorators>Not present</decorators>
		<operators>Not present</operators>
		<pre-post-incrementation>Not present</pre-post-incrementation>
	</programming_language>
	
	<programming_language>
		<name>Java</name>
		<description>
			Java is a high-level, class-based, object-oriented programming language that is 
			designed to have as few implementation dependencies as possible.<br></br><br></br>
			It is a general-purpose programming language intended to let programmers write once, 
			run anywhere meaning that compiled Java code can run on all platforms that support 
			Java without the need to recompile. <br></br><br></br>
			
			Java applications are typically compiled to bytecode that can run on any 
			Java virtual machine (JVM) regardless of the 
			underlying computer architecture. The syntax of Java is similar to C and C++, 
			but has fewer low-level facilities than either of them. The Java runtime provides 
			dynamic capabilities (such as reflection and runtime code modification) that are 
			typically not available in traditional compiled languages.
		</description>
		<oop>Java OOP</oop>
		<encapsulation>Not present</encapsulation>
		<polymorphism>Not present</polymorphism>
		<inheritance>Not present</inheritance>
		<abstraction>Not present</abstraction>
		<generic-programming>Not present</generic-programming>
		<variable-arguments-lists>Not present</variable-arguments-lists>
		<simple-data-types>Not present</simple-data-types>
		<complex-data-types>Not present</complex-data-types>
		<loops>Not present</loops>
		<collections>Not present</collections>
		<collection-methods>Not present</collection-methods>
		<dynamic-memory-allocation>Not present</dynamic-memory-allocation>
		<read-from-file>Not present</read-from-file>
		<write-to-file>Not present</write-to-file>
		<serialization>Not present</serialization>
		<deserialization>Not present</deserialization>
		<constructors>Not present</constructors>
		<instantiation>Not present</instantiation>
		<destructors>Not present</destructors>
		<function-overloading>Not present</function-overloading>
		<operator-overloading>Not present</operator-overloading>
		<enums>Not present</enums>
		<multi-threading>Not present</multi-threading>
		<namespaces>Not present</namespaces>
		<exception-handling>Not present</exception-handling>
		<bitwise-operators>Not present</bitwise-operators>
		<default-parameters>Not present</default-parameters>
		<interfaces>Not present</interfaces>
		<macros>Not present</macros>
		<defines>Not present</defines>
		<random-generators>Not present</random-generators>
		<command-line-arguments>Not present</command-line-arguments>
		<ternary-operator>Not present</ternary-operator>
		<modular-programming>Not present</modular-programming>
		<string-methods>Not present</string-methods>
		<datatype-conversions>Not present</datatype-conversions>
		<optional-parameters>Not present</optional-parameters>
		<partial-classes>Not present</partial-classes>
		<decorators>Not present</decorators>
		<operators>Not present</operators>
		<pre-post-incrementation>Not present</pre-post-incrementation>
	</programming_language>
	
	<programming_language>
		<name>Python</name>
		<description>
			Python is a high-level, general-purpose programming language. Its design 
			philosophy emphasizes code readability with the use of significant indentation.
			<br></br><br></br>

			Python is dynamically typed and garbage-collected. It supports multiple 
			programming paradigms, including structured (particularly procedural), 
			object-oriented and functional programming. It is often described as a 
			"batteries included" language due to its comprehensive standard library.
		
		</description>
		<oop>Python OOP</oop>
		<encapsulation>Not present</encapsulation>
		<polymorphism>Not present</polymorphism>
		<inheritance>Not present</inheritance>
		<abstraction>Not present</abstraction>
		<generic-programming>Not present</generic-programming>
		<variable-arguments-lists>Not present</variable-arguments-lists>
		<simple-data-types>Not present</simple-data-types>
		<complex-data-types>Not present</complex-data-types>
		<loops>Not present</loops>
		<collections>Not present</collections>
		<collection-methods>Not present</collection-methods>
		<dynamic-memory-allocation>Not present</dynamic-memory-allocation>
		<read-from-file>Not present</read-from-file>
		<write-to-file>Not present</write-to-file>
		<serialization>Not present</serialization>
		<deserialization>Not present</deserialization>
		<constructors>Not present</constructors>
		<instantiation>Not present</instantiation>
		<destructors>Not present</destructors>
		<function-overloading>Not present</function-overloading>
		<operator-overloading>Not present</operator-overloading>
		<enums>Not present</enums>
		<multi-threading>Not present</multi-threading>
		<namespaces>Not present</namespaces>
		<exception-handling>Not present</exception-handling>
		<bitwise-operators>Not present</bitwise-operators>
		<default-parameters>Not present</default-parameters>
		<interfaces>Not present</interfaces>
		<macros>Not present</macros>
		<defines>Not present</defines>
		<random-generators>Not present</random-generators>
		<command-line-arguments>Not present</command-line-arguments>
		<ternary-operator>Not present</ternary-operator>
		<modular-programming>Not present</modular-programming>
		<string-methods>Not present</string-methods>
		<datatype-conversions>Not present</datatype-conversions>
		<optional-parameters>Not present</optional-parameters>
		<partial-classes>Not present</partial-classes>
		<decorators>Not present</decorators>
		<operators>Not present</operators>
		<pre-post-incrementation>Not present</pre-post-incrementation>
	</programming_language>
	
</content>
