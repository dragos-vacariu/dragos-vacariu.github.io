<?xml version="1.0" encoding="UTF-8"?>

<content>
    <manifest>
        <name>General-Programming-Knowledge</name>
        <oop>
            OOP stands for Object-Oriented Programming.
            <br></br><br></br>
            Procedural programming is about writing procedures or functions 
            that perform operations on the data, 
            while object-oriented programming is about creating objects that contain both 
            data and functions.
            <br></br><br></br>
            <green>
            Object-oriented programming has several advantages over procedural programming:
            </green>
            <br></br><br></br>
            
            OOP is faster and easier to execute;<br></br>
            OOP provides a clear structure for the programs;<br></br>
            OOP helps to keep the code DRY "Don't Repeat Yourself", and makes the code 
            easier to maintain, modify and debug;<br></br>
            OOP makes it possible to create full reusable applications with less code and 
            shorter development time;
            
            <br></br><br></br>
            
            Tip: The "Don't Repeat Yourself" (DRY) principle is about reducing the repetition 
            of code. <br></br>
            You should extract out the codes that are common for the application, 
            and place them at a single place and reuse them instead of repeating it.
            
            <br></br><br></br>
            <green>Terminology:</green>
            <br></br><br></br>
            <brown>Classes:</brown>
            <br></br><br></br>
            A class is a user-defined prototype for an object that defines a set 
            of attributes that 
            characterize any object/instance of the class.
            <br></br><br></br>
            <brown>Attributes:</brown>
            <br></br><br></br>
            The attributes are data members (class variables and 
            instance variables) and methods, accessed using the <code>.</code> operator.
            The attributes are also refered to as: fields/variables and methods/properties.
            <br></br><br></br>
            <brown>Class variables:</brown>
            <br></br><br></br>
            A class variable is a variable that is shared by all instances 
            of a class.
            <br></br>
            Class variables are defined within a class but 
            outside any of any class method. 
            <br></br>
            Typically in OOP languages class variables are 
            defined using the static keyword.
            <br></br>
            Class variables are not used as frequently as instance variables.
            <br></br><br></br>
            <brown>Instance variables:</brown>
            <br></br><br></br>
            An instance variable is a non-static variable that is defined 
            inside a class and belongs only to the current instance of a 
            class. Instance variables
            can be refered to by using this keyword in languages such as: C++, C#, Java,
            JavaScript or by using self keyword in Python.
            <br></br><br></br>
            <brown>Data member:</brown>
            <br></br><br></br>
            A data member is a class variable or instance variable that 
            holds data associated 
            with a class and its objects.
            <br></br><br></br>
            <brown>Function overloading:</brown>
            <br></br><br></br>
            Function overloading is the assignment of more than one behavior to a 
            particular function.
            The operation performed varies by the types of objects or arguments involved.
            <br></br><br></br>
            <brown>Instance:</brown>
            <br></br><br></br>
            An instance is an individual object of a certain class. 
            An instance of an object is created
            by involking the constructor of the object. 
            The process of creating an object is 
            called
            instanciation or instancing.
            <br></br><br></br>
            <brown>Method:</brown>
            <br></br><br></br>
            A method is another name given to a function that is defined 
            within a class definition. Methods
            can also belong to the class or to the instance.
            <br></br><br></br>
            <brown>Object:</brown>
            <br></br><br></br>
            An instance of the class is also called as an object.
            An object is a data structure that's defined by its class.
            <br></br>
            An object comprises from both data members (class variables 
            and instance variables) and methods.
            <br></br><br></br>
            <brown>Operator overloading:</brown>
            <br></br><br></br>
            The assignment of more than one function to a particular 
            operator is called operator 
            overloading. Via operator overloading, an operator can be customized
            so that it produces the desired behaviour on complex data types such as 
            objects.
            <br></br><br></br>
            <green>Class members vs. Instance members:</green>
            <br></br><br></br>
            A member is either a variable or a method. 
            A method belonging to the class is
            defined in most OOP languages by using the static keyword.
            <br></br><br></br>
            Class methods or variables
            cannot be refered to by using this or self keywords. 
            <br></br><br></br>
            Class methods and variables can be accessed without an 
            instance
            of the class by using the name of the class followed by the 
            . operator.
            <br></br><br></br>
            Class members cannot be combined with instance members. 
            Meaning we cannot have a class method
            that would access an instance member. 
            <br></br><br></br>
            Class methods cannot directly access instance variables 
            and instance methods but the reversed way is possible: 
            instance methods can access class variables and 
            class methods directly.
            <br></br><br></br>
            <green>OOP Concepts:</green>
            <br></br><br></br>
            Typically an object-oriented programming language 
            has 4 fundamental concepts:
            <br></br><br></br>
            
            1. Inheritance<br></br>
            2. Polymorphism<br></br>
            3. Encapsulation<br></br>
            4. Abstraction<br></br>
            
            <br></br>
        </oop>
        <encapsulation>
            The meaning of Encapsulation, is to make sure that "sensitive" data is hidden from 
            users.<br></br><br></br> 
            To achieve this, you must declare class variables/attributes as <code>private</code> 
            (cannot be accessed from outside the class). <br></br><br></br>
            If you want others to read or modify 
            the value of a <code>private</code> member, you can provide <code>public</code> get and 
            set methods.<br></br>
            <br></br>
            <green>
            Conventions:
            </green>
            <br></br><br></br>
            
            - good programmers use private fields for a class. 
            (A field is a variable declared in the class)
            <br></br>
            - good programmers use at least a constructor for a class. 
            (And that constructor is used to initialize the
            fields.)
            <br></br>
            - good programmers use encapsulation for controling the value 
            that get in or get out from the fields
            <br></br>
            - a method inside a class is also called 
            property of the class, 
            there can be public or private properties
            
            <br></br><br></br>
            Encapsulation is one of the 4 OOP fundamental concepts.
            <br></br>
        </encapsulation>
        <polymorphism>
            Polymorphism means "many forms", and it occurs when we have many 
            classes that are related to each other by inheritance.
            <br></br><br></br>
            Polymorphism is the act of creating a collection of different 
            object types which are inherited from the same 
            base class. 
            <br></br><br></br>
            A polymorphic type is one whose operations can also be 
            applied to values of some other type, or types. 
            When calling a virtual function from any 
            derived class the overrided method will be invoked not the 
            original one.
            <br></br><br></br>
            <green>There are several fundamentally different kinds of polymorphism:</green>
            <br></br><br></br>
            Ad hoc polymorphism: when a function has different implementations 
            depending on a limited range of individually specified types 
            and combinations. 
            <br></br><br></br>
            Ad hoc polymorphism: is supported in many languages using 
            function overloading.
            <br></br><br></br>
            Parametric polymorphism: when the code is written without 
            mention of any specific type and thus can be used transparently with any 
            number of new types. 
            In the object-oriented programming community, this is often known as 
            generics or generic programming.
            <br></br>
            In the functional programming community, 
            this is often shortened to polymorphism. 
            <br></br><br></br>
            Subtyping (also called subtype polymorphism or 
            inclusion polymorphism): when a name denotes instances of 
            many different classes related by some common superclass.
            <br></br><br></br>
            Polymorphism is one of the 4 OOP fundamental concepts.
            <br></br>
        </polymorphism>
        <simple-data-types>
            In programming, data type refers to the type of value a variable 
            as and what type of mathematical, relational or logical operations can be applied 
            without causing an error.
            <br></br><br></br>
            A data type is an attribute associated with a piece of 
            data (variable) that tells a computer system how to interpret its value.
            <br></br><br></br>
            <green>Data-types in Programming:</green>
            <br></br><br></br>
            <code>short int</code><br></br>
            - has value range <code>[-32,768 to 32,767]</code>;<br></br>
            - format specifier <code>%hd</code>;<br></br>
            - occupies <code>2 bytes</code> memory;
            <br></br><br></br>
            <code>unsigned short int</code><br></br>
            - has value range <code>[-32,768 to 65,535]</code>;<br></br>
            - format specifier <code>%hu</code>;<br></br>
            - occupies <code>2 bytes</code> memory;
            <br></br><br></br>
            <code>unsigned int</code><br></br>
            - has value range <code>[0 to 4,294,967,295]</code>;<br></br>
            - format specifier <code>%u</code>;<br></br>
            - occupies <code>4 bytes</code> memory;
            <br></br><br></br>
            <code>int</code><br></br>
            - has value range <code>[-2,147,483,648 to 2,147,483,647]</code>;<br></br>
            - format specifier <code>%d</code>;<br></br>
            - occupies <code>4 bytes</code> memory;
            <br></br><br></br>
            <code>long int</code><br></br> 
            - has value range <code>[-2,147,483,648 to 2,147,483,647]</code>;<br></br>
            - format specifier <code>%ld</code>;<br></br>
            - occupies <code>4 bytes</code> memory;
            <br></br><br></br>
            <code>unsigned long int</code><br></br>
            - has value range <code>[0 to 4,294,967,295 ]</code>;<br></br>
            - format specifier <code>%lu</code>;<br></br>
            - occupies <code>4 bytes</code> memory;
            <br></br><br></br>
            <code>long long int</code><br></br>
            - has value range <code>[-(2^63) to (2^63)-1]</code>;<br></br>
            - format specifier <code>%lld</code>;<br></br>
            - occupies <code>8 bytes</code> memory;
            <br></br><br></br>
            <code>unsigned long long int</code><br></br>
            - has value range <code>[-(2^63) to 18,446,744,073,709,551,615 ]</code>;<br></br>
            - format specifier <code>%llu</code>;<br></br>
            - occupies <code>8 bytes</code> memory;
            <br></br><br></br>
            <code>signed char</code><br></br>
            - has value range <code>[-128 to 127]</code>;<br></br>
            - format specifier <code>%c</code>;<br></br>
            - occupies <code>1 byte</code> memory;
            <br></br><br></br>
            <code>unsigned char</code><br></br>
            - has value range <code>[0 to 255]</code>;<br></br>
            - format specifier <code>%c</code><br></br>
            - occupies <code>1 byte</code> memory;
            <br></br><br></br>
            <code>float</code><br></br>
            - has value range <code>[1.2E-38 to 3.4E+38]</code>;<br></br>
            - format specifier <code>%f</code>;<br></br>
            - occupies <code>4 bytes</code> memory;
            <br></br><br></br>
            <code>double</code><br></br>
            - has value range <code>[1.7E-308 to 1.7E+308]</code>;<br></br>
            - format specifier <code>%lf</code>;<br></br>
            - occupies <code>8 bytes</code> memory;
            <br></br><br></br>
            <code>long double</code><br></br>
            - has value range <code>[3.4E-4932 to 1.1E+4932]</code>;<br></br>
            - format specifier <code>%Lf</code>;<br></br>
            - occupies <code>16 bytes</code> memory;
        </simple-data-types>
        <complex-data-types>
            In Programming, a data type is an attribute associated with a 
            piece of data that tells a computer system how to 
            interpret its value. <br></br>
            <br></br>
            <green>
                Data types that are derived from fundamental data types:
            </green>
            <br></br><br></br>
            <code>bool type</code> - The bool type is a byte-sized type that can only hold the value true or false.<br></br><br></br>
            <code>Enumerated type / Enums</code> - An <code>enum</code> is a special type that represents a group of constants 
            (unchangeable values).
            <br></br><br></br>
            <code>Arrays</code> - A collection of elements of the same data type. <br></br>
            These entities or elements can be of <code>int</code>, <code>float</code>, <code>char</code>, or <code>double</code> 
            data type or can be of <code>user-defined</code> data types such as    like <code>structures</code>.
            <br></br><br></br>
            
            The size of an array can be calculated by multiplying the <code>data-type * numberOfElements</code> within the array.
            
            <br></br><br></br>
            <code>Pointers</code> - A variable that stores the memory address of another variable. 
            <br></br>
            The size of a pointer varies depending on factors such as the operating system and CPU 
            architecture.<br></br><br></br>
            
            Typically, on a <code>32-bit</code> computer system, the size of pointer is <code>4 bytes</code>,    
            while on a <code>64-bit</code> computer system, it is <code>8 bytes</code>.
            
            <br></br><br></br>
            <code>Structures</code> - A collection of variables of different data types grouped 
            together under a single name. 
            <br></br><br></br>
            
            The size of a <code>struct</code> can be calculated by summing up the size of all the element data-types.
            
            <br></br><br></br>
            <code>Unions</code> - A special type of structure that can store only one value at a time. <br></br><br></br>
            
            The size of the <code>union</code> is equal to the size of the largest element defined within the union.
            
            <br></br><br></br>
            <code>Typedefs</code> - A way to create a new name for an existing data type to improve code 
            readability and maintainability.<br></br><br></br>
            <code>void</code> - It's used to indicate an empty data type, usually used with pointers.<br></br>
        </complex-data-types>
        <loops>
            In computer programming, a loop is a sequence of instructions that is 
            continually repeated until a certain condition is reached. 
            <br></br><br></br>
            Typically, a certain process is done, such as getting an item of data 
            and changing it, and then some condition is checked such as whether a 
            counter has reached a prescribed number.
            <br></br><br></br>
            <green>
            For, while, do-while loops:
            </green>
            <br></br><br></br>
            <brown>While loop:</brown><br></br><br></br>
            While loop does not depend upon the number of iterations. 
            <br></br>
            If the test condition will 
            become false then it will break from the while loop else body will be executed.
            <br></br><br></br>
<code>
/*While loop syntax: */
int counter = 0;
while(counter &lt; 5)
{
    /*code goes here*/
     counter++;
}
</code>
            <br></br>
            <brown>For loop:</brown><br></br><br></br>
            For loop uses a loop variable to control the loop. 
            <br></br><br></br>
            Firstly the loop variable is initialized with some value.<br></br>
            Then its test condition is checked. 
            <br></br><br></br>
            If the 
            statement is true then control will move to the body and the body of for 
            loop will be executed. 
            <br></br>
            Steps will be repeated untill the test condition becomes false. 
            <br></br>
            When the test condition will be false the loop will exit.
            <br></br><br></br>
            
            Initialization Expression: In this expression, we assign a loop variable 
            or loop counter to some value. <br></br>
            Example: <code>int counter=1;</code>
            <br></br><br></br>
            
            Test Expression: In this expression, test conditions are performed.
            <br></br>            
            If the condition evaluates to true then the loop body will be executed and 
            then an update of the loop variable is done. 
            <br></br>
            If the test expression becomes 
            false then the control will exit from the loop. <br></br>
            Example: <code>counter&lt;5;</code>
            <br></br><br></br>
            
            Update Expression: After execution of the loop body loop variable is updated 
            by some value. <br></br>
            It could be incremented, decremented, multiplied, or divided by 
            any value. <br></br>
            Example: <code>counter++;</code><br></br><br></br>

<code>
/*For loop syntax: */
for(int counter = 0; counter &lt; 5; counter++)
{
    /*code goes here*/
}
</code>
            <br></br>        
            <brown>Do-while loop:</brown><br></br><br></br>
            The do-while loop is similar to a while loop but the only difference 
            lies in the do-while loop test condition which is tested at the end of 
            the body. <br></br>
            In the do-while loop, the loop body will execute at least once 
            irrespective of the test condition.<br></br><br></br>
<code>
/*Do while loop syntax: */
do
{
    /*code goes here*/
     counter++;
}
while(counter &lt; 5)
</code>
        </loops>
        <dynamic-memory-allocation>
            Dynamic memory is allocated from the heap using some standard library functions. 
            The two dynamic memory key functions are <code>malloc()</code> and <code>free()</code>. 
            <br></br><br></br>
            The <code>malloc()</code> function takes a single parameter, which is the size of the requested memory 
            area in bytes. <br></br>
            It returns a pointer of type void which 
            can be cast into a pointer of any form. 
            <br></br><br></br>
            
            It doesn’t initialize the memory at execution time.<br></br>
            So each block will initially have a default garbage value. 
            
            <br></br><br></br>
<code>
//Example of dynamic memory allocation

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;conio.h&gt;

int main()
{
    int *A;
    int i;
    
    /*
    Prototype: void *malloc(size_t size);
    */

    A=(int *)malloc(20*sizeof(int)); 
    // malloc return a void pointer that needs to be converted
    //into a pointer to however the type of the variable that uses it has. 
    //(int *) - is the type of pointer A
    //20 = the number of memory cells allocated;
    
    for (i=0;i&lt;20;i++)
        printf("A[%d]=%d\n", i, A[i]); //the value in each memory cell can be anything
    free(A);
}
</code>
            Calloc function allocates the requested memory and returns a pointer to it similarly to malloc. 
            <br></br><br></br>
            The <code>malloc()</code> and <code>calloc()</code> do differentiate in how the functions are used when allocating 
            memory at runtime. <br></br><br></br>
            The <code>malloc()</code> function only returns the starting address, it doesn't zero it.
            <br></br>            
            On the other hand, the <code>calloc()</code> function returns the starting address, zeroing it.
            <br></br>    
<code>
/*Prototype void *calloc(size_t nitems, size_t size)*/

A=(int *)calloc(20, sizeof(int)); 
//calloc does the same as malloc while initializing all elements to 0:
    
for (i=0;i&lt;20;i++)
    printf("A[%d]=%d\n", i ,A[i]); //the value in each memory cell is 0
    
free(A); 
//free is used to free the allocated memory. 
//There is no delete() in C language.
    
</code>
        </dynamic-memory-allocation>
        <serialization>
            Serialization is the process of converting a data object (a combination of code and data 
            represented within a region of data storage) into a series of bytes that saves the state 
            of the object in an easily transmittable form.<br></br><br></br>
        </serialization>
        <deserialization>
            Deserialization is the process of reconstructing a data structure or object from a series 
            of bytes or a string in order to instantiate the object for consumption. 
            <br></br><br></br>
            This is the 
            reverse process of serialization, i.e., converting a data structure or object into a 
            series of bytes for storage or transmission across devices.<br></br>
        </deserialization>
        <enums>
            Enumeration (or <code>enum</code>) is a user defined data type. <br></br>
            It is mainly used to 
            assign names to integral constants, the names make a program easy to read and maintain.
            <br></br><br></br>
        </enums>
        <concurrent-programming>
            Concurrent Programming is a technique in which two or more 
            processes start, run in an interleaved fashion through context switching 
            and complete in an overlapping time period by managing access to 
            shared resources e.g. on a single core of CPU.
            <br></br><br></br>
            This doesn’t necessarily mean that multiple processes will be running 
            at the same instant – even if the results might make it seem like it.
            <br></br><br></br>
            Concurrent Programming can be clasified as asynchronous if it enables operations 
            to be executed without waiting for previous tasks to complete. For instance, if we have 2 processes, 
            one that
            retrieves some information from a server and the other one which sets up an environment where the retrieved 
            information should be displayed, it cannot be considered asynchronous as there is a scenario 
            in which the process
            of setting up the environment is faster than the process of retrieving the information from 
            the server, case in which
            one process has to wait for the other to finish and this would 
            classify it synchronous.
            <br></br><br></br>
            Blocking in asynchronous programming is when a website or browser is no longer able to 
            continue a function and can't perform any tasks until the processor regains control. 
            A frozen web page or application is a typical example of blocking. 
            <br></br><br></br>
            Concurrent Programming is an essential technique for design applications 
            that can execute tasks simultaneously, in order to increasing overall 
            efficiency and responsiveness.
            <br></br><br></br>
            <green>Asynchronous programming vs. synchronous programming</green>
            <br></br><br></br>
            Both asynchronous and synchronous programming involve similar concepts 
            within the broader field of computer programming. 
            <br></br><br></br>
            Synchronous or sequential programming is when tasks occur separately 
            or one after another. 
            The program pauses while the system performs the action and only responds once it receives 
            the result. It features a single-thread model, meaning that it only performs a 
            single action at a time.
            <br></br><br></br>
            Asynchronous programming differs in that it allows multiple tasks to run at the same time, 
            and the programmer can often manage these tasks directly. It allows programs to continue to run even after 
            you start a specific action.
            <br></br><br></br>
            <green>Concurency scenarios:</green>
            <br></br><br></br>
            Asynchrony - This means that your program performs non-blocking operations. 
            For example, it can initiate a request for a remote resource via HTTP and then go on to 
            do some other task while it waits for the response to be received. It’s a bit like when 
            you send an email and then go on with your life without waiting for a response.
            <br></br><br></br>
            Parallelism - This means that your program leverages the hardware of multi-core machines 
            to execute 
            tasks at the same time by breaking up work into tasks, each of which is executed on a separate core. 
            It’s a bit like singing in the shower: you’re actually doing two things at exactly the same time.
            <br></br><br></br>
            Multithreading - This is a software implementation allowing different threads to be executed 
            concurrently. A multithreaded program appears to be doing several things at the same time even 
            when it’s running on a single-core machine. This is a bit like chatting with different people 
            through various IM windows; although you’re actually switching back and forth, the net result 
            is that you’re having multiple conversations at the same time.
            <br></br><br></br>
            <green>Principles of concurrent Programming:</green>
            <br></br><br></br>
            The are some basic principles and concepts behind concurrent programming: 
            <br></br><br></br>
            Parallelism: Concurrent programs can run multiple processes or 
            threads simultaneously, 
            utilizing multiple processing units available in today's computer systems.
            <br></br><br></br>
            Non-determinism: Due to the unpredictable order of execution, 
            concurrent programs can 
            give different results on different runs, making debugging and testing more complex. 
            This concept arises from the uncertain order in which threads 
            or processes access shared resources and interact with each other.
            <br></br><br></br>
            Synchronization: Concurrent programs use synchronization mechanisms 
            to coordinate access to shared resources and ensure mutually exclusive 
            access or resource protection to prevent data inconsistency and 
            race conditions.
            <br></br><br></br>
            <green>Implementation Techniques:</green>
            <br></br><br></br>
            Concurrent Programming can be implemented through the use of 
            multithreading and multiprocessing.
            <br></br><br></br>
            A thread is a single sequence stream within a process.
            <br></br><br></br>
            A stream can be thought of as a path or channel, 
            through which the data is flowing in and out of the program.
            <br></br><br></br>
            Because threads have some of the properties of processes, 
            they are sometimes called lightweight processes.
            <br></br><br></br>
            Threads are not independent from each other unlike processes. 
            As a result, 
            threads share with other threads their code section, 
            data section and OS resources such as: opened files 
            and signals.
            <br></br><br></br>
            Signals are software generated interrupts that are sent to a process 
            when an event happens.
            <br></br><br></br>
            Similar to processes, a thread has its own program 
            counter (PC), a register set, and a stack space.
            <br></br><br></br>
            The program counter (also called "instruction pointer") is 
            part of the hardware; more specifically, it's a processor register. 
            The whole purpose of this register is 
            to point to the current instruction in the memory that is being executed by 
            the processor.
            <br></br><br></br>
            A process is the instance of a computer program that is being 
            executed by 
            one or many threads. By multiprocessing a program can be divided 
            into independent processes, which can run individually as 
            separate programs. This would allow the possibility to offload/distribute 
            these processes on separate cores which would increase performance.
            <br></br><br></br>
            <green>Understanding threading and processing:</green>
            <br></br><br></br>
            A CPU ( also called a central processing unit , main processor, 
            or just processor) is essentially the brain that processes and carries 
            out instructions. 
            <br></br>
            CPUs come in many different varieties, such as 
            single-core, dual-core, 
            quad-core, and other multi-core processors.
            <br></br><br></br>
            Cores are physical processing units. The number of cores 
            in a system will determine how many programs and tasks it can 
            execute simultaneously (in parallel). 
            For instance, a single-core processor may be able to handle one task at a time. 
            By contrast, a quad-core processor could handle up to four 
            simultaneous tasks.
            <br></br><br></br>
            Threads are virtual sequences of instructions given to a CPU. 
            A thread is a sequence of instructions given to the CPU by a program 
            or application. The more threads a CPU can execute at once, the more 
            tasks 
            it can complete.
            Hyperthreading allows multi-core processors to execute two 
            thread concurrently on each core, meaning a 
            quad-core processor could execute up to 8 threads 
            (2 threads on each core).
            <br></br><br></br>
            A thread can be seen as a single-handed person performing one task at 
            a time. 
            Even with one thread
            we can run many programs simultaneous from our perspective, but from CPU's 
            perspective, these tasks are not simultaneous. The CPU has to switch the 
            thread
            between the tasks on every few microseconds, therefore
            moving its hand from doing one thing to doing the other thing so fast that a real person 
            would not be able to notice any difference. <br></br>
            Example: the music doesn't stop playing when 
            writing the keyboard. 
            <br></br><br></br>
            By hyperthreading, the core gets a second hand available, 
            and can perform 
            2 simultaneous tasks but using the same the shared resources of the 
            core, 
            meaning it's slower than doing simultaneous tasks on different cores, 
            but faster than doing single tasks on one core. 
            <br></br><br></br>
            Multithreading refers to using multiple threads 
            (2 threads) 
            to one core.
            Multithreading allows for better utilization of available system resources by 
            dividing tasks into separate threads and running them in parallel.
            Hyperthreading further increases performance by allowing processors to 
            execute two 
            threads concurrently. 
            <br></br><br></br>
            Multiprocessing is the utilization of two or more central processing 
            units (CPUs) in achieving one task, meaning we can have 2 cores 
            running same program sharing among themselves data. 
            <br></br>
            Similar to 2 workers working on 
            same task, passing around their tools from one to the other.
            <br></br><br></br>
            <green>Multithreading vs. multiprocessing:</green>
            <br></br><br></br>
            Both multithreading and multiprocessing give birth to few challenges 
            when it comes to concurrent programming.
            <br></br><br></br>
            <brown>The Race Condition:</brown>
            <br></br><br></br>
            A race condition occurs when two or more processes/threads 
            can access shared data and they try to change it at the same time. 
            As a result, the values of variables 
            may be unpredictable and vary depending on the timings of context switches 
            of the processes/threads.
            <br></br><br></br>
            <brown>Process/Thread Syncronization:</brown>
            <br></br><br></br>
            Process Synchronization and Thread Synchronization 
            are two mechanism defined for concurrent programming in order to ensure 
            that two or more concurrent processes/threads do not simultaneously execute 
            some particular program segment known as critical section.
            <br></br><br></br>
            A critical section refers to the parts of the 
            program where the shared resources are being accessed by different 
            threads/processes. So the 2 workers or the 2 hands 
            working on the same task collide to each other.
            <br></br><br></br>
            By using Process Synchronization and Thread Synchronization 
            the race condition can be avoided.
            <br></br><br></br>
            Both multithreading and multiprocessing can be used to 
            increase the computing power of a system, but there are some key differences between 
            these two approaches. 
            <br></br><br></br>
            <brown>
            Differences between Multithreading and Multiprocessing:
            </brown>
            <br></br><br></br>
            Multiprocessing uses two or more CPUs to increase computing power, 
            whereas 
            multithreading uses a single process with multiple 
            code segments to increase computing power.
            <br></br><br></br>
            Multithreading focuses on generating computing threads from a 
            single process, 
            whereas multiprocessing increases computing power by adding 
            CPUs. Meaning via multiprocessing we can distribute proccesses on 
            separate CPUs, whereas this is not possible with multithreading.
            <br></br><br></br>
            Multiprocessing is used to create a more reliable system, whereas 
            multithreading is used to create threads that run parallel to each other.
            <br></br><br></br>
            Multithreading is quick to create and requires few resources, 
            whereas multiprocessing 
            requires a significant amount of time and specific resources for its creation.
            <br></br><br></br>
            Multiprocessing executes many processes simultaneously, 
            whereas multithreading executes many threads simultaneously.
            <br></br><br></br>
            Multithreading uses a common address space for all 
            the threads, whereas 
            multiprocessing 
            creates a separate address space for each process.
            <br></br><br></br>
            In multiprocessing each process has its own memory 
            address space (stack memory). So when returning a value
            from a process, the value returned will not be 
            seen by the rest of the program unless it is saved in a file, in a 
            shared memory address, or in a message pipe, 
            whereas multithreading is able to return values which can be used 
            later in the main program.
            <br></br>
            A pipe is a technique for passing information from one program process 
            to another.
            <br></br><br></br>
            A process is treated as an individual program, (it even creates a 
            process in the Task Manager).
            Processes can be sent through different cores, that would speed 
            up the program even more.
            <br></br><br></br>
            Creating multiple processes is costly compare to threads. 
            Since for each process there is allocated another stack memory 
            space.
            <br></br><br></br>
            Multithreading is recommended for IO (input/output) operations such as: 
            file inputting/outputting and http requests, whereas 
            multiprocessing is recommended for CPU intensive operations 
            such as: calculations.
            <br></br><br></br>
            <green>Advantages of multithreading:</green>
            <br></br><br></br>
            1. It requires less memory storage.<br></br>
            2. Accessing memory is easier since threads share the same 
            parent process.<br></br>
            3. Switching between threads is fast and efficient.<br></br>
            4. It's faster to generate new threads within an existing process 
            than to create 
            an entirely new process.<br></br>
            5. All threads share one process memory pool  and the same 
            address space.<br></br>
            6. Threads are more lightweight and have lower overhead. 
            Any combination of excess or indirect computation time, memory, bandwidth, or other 
            resources that are required to perform a specific task is refered to as 
            overhead.
            <br></br> 
            7. The cost of communication between threads is relatively low.
            Meaning that threads can communicate with each other more easily 
            than processes can.
            <br></br>
            8. Creating responsive user interactions (UIs) is easy.
            <br></br><br></br>
            <green>Disadvantages of multithreading:</green>
            <br></br><br></br>
            1. A multithreading system cannot be interrupted/killed. Special attention has to
            be paid to memory leaks.
            A memory leak occurs when programmers allocate memory on 
            the heap and forget to deallocate it.<br></br>
            2. The code can be more challenging to understand.<br></br>
            3. The overhead associated with managing different 
            threads may be too costly for basic tasks.<br></br>
            4. Increased potential for race conditions. 
            <br></br>
            5. Debugging and troubleshooting issues may become more 
            challenging because the code can be complex.
            <br></br><br></br><br></br>
            <green>Advantages of multiprocessing:</green>
            <br></br><br></br>
            1. It uses simple coding that's easy to understand.<br></br>
            2. Child processes can be interrupted.<br></br>
            3. It completes tasks faster and analyzes large amounts of data.<br></br>
            4. It uses multiple CPUs to improve a system's overall processing power.<br></br>
            5. It removes synchronization primitives.<br></br>
            6. It's more cost-effective than single processor systems.
            <br></br><br></br>
            <green>Disadvantages of multiprocessing:</green>
            <br></br><br></br>
            1. It requires more memory storage and overhead than threads 
            in order to move data between the processes.<br></br>
            2. Spawning processes take longer than spawning threads.<br></br>
            3. An inter-process communication (IPC) model must be implemented to 
            share objects between the processes.<br></br>
            4. The entire memory is copied into each subprocess, which can also create more 
            overhead.
            <br></br><br></br>
            <green>Choosing between multithreading and multiprocessing:</green>
            <br></br><br></br>
            1. Multithreading can proove optimal for make user interaction (UI) 
            programs responsive.
            <br></br>
            These programs have to wait for the user to interact with them, so using threads 
            provides enough computing power. 
            <br></br><br></br>
            For instance: Multithreading can proove optimal for creating an 
            online writing 
            program in which one thread could track the user's keystrokes, 
            a second thread could display the text for the user to read and a third 
            thread could check the inputted text to identify spelling and grammar errors.
            <br></br><br></br>
            2. Multithreading can proove optimal for creating I/O-bound or network-bound 
            applications.
            <br></br>
            Threads can provide all the computing power needed to access web servers 
            and download content from the internet. 
            <br></br><br></br>
            For instance: many data scientists use multithreading to create web 
            scraping applications.
            <br></br><br></br>
            3. Multiprocessing can proove optimal for creating computation-intensive 
            programs.
            <br></br>
            Multiprocessing can help analyzing large volumes of data quickly.
            <br></br><br></br>
            4. Multiprocessing can proove optimal for develop programs that 
            are CPU intensive.
            <br></br>
            Multiprocessing can help to speed up processes and provide 
            reliable solutions for programs that involve several CPU tasks.
            <br></br><br></br>
        </concurrent-programming>
        <bitwise-operators>
            The <code>&#38;</code> (bitwise AND) in C takes two numbers as operands and does AND on every bit 
            of two numbers. <br></br>
            The result of AND is 1 only if both bits are 1.  
            <br></br><br></br>
            The <code>|</code> (bitwise OR) in C takes two numbers as operands and does 
            OR on every bit 
            of two numbers. <br></br>
            The result of OR is 1 if any of the two bits is 1. 
            <br></br><br></br>
            The <code>^</code> (bitwise XOR) takes two numbers as operands and does XOR on every 
            bit of two numbers.<br></br> 
            The result of XOR is 1 if the two bits are different. 
            <br></br><br></br>
            The <code>&lt;&lt;</code> (left-shift) takes two numbers, left-shifts the bits of the 
            first operand, and the second operand decides the number of places to shift. 
            <br></br><br></br>
            The <code>&gt;&gt;</code> (right-shift) takes two numbers, right-shifts the bits of the 
            first operand, and the second operand decides the number of places to shift.
            <br></br><br></br>
            The <code>~</code> (bitwise NOT) takes one number and inverts all bits of it.
            <br></br><br></br>
            
            The left-shift and right-shift operators should not be used for 
            negative numbers.<br></br>
            The left-shift and right-shift operators are equivalent to 
            multiplication and division by 
            2 respectively.<br></br><br></br>
            
            
            The bitwise OR of two numbers is just the sum of those two numbers if there is no carry 
            involved, otherwise, you just add their bitwise AND.
            <br></br><br></br>
            
            Let’s say, we have <code>a=5(101)</code> and <code>b=2(010)</code>, since there is no carry involved, 
            their sum is just <code>a|b</code>. <br></br>
            Now, if we change 'a' to 6 which is 110 in binary, their sum would change 
            to <code>a|b + a&#38;b</code> since there is a carry involved.
            <br></br><br></br>
            The bitwise XOR operator is the most useful operator from a technical interview perspective.
            <br></br><br></br>
            It is used in many problems. <br></br>
            <br></br>
            
            The <code>&#38;</code> operator can be used to quickly check if a number is odd or even.<br></br>

            The value of the expression <code>(x &#38; 1)</code> would be non-zero only if x is odd, otherwise, 
            the value would be zero. <br></br><br></br>
            
            The <code>~</code> operator should be used carefully.
            <br></br><br></br>
            The result of the <code>~</code> operator on a small number can be a big number if the result 
            is stored in an unsigned variable. <br></br><br></br>
            
            The result may be a negative number if the result 
            is stored in a signed variable (assuming that the negative numbers are stored into a
            complement form where the leftmost bit is the sign bit).<br></br>
            
        </bitwise-operators>
        <macros>
            Macros are powerful tools that allow developers to define reusable code snippets. 
            <br></br><br></br>
            They are defined using preprocessor directives and primarily used for 
            code substitution and generation. 
            <br></br><br></br>
            Macros provide a convenient way to write concise and 
            efficient code, 
            improving the readability and maintainability of programs.
            <br></br><br></br>
<code>
// Program to illustrate macros

#include &lt;stdio.h&gt;
 
// Macro definition
#define AREA(l, b) (l * b)
 
int main()
{
    // Given lengths l1 and l2
    int l1 = 10, l2 = 5, area;
 
    // Find the area using macros
    area = AREA(l1, l2);
 
    // Print the area
    printf("Area of rectangle"
           " is: %d",
           area);
 
    return 0;
}
</code>        
            <br></br>
            <green>
            Object-Like Macros:
            </green>
            <br></br><br></br>
            An object-like macro is a simple identifier that will be 
            replaced by a code fragment. 
            <br></br>
            It is called object-like because it looks like an object in code that uses it. 
            <br></br><br></br>
            <brown>
            It is popularly used to replace a symbolic name with a numerical/variable represented 
            as a constant.
            </brown>
            <br></br><br></br>
<code>
//Chain Macros
  
// Macro definition
#define INSTAGRAM FOLLOWERS
#define FOLLOWERS 138 

/*
Both macros INSTAGRAM and FOLLOWERS have same value - 138
*/


Multi-line macros
#include &lt;stdio.h&gt;
 
// Multi-line Macro definition
#define ELE 1, \
            2, \
            3
 
int main()
{
 
    // Array arr[] with elements
    // defined in macros
    int arr[] = { ELE };
 
    // Print elements
    printf("Elements of Array are:\n");
 
    for (int i = 0; i &lt; 3; i++) {
        printf("%d  ", arr[i]);
    }
    return 0;
}
  
</code>
        </macros>
        <defines>
            In programming, <code>#define</code> is a preprocessor directive that is used to define macros. 
            <br></br><br></br>
            The macros are the identifiers which are replaced by their value before 
            compilation. <br></br><br></br>
            We can define constants and functions like macros using <code>#define</code>.
        </defines>
        <command-line-arguments>
            Command-line arguments are passed to the main function 
            as (<code>argc</code>, <code>argv</code>), or (<code>args</code>). 
            <br></br>
            Command-line arguments are used to control the program from 
            the outside.
            <br></br><br></br>
            <green>For C/C++:</green>
            <br></br><br></br>
            In languages such as C and C++ both <code>argc</code> and <code>argv</code> are being 
            used for this purpose as follows:
            <br></br><br></br>
            The name of the program is 
            stored in <code>argv[0]</code>, the first command-line parameter in <code>argv[1]</code>, 
            and the    last argument in <code>argv[n]</code>.
            <br></br><br></br>
            <code>argc</code> - argument count is an integer variable that stores
            the number of command-line 
            arguments passed by the user including the name of the program. 
            So if we pass a 
            value to a program, the value of <code>argc</code> would be 2 
            (one for argument and one for 
            program name). 
            <br></br><br></br>
            The value of argc should be non-negative.
            
            <br></br><br></br>
            <code>argv</code> - argument vector is an array of character pointers 
            listing all the arguments.
            If <code>argc</code> is greater than zero, the array elements from <code>argv[0]</code> 
            to <code>argv[argc-1]</code> will 
            contain pointers to strings.<br></br><br></br>
            <code>argv[0]</code> is the name of the program. 
            <br></br><br></br>
            After that until <code>argv[argc-1]</code> every element 
            is a command-line argument.
            <br></br><br></br>
            <brown>Properties of command-line arguments in C/C++:</brown>
            <br></br><br></br>
            
            <code>argv[argc]</code> is a NULL pointer.<br></br>
            <code>argv[0]</code> holds the name of the program.<br></br>
            <code>argv[1]</code> points to the first command-line argument and <code>argv[argc-1]</code> points to 
                the last argument.
            
            <br></br><br></br>
            <green>For Java/C#:</green>
            <br></br><br></br>
            In programming languages such as: C# and Java, only one variable is used to 
            store the command-line arguments: <code>args</code>
            <br></br><br></br>
            In these languages <code>args</code> is declared as an array of 
            string 
            elements. The length of the <code>args</code> can be obtained by using the OOP 
            attributes of the string
            class defined in those languages: <code>args.length</code> (in Java) 
            or <code>args.Length</code> (in C#).
            <br></br><br></br>
            <green>Overall properties of Command-Line Arguments:</green>
            <br></br><br></br>
            
            They are passed to the <code>main()</code> function.<br></br>
            They are parameters/arguments supplied to the program when it is invoked.<br></br>
            They are used to control programs from outside instead of hard coding those values 
            inside the code.
            
            <br></br><br></br>
        </command-line-arguments>
        <ternary-operator>
            Ternary operator is used for decision making instead of placing longer <code>if</code> and <code>else</code>
            conditional statements.
            <br></br><br></br>
            Syntax:
            <code>condition ? value_if_true : value_if_false</code>
            <br></br>
            The statement evaluates to <code>value_if_true</code> if condition is met, and <code>value_if_false</code> 
            otherwise.<br></br><br></br>
            
            <green>The ternary operator take three arguments:</green>
            <br></br><br></br>
            
            The first is a comparison argument;<br></br>
            The second is the result upon a <code>true</code> comparison;<br></br>
            The third is the result upon a <code>false</code> comparison;<br></br><br></br>
            
        </ternary-operator>
        <modular-programming>
            Modular programming consists of separating implementation from interface and 
            hiding information in the implementation.
            <br></br><br></br>
            <green>Advantages of modular programming:</green>
            <br></br><br></br>
            
            <indigo>Code is easier to read:</indigo><br></br>
            Working on modular programming makes code easier 
            to read 
            because functions perform different tasks as compared to monolithic codes. 
            Sometimes modular programming can be a bit messy if we pass arguments and 
            variables in different functions. 
            The use of modules should be done in a 
            sensible manner so as to avoid any problem. <br></br>
            Functions should be neat, clean, 
            and descriptive.<br></br><br></br>
            
            <indigo>Code is easier to test:</indigo><br></br>
            In software, some functions perform fewer tasks than
            other functions. If the software is easily split 
            using modules, it becomes easier to test. <br></br>
            We can also focus on the riskier 
            functions during testing and use more test cases to make it bug-free.<br></br><br></br>
            
            <indigo>Reusability:</indigo><br></br>  
            There are times where a piece of code is implemented 
            everywhere in 
            our program. Instead of copying and pasting it, again and again, modularity 
            gives us the advantage of reusability so that we can pull our code from 
            anywhere using interfaces or libraries. <br></br>
            The concept of reusability also 
            reduces the size of our program.<br></br><br></br>
            
            <indigo>Faster fixes:</indigo><br></br>            
            Suppose there is an error in the payment options in any 
            application, and the bug needs to be removed. Modularity can be a great help 
            because we know that there will be a separate function that will contain the 
            code of payments, and only that function will only be rectified.<br></br>
            Using modules to find and fix bugs becomes much more 
            smooth and maintainable.<br></br><br></br>
            
            <indigo>Low-risk update:</indigo><br></br>
            In modular programming, a defined layer of APIs protects 
            things that 
            use it from making changes inside the library. Unless there is a change in the API, 
            there is a low risk for someone's code-breaking. <br></br>
                        For example, if you didn't have 
            explicit APIs and someone changed a function they thought was only used within that 
            same library (but it was used elsewhere), they could accidentally break 
            something.<br></br><br></br>
            
            
            <indigo>Easy collaboration:</indigo><br></br>
            
            Different developers work on a single piece of code in the team. 
            There are chances of conflicts when there's a git merge. 
            This conflict can be reduced 
            if the code is split between more functions, files, repos, 
            etc. <br></br>
            We can also provide 
            ownership to specific code modules, where a team member can break them down into 
            smaller tasks.<br></br><br></br>
            
            <green>Disadvantages of modular programming:</green>
            <br></br><br></br>
            
            <indigo>Requires more resources:</indigo><br></br>
            There is a need for extra time and 
            budget for a product in modular programming.
            <br></br><br></br>
            
            <indigo>Increases the risk and the difficulty:</indigo><br></br>
            It is a challenging task to 
            combine and integrate all the modules into a single program.
            <br></br><br></br>
            
            <indigo>Additional efforts needed for the design:</indigo><br></br> 
            The design should be carefully defined 
            so that the impact for the other program modules is minimum.
            <br></br><br></br>
            
            <indigo>The task repetition impacts the software performance:</indigo><br></br>
            Some modules may partly 
            repeat the task 
            performed by other modules. Hence, modular programs may need more memory, 
            space and extra time for execution.
            <br></br><br></br>
            
            <indigo>The work efficiency might be impacted:</indigo><br></br>
            It reduces the program's 
            efficiency because testing and debugging are 
            time-consuming, where each function contains a thousand lines of code.
            <br></br><br></br>
            
            <indigo>The code readability might be affected:</indigo><br></br>
            Integrating various modules into a 
            single program might prove be a difficult task because 
            different people working on the design of different modules may not have the 
            same style.
            <br></br><br></br>
            
        </modular-programming>
        <datatype-conversions>
            <green>Generally there are two types of conversions:</green>
            <br></br><br></br>
            
            - implicit conversion (done automatically by the compiler)<br></br>
            - explicit conversion (done manually by the developer)<br></br>
            
            <br></br>
            Implicit conversion is done automatically by the compiler when you assign a value 
            of one type to another.<br></br><br></br>
            Explicit conversion is done manually by placing the type in parentheses <code>()</code> in front 
            of the value. Also knows as typecasting. 
            <br></br>
        </datatype-conversions>
        <operators>
            An operator is a symbol that tells the compiler to perform specific mathematical or 
            logical functions. 
            <br></br><br></br>
            By definition, an operator performs a certain operation on 
            operands. 
            <br></br>
            An operator needs one or more operands for the operation to be performed.<br></br>
            <br></br>
            Depending on how many operands are required to perform the operation, operands are called as 
            unary, binary or ternary operators.
            They need one, two or three operands respectively.<br></br>
            <br></br>
            Unary operators − <code>++</code> (increment), <code>--</code> (decrement), <code>!</code> (NOT), <code>~</code> (compliment), <code>&#38;</code> (address of), <code>*</code> (dereference)
            <br></br><br></br>
            Binary operators − arithmetic, logical and relational operators except <code>!</code>
            <br></br><br></br>
            Ternary operators − The <code>?</code> operator.
            <br></br><br></br>
            <green>Most programming languages are rich in built-in operators and provides the following types of operators:</green>
            <br></br><br></br>
            <brown>Assume variable <code>A = 10</code> and variable <code>B = 20 </code> then: 
            </brown><br></br><br></br>
            <br></br>
            <green>Arithmetic Operators: <br></br></green>
                <br></br>
                <code>+</code> it adds two operands.<br></br>
                <code>A + B = 30</code><br></br>
                <br></br>
                
                <code>−</code> it subtracts second operand from the first.<br></br>
                <code>A − B = -10</code><br></br>
                <br></br>
                
                <code>*</code> it multiplies both operands.<br></br>
                <code>A * B = 200</code><br></br>
                <br></br>
                
                <code>/</code> it divides numerator by de-numerator.<br></br>
                <code>B / A = 2</code><br></br>
                <br></br>
                
                <code>%</code> is the Modulus Operator.<br></br>
                It gives the remainder after an integer division.<br></br>
                <code>B % A = 0</code><br></br>
                <br></br><br></br>
                
                <code>++</code> is the Increment operator. <br></br>
                It increases the integer value by one.<br></br>
                <code>A++ = 11</code><br></br>
                <br></br>
                <code>--</code> is the Decrement operator.<br></br>
                It decreases the integer value by one.<br></br>
                <code>A-- = 9</code><br></br>
                <br></br>
                <green><br></br>Relational Operators:<br></br></green>
                <br></br>
                
                <code>==</code> it checks if the values of two operands are equal or not. <br></br>
                If yes, then the condition becomes true.<br></br>
                <code>(A == B) is not true.</code><br></br>
                <br></br>

                <code>!=</code> it checks if the values of two operands are equal or not.<br></br>
                If the values are not equal, then the condition becomes true.<br></br>
                <code>(A != B) is true.</code><br></br>
                <br></br>

                <code>&gt;</code> it checks if the value of left operand is greater than the value of 
                right operand.<br></br>
                If yes, then the condition becomes true.<br></br>
                <code>(A &gt; B) is not true.</code><br></br>
                <br></br>

                <code>&lt;</code> it checks if the value of left operand is less than the value of 
                right operand.<br></br>
                If yes, then the condition becomes true.<br></br>
                <code>(A &lt; B) is true.</code><br></br>
                <br></br>

                <code>&gt;=</code> it checks if the value of left operand is greater than or equal to 
                the value of right operand.<br></br>
                If yes, then the condition becomes true.<br></br>
                <code>(A &gt;= B) is not true.</code><br></br>
                <br></br>

                <code>&lt;=</code> it checks if the value of left operand is less than or equal to the value 
                of right operand.<br></br>
                If yes, then the condition becomes true.<br></br>
                <code>(A &lt;= B) is true.</code><br></br>
                <br></br>
                
                <green><br></br>Logical Operators:<br></br></green>
                <br></br>
    
                <code>&#38;&#38;</code> it's called Logical AND operator.<br></br> 
                Results in TRUE if both the operands are non-zero, 
                then the condition becomes true.<br></br>
                <code>(A &#38;&#38; B) is false.</code><br></br>
                <br></br>

                <code>||</code> it's called Logical OR Operator.<br></br>  
                Results in TRUE if any of the two operands is non-zero, 
                then the condition becomes true.<br></br>
                <code>(A || B) is true.</code><br></br>
                <br></br>

                <code>!</code> it's called Logical NOT Operator. <br></br>
                It is used to reverse the logical state of 
                its operand. 
                If a condition is true, then Logical NOT operator will make it false.
                <br></br>
                <code>!(A &#38;&#38; B) is true.</code><br></br>
                <br></br>
                
                <green><br></br>Bitwise Operators:<br></br></green>
                <br></br>
                <code>&#38;</code> binary AND Operator copies a bit to the result if it exists in both operands.<br></br>    
                <code>(A &#38; B) = 12, i.e., 0000 1100</code><br></br>
                <br></br>

                <code>|</code> binary OR Operator.<br></br>
                It copies a bit if it exists in either operand.<br></br>
                <code>(A | B) = 61, i.e., 0011 1101</code><br></br>
                <br></br>
                <code>^</code> binary XOR Operator.<br></br>
                It copies the bit if it is set in one operand but not both.<br></br>
                <code>(A ^ B) = 49, i.e., 0011 0001</code><br></br>
                <br></br>
                <code>~</code> binary One's Complement Operator.<br></br>
                Is unary and has the effect of 'flipping' bits.<br></br>
                <code>(~A ) = ~(60), i.e,. -0111101</code><br></br>
                <br></br>
                <code>&lt;&lt;</code> binary Left Shift Operator.<br></br>
                The left operands value is moved left by the number of bits specified by the 
                right operand.<br></br>
                <code>A &lt;&lt; 2 = 240 i.e., 1111 0000</code><br></br>
                <br></br>
                <code>&gt;&gt;</code> binary Right Shift Operator. <br></br>
                The left operands value is moved right by the number of bits specified 
                by the right operand.<br></br>
                <code>A &gt;&gt; 2 = 15 i.e., 0000 1111</code><br></br>
                <br></br>
                
                <green><br></br>Assignment Operators:<br></br></green>
                <br></br>
                <code>=</code> is the assignment operator. <br></br>
                Assigns values from right side operands to left side operand.<br></br>
                <code>C = A + B will assign the value of A + B to C</code><br></br>
                <br></br>
                <code>+=</code> the add AND assign operator. <br></br>
                It adds the right operand to the left operand and assign the result 
                to the left operand.<br></br>
                <code>C += A is equivalent to C = C + A</code><br></br>
                <br></br>
                <code>-=</code> Subtract AND assignment operator. <br></br>
                It subtracts the right operand from the left operand and assigns 
                the result to the left operand.<br></br>
                <code>C -= A is equivalent to C = C - A</code><br></br>
                <br></br>
                <code>*=</code> Multiply AND assignment operator. <br></br>
                It multiplies the right operand with the left operand and assigns 
                the result to the left operand.<br></br>    
                <code>C *= A is equivalent to C = C * A</code><br></br>
                <br></br>
                <code>/=</code> the divide AND assign operator. <br></br>
                It divides the left operand with the right operand and assigns the 
                result to the left operand.<br></br>
                <code>C /= A is equivalent to C = C / A</code><br></br>
                <br></br>
                <code>%=</code> the modulus AND assign operator. <br></br>
                It takes modulus using two operands and assigns the 
                result to the left operand.<br></br>
                <code>C %= A is equivalent to C = C % A</code><br></br>
                <br></br>
                <code>&lt;&lt;=</code> the Left shift AND assign operator.<br></br>
                It takes the value stored in variable C shifts it to the left by 
                the number of bits specified 
                after the equal sign and then assigns the result of the operation back to C variable<br></br>
                <code>C &lt;&lt;= 2 is same as C = C &lt;&lt; 2</code><br></br>
                <br></br>
                <code>&gt;&gt;=</code> the Right shift AND assign operator.<br></br>
                It takes the value stored in variable C shifts it to the right by the 
                number of bits specified after the equal sign and then assigns the result of the 
                operation back to C variable.<br></br>
                <code>C &gt;&gt;= 2 is same as C = C &gt;&gt; 2</code><br></br>
                <br></br>
                <code>&#38;=</code> the bitwise AND assign operator.<br></br>
                It takes the value stored in variable C performs bitwise AND with 
                the value specified after the equal sign and then assigns the result of 
                the operation back to C variable.<br></br>
                <code>C &#38;= 2 is same as C = C &#38; 2</code><br></br>
                <br></br>
                <code>^=</code> the bitwise exclusive OR and assign operator.<br></br>
                It takes the value stored in variable C performs bitwise XOR with the value 
                specified after the equal sign and then assigns the result of the 
                operation back to C variable.<br></br>
                <code>C ^= 2 is same as C = C ^ 2</code><br></br>
                <br></br>
                <code>|=</code> the bitwise inclusive OR and assign operator.<br></br>
                It takes the value stored in variable C performs bitwise OR with the 
                value specified after the equal sign and then assign the result of the 
                operation back to C variable.<br></br>
                <code>C |= 2 is same as C = C | 2</code><br></br>
                <br></br>
        </operators>
        <pre-post-incrementation>
            Increment operators are used to increase the value of a variable by 1.<br></br>
            This operator is represented by the <code>++</code> symbol. <br></br><br></br>
            The increment operator can either
            increase the value of the variable by 1 before assigning it to the variable or 
            can increase the value of the variable by 1 after assigning the variable. 
            Thus it can be classified into two types
            <br></br><br></br>
            <green>Classification of the increment operator:</green>
            <br></br><br></br>
            
            <brown>Pre-Increment Operators:</brown><br></br>
<code>
a = ++x; // first x will be incremented then value of x is assigned to a;
</code>
            <br></br>
            <brown>Post-Increment Operator:</brown><br></br>
<code>
a = x++; // first x value is assigned to a, then the value of x gets incremented;
</code>
            
        </pre-post-incrementation>
        <constructors>
            A constructor is a special method that is automatically called when an object 
            of a <code>class</code> is created.
            <br></br><br></br>
            Constructors can also take parameters (just like 
            regular functions), which can be useful for setting initial 
            values for attributes.<br></br>
        </constructors>
        <instantiation>
            In object-oriented programming, an instance is a concrete realization 
            of a class. 
            <br></br><br></br>
            When you define a <code>class</code>, you're essentially creating a blueprint. 
            <br></br><br></br>
            An instance is an object built from that blueprint. <br></br>
            It has all the characteristics defined in the <code>class</code>, but with specific values.
            <br></br>
        </instantiation>
        <destructors>
            Destructor is an instance member function that is invoked automatically whenever an object is 
            going to be destroyed. <br></br><br></br>
            The destructor is the last function that is going to be called before an 
            object is destroyed.
            <br></br><br></br>
            <green>About destructors:</green>
            <br></br><br></br>
            
            - A destructor is also a special member function like a constructor. <br></br>
            - Destructor destroys the class objects created by the constructor. <br></br>
            - Destructor has the same name as their <code>class</code> name preceded by a 
            tilde (<code>~</code>) symbol.<br></br>
            - It is not possible to define more than one destructor. <br></br>
            - The destructor is the only one way to destroy the object created by the constructor. 
            <br></br>
            - The destructor can-not be overloaded.
            <br></br>
            - Destructor neither requires any argument nor returns any value.<br></br>
            - It is automatically called when an object goes out of scope. <br></br>
            - Destructor release memory space occupied by the objects created by the constructor.<br></br>
            - In destructor, objects are destroyed in the reverse of an object creation.<br></br>
            
        </destructors>
        <function-overloading>
            Function overloading is a feature of object-oriented programming 
            where two or more 
            functions can have the same name but different parameters. <br></br><br></br>
            Function overloading can be considered as an example of a polymorphism 
            feature.
            <br></br><br></br>
            Multiple functions having same name but different parameters is 
            known as function overloading.<br></br>
            If we have to perform one operation then having same name for the functions 
            doing it increases 
            the readability of the program.
            <br></br><br></br>
            <green>Function Overloading vs. Function Overriding:</green>
            <br></br><br></br>
            Function/Method overloading refers to defining multiple functions/methods 
            with the same name but different parameters within the same class, 
            while function/method overriding involves 
            creating a function/method in the child class that has the same name, 
            parameters, and 
            return type as a function/method in the parent class.
            <br></br><br></br>
            <brown>
            Overloaded functions can be defined both outside and inside classes.
            </brown><br></br>
        </function-overloading>
        <operator-overloading>
            Operator overloading is a compile-time polymorphism. <br></br><br></br>
            It is an idea of giving special meaning to an existing operator 
            without changing its original meaning. <br></br>
        </operator-overloading>
        <namespaces>
            A namespace is a feature which can be defined as a
            declarative region that provides a scope to the 
            identifiers (names of functions, 
            variables or other user-defined data types) inside it. 
            <br></br>
        </namespaces>
        <exception-handling>
            In computer programming exceptions are runtime anomalies or abnormal conditions that a program 
            encounters during its execution. 
            <br></br><br></br>
            The process of handling these exceptions is 
            called exception handling. <br></br>
            <br></br>
            Using the exception handling mechanism, the control 
            from one part of the program where the exception occurred can be transferred 
            to another part of the code.
            <br></br><br></br>
            By using exception handling we can handle the anomalies so that our 
            program keeps running.<br></br>
        </exception-handling>
        <default-parameters>
            A default parameter/argument is a value provided in a function declaration that is 
            automatically assigned by the compiler if the calling function doesn’t provide 
            a value for the argument. <br></br>
            <br></br>
            In case any value is passed, the default value is 
            overridden. <br></br>
        </default-parameters>
        <interfaces>
            In programming: an interface describes the behavior or capabilities of a class without 
            committing to a particular implementation of that class.
            <br></br><br></br>
            The interfaces are implemented using abstract classes and these abstract classes
            should not be confused with data abstraction which is a concept of keeping 
            implementation details separate from associated data.<br></br>
        </interfaces>
        <abstract-classes>
            The purpose of an abstract class (often referred to as an ABC) is to provide an 
            appropriate base class from which other classes can inherit. <br></br>
            <br></br>
            Abstract classes cannot be used to instantiate objects and serves only as an 
            interface. <br></br>
            Attempting to instantiate an object of an abstract class causes a 
            compilation error. <br></br>
            <br></br>
            If a subclass of an ABC needs to be instantiated, it has to implement each of 
            the virtual/abstract functions, which means that it supports the 
            interface declared by the 
            ABC. <br></br><br></br>
            Failing to override a pure virtual/abstract function in a 
            derived class, 
            then attempting to instantiate objects of that <code>class</code>, is a compilation error.
            <br></br><br></br>
            An object-oriented system might use an abstract base class to provide a common and 
            standardized interface appropriate for all the external applications. <br></br>
            Through inheritance from the abstract base class, derived classes are 
            formed that operate similarly.
            <br></br><br></br>
            The capabilities (i.e., the public functions) offered by the external applications 
            are provided as pure virtual/abstract functions in the abstract base class. 
            <br></br><br></br>
            The implementations of these pure virtual/abstract functions are provided in 
            the derived 
            classes that correspond to the specific types of the application.<br></br>
        </abstract-classes>
        <optional-parameters>
            A parameter with a default value, is often known as an "optional parameter".
            <br></br><br></br> 
            For more information see the default-parameters section.
        </optional-parameters>
        <decorators>
            Decorator is a structural pattern that allows adding new behaviors to objects 
            dynamically by placing them inside special wrapper objects , called decorators. 
            <br></br><br></br>
            Using decorators you can wrap objects  countless number of times since both target 
            objects  and decorators follow the same interface.<br></br>
        </decorators>
        <generic-programming>
            Generic programming is a style of computer programming in which 
            algorithms are 
            written in terms of data types to-be-specified-later that are then instantiated 
            when needed for specific types provided as parameters.
            <br></br><br></br>            
            The functions and classes which are data type independent 
            are called generics, 
            and this concept is called generic programming. 
            <br></br><br></br>
            <brown>
            Generic Programming provides efficiency by reducing code 
            repetition and in-demand compilation.
            </brown>
            <br></br>
        </generic-programming>
        <abstraction>
            Abstraction means displaying only essential information and hiding the 
            details. <br></br><br></br>
            Abstraction is a powerful technique that allows for a separation of 
            concerns between the 
            interface and implementation of a <code>class</code>. 
            <br></br><br></br>
            It helps to reduce complexity and improve 
            maintainability by allowing changes to be made to the 
            implementation without affecting 
            the overall behavior of the <code>class</code>.
            <br></br><br></br>
            Can be used to create a base implementation or contract for the 
            actual implementation from base classes.
            <br></br><br></br>
            <green>Types of Abstraction in OOP:</green>
            <br></br><br></br>
            <brown>Data abstraction:</brown>
            <br></br><br></br>
            Data abstraction is one of the most essential and important features of 
            object-oriented programming. 
            <br></br><br></br>
            Data abstraction refers to providing only essential information 
            about the data to the outside world, hiding the background details or implementation. 
            <br></br><br></br>
            Using data abstraction, we are not allowed to access the variables directly, however, 
            one can call the setter function to set the values or the 
            getter function to get the values.
            <br></br><br></br>
            
            Advantages of Data Abstraction:
            <br></br><br></br>
            
            Helps the user to avoid writing the low-level code;<br></br>
            Avoids code duplication and increases reusability.<br></br>
            Can change the internal implementation of the <code>class</code> independently 
            without affecting the user.
            <br></br>
            Helps to increase the security of an application or program as only important 
            details are provided to the user.<br></br>
            It reduces the complexity as well as the redundancy of the code, therefore 
            increasing the readability.
            
            <br></br><br></br>
            <brown>Process Abstraction:</brown>
            <br></br><br></br>
            Process abstraction focuses on abstracting the behavior or 
            processes of an object. 
            <br></br>
            It allows developers to define the methods an object that can perform without 
            specifying how these methods are implemented. 
            <br></br><br></br>
            Process abstraction is achieved through interfaces. 
            <br></br>
            Interfaces define a set of method signatures without providing the method 
            implementations, enabling multiple classes to implement the same 
            interface in different ways.
            <br></br><br></br>
            <brown>Abstraction vs. Concrete Implementation:</brown>
            <br></br><br></br>
            Abstraction provides a clear distinction between the interface 
            of an object and its internal implementation. 
            This separation enables developers to focus on 
            high-level design and promotes code reusability.
            <br></br><br></br>
            Concrete implementation, 
            on the other hand, involves the actual coding and realization of the abstract 
            concepts. Striking a balance between abstraction and concrete 
            implementation is 
            essential in creating maintainable, scalable, and 
            efficient software systems.
            <br></br><br></br>
            Abstraction is one of the 4 OOP fundamental concepts, 
            and it is regarded to abstract objects, which are the objects 
            that contain fields and methods to be inherited by their children. 
            <br></br><br></br>
            An abstract object is like a dead parent
            which has to allow inheritance to their children and nothing more.
            <br></br><br></br>
            Abstraction is the quality of dealing with ideas rather than events.
            <br></br><br></br>
            For example, when you consider the case of e-mail, complex details such as what happens 
            as soon as you send an e-mail, the protocol your e-mail, server uses, are hidden from 
            the user. 
            <br></br><br></br>
            Therefore, to send an e-mail you just need to type the content, mention the 
            address of the receiver, and click send.
            <br></br><br></br>
            Similarly, in object-oriented programming, abstraction is a process of 
            hiding the implementation details from the user, only the functionality will be 
            provided to the user. 
            <br></br><br></br>
            In other words, the user will have the information on what the object does 
            instead of how it does it.
            <br></br>
        </abstraction>
        <variable-arguments-lists>
            In programming: A function that takes a variable number of arguments 
            is called a 
            variadic function. 
            <br></br><br></br>
            A variadic function must specify at least one fixed argument 
            with an explicitly declared data type. 
            <br></br><br></br>
            Additional arguments can follow, and can vary in 
            both quantity and data type.
            <br></br><br></br>
            The variable number of arguments permits a function to 
            accept any number of arguments.
            <br></br>
        </variable-arguments-lists>
        <random-generators>
            A random number generator forms the backbone of creating pseudo-random numbers.
            <br></br><br></br>
            The idea behind pseudo-random numbers is that a computer does not have a thinking 
            process to select a random number. <br></br><br></br>
            So even though an output number produced may seem random, the values are 
            mathematically computed.
        </random-generators>
        <preprocessor-directives>
            Preprocessor directives are lines of the source file where the first non-whitespace 
            character is <code>#</code> , which distinguishes them from other lines of text. 
            <br></br><br></br>
            The effect of each preprocessor directives is a change to the text and the 
            result is a 
            transformation of the text that does not contain the directives nor comments.
            <br></br><br></br>
            <green>The #define preprocessor as example:</green>
            <br></br><br></br>
            The <code>#define</code> preprocessor directive creates symbolic constant. 
            <br></br>
            <br></br>
            The symbolic constant is called a macro and the general form of the 
            directive is:<br></br>
<code>
#define macro-name replacement-text
</code>
            <br></br>
        </preprocessor-directives>
        <collections>
            In computer programming: A collection is an object that groups 
            multiple elements into a single unit.
            <br></br><br></br> 
            Collections are used to store, retrieve, manipulate, and communicate 
            aggregate data.
            <br></br>
        </collections>
        <read-from-file>
            File handling is the process in which we create, open, 
            read, write, and close operations on a file.
            <br></br> <br></br> 
            A file is a collection of data stored in the secondary memory. 
            <br></br><br></br> 
            The data is entered into the programs through the keyboard. 
            <br></br><br></br> 
            Files are used for storing information that can be processed 
            by the programs. 
            <br></br><br></br> 
            Files are not only used for storing the data, programs are also 
            stored in files.
            <br></br><br></br>
            <green>Features of file handling:</green>
            <br></br><br></br>
            <indigo>Reusability:</indigo><br></br>
            The data stored in the file can be accessed, 
            updated, and deleted anywhere and anytime providing  
            high reusability.
            <br></br><br></br>
            <indigo>Portability:</indigo><br></br>
            Without losing any data, files can be transferred to 
            another in the computer system. The risk of flawed coding is 
            minimized with this feature.
            <br></br><br></br>
            <indigo>Efficiency:</indigo><br></br>
            A large amount of input may be required for some programs. 
            File handling allows you to easily access a part of a file using few 
            instructions which saves a lot of time and reduces the chance of errors.
            <br></br><br></br>
            <indigo>Storage Capacity:</indigo><br></br>
            Files allow you to store a large amount of data 
            without having to worry about storing everything simultaneously in a program.
            <br></br><br></br>
        </read-from-file>
        <write-to-file>
            When a program is terminated, the entire data is lost.
            <br></br><br></br>  
            Storing in a file will preserve your data even if the 
            program terminates.
            <br></br><br></br>  
            A file is a container in computer storage devices used for storing 
            data.
            <br></br> 
        </write-to-file>
        <inheritance>
            Inheritance allows programmers to create classes that are built 
            upon existing 
            classes, to specify a new implementation  while maintaining the 
            same behaviors
            (realizing an interface), to reuse code and to independently extend 
            original software via <code>public classes</code> and <code>interfaces</code>.
            <br></br><br></br>
            Inheritance consist in classes that can inherit other classes 
            behaviour and functionality. 
            <br></br>
            Example: A class that inherits from another class 
            can have access to its variables and methods as if it were its own.
            <br></br><br></br>
            Inheritance is one of the 4 OOP fundamental concepts.
            <br></br>
        </inheritance>
        <recursion>
            Recursion is a programming concept available to all programming languages.
            <br></br> <br></br> 
            Recursion is achieved by using recursive functions.
            <br></br> <br></br> 
            A recursive function is a function that calls itself.
            <br></br> <br></br> 
            Recursion is a concept where the solution to a problem depends on 
            solutions to smaller instances of the same problem (as opposed to iteration).
            <br></br> 
            
            Example: <code>5! = (4!*5) = (3! * 4 * 5) = (2! *3 *4 *5)</code> etc.
            
            <br></br> <br></br> 
            A recursive function needs to have a condition or 
            exit statement in order to stop the recursion and to avoid infinite looping 
            and stack overflow.
            <br></br> <br></br> 
            <green>Stack overflow:</green>
            <br></br> <br></br> 
            Stack overflow is a type of buffer overflow error 
            which occurs when the stack memory gets exhausted and the computer program 
            still tries to use more memory space. 
            <br></br> <br></br> 
            All local variables are stored in the stack memory. 
            Every function has it's own stack, once the function ends 
            the stack is empties and everything stored is lost 
            (local variables die).
            <br></br> <br></br> 
            The overall stack memory allocated by the program is only few megabytes. 
            That's why in some programming languages we need to make use of 
            dynamic memory allocation. 
            <br></br> <br></br> 
            Dynamic memory allocation allows using the rest of the RAM memory, 
            and enables 
            using global variables, or variables stored in heap 
            (variables that don't die).
            These variables live through the lifetime of the program or can be 
            deallocated
            when no longer needed. 
            <br></br><br></br>
            <green>
                Recursion vs Loops:
            </green>
            <br></br><br></br>
            Using the loop: the code is easier to read and understand 
            (reading code is always a lot harder than writing it), and loops are 
            generally faster.
            <br></br><br></br>
            Recursion is useful when it is the natural way of viewing the problem, 
            but you must be sure that there is a manageable number of stack frames 
            involved. 
            <br></br><br></br>
            A stack frame is a block of memory assigned to the stack 
            when a function is called, if the stack frames exceeds the 
            stack memory capacity, the stack overflow error will occur 
            and will terminate the program.
            <br></br>
       </recursion>
        <string-methods>
            A string is a variable that holds a sequence of 
            one or more alphanumeric characters.
            <br></br><br></br> 
            It is usually possible to manipulate a string to provide information or 
            to alter the contents of a string using methods.
            <br></br>
        </string-methods>
        <reflection>
            Reflective programming or reflection is a mechanism that 
            enables a process perform 
            introspective operations, examine and modify its 
            own structure and behavior.
            <br></br>
            The reflection APIs built into programming languages allows
            developers to inspect code at runtime.
            <br></br><br></br>
            Reflection is used to obtain information about the software implementation 
            (the metadata), while it is in runtime. 
            <br></br><br></br>
            Also reflection is the ability of inspecting the code's metadata 
            in runtime.
            The metadata is related to the implementation, contains the 
            information about the fields, methods, properties, 
            variable, etc. used inside the software.
        </reflection>
        <functions>
            In computer programming: a function is a block of organized, reusable code that 
            is used to perform a single, related action.
            Functions provide better modularity for your application and a high degree 
            of code reusing.
            Functions can be defined with parameters, these are local variables whose scope
            is on function level. Once the function ends, the variables die, and all the data
            stored in them is lost, so if everything should be kept alive, it has to be returned
            back to the caller function and stored.
            <br></br>
            <green>Default Parameters/Arguments in Python:</green>
            <br></br><br></br>
            All parameters/arguments in the Python are passed by reference. 
            <br></br>
        </functions>
    </manifest>
    
    <manifest>
        <name>C</name>
        <description>
            C is a general-purpose computer programming language.<br></br><br></br>
            It was created in the 1970s by Dennis Ritchie, and remains very widely used and 
            influential. <br></br><br></br>
            By design, C's features cleanly reflect the 
            capabilities of the targeted CPUs. It has found lasting use in operating 
            systems, device drivers, and protocol stacks, but its use in application 
            software has been decreasing. <br></br><br></br>
            C is commonly used on computer architectures that range from the largest 
            supercomputers to the smallest microcontrollers 
            and embedded systems.
        </description>
        <generic-programming>
            *General-Programming-Knowledge*
            <br></br>
            <green>
            In C Language generic programming can be achieved using:
            </green>
            <br></br><br></br>
            
            Variable argument lists;<br></br>
            Using <code>void *</code> and function pointers to write generic code;<br></br>
            Using libraries to reuse code without copying and recompiling;<br></br>
            Using plugins to get run-time overriding;<br></br>
            Using macros;
            
<code>
//Example of generic programming in C using function-like macros:

#include &lt;stdio.h&gt;

#define incr(x) (++(*x))

int main()
{

    int i=5;
    float f=5.6f;
    char c='a';

    incr(&#38;i);
    incr(&#38;f);
    incr(&#38;c);

    printf("i=%d; f=%f; c=%c\n", i,f,c);

    return 0;
}
</code>
        </generic-programming>
        <variable-arguments-lists>
            *General-Programming-Knowledge*
            <br></br>
            C language allows a function call to have a variable number of
            arguments with the variable argument list mechanism.<br></br>
            Use ellipsis <code>...</code> to denote a variable number of arguments to
            the compiler. 
            <br></br><br></br>
            The ellipsis can only occur at the end of an
            argument list.<br></br><br></br>
            <green>
            Here are some standard function calls that use variable
            argument lists:
            </green>
            <br></br><br></br>
            <code>int printf(const char *format, ...);</code><br></br>
            <code>int scanf(const char *format, ...);</code><br></br>
            <code>int execlp(const char *file, const char *arg, ...);</code><br></br>
<code>
//Example of variadic functions in C:

#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;

int AddNumbers(int n, ...)
{
    // Variadic function to add numbers
    
    int Sum = 0;

    //Declaring pointer to the argument list
    //va_list type comes from stdarg.h
    va_list ptr;

    //Initializing argument to the list pointer
    //va_start function comes from stdarg.h
    va_start(ptr, n);

    for (int i = 0; i &lt; n; i++)
    {
        //Accessing current variable and 
        //pointing to next one
        Sum += va_arg(ptr, int);
        //va_arg function comes from stdarg.h
    }
    // Ending argument list traversal
    va_end(ptr);
    //va_end function comes from stdarg.h
    
    return Sum;
}
</code>
        </variable-arguments-lists>
        <simple-data-types>*General-Programming-Knowledge*</simple-data-types>
        <complex-data-types>*General-Programming-Knowledge*
            <br></br><br></br>
            <green>
            The C programming language, as of C99, supports complex number math with the three 
            built-in complex types:
            </green>
            <br></br><br></br>
            <code>double _Complex</code><br></br>
            <code>float _Complex</code><br></br>
            <code>long double _Complex</code><br></br>
            <br></br>
            When the header <code>complex.h</code> is 
            included, the three complex number types are also accessible as <code>double complex</code>, 
            <code>float complex</code>, <code>long double complex</code>.<br></br><br></br>
        </complex-data-types>
        <preprocessor-directives>
            *General-Programming-Knowledge*
        </preprocessor-directives>
        <loops>*General-Programming-Knowledge*</loops>
        <collections>
            *General-Programming-Knowledge*
            <br></br>
            <code>Arrays</code> are collections of elements of the same data type with fixed size. 
            <br></br>
            Once the array is defined, its size cannot be changed.
            <br></br><br></br>

<code>
/*Declaring arrays and initializing arrays*/

int arr[5];
int array_initialized[7] = [1,2,3,4,5,6,7];
float array_floats[3] = [2.0f, 3.0f, 2.11f];
</code>
            <br></br>
            The <code>linked list</code> is a complex data type, which consists of a structure with 
            at least 2 elements: value and pointer
            to the next element. <br></br>
            The memory can be allocated dynamically for each element added to the list. 
            <br></br><br></br>

            The main benefit of a <code>linked list</code>
            consists in the possibility of adding a variable number of elements, being able to 
            delete or add an element 
            without making copies
            or exchanges, but only by changing the addresses of the assigned pointers for 
            the next / previous element.
            <br></br><br></br>
            
<code>
//Declaring and initializing a Linked List

void createAddElementsOnLinkedList()
{
    //Linked list definition:
    struct LinkedList{
        int value; // this will store the value
        
        // this will store the address of the previous block of memory
        struct LinkedList * previous;
        
        // this will store the address of the next block of memory
        struct LinkedList * next; 
    };

    struct LinkedList* list = NULL; // creating a linked list

    int counter = 0;
    while(counter &lt; 10)
    {
        // if this is the first element to be introduced on the linked list
        if(list == NULL)
        {
            // allocate memory.
            list = (struct LinkedList* )malloc(sizeof(struct LinkedList));
            
            // add value
            list->value = counter;
            
            // there is no previous element.
            list->previous = NULL;
            
            // we don't know if there will be a next element.
            list->next = NULL; 
        }

        else //enter here after the first element was added.
        {
            // allocate space for the next element
            list->next = (struct LinkedList* ) malloc(sizeof(struct LinkedList)); 
            
            // we're still on the previous element, 
            //so assign the link to the next element.previous
            list->next->previous = list;
            
            // next element become current element
            list = list->next;
            
            // add value
            list->value = counter;
            
            // we don't know if there will be a next element.
            list->next = NULL;  
        }
        counter++;
    }

    //printing the linked list

    // list is currently pointing to the last element. 
    //So we will display it from last to first.
    while(list != NULL) 
    {
        printf("%d ", list->value);
        list = list->previous; // go to the previous
    }
}
</code>
        </collections>
        <collection-methods>
            There are no built-in functions for working with collections in C language.
        </collection-methods>
        <dynamic-memory-allocation>*General-Programming-Knowledge*</dynamic-memory-allocation>
        <read-from-file>
            *General-Programming-Knowledge*
            <green>File handling in C:</green>
            <br></br><br></br>
            C programming language supports four pre-defined functions to 
            read contents from a file, defined in <code>stdio.h</code> header file:
            <br></br><br></br>
            <code>fgetc()</code><br></br>
            This function is used to read a single character from the file.<br></br><br></br>
            <code>fgets()</code><br></br>
            This function is used to read strings from files.
            <br></br><br></br>
            <code>fscanf()</code><br></br>
            This function is used to read formatted input from a file.<br></br><br></br>
            <code>fread()</code><br></br>
            This function is used to read the block of raw bytes from files. This is used 
            to read binary files.
            <br></br><br></br>
            <green>
            Opening a file:
            </green>
            <br></br><br></br>
            To open a file use: <code>fopen(filename, mode)</code>;
            <br></br><br></br>
            Where:<br></br><br></br>
            <code>filename</code><br></br>    
            The name of the actual file you want to open (or create), like filename.txt.
            <br></br><br></br>
            <code>mode</code><br></br>    
            A single character, which represents what you want to do with the file 
            (read, write or append):<br></br><br></br>
            <code>w</code> - Writes to a file;<br></br>
            <code>a</code> - Appends new data to a file;<br></br>
            <code>r</code> - Reads from a file;<br></br>
    
<code>
/*Read file char by char*/

//FILE is basically a data type, and we need to 
//create a pointer variable to work with it 
FILE* ptr; 
char ch;

// Opening file in reading mode
ptr = fopen("test.txt", "r");

if (NULL == ptr) {
    printf("file can't be opened \n");
}

printf("content of this file are \n");

// Printing what is written in file
// character by character using loop.
do {
    ch = fgetc(ptr);
    printf("%c", ch);

    // Checking if character is not EOF.
    // If it is EOF stop reading.
} while (ch != EOF); 

</code>

<code>
/*
Alternatively feof function can be used:
feof() function takes file pointer as argument 
and returns true if pointer reaches the end of the file. 
*/

while (!feof(ptr)) 
{
    ch = fgetc(ptr);
    printf("%c", ch);
}
</code>

<code>
//Reading whole content of the file as string:

//fgets() reads one string at a time from the file. fgets() returns 
//a string if it is successfully read by function or returns NULL
//if it cannot read. 

//Prototype: char * fgets(char *str, int size, FILE * ptr);

while (fgets(str, 50, ptr) != NULL) {
    printf("%s", str);
}
</code>

<code>
/*
fscanf() reads formatted input from a stream.

Approach:

fscanf reads formatted data from the files and stores it in variables.
The data in the buffer is printed on the console till the end of the 
file is reached.

*/

char buf[100];
while (fscanf(ptr, "%*s %*s %s ", buf) == 1)
    printf("%s\n", buf);
</code>
        
        </read-from-file>
        <write-to-file>
            *General-Programming-Knowledge*
            <br></br>
            To create a file, or write to a file you can use the <code>w</code> mode inside the <code>fopen()</code> function.
            <br></br><br></br>
            <green>
            Opening a file:
            </green>
            <br></br><br></br>
            Function Prototype: <code>fopen(filename, mode)</code>;
            <br></br><br></br>
            Where:<br></br><br></br>
            <code>filename</code><br></br>    
            The name of the actual file you want to open (or create), like filename.txt.
            <br></br><br></br>
            <code>mode</code><br></br>    
            A single character, which represents what you want to do with the file 
            (read, write or append):<br></br><br></br>
            <code>w</code> - Writes to a file;<br></br>
            <code>a</code> - Appends new data to a file;<br></br>
            <code>r</code> - Reads from a file;<br></br>
            <br></br>
            The <code>w</code> mode means that the file is opened for writing. 
            <br></br>
            To insert content to it, you can 
            use the <code>fprintf()</code> function and add the pointer variable (fptr in our example) and some text:
            <br></br><br></br>
            If you write to a file that already exists, the old content is deleted, and the new content 
            is inserted. 
            <br></br>
            This is important to know, as you might accidentally erase existing content.
            <br></br>
<code>
//Example of writing to file in C

//FILE is basically a data type, and we need to 
//create a pointer variable to work with it 
FILE *fptr; 

// Open a file in writing mode
fptr = fopen("filename.txt", "w");

// Write some text to the file using fprintf
fprintf(fptr, "Some text");

// Write some other text to the file fputs
fputs("Line wrote with fputs.", fp); 

// Close the file
fclose(fptr); 
// this will close the file.
</code>    
        <br></br>
        <green>
        Closing the file:
        </green>
        <br></br><br></br>
        It is considered as good practice, because it makes sure that:
        <br></br><br></br>
        
        Changes are saved properly. <br></br>
        Other programs can use the file (if you want). <br></br>
        Clean up unnecessary memory space. <br></br><br></br>
        
        If you want to add content to a file without deleting the old content, 
        you can use the <code>a</code> mode. <br></br>
        The <code>a</code> mode appends content at the end of the file:<br></br>
        
<code>
/*Example*/

FILE *fptr;

// Open a file in append mode
fptr = fopen("filename.txt", "a"); 

/*Just like with the w mode; if the file does not exist, 
the a mode will create a new file with the "appended" content.*/

// Append some text to the file
fprintf(fptr, "\nHi everybody!");

// Close the file
fclose(fptr);
</code>
        </write-to-file>
        <serialization>
            *General-Programming-Knowledge*
            C and C++ do not provide serialization as any sort of high-level construct, 
            but both languages support writing any of the built-in data types, as well as 
            plain old data structs, as binary data. 
            <br></br><br></br>
            As such, it is usually trivial to write custom serialization functions.
            <br></br>
        </serialization>
        <deserialization>
            *General-Programming-Knowledge*
            <br></br>
            C and C++ do not provide serialization as any sort of high-level construct, 
            but both languages support writing any of the built-in data types, as well as 
            plain old data structs, as binary data. 
            <br></br><br></br>
            As such, it is usually trivial to write custom serialization functions.
            <br></br>
        </deserialization>
        <enums>
            *General-Programming-Knowledge*
<code>
//Syntax: enum flag{constant1, constant2, constant3, ....... };

// An example program to demonstrate working
// of enum in C

#include &lt;stdio.h&gt;
 
enum week{Mon, Tue, Wed, Thur, Fri, Sat, Sun};
 
int main()
{
    enum week day;
    day = Wed;
    printf("%d",day);
    return 0;
} 
</code>
        </enums>
        <concurrent-programming>
            *General-Programming-Knowledge*
            <br></br>
<code>
/*Example of using multi-threading in C Language*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt; //Header file for sleep().
#include &lt;pthread.h&gt;
  
// A normal C function that is executed as a thread  
// when its name is specified in pthread_create() 

void *myThreadFun(void *vargp) 
{ 
    sleep(1); 
    printf("Printing GeeksQuiz from Thread \n"); 
    return NULL; 
} 
   
int main() 
{ 
    pthread_t thread_id; 
    printf("Before Thread\n"); 
    pthread_create(&#38;thread_id, NULL, myThreadFun, NULL); 
    pthread_join(thread_id, NULL); 
    printf("After Thread\n"); 
    exit(0); 
}
</code>
        <br></br>
        In C/C++: one of the main workhorse functions that makes multiprocessing 
        possible is <code>fork()</code>.
        <br></br><br></br>
        <code>fork()</code> is a function that clone a process, spawning an identical 
        copy of it.
        <br></br>
<code>
//Example of multi-processing in C/C++:

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/wait.h&gt;

int main(int argc, char **argv)
{
    pid_t pid = fork ();
    if (pid != 0) 
    {
        waitpid (pid, NULL, 0);
    }
    printf ("Hello, World!\n");
}
</code>
        </concurrent-programming>
        <exception-handling>
            C does not provide direct support to 
            error handling (or exception handling).
        </exception-handling>
        <bitwise-operators>
            *General-Programming-Knowledge*
            <br></br>
<code>
// Example on how to use the bitwise operators:

#include &lt;stdio.h&gt;

int main()
{
    // a = 5(00000101), b = 9(00001001)
    unsigned char a = 5, b = 9;
 
    // The result is 00000001
    printf("a = %d, b = %d\n", a, b);
    printf("a &#38; b = %d\n", a &#38; b);
 
    // The result is 00001101
    printf("a|b = %d\n", a | b);
 
    // The result is 00001100
    printf("a^b = %d\n", a ^ b);
 
    // The result is 11111010
    printf("~a = %d\n", a = ~a);
 
    // The result is 00010010
    printf("b&lt;&lt;1 = %d\n", b &lt;&lt; 1);
 
    // The result is 00000100
    printf("b&gt;&gt;1 = %d\n", b &gt;&gt; 1);
 
    return 0;
    
    /*
        OUTPUT: 
        
        a = 5, b = 9
        a&#38;b = 1
        a|b = 13
        a^b = 12
        ~a = 250
        b&lt;&lt;1 = 18
        b&gt;&gt;1 = 4
    */
}
</code>
        </bitwise-operators>
        <default-parameters>
            *General-Programming-Knowledge*
            <br></br>
            There are no default parameters in C. <br></br><br></br>
            But one way to achieve this is by passing NULL pointers and 
            then set the values to the default if NULL is passed.
            <br></br>
<code>
//Example of function with default parameters in C:

void OpenFile(char *path)
{
    FILE *outHandle;

    if (path==NULL)
    {
        outHandle=fopen("DummyFile", "w");
    }
    else
    {
        outHandle=fopen(path, "w");
    }
}

int main()
{
    char* filePath;
    OpenFile(filePath);
}
</code>
        </default-parameters>
        <interfaces>
            *General-Programming-Knowledge*
            <br></br>
            In C - an interface can be implemented as a set of function declarations without 
            any implementation details. <br></br><br></br>
            <brown>
            It defines a contract that concrete implementations must adhere to by providing 
            definitions for all the functions declared in the interface.
            </brown>
<code>
// Declare an interface for a shape
struct shape_interface 
{
  // Function pointers for the interface functions
  double (*area)(void*);
  double (*perimeter)(void*);
}; 

/*
In OOP there are classes that store to both the variables and 
the methods of an object.

In C we can have structs that store variables and function  
pointers initialized with references of functions defined 
outside the struct to hold the implementation for defined 
behaviours.

This is somehow similar to OOP.

*/
</code>
        </interfaces>
        <macros>*General-Programming-Knowledge*</macros>
        <defines>*General-Programming-Knowledge*</defines>
        <random-generators>
            The <code>rand()</code> function returns the random integers whose range from <code>0</code> to 
            <code>RAND_MAX</code>. <br></br><br></br>
            The <code>RAND_MAX</code> is a symbolic constant that defines in <code>stdlib.h</code> header file, whose value 
            is greater but less than 32767 depending on the C libraries.<br></br><br></br>
<code>
//Example of using rand() to generate random numbers

#include &lt;stdio.h&gt;    
#include &lt;conio.h&gt;  
#include &lt;stdlib.h&gt;  

void main()  
{     
    // use rand() function to generate the number  
    printf (" The random number is: %d", rand());  
    printf ("\n The random number is: %d", rand());  
      
    printf (" \n The random number is: %d", rand());  
    printf ("\n The random number is: %d", rand());  
    getch();  
}          
</code>
            <br></br>
            The <code>srand()</code> function is a C library function that determines the initial 
            point to generate 
            different series of pseudo-random numbers. 
            <br></br><br></br>
            A <code>srand()</code> function cannot be used without 
            using a <code>rand()</code> function. 
            <br></br><br></br>
            The <code>srand()</code> function is required to set the value of the seed 
            only once in a program to generate the different results of random integers before 
            calling the <code>rand()</code> function. <br></br><br></br>
<code>
//Example of using srand() to generate pseudo-random numbers

#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;time.h&gt;  // use time.h header file to use time  
      
int main()  
{  
    int num, i;  
    time_t t1; // declare time variable  
      
    printf(" Enter a number to set the limit for a random number \n");  
    scanf (" %d", &#38;num);  
      
    /* define the random number generator */  
    srand ( (unsigned) time (&#38;t1)); // pass the srand() parameter  
    printf("\n"); // print the space
    /* generate random number between 0 to 50 */  
}  
</code>
        </random-generators>
        <command-line-arguments>
            *General-Programming-Knowledge*
<code>
/*Example of command line arguments in C:*/

int main(int argc, char *argv[]) { /* ... */ }

//OR
int main(int argc, char **argv) { /* ... */ }
</code>
        </command-line-arguments>
        <ternary-operator>
            *General-Programming-Knowledge*
<code>
/*Using IF ELSE statements:*/

int a = 10, b = 20, c;

if (a &lt; b) 
{
    c = a;
}
else 
{
    c = b;
}

printf("%d", c);
</code>

<code>
/*Using TERNARY operator:*/

int a = 10, b = 20, c;

c = (a &lt; b) ? a : b;

printf("%d", c);

/*The output of both samples of code from above will result in: c = 3*/
</code>
        </ternary-operator>
        <modular-programming>
            *General-Programming-Knowledge*
            <br></br>
            In C language this is achieved by placing 
            the interface definition in a header file and the implementation in a source 
            file. <br></br>
            The disciplined use of <code>static</code> keyword is practiced in order to hide implementation details.
            <br></br><br></br>
<code>
/*FILE module.h*/
 extern unsigned int Calculate_NoOfChars_In_string(char* str);

/*FILE module.c*/
unsigned int Calculate_NoOfChars_In_string(char* str)
{
    unsigned int counter = 0;
    while(str[counter]!="\0")
    {
        counter++;
    }
    return counter;
}

/*FILE main.c*/
#include &lt;module.h&gt;  
#include &lt;stdio.h&gt;  

int main()
{
    char strA[10] = "Some text.";
    unsigned int length = Calculate_NoOfChars_In_string(strA);
    print("String length is: %d\n", length);
}
</code>
        </modular-programming>
        <string-methods>
            *General-Programming-Knowledge*
            <br></br>
            C has many useful string functions, which can be used to perform certain operations 
            on strings.<br></br><br></br>
            To use them, you must include the <code>&lt;string.h&gt;</code> header file in your program.
            <br></br><br></br>
<code>
/* GET THE SIZE (IN CHARACTERS) OF STRINGS */

char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
printf("%d", strlen(alphabet));

/* Note that sizeof and strlen behaves differently, as sizeof also 
includes the \0 character when counting.*/

/* CONCATENATE STRINGS */

char str1[20] = "Hello ";
char str2[] = "World!";

// Concatenate str2 to str1 (result is stored in str1)
strcat(str1, str2);

// Print str1
printf("%s", str1);

/* COPY STRINGS */
char str1[20] = "Hello World!";
char str2[20];

// Copy str1 to str2
strcpy(str2, str1);

// Print str2
printf("%s", str2);

/* COMPARE STRINGS */

char str1[] = "Hello";
char str2[] = "Hello";
char str3[] = "Hi";

// Compare str1 and str2, and print the result
printf("%d\n", strcmp(str1, str2));  
// Returns 0 (the strings are equal)

// Compare str1 and str3, and print the result
printf("%d\n", strcmp(str1, str3));  
// Returns -4 (the strings are not equal)
</code>
        </string-methods>
        <datatype-conversions>
            *General-Programming-Knowledge*
            <br></br>
            It is one of the important concepts introduced in 'C' 
            programming.<br></br>
<code>
//Automatic conversion: int to float
float myFloat = 9;

printf("%f", myFloat); // 9.000000

//the compiler automatically converts the int value 
//9 to a float value of 9.000000.

//Automatic conversion: float to int
int myInt = 9.99;

printf("%d", myInt); // 9

//the compiler automatically converts the float value of 
//9.99 to int value 9.
</code>

<code>
//Calculate the percentage of a user's score in relation to 
//the maximum score in a game:

//Set the maximum possible score in the game to 500
int maxScore = 500;

//The actual score of the user
int userScore = 420;

/* 
Calculate the percentage of the user's score in relation to the 
maximum available score.
Convert userScore to float to make sure that the division is accurate.
*/
float percentage = (float) userScore / maxScore * 100.0;

//Print the percentage
printf("User's percentage is %.2f", percentage);
</code>
        </datatype-conversions>
        <optional-parameters>*General-Programming-Knowledge*</optional-parameters>
        <operators>
            *General-Programming-Knowledge*
            <green><br></br>Misc Operators:<br></br></green>
                <br></br> 
                <code>sizeof()</code><br></br> 
                It returns the size of a variable. <br></br>
                <code>sizeof(a)</code>, 
                where <code>a</code> is integer, will return 4.
                <br></br><br></br>
                <code>&#38;</code><br></br>
                It returns the address of a variable.<br></br> 
                <code>&#38;a;</code> returns the actual 
                address of the variable.
                <br></br><br></br>
                <code>*</code><br></br>
                Pointer to a variable.<br></br>
                <code>*a;</code> also known as deferefering the pointer <code>a</code>
                <br></br><br></br>
                <code>? :</code><br></br>
                Conditional Expression. <br></br>
                If Condition is <code>true</code> ? 
                then value X : otherwise value Y; 
                <br></br>
        </operators>
        <pre-post-incrementation>
            *General-Programming-Knowledge*
            <br></br>
<code>
//pre increment operator

#include &lt;stdio.h&gt;  
 
int main()
{
    int x = 10, a;
 
    a = ++x; // x will be incremented to 11 then value of x is assigned to a;
 
    printf("a = %d\n", a);
 
    printf("x = %d\n", x);
    return 0;
    
    /*
        OUTPUT: 
        a = 11
        x = 11
    */
}
</code>

<code>
//post increment operator

#include &lt;stdio.h&gt;  
 
int main()
{
    int x = 10, a;
 
    a = x++; // x value is assigned to a, then x value gets incremented to 11;

    printf("a = %d\n", a);
 
    printf("x = %d\n", x);
    return 0;
    
    /*
        OUTPUT: 
        a = 10
        x = 11
    */
}
</code>
        </pre-post-incrementation>
        <recursion>
            *General-Programming-Knowledge*
<code>
//Example of recursion in C:

#include &lt;stdio.h&gt;  

int fact (int);

int main()  
{  
    int n, f;  
    printf("Enter the number whose factorial you want to calculate?");  
    scanf("%d", &#38;n);  
    
    //Calling the recursive function:
    f = fact(n);
    
    //Printing the result:
    printf("factorial = %d",f);  
}

int fact(int n)  
{
    //Recursive function:
    
    if (n==0)  
    {  
        return 0;  
    }  
    else if ( n == 1)  
    {  
        return 1;  
    }  
    else   
    {  
        return n*fact(n-1);  
    }  
}  
</code>
        </recursion>
        <polymorphism>
            *General-Programming-Knowledge*
            <br></br>
            <green>Polymorphism in C:</green>
            <br></br><br></br>
            Even though C does not support OOP. A type of polymorphism can still 
            be achieved
            by using the generic pointer.
            <br></br><br></br>
            The type <code>void *</code> is used as a generic pointer in 
            C (similar in concept to Object type in OOP). 
            <br></br><br></br>
            Pointers to any type can be assigned to a
            variable of type <code>void *</code>, which allows parametric polymorphism.
<code>
//Example of parametric polymorphism in C:

void swap(void v[], int i, int j)
{
    //interchange values between index i and j
    void *tmp = v[i]; 
    v[i] = v[j]; 
    v[j] = tmp;
}

void qsort(void v[], int left, int right, int (*compare)(void *, void *))
{
    //sort to increasing order elements between index
    //left and right from array v[]
    
    int i, last;
    
    /* do nothing if array contains */
    /* less than two elements */
    if (left >= right) 
    {
        return; 
    }
    
    swap(v, left, (left + right)/2);
    last = left;
    
    for (i = left+1; i&lt;= right; i++)
    {
        if ((*compare)(v[i], v[left]) &lt; 0)
        {
            swap(v, ++last, i);
        }
    }
    swap(v, left, last);
    
    //Recursion
    qsort(v, left, last-1, compare);
    qsort(v, last+1, right, compare);
}
</code>
        </polymorphism>
    </manifest>
    
    <manifest>
        <name>C++</name>
        <description>
            C++ is a high-level, general-purpose programming language 
            created by Danish computer scientist Bjarne Stroustrup. <br></br><br></br>
            First released in 1985 as an extension of the C programming language, 
            it has since expanded significantly over time; as of 1997, C++ has object-oriented, 
            generic, and functional features. <br></br>
            In addition to facilities for low-level memory 
            manipulation for making things like microcomputers or to make operating systems 
            like Linux or Windows. <br></br><br></br>
            
            It is almost always implemented as a compiled language, 
            and many vendors provide C++ compilers, including the Free Software Foundation, 
            LLVM, Microsoft, Intel, Embarcadero, Oracle, and IBM.
        </description>
        <oop>*General-Programming-Knowledge*</oop>
        <encapsulation>
            *General-Programming-Knowledge*
<code>
//Example of encapsulation

#include &lt;iostream&gt;  
using namespace std;

class Employee 
{
  private:
    // Private attribute
    int salary;

  public:
    // Setter
    void setSalary(int s) 
    {
      salary = s;
    }
    
    // Getter
    int getSalary() 
    {
      return salary;
    }
};

int main() 
{
    Employee myObj;
    myObj.setSalary(50000);
    cout &lt;&lt; myObj.getSalary();
    return 0;
}
</code>
        </encapsulation>
        <polymorphism>
            *General-Programming-Knowledge*
<code>
//Example of polymorphism

#include &lt;iostream&gt;  

/*

The word polymorphism means having many forms. 

Typically, polymorphism occurs when there is a hierarchy of classes 
and they are related by inheritance.

C++ polymorphism means that a call to a member function will cause a 
different function to be executed depending on the type of object 
that invokes the function. 

Example: if a parent class function is set to be overridable, 
then a parent class pointer can have functionality of the 
child class object.

A pure virtual function is a function that is declared in 
the parent class and it should be defined in every child classes.

Syntax: virtual void DisplayFunction () = 0;

*/

using namespace std;

class Shape
{
    //By default a member without access-specifier is set to private.
    protected:
        int length;
        int height;

    public:
        //Each child class has to provide its own definition of this method.
        virtual void DisplayInfo() 
        {
            cout &lt;&lt; "This is the parent class." &lt;&lt; endl;
        }
};

class Square: public Shape
{
    private:
        int area;
        void CalcArea()
        {
            area=length*height;
        }

    public:
        Square (int len, int hg)
        {
            length=len;
            height=hg;
            CalcArea();
        };
        
        void DisplayArea()
        {
            cout &lt;&lt; "Area: " &lt;&lt; area &lt;&lt; endl;
        }
        
        //This function overrides the parent class function
        void DisplayInfo()
        {
            cout &lt;&lt; "This is the child class." &lt;&lt; endl;
        }
};

class Circle: public Shape
{
    private:
        int radius;
    
    public:
        Circle(int len)
        {
            radius=len/2;
        }
        void DisplayRadius()
        {
            cout &lt;&lt; "Radius: " &lt;&lt; radius &lt;&lt; endl;
        }
};

int main()
{
    Shape *p;
    Circle circle_object(22);
    Square square_object(4,3);
    
    /*
    The pointer of type Shape can reference any of the 
    Shape class children, but having only 
    the functionality of Shape Class.
    */
    
    p=&#38;circle_object;
    p-&gt;DisplayInfo();
    p=&#38;square_object;
    p-&gt;DisplayInfo();
    
    int a;
    cin &gt;&gt; a;
    return 0;
    
    /*
    Using same variable we accessed different behaviour for 
    each child class.
    */
}
</code>    
        </polymorphism>
        <inheritance>
            *General-Programming-Knowledge*
            <br></br>
            In C++, it is possible to inherit attributes and methods from one <code>class</code> 
            to another. <br></br><br></br>
            <green>
            We group the "inheritance concept" into two categories:
            </green>
            <br></br><br></br>
            
            - derived class (child) - the class that inherits from another class;<br></br>
            - base class (parent) - the class being inherited from;<br></br><br></br>
            
            To inherit from a <code>class</code>, use the : symbol.<br></br>
<code>
#include &lt;iostream&gt;  
#include &lt;conio.h&gt;  

using namespace std;

//BASE CLASS
class Shape{

    protected: 
    //protected variables are visible into this class and the other classes 
    //that are inherited from this.

    string name;
        
    public:
    Shape(string newname)
    {
        name=newname;
    }
    string getName() const
    {
        return name;
    }
};

//CHILD CLASS ONE
class Circle : public Shape 
//making Circle class derive from the Shape class (setting the inheritance).
{
    //inheritance is a way to make 2 classes share the same variables between each other

    double radius; //this variable can be private, or protected or public (anything).

    public:
        Circle(string inheritedName, double newradius) : Shape (inheritedName)
        //this will call the Shape constructor which will set a value into it's string 
        //variable called 'name', in this way, a variable will be used in 2 classes.
        {
            radius=newradius;
        }
        double getCircleRadius() const
        {
            return radius;
        }

};

//CHILD CLASS TWO
class Rectangle : public Shape 
// making the Rectangle class derive from Shape Class, 
//let the Rectangle Class, use the protected variables of the Shape Class.
{
    double length, width;

    public:
        Rectangle (string inheritedName2, double newlength, double newwidth): Shape (inheritedName2)
        {
            length=newlength;
            width=newwidth;
        }
        double getRectangleLength() const
        {
            return length;
        }
        double getRectangleWidth () const
        {
            return width;
        }
};

int main()
{
    Shape object("Shape Class String"); //create object
    cout &lt;&lt; object.getName() &lt;&lt; endl; //calling a function from the class

    cout &lt;&lt; endl &lt;&lt; "CHILD ONE CLASS: " &lt;&lt; endl;
    
    Circle objectchild ("Circle (stored in Shape Class String)", 3.0); //create object
    
    //calling a function from Shape Class using the object from Circle Class.
    cout &lt;&lt; objectchild.getName() &lt;&lt; endl; 
    cout &lt;&lt; objectchild.getCircleRadius() &lt;&lt; endl;

    cout &lt;&lt; endl &lt;&lt; "CHILD TWO CLASS: " &lt;&lt; endl;
    
    Rectangle objectchild2("Rectangle (stored in Shape Class String)", 20.0, 65.0); //create object
    
    //calling a function from Shape Class using the object from Rectangle Class.
    cout &lt;&lt; objectchild2.getName() &lt;&lt; endl; 
    cout &lt;&lt; objectchild2.getRectangleLength() &lt;&lt; endl;
    cout &lt;&lt; objectchild2.getRectangleWidth() &lt;&lt; endl;

    getch();
    return 0;
}
</code>
        </inheritance>
        <abstraction>
            *General-Programming-Knowledge*
<code>
// Example of Data Abstraction in C++

#include &lt;iostream&gt;  
using namespace std;
 
class implementAbstraction 
{
    private:
        int a, b;
     
    public:
        // method to set values of private members
        void set(int x, int y)
        {
            a = x;
            b = y;
        }
     
        void display()
        {
            cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;
            cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;
        }
};
 
int main()
{
    implementAbstraction obj;
    obj.set(10, 20);
    obj.display();
    return 0;
    
    /*
        OUTPUT:
        a = 10
        b = 20
    */
}
</code>
        </abstraction>
        <generic-programming>
            *General-Programming-Knowledge*
            <br></br>    
            In C++ the templates generalize the algorithm to make it data type-independent.
            <br></br><br></br>

<code>
//Example of generic programming in C++

#include &lt;iostream&gt;  

// Template Function with a Type T
// During instantiation, this T will be replaced by the data type of argument.
template &lt;class T&gt;  
T maxNum (T a, T b) {
 return (a &gt;   b ? a : b); //ternary operator
}

int main()
{
    int x = 5, y = 2;
    float a = 4.5, b = 1.3;
    
    std::cout &lt;&lt; maxNum&lt;int&gt;(x, y) &lt;&lt; "\n";
    std::cout &lt;&lt; maxNum&lt;float&gt;(a, b);
    return 0;
}
</code>
        </generic-programming>
        <variable-arguments-lists>
            *General-Programming-Knowledge*
            <br></br>
            Functions with a variable number of arguments in C++ can be easily implemented using 
            a vector or an array if all the arguments are the same type.
            <br></br><br></br>
            If all arguments are of different types, then we need to use the <code>cstdarg</code> header file 
            to implement variadic functions.
            <br></br><br></br>
            Variadic functions do not put restrictions on the types of arguments. <br></br>
            They also do not perform integer and floating-point enhancements.
            <br></br>
<code>
// Implementation of variable arguments using vector.

#include &lt;iostream&gt; 
#include &lt;vector&gt; 
using namespace std;

// Using vector of string as a parameter to store a variable number of strings.

void printNames(vector&lt;string&gt;  nameVector) {
    for (string &#38;name : nameVector) {
        cout &lt;&lt; name &lt;&lt; " ";
    }
    cout &lt;&lt; '\n';
}

int main() {
    printNames({"Scaler", "Topics"});
    printNames({"Technopedia", "for", "your", "mastermind!"});
    return 0;
}
</code>

<code>
// Implementation of variable arguments using cstdarg variadic functons.

#include &lt;iostream&gt; 
#include &lt;cstdarg&gt; 

using namespace std;

void printDeveloperData(const char* fmt...) {
    va_list args;
    va_start(args, fmt);
 
    while (*fmt != '\0') 
    {
        if (*fmt == 'd') 
        {
            int version = va_arg(args, int);
            std::cout &lt;&lt; "C++ Version: " &lt;&lt; version;
        } 
        else if (*fmt == 'c') 
        {
            int name = va_arg(args, int);
            std::cout &lt;&lt; "Name: " &lt;&lt; static_cast&lt;char&gt; (name);
        } 
        else if (*fmt == 'f') 
        {
            double stability_percentage = va_arg(args, double);
            std::cout &lt;&lt; "Stability Percentage: " &lt;&lt; stability_percentage &lt;&lt; "%";
        }
        ++fmt;
        cout &lt;&lt; '\n';
    }
 
    va_end(args);
}
 
int main() {
    printDeveloperData("cdf", 'B', 20, 94.7);
    
    return 0;

}
</code>

<code>
// Implementation of variable arguments using variadic templates.

#include &lt;iostream&gt; 
using namespace std;

template &lt;typename T&gt; 
void printDeveloperData(T t) {
    cout &lt;&lt; t &lt;&lt; '\n' ;
}

template&lt;typename T, typename... Args&gt; 
void printDeveloperData(T t, Args... args) {
    cout &lt;&lt; t &lt;&lt; '\n';
    printDeveloperData(args...) ;
}

int main() {
    printDeveloperData("Bjarne", 20, 94.7);
}
</code>
        </variable-arguments-lists>
        <simple-data-types>
            All variables use data type during declaration to restrict the type of data to 
            be stored. <br></br>
            Therefore, we can say that data types are used to tell the variables 
            the type of data they can store. <br></br><br></br>
            Whenever a variable is defined in C++, 
            the compiler allocates some memory for that variable based on the data type 
            with which it is declared. <br></br><br></br>
            Every data type requires a different amount of memory.
            <br></br><br></br>
            <green>The datatypes presented on C Language are still available in C++:</green>
            <br></br><br></br>
            *General-Programming-Knowledge*
            <br></br><br></br>
            <green>Primitive Datatypes:</green><br></br><br></br>
            
            Integer<br></br>
            Character<br></br>
            Boolean<br></br>
            Floating Point<br></br>
            Double Floating Point<br></br>
            Valueless or Void<br></br>
            Wide Character<br></br>
            
            <br></br>
        </simple-data-types>
        <complex-data-types>
            *General-Programming-Knowledge*
            <br></br>
            <brown>Aditional to the C Language, C++ introduced classes as a user-defined datatype. </brown>
            <br></br><br></br>
            <green>Derived Datatypes:</green><br></br>
            
            Function<br></br>
            Array<br></br>
            Pointer<br></br>
            Reference<br></br>
            
            <br></br>
            <green>User-defined Datatypes:</green><br></br>
            
            Class<br></br>
            Structure<br></br>
            Union<br></br>
            Enumeration<br></br>
            Typedef defined Datatype<br></br>
            
        </complex-data-types>
        <preprocessor-directives>
            *General-Programming-Knowledge*
        </preprocessor-directives>
        <loops>
            *General-Programming-Knowledge*
            <br></br>
            <green>
            Additional to the C language: 
            </green>
            <br></br><br></br>
            Additional to the loops presented in C language, there is also a "for-each loop" 
            (introduced in C++ version 11 (2011), which is used exclusively to loop through 
            elements in an array (or other data sets):
<code>
/*Example of foreach loop in C++*/

int myNumbers[5] = {10, 20, 30, 40, 50};

for (int i : myNumbers) 
{
  cout &lt;&lt;  i &lt;&lt;  "\n";
}
</code>
        </loops>
        <collections>
            *General-Programming-Knowledge*
            <br></br>
            Additional to C Language: C++ introduced several new collection classes datatypes:
            <br></br><br></br>
            <green>
                Vector: 
            </green>
            <br></br><br></br>
            The C++ Standard Library vector class is a class template for sequence containers.<br></br>
            <br></br>
            
            Vector is a type of dynamic array which has the ability to resize 
            automatically after insertion or deletion of elements. <br></br>
            The elements in <code>vector</code> 
            are placed in contiguous storage so that they can be accessed and traversed using 
            iterators. <br></br>
            Element is inserted at the end of the <code>vector</code>.<br></br><br></br>
            
<code>
#include &lt;iostream&gt; 
#include &lt;vector&gt; 
 
int main()
{
    // Create a vector containing integers
    std::vector&lt;int&gt;  v = {8, 4, 5, 9};
 
    // Add two more integers to vector
    v.push_back(6);
    v.push_back(9);
 
    // Overwrite element at position 2
    v[2] = -1;
 
    // Print out the vector
    for (int n : v)
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
</code>    
        <green>
        List: 
        </green>
        <br></br><br></br>
        
        List is a double linked sequence that supports both forward and backward 
        traversal. <br></br>
        The time taken in the insertion and deletion in the beginning, end 
        and middle is constant.<br></br> 
        It has the non-contiguous memory and there is no 
        pre-allocated memory.<br></br>
        
<code>
// C++ program to demonstrate the use of list containers

#include &lt;iostream&gt; 
#include &lt;list&gt; 
using namespace std;
 
int main()
{
    // defining list
    list&lt;int&gt;  gqlist{12,45,8,6};
 
    for (auto i : gqlist) {
        cout &lt;&lt; i &lt;&lt; ' ';
    }
    return 0;
}
</code>
        </collections>
        <collection-methods>
            Some of the methods available in C++ for the Collection Type Classes: 
            Vector or List are:
            <br></br><br></br>
            <green>Capacity:</green><br></br><br></br>
            <code>size()    </code><br></br>Return size<br></br><br></br>
            <code>max_size()</code><br></br>Return maximum size<br></br><br></br>
            <code>resize()    </code><br></br>Change size<br></br><br></br>
            <code>capacity()</code><br></br>Return size of allocated storage capacity<br></br><br></br>
            <code>empty()    </code><br></br>Test whether vector is empty<br></br><br></br>
            <code>reserve()    </code><br></br>Request a change in capacity<br></br><br></br>
            <code>shrink_to_fit()</code><br></br>Shrink to fit<br></br><br></br>
            <br></br>
            <green>Element access:</green><br></br><br></br>
            <code>operator[]</code><br></br>Access element<br></br><br></br>
            <code>at()</code><br></br>Access element<br></br><br></br>
            <code>front()</code><br></br>Access first element<br></br><br></br>
            <code>back()</code><br></br>Access last element<br></br><br></br>
            <code>data()</code><br></br>Access data<br></br><br></br>
            <br></br>
            <green>Modifiers:</green><br></br><br></br>
            <code>assign()</code><br></br>Assign vector content<br></br><br></br>
            <code>push_back()</code><br></br>Add element at the end<br></br><br></br>
            <code>pop_back()</code><br></br>Delete last element<br></br><br></br>
            <code>insert()</code><br></br>Insert elements<br></br><br></br>
            <code>erase()</code><br></br>Erase elements<br></br><br></br>
            <code>swap()</code><br></br>Swap content<br></br><br></br>
            <code>clear()</code><br></br>Clear content<br></br><br></br>
            <code>emplace()</code><br></br>Construct and insert element<br></br><br></br>
            <code>emplace_back()</code><br></br>Construct and insert element at the end<br></br><br></br>
        </collection-methods>
        <dynamic-memory-allocation>
            *General-Programming-Knowledge*
            <br></br>
            <green>
            Additional to the C language: 
            </green>
            <br></br><br></br>
            C++ integrates the operators <code>new</code> and <code>delete</code> for allocating dynamic memory.
            <br></br><br></br>
            Operators <code>new</code> and <code>new[]</code>: 
            <br></br><br></br>
            Dynamic memory is allocated using operator <code>new</code>. <br></br>
            <code>new</code> is followed by a data 
            type specifier and, if a sequence of more than one element is required, 
            the number of these within brackets <code>[]</code>. <br></br>
            It returns a pointer to the beginning of the new block of memory allocated. <br></br>
<code>
//Example:

int * foo;
foo = new int [5];
</code>
        In this case, the system dynamically allocates space for five elements of type <code>int</code> 
        and returns a pointer to the first element of the sequence, which is assigned to 
        <code>foo</code> (a pointer). <br></br><br></br>
        Therefore, <code>foo</code> now points to a valid block of memory with space 
        for five elements of type <code>int</code>.<br></br>
        <br></br>
        Operators <code>delete</code> and <code>delete[]</code>: 
        <br></br><br></br>
        In most cases, memory allocated dynamically is only needed during specific periods 
        of time within a program; once it is no longer needed, it can be freed so that 
        the memory becomes available again for other requests of dynamic memory. <br></br>
        <br></br>
        This is the purpose of operator <code>delete</code>, whose syntax is: <br></br>
<code>
// Example of dynamic allocation
// and deallocation of memory using new and delete

#include &lt;iostream&gt; 
using namespace std;

int main()
{
    // Pointer initialization to null
    int* p = NULL;

    // Request memory for the variable
    // using new operator
    p = new (nothrow) int;
    if (!p)
        cout &lt;&lt; "allocation of memory failed\n";
    else {
        // Store value at allocated address
        *p = 29;
        cout &lt;&lt; "Value of p: " &lt;&lt; *p &lt;&lt; endl;
    }

    // Request block of memory
    // using new operator
    float* r = new float(75.25);

    cout &lt;&lt; "Value of r: " &lt;&lt; *r &lt;&lt; endl;

    // Request block of memory of size n
    int n = 5;
    int* q = new (nothrow) int[n];

    if (!q)
        cout &lt;&lt; "allocation of memory failed\n";
    else {
        for (int i = 0; i &lt; n; i++)
            q[i] = i + 1;

        cout &lt;&lt; "Value store in block of memory: ";
        for (int i = 0; i &lt; n; i++)
            cout &lt;&lt; q[i] &lt;&lt; " ";
    }

    // freed the allocated memory
    delete p;
    delete r;

    // freed the block of allocated memory
    delete[] q;

    return 0;
    
    /*
        OUTPUT:
        Value of p: 29
        Value of r: 75.25
        Value store in block of memory: 1 2 3 4 5 
    */
}
</code>
        </dynamic-memory-allocation>
        <read-from-file>
            *General-Programming-Knowledge*
            The <code>fstream</code> library can be used in C++ to work with files.
            <br></br><br></br>
            There are three classes included in the <code>fstream</code> library, 
            which are used to create, write or read files:
            <br></br><br></br>
            <green>Class description:</green><br></br><br></br>
            <code>ofstream</code> - Creates and writes to files.<br></br>
            <code>ifstream</code> - Reads from files.<br></br>
            <code>fstream</code>  - A combination of <code>ofstream</code> and <code>ifstream</code>: 
            creates, reads, and writes to files.
            <br></br><br></br>
            To read from a file, use either the <code>ifstream</code> or <code>fstream class</code>, and the name of the file.
            <br></br><br></br>
            Note: we also use a <code>while</code> loop together with the <code>getline()</code> function 
            (which belongs to the <code>ifstream</code> class) to read the file line by line, and to print 
            the content of the file:
            <br></br>
<code>
// Create a text string, which is used to output the text file

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;

int main() 
{
    string myText;

    // Read from the text file
    ifstream MyReadFile("filename.txt");

    // Use a while loop together with the getline() 
    //to read the file line by line
    while (getline (MyReadFile, myText)) 
    {
      // Output the text from the file
      cout &lt;&lt; myText;
    }

    // Close the file
    MyReadFile.close(); 
    //It is considered good practice to close the file, 
    //and it can clean up unnecessary memory space.
}
</code>
        </read-from-file>
        <write-to-file>
            The <code>fstream</code> library can be used in C++ to work with files.
            <br></br><br></br>
            There are three classes included in the <code>fstream</code> library, which are used to 
            create, 
            write or read files:
            <br></br><br></br>
            <green>Class description:</green><br></br><br></br>
            <code>ofstream</code> - Creates and writes to files.<br></br>
            <code>ifstream</code> - Reads from files.<br></br>
            <code>fstream</code> - A combination of <code>ofstream</code> and <code>ifstream</code>: 
            creates, reads, and writes to files.
            <br></br><br></br>
            Create and Write To a File:
            <br></br><br></br>
            To create a file, use either the <code>ofstream</code> or <code>fstream class</code>, and specify 
            the name of the file.
            <br></br><br></br>
            To write to the file, use the insertion operator (<code>&lt;&lt;</code>).<br></br>
<code>
//Example of writing to file using fstream in C++

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;

int main() 
{
    // Create and open a text file
    ofstream MyFile("filename.txt");

    // Write to the file
    MyFile &lt;&lt; "Files can be tricky, but it is fun enough!";

    // Close the file
    MyFile.close(); 
    //It is considered good practice to close the file, 
    //and it can clean up unnecessary memory space.
}
</code>
        </write-to-file>
        <serialization>
            *General-Programming-Knowledge*
            <br></br>
            Storing the state of an object to a file:<br></br>
<code>
/*Example of C++ object.field serialization and deserialization*/

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;

class Student 
{
    public:
    
    string name;
    int rollno;
    string branch;

    Student () // default constructor
    {
    } 
    
    Student (string n, int r, string b) // overloading constructor
    {
        name = n;
        rollno = r;
        branch = b;
    }
    
    //override the insertion operator for object.field serialization
    friend ofstream &#38; operator &lt;&lt; (ofstream &#38; ofs, Student s);
    //now we can write individually every class field member to the file.
    //Example: ofs &lt;&lt; s1.name; 
    
    //override the extraction for object.field deserialization
    friend ifstream &#38; operator &gt;&gt; (ifstream &#38; ifs, Student &#38; s);
    //now we can read individually every class field member from the file. 
    //Example: ifs &gt;&gt; s1.name; 
};

int main() 
{
    Student s1 ("James", 28, "IT");

    //Open the output stream
    ofstream ofs ("Student.txt", ios::trunc);

    //writing to the file
    ofs &lt;&lt; s1.name &lt;&lt; endl;
    ofs &lt;&lt; s1.rollno &lt;&lt; endl;
    ofs &lt;&lt; s1.branch &lt;&lt; endl;
    ofs.close();

    Student s2; //empty object

    //Open the input stream
    ifstream ifs("Student.txt");

    //reading from the file
    ifs &gt;&gt; s2.name;
    ifs &gt;&gt; s2.rollno;
    ifs &gt;&gt; s2.branch;
    ifs.close();

    cout &lt;&lt; s2.name &lt;&lt; endl;
    cout &lt;&lt; s2.rollno &lt;&lt; endl;
    cout &lt;&lt; s2.branch &lt;&lt; endl;

    /*
        OUTPUT: 
        James 
        28 
        IT
    */
}
</code>
        </serialization>
        <deserialization>
            *General-Programming-Knowledge*
            <br></br>
            Deserialization is the reverse process of Serialization, 
            where the byte stream is used to reconstruct the original object.<br></br>
<code>
/*Example of C++ whole-object serialization and deserialization*/

#include &lt;iostream&gt; 
#include &lt;fstream&gt; 

using namespace std;
class Student
{
    public:
    
    string name;
    int rollno;
    string branch;
    Student () // default constructor
    {
    }
    
    Student (string n, int r, string b) // overloading constructor
    {
        name = n;
        rollno = r;
        branch = b;
    }

    //override the insertion operator for object.field serialization
    friend ofstream &#38; operator &lt;&lt; (ofstream &#38; ofs, Student s);
    //now we can write individually every class field member to the file. 
    //Example: ofs &lt;&lt; s1.name; 
    
    //override the extraction for object.field deserialization
    friend ifstream &#38; operator &gt;&gt; (ifstream &#38; ifs, Student &#38; s);
    //now we can read individually every class field member from the file. 
    //Example: ifs &gt;&gt; s1.name; 
};

//Overriding the operators for whole-object serialization and deserialization
ofstream &#38;  operator &lt;&lt; (ofstream &#38; ofs, Student s)
{
    ofs &lt;&lt; s.name &lt;&lt; endl;
    ofs &lt;&lt; s.rollno &lt;&lt; endl;
    ofs &lt;&lt; s.branch &lt;&lt; endl;
    return ofs;
}
ifstream &#38; operator &gt;&gt; (ifstream &#38; ifs, Student &#38; s)
{
    ifs &gt;&gt; s.name &gt;&gt; s.rollno &gt;&gt; s.branch;
    return ifs;
}

/*
now we can read/write the whole object to and from the file. 

Example: 
ofs &lt;&lt; s1; 
ifs &gt;&gt; s2; 

*/

int main()
{
    Student s1("James", 28, "IT");

    //Open the output stream
    ofstream ofs("Student.txt", ios::trunc);
    ofs &lt;&lt;  s1;
    ofs.close();

    Student s2; // empty object

    //Open the input stream
    ifstream ifs("Student.txt");
    ifs &gt;&gt; s2;
    ifs.close();
        
    cout &lt;&lt; s2.name &lt;&lt; " " &lt;&lt; s2.rollno &lt;&lt; " " &lt;&lt; s2.branch &lt;&lt; endl;

    /*
        OUTPUT:
        James 28 IT
    */
}
</code>
        </deserialization>
        <constructors>
            *General-Programming-Knowledge*
<code>
/*Example of constructor in C++*/

#include &lt;iostream&gt; 

using namespace std;

class MyClass   // The class
{     
    public:           // Access specifier
        MyClass()     // Constructor
        {     
            /*
            The constructor has the same name as the class, 
            it is always public, 
            and it does not have any return value.
            */

              cout &lt;&lt; "Hello World!";
        }
};

int main() 
{
      MyClass myObj; 
      // Create an object of MyClass (this will call the constructor)
      return 0;
}
</code>
        </constructors>
        <instantiation>
            *General-Programming-Knowledge*
<code>
/*Example of instantiation*/

#include &lt;stdio.h&gt; 

class MyClass{

public:
    MyClass(){}
    void PrintMessage()
    {
        printf("Message from class member.\n");
    }
};

int main()
{
    //Instantiating the class:
    MyClass obj; 
    obj.PrintMessage();

    return 0;
}
</code>
        </instantiation>
        <destructors>
            *General-Programming-Knowledge*
<code>
class Test {
public:
    // User-Defined Constructor
    Test() { cout &lt;&lt; "\n Constructor executed"; }
 
    // User-Defined Destructor
    ~Test() { cout &lt;&lt; "\n Destructor executed"; }
};
</code>
        </destructors>
        <function-overloading>
            *General-Programming-Knowledge*
<code>
/*Example of function overloading*/

#include &lt;iostream&gt; 
using namespace std;
 
 
void add(int a, int b)
{
  cout &lt;&lt; "sum = " &lt;&lt; (a + b);
}
 
void add(double a, double b)
{
    cout &lt;&lt; endl &lt;&lt; "sum = " &lt;&lt; (a + b);
}
 
int main()
{
    add(10, 2); //calling function with ints
    add(5.3, 6.2); //calling function with floats
 
    return 0;
}
</code>
        </function-overloading>
        <operator-overloading>
            *General-Programming-Knowledge*
<code>
// Example of Operator Overloading

#include &lt;iostream&gt; 
using namespace std;
 
class Complex 
{
    private:
        int real, imag;
     
    public:
        Complex(int r = 0, int i = 0)
        {
            real = r;
            imag = i;
        }
     
        // This is automatically called when '+' is used with
        // between two Complex objects
        Complex operator+(Complex const    &#38; obj)
        {
            Complex res;
            res.real = real + obj.real;
            res.imag = imag + obj.imag;
            return res;
        }
        void print() { cout &lt;&lt; real &lt;&lt; " + i" &lt;&lt; imag &lt;&lt; '\n'; }
};
 
int main()
{
    Complex c1(10, 5), c2(2, 4);
    Complex c3 = c1 + c2;
    c3.print();
    
    /*
        OUTPUT:
        12 + i9
    */
}
</code>
        </operator-overloading>
        <enums>
            *General-Programming-Knowledge*
            <green>Comparison to C Language: </green>
            <br></br><br></br>
            In C, an enum is basically a way to alias names to integers. 
            This does not lead to 
            improved type checking. <br></br>
            In C++, an enum defines an actual type, which results in 
            strong type checking.<br></br>
<code>
#include &lt;iostream&gt; 
#include &lt;conio.h&gt; 

using namespace std;

/*
While processing a game loop, there are lots of statements to be checked, 
so in order to use those statements, 
variables that will hold a certain value will be created. 

Example:
int GamePlay =1;
int PauseGame = 2;
int ExitGame = 3;

So in this way the statements can be checked, 
to see when the game should be paused, should run, or should exit. 
As you see above, the variables that are used needs to have different values.

An enum is a way to enclose a bunch of constants, 
An enum guarantees that every variable inside it, will have different values.

Example: an enum with the variables above, can be created as follows:
enum GameStates {GamePlay, PauseGame, ExitGame};

So the synthax is:
enum &lt;name&gt; {states/members};
*/

//Creating a GLOBAL enum:
enum GameStates {GamePlay, PauseGame, ExitGame}; 
//the elements will take as constant value the position inside the enum;
//In this case: GamePlay = 0; PauseGame=1; ExitGame=2;

/*

enum members cannot be initialized with values: 
Example GamePlay = 5, this will give compilation error.

Instead the enum can be initialized only as follows:
GameStates=ExitGame;

In this case the active value of the enum will be ExitGame;
The syntax is : &lt;enum name&gt; = &lt;enum member&gt;;

An enum class is an enum that will use the scope resolution and 
an object of the enum class for assignments as above.

Example:
GameStates gameStates=GameStates::ExitGame;

An enum class will make possible that you can have multiple 
enums with the same members. 

So we could have for example:
enum class GameState {Exit, MainMenu};
enum class SoftwareState (Exit, MainMenu);

Without using an enum class this could not be possible because, 
the 2 members will conflict to each other
(compilation error).

Syntax to create an enum class:

enum class &lt;name&gt; { member1, member2...}
An enum cannot be forward declared, unless it's an enum class. 
So only enum classes can be forward declared.

To change the default value of an ENUM Member which consist in it's position 
on the enum, you can do as follows:

enum GameState {MainMenu=5, GamePlay=7, GameExit, GamePaused}; 
//the two uninitialized members follow gets the value of the
previous member+1; so GameExit will be 8, GamePause will be 9;

*/

int main()
{
    cout &lt;&lt; "GamePlay value: " &lt;&lt; GamePlay &lt;&lt; endl; // this is 0;
    cout &lt;&lt; "PauseGame value: " &lt;&lt; PauseGame &lt;&lt; endl; // this is 1;
    cout &lt;&lt; "ExitGame value: " &lt;&lt; ExitGame &lt;&lt; endl; // this is 2;
    getch();
    return 0;
}
</code>
        </enums>
        <concurrent-programming>
            *General-Programming-Knowledge*
            <br></br>
            C++ multithreading involves creating and using thread objects, seen as <code>std::thread</code> 
            in code, to carry out delegated sub-tasks independently. <br></br>
            New threads are passed a 
            function to complete, and optionally some parameters for that function.
            <br></br>
<code>
#include &lt;iostream&gt; 
#include &lt;cstdlib&gt; 
#include &lt;pthread.h&gt; 

using namespace std;

#define NUM_THREADS 5

void *PrintHello(void *threadid) 
{
   long tid;
   tid = (long)threadid;
   cout &lt;&lt; "Hello World! Thread ID, " &lt;&lt; tid &lt;&lt; endl;
   pthread_exit(NULL);
}

int main () 
{
   pthread_t threads[NUM_THREADS];
   int rc;
   int i;
   
   for( i = 0; i &lt; NUM_THREADS; i++ ) 
   {
      cout &lt;&lt; "main() : creating thread, " &lt;&lt; i &lt;&lt; endl;
      rc = pthread_create(&#38;threads[i], NULL, PrintHello, (void *)i);
      
      if (rc) 
      {
         cout &lt;&lt; "Error:unable to create thread," &lt;&lt; rc &lt;&lt; endl;
         exit(-1);
      }
   }
   pthread_exit(NULL);
}
</code>
        <br></br>
        In C/C++: one of the main workhorse functions that makes multiprocessing 
        possible is <code>fork()</code>.
        <br></br><br></br>
        <code>fork()</code> is a function that clone a process, spawning an identical 
        copy of it.
        <br></br>
<code>
//Example of multi-processing in C/C++:

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/wait.h&gt;

int main(int argc, char ** argv)
{
    pid_t pid = fork();
    
    if (pid == 0) 
    { 
        //we are in the child process
        printf("Hello from the child process!\n");
        exit (0); 
        //terminates the child process
    } 
    else 
    {
        //now in the parent process
        waitpid(pid, NULL, 0);
        printf("The child process has exited. Hello from the parent!\n");
    }
    return 0;
}
</code>
        </concurrent-programming>
        <namespaces>
            *General-Programming-Knowledge*
            <br></br>
            <brown>
            In C++ multiple namespace blocks 
            with the same name are allowed.
            </brown><br></br>
<code>
namespace Data
{
    class ObjectManager
    {
    public:
        void DoSomething() {}
    };
    void Func(ObjectManager) {}
}
</code>
        </namespaces>
        <exception-handling>
            *General-Programming-Knowledge*
            <br></br>
<code>
// C++ example on how to use of try,catch and throw
// for exception handling.
 
#include &lt;iostream&gt; 
#include &lt;stdexcept&gt; 
using namespace std;
 
int main()
{
 
    // try block
    try 
    {
        int numerator = 10;
        int denominator = 0;
        int res;
 
        // check if denominator is 0 then throw runtime
        // error.
        if (denominator == 0) 
        {
            throw runtime_error(
                "Division by zero not allowed!");
        }
 
        // calculate result if no exception occurs
        res = numerator / denominator;
        //[printing result after division
        cout &lt;&lt; "Result after division: " &lt;&lt; res &lt;&lt; endl;
    }
    // catch block to catch the thrown exception
    catch (const exception&#38; e) 
    {
        // print the exception
        cout &lt;&lt; "Exception " &lt;&lt; e.what() &lt;&lt; endl;
    }
 
    return 0;
}
</code>
        </exception-handling>
        <bitwise-operators>
            *General-Programming-Knowledge*
            <br></br>
            Bitwise operators in C/C++ are 
            tools for working with individual bits in data. <br></br>
            <br></br>
            They might not be as famous as other 
            operators, but they’re essential for tasks like making code more efficient or 
            controlling hardware.
        </bitwise-operators>
        <default-parameters>
            *General-Programming-Knowledge*
<code>
// Example of Default Parameters/Arguments in C++.

#include &lt;iostream&gt; 
using namespace std;
 
// A function with default arguments,
// it can be called with
// 2 arguments or 3 arguments or 4 arguments.

//assigning default values to z,w as 0
int sum(int x, int y, int z = 0, int w = 0) 
{
    return (x + y + z + w);
}
 
int main()
{
    // Statement 1
    cout &lt;&lt; sum(10, 15) &lt;&lt; endl;
   
    // Statement 2
    cout &lt;&lt; sum(10, 15, 25) &lt;&lt; endl;
   
    // Statement 3
    cout &lt;&lt; sum(10, 15, 25, 30) &lt;&lt; endl;
    return 0;
}
</code>
        </default-parameters>
        <interfaces>
            *General-Programming-Knowledge*
<code>
/*Example of an interface implementation*/

class Box 
{
   public:
        // pure virtual function
        virtual double getVolume() = 0;
      
   private:
        //Length of a box
        double length;
        
        //Breadth of a box
        double breadth;
        
        //Height of a box
        double height; 
};
</code>
        </interfaces>
        <abstract-classes>
            *General-Programming-Knowledge*
<code>
/*Example of abstract class*/

#include &lt;iostream&gt; 
 
using namespace std;
 
// Base class
class Shape {
   public:
      // pure virtual function providing interface framework.
      virtual int getArea() = 0;
      void setWidth(int w) {
         width = w;
      }
   
      void setHeight(int h) {
         height = h;
      }
   
   protected:
      int width;
      int height;
};
 
// Derived classes
class Rectangle: public Shape {
   public:
      int getArea() { 
         return (width * height); 
      }
};

class Triangle: public Shape {
   public:
      int getArea() { 
         return (width * height)/2; 
      }
};
 
int main(void) {
   Rectangle Rect;
   Triangle  Tri;
 
   Rect.setWidth(5);
   Rect.setHeight(7);
   
   // Print the area of the object.
   cout &lt;&lt; "Total Rectangle area: " &lt;&lt; Rect.getArea() &lt;&lt; endl;

   Tri.setWidth(5);
   Tri.setHeight(7);
   
   // Print the area of the object.
   cout &lt;&lt; "Total Triangle area: " &lt;&lt; Tri.getArea() &lt;&lt; endl; 

   return 0;
}
</code>
        
        </abstract-classes>
        <macros>
            *General-Programming-Knowledge*
            <green>Similar to C Language:</green> 
            <br></br><br></br>
            A C++ macro is defined as a section of code that that particular macro value can 
            replace. <br></br><br></br>
            We can define the macro by using a <code>#define</code> directive.<br></br> 
            When the compiler goes to the macros while program compilation, 
            the macro's name is replaced by the definition of the macro. 
            <br></br><br></br>
            The termination of the C++ Macros does not need a 
            semi-colon (;).
            <br></br><br></br>
            <green>Additionally to the C Language:</green><br></br>
            The header file: <code>&lt;limits.h&gt;</code> 
            is defined to help finding 
            the range of fundamental data-types. <br></br>
             <br></br>
            Unsigned modifiers have minimum value is zero. 
            So, no macro constants are defined for the unsigned minimum value.
            <br></br><br></br>
            <green>
            Macro Constants:
            </green>
            <br></br><br></br>
            <code>CHAR_MIN</code>  - The minimum value for an object of type char; <br></br><br></br>    
            <code>CHAR_MAX</code>  - Maximum value for an object of type char; <br></br><br></br>        
            <code>SCHAR_MIN</code>  - The minimum value for an object of type Signed char; <br></br><br></br>    
            <code>SCHAR_MAX</code>  - Maximum value for an object of type Signed char; <br></br><br></br>        
            <code>UCHAR_MAX</code>  - Maximum value for an object of type Unsigned char; <br></br><br></br>        
            <code>CHAR_BIT</code>  - Number of bits in a char object; <br></br><br></br>        
            <code>MB_LEN_MAX</code>  - Maximum number of bytes in a multi-byte character; <br></br><br></br>        
            <code>SHRT_MIN</code>  - The minimum value for an object of type short int; <br></br><br></br>        
            <code>SHRT_MAX</code>  - Maximum value for an object of type short int; <br></br><br></br>        
            <code>USHRT_MAX</code>  - Maximum value for an object of type Unsigned short int; <br></br><br></br>        
            <code>INT_MIN</code>  - The minimum value for an object of type int; <br></br><br></br>        
            <code>INT_MAX</code>  - Maximum value for an object of type int; <br></br><br></br>        
            <code>UINT_MAX</code>  - Maximum value for an object of type Unsigned int; <br></br><br></br>    
            <code>LONG_MIN</code>  - The minimum value for an object of type long int; <br></br><br></br>        
            <code>LONG_MAX</code>  - Maximum value for an object of type long int; <br></br><br></br>        
            <code>ULONG_MAX</code>  - Maximum value for an object of type Unsigned long int; <br></br><br></br>        
            <code>LLONG_MIN</code>  - The minimum value for an object of type long long int; <br></br><br></br>        
            <code>LLONG_MAX</code>  - Maximum value for an object of type long long int; <br></br><br></br>    
            <code>ULLONG_MAX</code> - Maximum value for an object of type Unsigned long long int;<br></br>            
            
<code>
/*An example of defining a C++ macro:*/

using namespace std;
 
// Here is the definition of macro.
#define AREA(l, b) (l * b)

int main() {
    // The given lengths are l1 and l2.
    int l1 = 20, l2 = 2, area;
 
    // Here, finding the area using macro.
    area = AREA(l1, l2);
 
    return 0;
}
</code>
        </macros>
        <defines>*General-Programming-Knowledge*</defines>
        <random-generators>
            *General-Programming-Knowledge*
            <br></br><br></br>
            <green>For C++:</green>
            <br></br><br></br>
            <code>rand()</code> function is an inbuilt function in C++ Standard Library, which is defined in 
            header file <code>&lt;cstdlib&gt;</code>. <br></br><br></br>

            The <code>rand()</code> function is 
            used in C++ to generate random numbers in the range <code>[0, RAND_MAX)</code>.
            <br></br><br></br>
            The random number is generated by using an algorithm that gives a series of 
            non-related numbers whenever this function is called.
            <br></br><br></br>
            <brown>Syntax of rand():</brown><br></br>
            <code>int rand(void);</code><br></br><br></br>
            <brown>Parameters of rand():</brown><br></br>
            This function does not take any parameters.<br></br><br></br>
            <brown>Return Value of rand():</brown><br></br>
            <code>rand()</code> returns a pseudo-random number in the range of <code>[0, RAND_MAX)</code>.
            <br></br>
<code>
// C++ program to demonstrate 
//  the use of rand() 

#include &lt;cstdlib&gt; 
#include &lt;iostream&gt;  
using namespace std; 
  
int main() 
{ 
    // This program will create some sequence of 
    // random numbers on every program run 
    for (int i = 0; i &lt; 5; i++) 
        cout &lt;&lt; rand() &lt;&lt; " "; 

    return 0; 
}
</code>
            <code>srand()</code> function is also available in C++.<br></br>
            This function sets the
            seed which is used by rand to generate "random" numbers.
        </random-generators>
        <command-line-arguments>
            *General-Programming-Knowledge*
<code>
//Example of command line arguments in C++:

int main(int argc, char *argv[])
{
     // Suitable Code
     return 0;
}
</code>
        </command-line-arguments>
        <ternary-operator>*General-Programming-Knowledge*</ternary-operator>
        <modular-programming>*General-Programming-Knowledge*
            <br></br>
            <green>Example of modular programming in C++:</green>
<code>
//FILE: vectors_of_objects_mainfile.cpp
//In this file we put everything together

#include "vectors_of_objects_class.h" 
//by this inclusion we get access to: vectors_of_objects_class

//Function prototyping or declaration
void createObjects(vector &lt;vectors_of_objects_class&gt;&#38;);
void printObjectsInfo(const vector &lt;vectors_of_objects_class&gt;&#38;); 

//The main function is the entry point of the program
int main()
{
    //creating a vector of objects;
    vector &lt;vectors_of_objects_class&gt; ObjectVector; 
    
    //Calling the function that populates the vector of objects.
    createObjects(ObjectVector);
    
    //Calling the function that prints out the vector of objects.
    printObjectsInfo(ObjectVector);
    return 0;
}

//Function definition
void createObjects(vector &lt;vectors_of_objects_class&gt;&#38; newObjVec)
{
    int age;
    string name;
    cout &lt;&lt; "How many people do you wish to add? ";
    int people;
    cin &gt;&gt; people;
    for(int i=0;i&lt;people;i++)
    {
        cout &lt;&lt; "People_" &lt;&lt; i &lt;&lt; " Name: ";
        cin &gt;&gt; name; //get the name from the keyboard
        cout &lt;&lt; "People_" &lt;&lt; i &lt;&lt; " Age: ";
        cin &gt;&gt; age; //get the age from the keyboard
        
         //creating the object with self made constructor
        vectors_of_objects_class ObjectInVector(name, age);
        
         //calling the class functions
        ObjectInVector.setAge(age);
        ObjectInVector.setName(name);
        newObjVec.push_back(ObjectInVector);
    }
    cout &lt;&lt; endl;
}

//defining the function
void printObjectsInfo(const vector &lt;vectors_of_objects_class&gt;&#38; newObjVec) 
{
    unsigned int sizeOfVector=newObjVec.size();
    for(int i=0;i&lt;sizeOfVector; i++)
    {
        cout &lt;&lt; "People_" &lt;&lt; i &lt;&lt; " Name: " &lt;&lt; newObjVec[i].getName() &lt;&lt; endl;
        cout &lt;&lt; "People_" &lt;&lt; i &lt;&lt; " Age: " &lt;&lt; newObjVec[i].getAge() &lt;&lt; endl;
    }
}

</code>

<code>
//FILE: vectors_of_objects_class.cpp
//In this file we implement the vectors_of_objects_class interface

#include "vectors_of_objects_class.h"

//Implementing the custom vector class interface

//Adding a default constructor
vectors_of_objects_class::vectors_of_objects_class() //default constructor
{
    //constructor
}

//Adding an overloading constructor that takes 2 arguments
vectors_of_objects_class::vectors_of_objects_class(string name, int age) 
{
    //initializing the variables;
    newage=0;
}

//Adding a default destructor
vectors_of_objects_class::~vectors_of_objects_class()
{
    //destructor
}

//Adding methods

//getter defined to access the private variable of the class
string vectors_of_objects_class::getName() const 
{
    return newname;
}

//getter defined to access the private variables of the class
int vectors_of_objects_class::getAge() const 
{
    return newage;
}

//setter defined to set the private variables of the class
void vectors_of_objects_class::setName(string name) 
{
    newname=name;
}

//setter defined to set the private variables of the class
void vectors_of_objects_class::setAge(int age) 
{
    newage=age;
}

</code>

<code>
//FILE: vectors_of_objects_class.h
//In this file we declare an interface called: vectors_of_objects_class


//this will ensure that the header file is only included once
#ifndef VECTORS_OF_OBJECTS_CLASS_H 
#define VECTORS_OF_OBJECTS_CLASS_H

#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

//Creating a custom vector class interface
class vectors_of_objects_class
{
    public:
        //default constructor
        vectors_of_objects_class(); 
        
        //self made constructor
        vectors_of_objects_class(string, int); 

        //Accessor functions:
        string getName () const;
        int getAge () const;

        //Mutator functions;
        void setName(string);
        void setAge(int);

        virtual ~vectors_of_objects_class();

    protected:

    private: //private variables;
        string newname; 
        int newage;
};

#endif // VECTORS_OF_OBJECTS_CLASS_H

</code>
        </modular-programming>
        <string-methods>
            *General-Programming-Knowledge*
            <br></br>
            The <code>std::string</code> is a <code>class</code> in C++ since C++98. 
            <br></br>
            This <code>class</code> is the standard 
            representation for a text <code>string</code>. 
            <br></br>
            It includes some typical <code>string</code> operations 
            like find, replace, concatenate, compare etc.
            <br></br>
            It is present in <code>&lt;string&gt;</code> 
            header file. <br></br><br></br>
            <green>
            Commonly Used String Functions in C++:<br></br>
            </green>
            <br></br>
            <code>length()</code> or <code>size()</code><br></br>
            It will return the length of the string.<br></br>
            <br></br>
            <code>array[index]</code><br></br>
            To access individual characters using array indexing.<br></br>
            <br></br>
            <code>at()</code><br></br>
            Used to access a character at a specified index.<br></br>
            <br></br>
            <code>+</code> Operator<br></br>
            <code>+</code> operator is used to concatenate two strings.<br></br>
            <br></br>
            <code>append()</code><br></br>
            The <code>append()</code> function adds one string to the end of another.<br></br>
            <br></br>
            <code>==</code> Operator<br></br>
            You can compare strings using the <code>==</code> operator.<br></br>
            <br></br>
            <code>compare()</code><br></br>
            The <code>compare()</code> function returns an integer value indicating the 
            comparison result.<br></br>
            <br></br>
            <code>substr()</code><br></br>
            Use the <code>substr()</code> function to extract a substring from a string.<br></br>
            <br></br>
            <code>find()</code><br></br>
            The <code>find()</code> function returns the position of the first occurrence of a substring.<br></br>
            <br></br>
            <code>replace()</code><br></br>
            Use the <code>replace()</code> function to modify a part of the string.<br></br>
            <br></br>
            <code>insert()</code><br></br>
            The <code>insert()</code> function adds a substring at a specified position.<br></br>
            <br></br>
            <code>erase()</code><br></br>
            Use the <code>erase()</code> function to remove a part of the string.<br></br>
            <br></br>
            <code>c_str()</code><br></br>
            To obtain a C-style string from a <code>std::string</code>, you can use the 
            <code>c_str()</code> function.<br></br>
        </string-methods>
        <datatype-conversions>*General-Programming-Knowledge*</datatype-conversions>
        <optional-parameters>*General-Programming-Knowledge*</optional-parameters>
        <decorators>
            *General-Programming-Knowledge*
<code>
/*Example of decorators*/

#include &lt;iostream&gt; 
using namespace std;

class Computer
{
    public:
        virtual void display()
        {
            cout &lt;&lt; "I am a computer..." &lt;&lt; endl;
        }
};

class CDDrive : public Computer
{
    private:
        Computer* c;
        
    public:
        CDDrive(Computer* _c)
        {
            c = _c;
        }
        void display()
        {
            c-&gt;display();
            cout &lt;&lt; "with a CD Drive..." &lt;&lt; endl;
        }
};

class Printer : public Computer
{
    private:
        CDDrive* d;
        
    public:
        Printer(CDDrive* _d)
        {
            d = _d;
        }
        void display()
        {
            d-&gt;display();
            cout &lt;&lt; "with a printer..." &lt;&lt; endl;
        }
};

int main()
{
    Computer* c = new Computer();
    CDDrive* d = new CDDrive(c);
    Printer* p = new Printer(d);

    p-&gt;display();
}
</code>
        </decorators>
        <operators>*General-Programming-Knowledge*</operators>
        <pre-post-incrementation>*General-Programming-Knowledge*</pre-post-incrementation>
        <recursion>
            *General-Programming-Knowledge*
        </recursion>
        <reflection>
            *General-Programming-Knowledge*
        </reflection>
    </manifest>
    
    <manifest>
        <name>C#</name>
        <description>
            C# is a general-purpose high-level programming language supporting multiple 
            paradigms. C# encompasses static typing, strong typing, 
            lexically scoped, imperative, declarative, 
            functional, generic, object-oriented (class-based), 
            and component-oriented programming disciplines. 
            <br></br><br></br>
            The C# programming language was designed by Anders Hejlsberg from Microsoft in 
            2000. 
            <br></br><br></br>
            Microsoft introduced C# along with .NET Framework and Visual Studio, both of 
            which were closed-source. At the time, Microsoft had no open-source products. 
            <br></br><br></br>
            Four years later, in 2004, a free and open-source project called Mono began, 
            providing a cross-platform compiler and runtime environment for the C# 
            programming language. 
            <br></br><br></br>
            A decade later, Microsoft released Visual Studio Code (code editor), 
            Roslyn (compiler), and the unified .NET platform (software framework), 
            all of which support C# and are free, open-source, and 
            cross-platform. 
            Mono also joined Microsoft but was not merged into .NET.<br></br><br></br>
        </description>
        <oop>*General-Programming-Knowledge*</oop>
        <encapsulation>
            *General-Programming-Knowledge*
<code>
using System;

/* Members of the class should never be set to public, because public means that anyone 
 * who works at that program is able to change the variable's value, so to avoid that, 
 * all the members (sometimes called properties), should be private, 
 * (or protected for inheritance purposes).
 * 
 * Encapsulation: 
 * uses getter functions for getting the value of private members of the class;
 * uses setter function for setting the value of a private members of the class;
 */
 
namespace project27_classes_encaptulation_and_exceptions_throwing
{
    class Program
    {
        public static void Main(string[] args)
        {
            Encapsulation_Example pobject = new Encapsulation_Example();
            pobject.SetAge(15);
            pobject.SetName("Ellias Mustellar");
            Console.WriteLine("Name: {0}\nAge: {1}", pobject.GetName(), pobject.GetAge());
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    class Encapsulation_Example
    {
        //Members: (sometimes called properties)
        
        //as good programming habbit the private variables in a function 
        //should start with underscore.
        private int _age; 

        private string _Name;
        
        //Setters:
        public void SetAge(int NewAge)
        {
            if(NewAge&lt;=0)
            {
                //An exception is an error message, that occures and terminates the 
                //program in case that something goes wrong.

                //Syntax for throwing exception:
                throw new Exception("A person cannot have NULL or NEGATIVE age.");
            }
            _age=NewAge;
        }
        
        public void SetName(string NewName)
        {
            //string.IsNullOrEmpty(string_name); // is a function 
            //that checks if a string is null or empty
            if(string.IsNullOrEmpty(NewName))
            {
                throw new Exception("The name cannot be NULL or EMPTY.");
            }
            _Name = NewName;
        }
        
        //Getters:
        public int GetAge()
        {
            return this._age;
        }
        public string GetName()
        {
            return this._Name;
        }
    }
}
</code>
        </encapsulation>
        <polymorphism>
            *General-Programming-Knowledge*
<code>
using System;

namespace project25_polymorphism
{
    class Program
    {
        public static void Main(string[] args)
        {
            
            Parent [] objarray = new Parent[4];
            objarray[0]=new Parent();
            objarray[1]=new Child1();
            objarray[2]=new Child2();
            objarray[3]=new Child3();
            
            foreach(Parent k in objarray)
            {
                k.DisplayInfo(); //each child has the properties of the parent class
                
                /* To see the information of each child class we could make a function which  
                 * will hide the parent class function, and contain the updated information of
                 * the child class. But a better way doing that is marking the parent class 
                 * you'd wish to hide with virtual keyword, which will allow every child class
                 * overide the method by their own needs.
                 */
            }
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    class Parent
    {
        protected string FirstName, LastName;
       
        public Parent()
        {
            FirstName="FN";
            LastName="LN";
        }
        
        //The virtual keyword will make this function overidable for each child class.
        public virtual void DisplayInfo()  
        {
            Console.WriteLine("This is parent class");
        }
    }
    
    class Child1:Parent
    {
        //This is the syntax: for overriding (overwriting) a function.
        public override void DisplayInfo()
        {
            Console.WriteLine("This is a child 1 class.");
        }
    }
    
    class Child2:Parent
    {
        //This is the syntax: for overriding (overwriting) a function.
        public override void DisplayInfo()
        {
            Console.WriteLine("This is a child 2 class.");
        }
    }
    
    class Child3:Parent
    {
        //This is the syntax: for overriding (overwriting) a function.
        public override void DisplayInfo()
        {
            Console.WriteLine("This is a child 3 class.");
        }
    }
}
</code>
        </polymorphism>
        <inheritance>
            *General-Programming-Knowledge*
            <br></br>
            In C# for an inherited class can be only one parent class 
            (only single class inheritance is allowed).
            <br></br><br></br> 
            In case of inherited classes: the parent class constructor gets automatically 
            executed before the child class constructor if the parent class constructor 
            has no arguments.
            <br></br><br></br>
            Otherwise: if the parent class has a constructors with multiple 
            arguments/parameters 
            it must be specified at the child class constructor declaration a 
            syntax<code>:base()</code>
            and specify the arguments of the constructor that you want to 
            be executed inside 
            the pharanteses.
            <br></br><br></br>
            <green>Sealing the inheritance:</green> 
            <br></br><br></br>
            To prevent a <code>class</code> of having children (inheritance), you can use the 
            <code>sealed</code> keyword.
            <br></br><br></br>
            A <code>sealed class</code> cannot have children (cannot be <code>base class</code>).
<code>
//FILE: MyClass.cs

using System;
using System.Collections.Generic;

namespace inherited_classes
{
    //These are called XML Comments:
    /// &lt;summary&gt;
    /// Inherited Classes
    /// &lt;/summary&gt;
    //This is the parent class.
    
    public class MyClass
    {
        protected string FirstName;
        protected string LastName;
        protected uint ?age;
        protected MyClass(string FSS)
        {
            Console.WriteLine(FSS);
        }
        public void DisplayInfo()
        {
            Console.WriteLine("Name: {0} {1}",FirstName, LastName);
            if(age==null)
            {
                Console.WriteLine("Age: No Age Provided");
            }
            else
            {
                Console.WriteLine("Age: {0}", age);
            }
        }
    }
    
    //This is the inherited class.
    public class Mates:MyClass
    {
        char Grades;
        
        //THIS IS DEFAULT CONSTRUCTOR
        public Mates(): base("CHILD CLASS CONTROLS THE PARENTS CLASS") //this needs to be public.
            //AS YOU SEE THE :base () sythax appears here too.
        {
            FirstName="No First Name Provided";
            LastName="No Last Name Provided";
            age = null;
        }
        
        //THIS IS OVERLOADED CONSTRUCTOR
        
        //the constructor needs to be public
        //:base () -> it's used to explicitely specify which constructor should be 
        //used for the parent class
        
        //The syntax must be used for each constructor of the child class.
        //if the parent class constructor takes no arguments, then the syntax is optional.
        public Mates(string FS, string LS, uint AGE_m, char GRD) : base("CHILD CLASS CONTROLS THE PARENTS CLASS")
        {
            FirstName=FS;
            LastName=LS;
            age=AGE_m;
            Grades=GRD;
        }
        public void DisplayGrades()
        {
            ///&lt;summary&gt;Displays the grades of the objects in this class.&lt;/summary&gt;
            Console.WriteLine("Grade: {0}", Grades);
        }
    }
}
</code>
        </inheritance>
        <abstraction>
            *General-Programming-Knowledge*
<code>
//Abstraction:

//Animal class provides empty function for eat() 
//and actual implementation for sound()

abstract class animal 
{
    public abstract void eat();
    public void sound() 
    {
        Console.WriteLine("dog can sound");
    }
}

//Class dog inherits animal and can provide its implementation to eat()
//while still be able to access actual implementation sound()

class dog: animal 
{
    public override void eat() 
    {
        Console.WriteLine("dog can eat");
    }
}
</code>
        </abstraction>
        <generic-programming>
            *General-Programming-Knowledge*
<code>
using System;
/* The generic is a specification that allows to a function/method or class to operate without 
 * depending on the data type that's been taking 
 * as parameters, and without losing the strong typed property of the function, and the performance.
 * Generics were introduced in C# 2.0, and they are used especially for class collections.
 * 
 * The conversion from value type to reference type is called boxing. When we talk about performance 
 * provided by generics, we mean that
 * no boxing will be effectuated. Boxing are weak in performance.
 */

namespace project45_generics
{
    class Program
    {
        public static void Main(string[] args)
        {
            Program aProg = new Program();
            
            //Using the generic function:
            bool result = aProg.IsEqual&lt;int&gt; (21,44); //the function works for any data type.
            Console.WriteLine("Result of the comparison: {0}", result);
            
            result = aProg.IsEqual&lt;string&gt; ("Adam", "Exit"); //the function works for any data type.
            Console.WriteLine("Result of the comparison: {0}", result);
            
            result = aProg.IsEqual&lt;char&gt;('a', 'a'); //the function works for any data type.
            Console.WriteLine("Result of the comparison: {0}", result);
            
            //Working with the generic class:
            MyClass&lt;int&gt; GenCls = new MyClass&lt;int&gt;();
            GenCls.printStuff(12,3);
            
            MyClass&lt;string> GenCls2 = new MyClass&lt;string&gt;();
            GenCls2.printStuff("Deady", "Online");
            
            //End of program.
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
        
        //Creating a generic function:
        public bool IsEqual &lt;T&gt; (T value1, T value2) //the parameters are of type T, into 
        //that type could be encapsulated any data type.
        {
            return value1.Equals(value2);
        }
        
        //The syntax to create a generic function is: access_modifier return_type function_name 
        //&lt;variable_type_name&gt; (arguments of variable_type_name).
    }
    
    //Creating a generic class
    #region GenericClass //this is how you can structure your code using regions
    class MyClass &lt;A&gt; //the syntax is class Class_Name &lt;variable_type_name&gt;
    {
        //Creating a function for the generic class.
        public void printStuff(A value1, A value2)
        {
            Console.WriteLine("The stuff sent is: {0} &#38;&#38; {1}", value1, value2);
        }
    }
    #endregion //end of the region
}
</code>
        </generic-programming>
        <variable-arguments-lists>
            *General-Programming-Knowledge*
            <br></br>
            Use the <code>param</code> keyword to get the variable arguments in C#.
<code>
//Example of working with variable arguments in C#

using System;

class Program {
   static void Main() {
      int mulVal1 = Multiply(5);
      int mulVal2 = Multiply(5, 10);

      Console.WriteLine(mulVal1);
      Console.WriteLine(mulVal2);
   }

   static int Multiply(params int[] b) {
      int mul =1;
      foreach (int a in b) {
         mul = mul*a;
      }
      return mul;
   }
}
</code>
        </variable-arguments-lists>
        <simple-data-types>
            *General-Programming-Knowledge*
<code>
//Example of working with different data type variables in C#

using System;

namespace project1_introduction 
{
    class Program
    {
        public static void Main(string[] args)
        {             
            //Data types:
            int numb_one = 5;
            float numb_two = 6.034f;
            double numb_three = 3.0;
            bool istrue = false;
            string name = "Black";
            object ANYTHING = "A variable that can be initialized with anything!";
            char character = 'X';
            
            //Printing the result on the screen;
            Console.Write("The result of addition is: " + (numb_one+numb_two) + "\n");
            Console.WriteLine("An object is: " + "\"" + ANYTHING + "\"");
            
            /*
             Console.WriteLine - automatically puts '\n' at the end of the line,  
             because it is a function designed to be used only for writing a line.
            */
            
            Console.Write(character + "\n");
            Console.WriteLine("Processing data!\n\n");
            while (numb_one>0)
            {
                if(numb_one==1)
                {
                    Console.WriteLine("The program will end.\n\n");
                }
                numb_one--;
            }
            Console.Write("Press any key to continue . . . ");
            
            //function to read keys;
            Console.ReadKey(true);
        }
    }
}
</code>
        </simple-data-types>
        <complex-data-types>
            *General-Programming-Knowledge*
            <br></br><br></br>
            <green>C# brings changes with regards to the datatypes which were available in C/C++:</green>
            <br></br><br></br>
            C# supports pointers in a limited extent. <br></br><br></br>
            A C# pointer is 
            nothing but a variable that 
            holds the memory address of another type. But in C# pointer can only be declared to 
            hold the memory address of value types and arrays. 
            <br></br><br></br>
            Unlike reference types, pointer types are not tracked by the default garbage 
            collection mechanism. For the same reason pointers are not allowed to point to a 
            reference type or even to a structure type which contains a 
            reference type. 
            <br></br><br></br>
            We can say that pointers can point to only unmanaged types which includes 
            all basic data types, enum types, other pointer types and 
            structs 
            which contain only unmanaged types.
            <br></br><br></br>
            <brown>There are no unions available in C#.</brown><br></br>
            <brown>There are no typedefs available in C#.</brown><br></br>
        </complex-data-types>
        <preprocessor-directives>
            *General-Programming-Knowledge*
            C# unlike C and C++ it does not allow the use directives to create macros. 
            <br></br><br></br>
            <brown>
                Although there is no #define in C# - some preprocessor directive are still available:
            </brown>
            <br></br><br></br>
<code>
//Example:

#if DEBUG
    Console.WriteLine("Debug version");
#endif
</code>
            A preprocessor directive must be the only 
            instruction on a line. <br></br>
        </preprocessor-directives>
        <loops>
            *General-Programming-Knowledge*
            <br></br>
            <brown>Foreach loop:</brown>
            <br></br><br></br>
            Foreach loop is used especially when trying to iterrate into a 
            list which has dinamic size, or an array with unknown size.
            <br></br><br></br>
            <green>The foreach loop is very similar to a for loop</green>.
            <br></br><br></br>
            Foreach is used only for Collection of data.
            The difference between for loop and foreach loop is that 
            in foreach loop there is no access to the index.
                
<code>
//Example of foreach loop in C#

using System;

namespace project6_foreach_loop
{
    class Program
    {
        public static void Main(string[] args)
        {
            int [] myarray = new int[10];
            for (int i=0;i&lt;10;i++)
            {
                myarray[i]=3*i;
            }
            
            Console.WriteLine("\nDisplaying elements using FOR LOOP: ");
            
            for (int i=0;i&lt;10;i++)
            {
                Console.WriteLine("myarray[" + i + "]=" +myarray[i]);
            }
            
            Console.WriteLine("\nDisplaying elements using FOREACH LOOP: ");
            
            // syntax forech (datatype iterator_name in data_collection)
            foreach(int iter in myarray) 
            {
                    Console.WriteLine("myarray[" + iter/3 + "]=" +iter);
            }
            
            Console.WriteLine("\nSimple task for FOREACH LOOP");
            
            // syntax forech (datatype iterator_name in data_collection)
            foreach(int iter in myarray) 
            {
                if(iter%5==0 &#38;&#38; iter>0)
                {
                    Console.WriteLine (iter + " is divisible with five.");
                }
            }
            
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </loops>
        <collections>
            *General-Programming-Knowledge*
            <br></br>
            <green>C# introduces the following collections:</green>
            <br></br><br></br>
            <code>Queue</code> is a collection type just like a list or dictionary, dispite that 
            once an object is retrieved from <code>Queue</code> (operation called dequeue), 
            that object
            gets automatically deleted from the beggining of the <code>Queue</code>.
            <br></br><br></br>
            You can think of a <code>Queue</code> just like a RAR archieve, in order to use an 
            object from the <code>Queue</code>, that object needs to be dequeued into an 
            another object, otherwise it will affect the entire content of the <code>Queue</code>, 
            unless an <code>foreach</code> loop is being used.
            <br></br><br></br>
            To prevent an object be deleted from the <code>Queue</code>, you 
            have to use a 
            <code>foreach</code> loop or the <code>.Peak</code> function. 
            <br></br><br></br>
            If you iterate through the <code>Queue</code> 
            using <code>foreach</code> loop, 
            and effect changes without affecting the content of the <code>Queue</code>.
            <br></br>
<code>
//Exemple on how to use Queue

using System;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic;

namespace queue_collection_type
{
    class Program
    {
        public static void Main(string[] args)
        {
            people p1 = new people ("Black", 22);
            people p2 = new people ("Mark", 24);
            
            //Creating Queue
            Queue &lt;people&gt; FirstQueue = new Queue &lt;people&gt; ();
            FirstQueue.Enqueue(p1);
            FirstQueue.Enqueue(p2);
            
            //Printing Information:
            Console.WriteLine("Number of objects in Queue: {0}\n", FirstQueue.Count());
            
            //This usage is wrong, unless it is moved into a foreach loop:
            //Console.WriteLine ("Name: {0}, Age: {1}", FirstQueue.Dequeue().name, 
            //                      FirstQueue.Dequeue().Age); 
            
            //A Queue is like an archieve, you need to extract the object from it, 
            //before using that object.
            Queue&lt;people&gt; SecondQueue = new Queue&lt;people&gt; ();
            SecondQueue.Enqueue(p1);
            SecondQueue.Enqueue(p2);
            people deq1 = FirstQueue.Dequeue();
            people deq2 = FirstQueue.Dequeue();
            
            /*
             SecondQueue=FirstQueue 
            
             These two Queues become highly connected one to another in the way that, 
             SecondQueue take all the objects from the FirstQueue, 
             but if in FirstQueue an object is removed so it is in the SecondQueue.
             
            */
            
            Console.WriteLine("Name: {0}, Age: {1}", deq1.name, deq1.Age);
            Console.WriteLine("Name: {0}, Age: {1}", deq2.name, deq2.Age);
            Console.WriteLine();
            
            //Auxiliar way -> Iteration:
            foreach (people p in SecondQueue)
            {
                Console.WriteLine("Name: {0}, Age: {1}", p.name, p.Age);
                Console.WriteLine ("Number of objects in Queue: {0}", FirstQueue.Count());
                Console.WriteLine("In the foreach loop the content of the Queue is it not affected, \n(Dequeue is made without removal).\n");
            }
            
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    class people 
    {
        public int Age {get; set;}
        public string name {get; set;}
        public people (string GivenName, int GivenAge) 
        {
            this.Age = GivenAge; 
            this.name = GivenName;
        }
    }
}
</code>
            
  <code>Stack</code> is a collection that uses the principle LIFO - Last In First Out, 
  and which can be accessed and handled similarly to a list.
  <br></br><br></br>
  Once an element gets retrieved from the <code>Stack</code> that object will be removed, 
  unless a <code>foreach</code> loop, or the <code>.Peek</code> function it's used.
  <br></br>
 
<code>
//Example on how to use Stack

using System;
using System.Collections.Generic;

namespace project61_stack_collection_type
{
    class Program
    {
        public static void Main(string[] args)
        {
            people p1 = new people ("Dragos", 22);
            people p2 = new people ("Adrian", 21);
            Stack&lt;people&gt; FirstStack = new Stack&lt;people&gt;();
            FirstStack.Push(p1);
            FirstStack.Push(p2);
            
            //The first will be the last:
            foreach (people p in FirstStack)
            {
                Console.WriteLine("Name: {0}    Age: {1}", p.Name, p.Age);
                Console.WriteLine("Number of elements on Stack: {0}", FirstStack.Count);
            }
            
            Console.WriteLine();
            Console.WriteLine("Outside the forech loop:");
            
            Console.WriteLine("Name: {0}", FirstStack.Pop().Name);
            Console.WriteLine("Number of elements on Stack: {0}", FirstStack.Count);
            Console.WriteLine("Name: {0}", FirstStack.Pop().Name);
            Console.WriteLine("Number of elements on Stack: {0}", FirstStack.Count);
            
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    
    class people
    {
        public string Name {get; set;}
        public int Age {get; set;}
        public people (string NewName, int NewAge) {Name=NewName; Age=NewAge;}
    }
}
</code>
        </collections>
        <dynamic-memory-allocation>
            In C#, objects are dynamically allocated on the heap using the 
            <code>new</code> keyword.
            <br></br><br></br>
            When an object is no longer needed, it is the responsibility of the garbage 
            collector to deallocate the memory and reclaim it for future use.
        </dynamic-memory-allocation>
        <read-from-file>
            *General-Programming-Knowledge*
<code>
//Example of reading content from a file.

using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;

namespace read_from_file
{
    class Program
    {
        public static void Main(string[] args)
        {
            string textFromFile = System.IO.File.ReadAllText("textfile.txt");
            
            if(textFromFile!=string.Empty)
            {
                Console.WriteLine("Text From File: \n\n{0}", textFromFile);
            }
            
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </read-from-file>
        <write-to-file>
            *General-Programming-Knowledge*
<code>
//Example of writing content to a file.

// Write file using StreamWriter
using (StreamWriter writer = new StreamWriter(fullPath))
{
   writer.WriteLine("Monica Rathbun");
   writer.WriteLine("Vidya Agarwal");
   writer.WriteLine("Mahesh Chand");
   writer.WriteLine("Vijay Anand");
   writer.WriteLine("Jignesh Trivedi");
}

// Read a file
string readText = File.ReadAllText(fullPath);
Console.WriteLine(readText);
</code>
        </write-to-file>
        <serialization>
            *General-Programming-Knowledge*
<code>
//Example of using serialization in C#

using System;  
using System.IO;  
using System.Runtime.Serialization.Formatters.Binary;
  
[Serializable]  //this will ensure that the class is serializable
class Student  
{  
    int rollno;  
    string name;  
    public Student(int rollno, string name)  
    {  
        this.rollno = rollno;  
        this.name = name;  
    }  
}

public class SerializeExample  
{  
    public static void Main(string[] args)  
    {  
        FileStream stream = new FileStream("e:\\sss.txt", FileMode.OpenOrCreate);  
        BinaryFormatter formatter=new BinaryFormatter();  
          
        Student s = new Student(101, "sonoo");  
        formatter.Serialize(stream, s);  
  
        stream.Close();  
    }  
}  
</code>
        </serialization>
        <deserialization>
            *General-Programming-Knowledge*
<code>
//Example of deserializating an object from a file.

using System;  
using System.IO;  
using System.Runtime.Serialization.Formatters.Binary;
  
[Serializable] //this will ensure that the class is serializable 
class Student  
{  
    public int rollno;  
    public string name;  
    public Student(int rollno, string name)  
    {  
        this.rollno = rollno;  
        this.name = name;  
    }  
}  

public class DeserializeExample  
{  
    public static void Main(string[] args)  
    {  
        FileStream stream = new FileStream("e:\\sss.txt", FileMode.OpenOrCreate);  
        BinaryFormatter formatter=new BinaryFormatter();  
  
        Student s=(Student)formatter.Deserialize(stream);  
        Console.WriteLine("Rollno: " + s.rollno);  
        Console.WriteLine("Name: " + s.name);  
  
        stream.Close();  
    }  
}  
</code>
        </deserialization>
        <constructors>
            *General-Programming-Knowledge*
            <br></br>
            In C# constructors can be defined for <code>structs</code> as well as <code>classes</code>.
            <br></br><br></br>
            A <code>struct</code> is a similar data type with a <code>class</code>, but 
            structs works with values, while classes works as 
            references.
            <br></br><br></br>
            <green>For a struct:</green>
            <br></br><br></br>
             - if we create 2 struct objects (object1 and 
             object2):
             <br></br>
 <code>
 object1 = object2;
 
 /*
    - in this case object1 will have all the values that 
    object2 has.
 */
 </code>
             <br></br>
             <green>For a class</green>:
             <br></br><br></br>
             - if we create 2 class objects (object1 and 
             object2):
             <br></br>
 <code>
 object1 = object2;
 
 /*
  - in this case object1, will be poiting to the object2's values 
    which are stored on the heap.
 */
 </code>
             <br></br>
             <brown>
             The constructors for both structs and classes are declared in the same way:
             </brown>
             <br></br>
<code>
//Example of constructors

using System;

namespace project5_structs_with_constructors
{
    class Program
    {
        struct MyStr
        {
            //Variables of the struct:
            public int posx, posy;
            
            //Constructor of the struct:
            public MyStr (int newposx, int newposy)
            {
                posx = newposx;
                posy = newposy;
            }
        }
        public static void Main(string[] args)
        {
            //Creating the instances/objects of the struct
            MyStr structure1 = new MyStr (4, 5);
            MyStr structure2 = new MyStr (10, 12);
            
            //Printing the values:
            Console.WriteLine("The first structure has: X=" +structure1.posx +" and Y=" +structure1.posy);
            Console.WriteLine("The second structure has: X=" +structure2.posx +" and Y=" +structure2.posy);
            structure1 = structure2;
            
            //Printing the values:
            Console.WriteLine("\nAfter setting structure1 = structure2.\n");
            Console.WriteLine("The first structure has: X=" +structure1.posx +" and Y=" +structure1.posy);
            Console.WriteLine("The second structure has: X=" +structure2.posx +" and Y=" +structure2.posy);
            
            //End of program:
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </constructors>
        <instantiation>
            *General-Programming-Knowledge*
            <br></br>
            When you create a <code>new</code> object in C# for a <code>class</code> using 
            the <code>new</code> 
            keyword, then it is called instantiation.
            <br></br>
<code>
Student s1 = new Student();
</code>
        </instantiation>
        <destructors>
            *General-Programming-Knowledge*
<code>
class Example
{ 
    // Rest of the class
    // members and methods.

   // Destructor
   ~Example()
    {
        // Your code
    }

} 
</code>
        </destructors>
        <function-overloading>
            *General-Programming-Knowledge*
<code>
//Example of function overloading in C#:

using System;

namespace project26_methods_and_functions_overloading
{
    class Program
    {
        public static void Main(string[] args)
        {
            int outsider;
            Program p = new Program();
            p.Add(10,12);
            p.Add(1,102,34);
            p.Add(0.2f,3.3f);
            p.Add(1,33, out outsider);
            Console.WriteLine("Func4 Result: {0}", outsider);
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
        
        /*
        A function or method can be overloaded using different number of parameters, 
        different types of parameters or different kind of parameters.
        
        Kinds of parameters are: input parameters, output parameters, reference parameters.
        Types of parameters are: float, int, double, char, etc...
        
        Overloading means that you can have multiple functions with the same name, but 
        respecting at least one of the criteria above (also it can respect all of the 
        criteria above). 
        
        This means that the signature of the overloaded function must be different from 
        the primary function.
        
        Signature consist in number, type and kind of parameters, and also in the code inside 
        the brackets. But a signature does not consist in the return type of the function, 
        the access modifier of the function, or the optional parameters (params) of the function.
        
        So a function CANNOT be overloaded ONLY by using different return types, access modifiers, 
        or optional params, it must be respected the criteria above.
        
        Examples:
        */
        
        public void Add(int numb1, int numb2)
        {
            Console.WriteLine("Func1\nThe Sum: {0}\n", numb1+numb2);
        }
        public void Add(int numb1, int numb2, int numb3) //method overloaded
        {
            Console.WriteLine("Func2\nThe Sum: {0}\n", numb1+numb2+numb3);
        }
        public void Add(float numb1, float numb2) //method overloaded
        {
            Console.WriteLine("Func3\nThe Sum: {0}\n", numb1+numb2);
        }
        public void Add (int numb1, int numb2, out int sum) //method overloaded
        {
            sum=numb1+numb2;
        }
    }
}
</code>
        </function-overloading>
        <operator-overloading>
            *General-Programming-Knowledge*
<code>
// Example of operator overloading in C#:

using System;

namespace Calculator 
{
     
    class Calculator 
    {
         
        public int number1 , number2;
        public Calculator(int num1 , int num2)
        {
            number1 = num1;
            number2 = num2;
        }
         
        // Function to perform operation
        // By changing sign of integers
        public static Calculator operator -(Calculator c1)
        {
            c1.number1 = -c1.number1;
            c1.number2 = -c1.number2;
            return c1;
        }
         
        // Function to print the numbers
        public void Print()
        {
            Console.WriteLine ("Number1 = " + number1);
            Console.WriteLine ("Number2 = " + number2);
        }
    }
     
    class EntryPoint
    {
         
        static void Main(String []args)
        { 
             
            // using overloaded - operator 
            // with the class object
            Calculator calc = new Calculator(15, -25);
             
            calc = -calc;
             
            // To display the result
            calc.Print();
        }
    }
}
</code>
        </operator-overloading>
        <enums>
            *General-Programming-Knowledge*
             The <code>enum</code> is like an <code>array</code> of <code>boolean</code> values, 
             in which only one can be <code>true</code> at a time.
             <br></br> <br></br> 
             This is useful while creating game engines, or software engines, 
             to know when a certain option is available. 
             <br></br><br></br> 
             Also this is used to control and interract the states in a certain application.
             <br></br> 
<code>
//Example of using enums in C#

using System;
using System.Threading.Tasks;
using System.Text;
using System.Linq;
using System.Collections.Generic;

namespace Software
{
    class Software
    {
         /*
          * NOTE: 
          * Enums cannot be declared inside a function, or method. 
          * NOT even within the Main function.
          */
        
        enum Gamestate {Playing, Menu, Pause=6}; //from now on, Gamestate is like a datatype.
        
        /*
         * From the moment of declaration the enum is initializing to true the first state. 
         * In this case:
         * Playing = true, until the programmer sets it otherwise.
         * The elements of the enum can also hold values, 
         * as it sets above, Pause = 6, Playing = 0, Menu = 1 
         * (by default the    value set for each element is its index).
         */
        
        public static int Main()
        {
            //Creating an object/instance for the enum;
            Gamestate gamestate;
            Console.WriteLine("Gamestate: " + Convert.ToInt32(Gamestate.Pause));
            Console.WriteLine("Gamestate: " + Convert.ToInt32(Gamestate.Playing));
            
            //Changing the state of the Gamestate enum;
            gamestate=Gamestate.Menu;
            
            /* Equivalence for this case:
             * bool Playing = false;
             * bool Menu = true;
             * bool Pause = false;
             */
             
            Console.WriteLine("Gamestate: " + gamestate);        
            gamestate=Gamestate.Playing;
            
            /* Equivalence:
             * bool Playing = true;
             * bool Menu = false;
             * bool Pause = false;
             */
             
            Console.WriteLine("Gamestate: " + gamestate);
            
            //Interraction of the user:
            int input=9;
            while(input>0 &#38;&#38; input&lt;10)
            {
                Console.WriteLine("Enter the option: ");
                input = Convert.ToInt16 (Console.ReadLine());
                switch(input)
                {
                        case 1:
                        {
                            gamestate = Gamestate.Menu;
                            Console.WriteLine("The active state: " + gamestate);
                            break;
                        }
                        case 2:
                        {
                            gamestate = Gamestate.Pause;
                            Console.WriteLine("The active state: " + gamestate);
                            break;
                        }
                        case 3:
                        {
                            gamestate = Gamestate.Playing;
                            Console.WriteLine("The active state: " + gamestate);
                            break;
                        }
                        default:
                        {
                            Console.WriteLine("This is not a gamestate");
                            break;
                        }
                }
            }
            Console.WriteLine("Out of the loop!");
            Console.ReadLine();
            return 0;
        }
    }
}
</code>
        </enums>
        <concurrent-programming>
            *General-Programming-Knowledge*
<code>
//Example of using multi-threading in C#

using System;
using System.Threading;

namespace MultithreadingApplication 
{
   class ThreadCreationProgram 
   {
      public static void CallToChildThread() 
      {
         try 
         {
            Console.WriteLine("Child thread starts");
            
            // do some work, like counting to 10
            for (int counter = 0; counter &lt;= 10; counter++) 
            {
               Thread.Sleep(500);
               Console.WriteLine(counter);
            }
            
            Console.WriteLine("Child Thread Completed");
         } 
         catch (ThreadAbortException e) 
         {
            Console.WriteLine("Thread Abort Exception");
         } 
         finally 
         {
            Console.WriteLine("Couldn't catch the Thread Exception");
         }
      }
      
      static void Main(string[] args) 
      {
         ThreadStart childref = new ThreadStart(CallToChildThread);
         Console.WriteLine("In Main: Creating the Child thread");
         
         Thread childThread = new Thread(childref);
         childThread.Start();
         
         //stop the main thread for some time
         Thread.Sleep(2000);
         
         //now abort the child
         Console.WriteLine("In Main: Aborting the Child thread");
         
         childThread.Abort();
         Console.ReadKey();
      }
   }
}
</code>
        </concurrent-programming>
        <namespaces>
            *General-Programming-Knowledge*
            <br></br>
            C# allows using <code>namespace</code> alliases to avoid 
            ambiguity errors. 
            <br></br><br></br>
            An ambiguity errors is when declaring 2 namespaces 
            which may contains some classes or functions with 
            the same name, so when trying to call one of such function, the compiler
            will not know to which one are you are refering to.
            <br></br>
<code>
//Example of using namespaces in C#

//FILE: MyClass.cs

using System;

//The namespace need to be declared in here

using Project20.DeadyOnline; //declaration of the namespace.
using PATA = Project20.DeadyOnline; //Creating a namespace alias called PATA.


//THIS IS AN EXTERNAL CLASS PROJECT
//in order to use this you need to right click on this project and add the ProjectA.TeamB
//as reference to the main project (in this case this is the main project).
using ProjectA.TeamB; 

namespace project20_namespaces
{
    class Program
    {
        public static void Main(string[] args)
        {
            //Creating an instance for the Class that's inside the namespace Project20.DeadyOnline
            //A namespace is using much like a path to a file, or a directory(folder).
            
            Project20.DeadyOnline.FirstClass p = new Project20.DeadyOnline.FirstClass();
            
            //If the namespace is declared above, an object of the class can be created as follows:
            FirstClass p2 = new FirstClass();
            
            //Calling the function that's inside the namespace below.
            
            //calling the STATIC function which has to be done using the qualify name of the class
            Project20.DeadyOnline.FirstClass.PrintingMethod();
            
            //calling the function using the namespace alias PATA.
            PATA.FirstClass.PrintingMethod();
            
            //Also the function can be called like this if the namespace is declared above.
            FirstClass.PrintingMethod();
            
            //calling the INSTANCE (non-static) function.
            p.AnotherMessage();
            
            //calling the INSTANCE (non-static function) using the object 2.
            p2.AnotherMessage(); 
            
            //Calling a function from external namespace and class.
            
            //creating an instance of the class.
            MyClass ms = new MyClass(); 
            
            //the function is INSTANCE function (so it needs to be called with and instance of
            //the class that it belongs to).
            ms.PrintName();

            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}

//Namespaces are used to organize the code/programs, and to avoid name clashes.
//Creating a namespace: (this is internal namespace because it's written into the same file.)
namespace Project20
{
    namespace DeadyOnline
    {
        class FirstClass
        {
            public static void PrintingMethod()
            {
                Console.WriteLine("This is a function from a SELF-CREATED namespace.");
            }
            public void AnotherMessage()
            {
                Console.WriteLine("This function is INSTANCE function.");
            }
        }
    }
}
</code>

<code>
//This is an external namespace

//FILE: Program.cs

using System;
using System.Collections.Generic;

namespace ProjectA.TeamB
{
    //This are called XML Comments, and are used to create descriptions.
    /// &lt;summary&gt;
    /// This is an Outside Class Project that contains a PrintName Function.
    /// &lt;/summary&gt;
    
    public class MyClass
    {
        public void PrintName()
        {
            Console.WriteLine("This is an external Class Project called ProjectA.TeamA");
        }
    }
}

/* 
//The code above is equivalent to this:

namespace ProjectA
{
    namespace TeamB
    {
        public class MyClass
        {
            public void PrintName()
            {
                Console.WriteLine("This is an external Class Project called ProjectA.TeamA");
            }
        }
    }
}

//THIS IS CALLED NASTED NAMESPACE (or a namespace inside of another).
 */
</code>
        </namespaces>
        <exception-handling>
            *General-Programming-Knowledge*
            <br></br> 
            <green>
                Disadvantages of unhandling exceptions:
            </green>
            <br></br> <br></br> 
            
             An unhandled exception would provide annoying error message to a user, 
             which could make the program be devoid using.
             <br></br> 
             An unhandled exception could also provide important information to a hacker.
             <br></br><br></br> 
             
             While handling the exceptions the <code>catch</code> block containing the specific 
             classes must be placed above the general class which should be the last one 
             at the bottom.
             <br></br> <br></br> 
             In this way specific exceptions will be handled first and in case the 
             <code>exception</code> was not handled
             specifically then it can be handled generically with the general <code>Exception Class</code>.
             <br></br> 
<code>
//Example on how to handle exceptions in C#

using System;
using System.IO; //namespace for files.

namespace project37_read_write_to_files_handling_exceptions
{
    class Program
    {
        public static void Main(string[] args)
        {
            
            //Creating a file read streamer:
            StreamReader readFromFile = new StreamReader(@"D:\error.txt"); // @ -> using the escape sequence
            
            //EXCEPTION HANDLING:
            
            //try to do this without exception
            try 
            {
                Console.WriteLine(readFromFile.ReadToEnd()); 
                //ReadToEnd will read all the content of the file (until the end).
            }
            
            /*
             * If there was an exception come to this catch statement
             * THIS IS A SPECIFIC CATCH, this is the child of EXCEPTION CLASS
             * try to handle the exception with this object.
             * This object is mostly for FileNotFoundException.
             */
            
            catch(FileNotFoundException fNotFound) 
            {
                //An object of type FileNotFoundException contain more information about 
                //the file that could not be found then an object of type 
                //Exception (as we use in our case).
                
                Console.WriteLine(fNotFound.Message);
                Console.WriteLine("Check for the file: {0}", fNotFound.FileName);
            }
            
            //If the catch above was not able to handle the exception try this one:
            //The Exception class is the parent of all the other classes above.
            //So this will catch any kind of exception that might have occurred.
            
            catch(Exception ex) //this can handle also the DirectoryNotFoundException.
            {
                Console.WriteLine(ex.Message);
            }
            
            //The finally is always executed regardless of the result whereas 
            //the execution of catch blocks execution is not a certainty.
            
            finally 
            //the finally block contain the code that should be executed by all means necessary
            {
                if(readFromFile!=null) //if the file is null then it cannot be closed.
                {
                    readFromFile.Close();
                }
            }
            
            //END OF EXCEPTION HANDLING.
            
            StreamWriter writeToFile = new StreamWriter(@"D:\writeToFile.txt");
            writeToFile.WriteLine("Project37 Read write to files, exception handling Finally!");
            writeToFile.Close(); //the filestream needs to be closed for the writing to work.
            
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </exception-handling>
        <bitwise-operators>*General-Programming-Knowledge*</bitwise-operators>
        <default-parameters>
            *General-Programming-Knowledge*
<code>
//Example of functions default-parameters:

static void MyMethod(string country = "Norway") 
{
  Console.WriteLine(country);
}

static void Main(string[] args)
{
  MyMethod("Sweden");
  MyMethod("India");
  MyMethod();
  MyMethod("USA");
}

// OUTPUT:
// Sweden
// India
// Norway
// USA
</code>
        </default-parameters>
        <interfaces>
            *General-Programming-Knowledge*
            <br></br>
            <green>
            An interface in C# is mostly like a class but with some differences:
            </green>
            <br></br><br></br>
            
             1. An <code>interface</code> cannot have field members/variable members (can have only 
             functions/methods, delegates, events or properties).
             <br></br><br></br>
             2. An <code>interface</code> cannot contain implementations for the functions/methods
             (an implementation of a function/method is the code between the brackets).
             <br></br><br></br>
             3. An <code>interface</code> has <code>public</code> fields set by default, so inside an 
             <code>interface</code> you 
             cannot use the <code>public</code> acces-modifier for its members.
             <br></br><br></br>
             4. A class can inherit from an <code>interface</code>. But with the condition of providing 
             the implementation for all the <code>interface</code> function/method members.
             <br></br><br></br>
             5. When a class provides implementation of an <code>interface</code> function member, 
             it also needs to make the member function <code>public</code>. 
             (The <code>public</code> access modifier must be used.)
             <br></br><br></br>
             6. A <code>class</code> or <code>struct</code> can inherit from MORE interfaces 
             at the same time. 
             Whereas a <code>class</code> or <code>struct</code> cannot inherit from
             more then one <code>class</code>.
             <br></br><br></br>
             7. An <code>interface</code> cannot be instanciated (an instance, 
             object of the <code>interface</code> 
             cannot be created), because doing this it would mean that you would be able to call 
             a function from the <code>interface</code>, and the <code>interface</code> cannot contain
             implemented members.
             
             <br></br><br></br>
<code>
//Example of using creating/using interfaces

using System;

namespace project30_interfaces
{
    //Creating an interface:
    public interface Ifirst_interface //an interface name usually starts with I (capital i).
    {
        //int age; -> an interface cannot have such fields (variable fields).
        //public void Print(); -> an interface cannot contain public access modifier.
        
        void Print(); //this is a function of the interface.
    }
    public interface Isecond_interface : Ithird_interface
    {
        void Print2();
    }
    public interface Ithird_interface
    {
        void Print3();
    }
    
    class Program
    {
        public static void Main(string[] args)
        {
            Inherited_from_interface Iobject = new Inherited_from_interface();
            Iobject.Print();
            Iobject.Print3(); //calling the grandpa's function.
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    
    class Inherited_from_interface : Ifirst_interface, Isecond_interface
    {
        /* A class that inherits from an interface HAS to provide implementations for all 
         * the interface methods members.
         */
         
        public void Print() //providing implementation for the interface function.
        {
            /*
             * IMPORTANT: 
             * when providing implementation for an interface function/method member you have
             * to specify it to be public. (YOU need to use the public access modifier.)
             * 
             * IF A CLASS inherits from multiple interfaces, then the class has to provide 
             * members.implementation for all the interface members.
             * 
             * IF A CLASS inherits from an interface which inherits from another interface, 
             * then the class has to provide implementation for both the parent
             * interface and grandparent interface as well.
             */
            
            Console.WriteLine("Class inherited from an interface.");
        }
        
        //A method can be implemented like this. (The brackets can be empty.)
        public void Print2() 
        {
            //By implementing a function inherited from an interface, 
            //you have to assure that the functionis public, and there 
            //exists the brackets (where the implementation should be made).
        }
        
        //this function is inherited from an interface which inherits from another interface.
        public void Print3() 
        {
            Console.WriteLine("This is the grandpa's function!");
        }
    }
}
</code>
        </interfaces>
        <random-generators>
            *General-Programming-Knowledge*
<code>
//Example of generating random numbers in C#

using System;

namespace project68_random_numbers
{
    class Program
    {
        public static void Main(string[] args)
        {
            Random i = new Random();
            int nr;
            nr=i.Next(1,5);
            Console.WriteLine("Value: {0}",nr);
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </random-generators>
        <command-line-arguments>
            *General-Programming-Knowledge*
<code>
//Example of command line arguments in C#:

using System; 

namespace ComLineArg   
{   
    class Program 
    {   
          
        // Main Method which accepts the 
        // command line arguments as  
        // string type parameters   
        static void Main(string[] args)  
        {   
              
            //Check the length of  
            //Command line arguments array
            if(args.Length > 0) 
            { 
                Console.WriteLine("Arguments Passed by the Programmer:");   
              
                //Print the command line  
                //arguments using foreach loop 
                foreach(Object obj in args)   
                {   
                    Console.WriteLine(obj);        
                }   
            }   
            else
            { 
                Console.WriteLine("No command line arguments found."); 
            } 
        }   
    } 
} 
</code>
        </command-line-arguments>
        <ternary-operator>
            *General-Programming-Knowledge*
<code>
//Example of using ternary operator in C#

using System;

namespace project11_ternary_operator
{
    class Program
    {
        public static void Main(string[] args)
        {
            bool istrue;
            int simpletest;
            int number = 10;
            
            //Ternary Operator "?":
            istrue = number==10 ? true : false;
            //Syntax: boolean variable = condition ? value for true : value for false
            
            /* Equivalence of that:
             * if(number==10)
             * {
             *         istrue=true;
             * }
             * else
             * {
             *         istrue=false;
             * }
             */
            
            Console.WriteLine("The value of istrue is: {0}", istrue);
            
            //Other example:
            simpletest = number==10 ? 10+2 : 10-2;
            Console.WriteLine("The value of simpletest is: {0}", simpletest);
            
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </ternary-operator>
        <modular-programming>
            *General-Programming-Knowledge*
<code>
//Example of modular programming in C#:

//FILE: project20_namespaces.cs

using System;


//THIS IS AN EXTERNAL CLASS PROJECT
//in order to use this you need to right click on this project and add the ProjectA.TeamB
//as reference to the main project (in this case this is the main project).

using ProjectA.TeamB; 

namespace project20_namespaces
{
    class Program
    {
        public static void Main(string[] args)
        {
            MyClass ms = new MyClass(); 
            
            ms.PrintName();

            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>

<code>
//This is an external namespace

//FILE: Program2.cs

using System;
using System.Collections.Generic;

namespace ProjectA.TeamB
{
    //This are called XML Comments, and are used to create descriptions.
    /// &lt;summary&gt;
    /// This is an Outside Class Project that contains a PrintName Function.
    /// &lt;/summary&gt;
    
    public class MyClass
    {
        public void PrintName()
        {
            Console.WriteLine("This is an external Class Project called ProjectA.TeamA");
        }
    }
}
</code>
        </modular-programming>
        <string-methods>
            *General-Programming-Knowledge*
            <br></br>
             A <code>stringbuilder</code> is a data type just like <code>string</code>. 
             <br></br><br></br>
             The main difference between them is that the <code>stringbuilder</code> is 
             mutable.
             Mutable means that once that is created the <code>string</code> can be 
             changed, whereas 
             <code>System.string</code> is not mutable, once created cannot be change. 
             <br></br><br></br>
             If you try to change a <code>string</code> after it was been initialized, the system will 
             create another object of the <code>string</code> in
             memory and pass the new value of the <code>string</code> to that object, 
             but the old object 
             which holds the old value of the <code>string</code> will not be cleaned
             until the end of the program, when the garbage collector does its work.
             <br></br><br></br>
             A <code>stringbuilder</code> should be used everytime when a <code>string</code> 
             that's created 
             tends to 
             change its value, in this way, only a single object will
             be created in memory no matter how many times its value will change, 
             because it's mutable.
             <br></br>
<code>
//Example of using StringBuilder and StringBuilder methods:

using System;
using System.Text; // using this for StringBuilder.

namespace project46_working_with_string_builder
{
    class Program
    {
        public static void Main(string[] args)
        {
            //Creating a stringbuilder:
            StringBuilder stringbuiler = new StringBuilder("Adam"); 
            //this is how a stringbuilder gets created and initialized
            
            //To concatenate string builders, there is a function called .Append();
            stringbuiler.Append(" has");
            stringbuiler.Append(" C#");
            stringbuiler.Append(" skills!");
            
            //Printing the stringbuilder:
            Console.WriteLine("{0}", stringbuiler);
            Console.WriteLine("{0}", stringbuiler.ToString()); 
            //this is a better way to print the stringbuilder
            
            //Other stringbuilder operations:
            stringbuiler.Clear(); //clear the stringbuiler's content
            Console.WriteLine("{0}", stringbuiler);
            
            //stringbuilder.Capacity returns the capacity of the stringbuilder
            Console.WriteLine("Stringbuilder Capacity: {0}", stringbuiler.Capacity); 
            
            Console.WriteLine("Stingbuilder Max Capacity: {0}",stringbuiler.MaxCapacity);
            
            //End of program:
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </string-methods>
        <datatype-conversions>
            *General-Programming-Knowledge*
<code>
//Example of datatype conversions:

using System;

namespace project13_implicit__explicit__data_type_conversions
{
    class Program
    {
        public static void Main(string[] args)
        {
            /* An implicit conversion is done by the compiler when there are no loss of information. 
             * Also there is no possibility of throwing exceptions during the conversion.
             * 
             * Example:
             */
             
            int numb1 = 100;
            float numb2 = numb1; //implicit conversion (done by the compiler).
            Console.WriteLine("The value of numb2 is: {0}", numb2);
            
            /* An explicit conversion is done by the programmer using type cast operators  
             * or predefined classes, data-conversion classes.
             * 
             * Example:
             */
            
            float numb3=123.543f;
            numb1 = (int) numb3; //explicit conversion using type cast.
            Console.WriteLine("The value of numb1 is: {0}", numb1);
            
            numb1 = Convert.ToInt32(numb3); //explicit conversion using Conversion Class.
            Console.WriteLine("The value of numb1 is: {0}", numb1);
            
            /* Conversion Class - will throw an exception/message when the conversion fails 
             * because one variable can't hold the value of the converted one.
             * Type Cast - will not throw any exception, will just print the minimum value that 
             * the variable can hold. 
             */
            
            //Parse Methods of converting string to int.
            string valueN = "199";
            numb1 = int.Parse(valueN); //parsing sinthax
            
            //in case if the string does not contain a valid number, an exception will be thrown. 
            //So the program will be terminated.
            Console.WriteLine("The value of numb1 after parsing is: {0}", numb1);
            
            //TryParse Methods of converting string to int.
            string valueB = "221a";
            int Result = 0;
            bool Success = int.TryParse(valueB, out Result); //sinthax of TryParse.    
            
            //if int.TryParsing is succesfull the bool Success will become true, 
            //else it will become false.
            
            //TryParse takes 2 arguments: the string to be converted 
            //and the variable that will stored the converted result (if it is successful). 
            
            //If the TryParse is not successful the Result will not be changed.
            
            if(Success)
            {
                Console.WriteLine("The value of numb1 after tryparsing is: {0}", Result );
            }
            else
            {
                Console.WriteLine("The number is invalid. The conversion was unsuccesful!");
            }
            
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>

<code>
//Example of explicit vs implicit conversions

using System;

namespace project30_explicit_vs_implicit_implementation
{
    interface I1
    {
        void Print(); 
        
        //when there are 2 interfaces with identical function, which inherits into the same child
        //the explicit implementation must be used to avoid ambiguity.
    }
    interface I2
    {
        void Print();
    }
    interface I3
    {
        void MessageShow();
    }
    interface I4
    {
        void MessageShow();
    }
    
    class Program: I1,I2,I3,I4 //this class inherits from all 4 interfaces
    {
        public static void Main(string[] args)
        {
            Program soft = new Program(); 
            //soft is reference variable for an object type Program stored in heap.
            
            soft.Print(); //calling the implicit implemented function
            
            //By TYPE CASTING - calling the explicit implemented functions.
            ((I3)soft).MessageShow(); //calling the explicit implemented function
            ((I4)soft).MessageShow(); //calling the explicit implemented function
            
            //By OBJECT REFERENCE - calling the explicit implemented functions.
            I3 explicit1 = new Program();
            I4 explicit2 = new Program();
            explicit1.MessageShow();
            explicit2.MessageShow();
            
            //END OF PROGRAM;
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
        
        //This is implicit implementation, the compilation and the runtime is fine, 
        //dispite that there is a simple implementation for the both functions.
        
        public void Print()
        {
            Console.WriteLine("Implicit Implemetation!");
        }
        
        //Explicit Implementation:
        
        //when explicitly implementing a function the access modifiers are not allowed
        void I3.MessageShow() 
        {
            Console.WriteLine("This is I3 function!");
        }
        
        //when explicitly implementing a function the access modifiers are not allowed
        void I4.MessageShow() 
        {
            Console.WriteLine("This is I4 function!");
        }
    }
}
</code>
        </datatype-conversions>
        <optional-parameters>
            *General-Programming-Knowledge*
            <br></br><br></br>
            <green>
                Ways of adding optional parameters in C#:
            </green>
            <br></br><br></br>
            
            1. Using <code>params</code> arrays (optional arrays created 
            using <code>params</code> keyword as prefix).<br></br>
            2. Methods overloading (overloading a method/function to 
            provide many versions with different number of parameters);<br></br>
            3. Methods with default parameter values.<br></br>
            4. Methods that are using optional attribute.<br></br>
            
            
<code>
//Example of using optional parameters:

using System;

//using this for the [Optional] or [OptionalAttribute] attribute
using System.Runtime.InteropServices; 

namespace project50_optional_parameters
{
    class Program
    {
        public static void Main(string[] args)
        {
            Program pr = new Program();
            Console.WriteLine("The result of adding 10, 3, 4, 6 is: {0}", pr.AddNumbers(10,3, new int[]{4,6}));
            Console.WriteLine("The result of adding 2 and 5 is: {0}", pr.AddNumbers(2,5));
            
            //Calling the second function:
            pr.PrintNrs(12);
            
            //To use the default value only for b (the second argument):
            pr.PrintNrs(1,c:22); //the value of b will be the default value (10);
            
            //To use default value only for c:
            pr.PrintNrs(1,2); //the value of c will be the default value (2);
            
            //CALLING THE OPTIONAL ATTRIBUTE FUNCTIONS:
            pr.DisplayArgs(1,3);
            pr.DisplayArgs(12,3,11);
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
        
        //Creating functions with default values:
        public int AddNumbers(int num1, int num2, int [] array = null) //syntax is just like in C++;
        {
            int result=num1+num2;
            if(array!=null)
            {
                foreach (int i in array)
                {
                    result+=i;
                }
            }
            return result;
        }
        
        
        //for a function with default parameters, the parameters initialized with
        //default values must be the last in the list of parameters 
        //(just like in case of params arrays).
        public void PrintNrs(int a, int b=10, int c=2) 
        {
            Console.WriteLine("Nr1= {0}\nNr2= {1}\nNr3= {2}", a, b, c);
        }
        
        //Creating functions with [Optional] attributes
        public void DisplayArgs(int num1, int num2, [Optional] int num3) 
        //this can also be done with [OptionalAttribute].
        {
            //In case that num3 is not specified by the user, it's value will be 0.
            Console.WriteLine("The numbers are: {0}, {1}, {2}", num1,num2,num3);
        }
    }
}
</code>
        </optional-parameters>
        <partial-classes>
            A partial class is a unique feature of C#. 
            <br></br><br></br>
            It can break the functionality of a single 
            <code>class</code> into many files. 
            <br></br><br></br>
            When the application is compiled, these files are then 
            reassembled into a single <code>class</code> file. 
            <br></br><br></br>
            The <code>partial</code> keyword is 
            used to build a <code>partial class</code>.
            <br></br><br></br>
            <brown>
            A partial class its used to separate/split a class into two or more parts, 
            across different files.
            </brown>
            <br></br><br></br>
            If the part of the class are in different files, those files must be 
            contained in the same assembly (directory of project), otherwise
            the compilation will fail. 
            <br></br><br></br>
            A partial class can also be used in techniques of splitting an 
            interface into more parts successfully.
             <br></br><br></br>
             <green>
             Important rules of partial classes:
             </green>
             <br></br><br></br>
             
             1. Without the partial keyword into the class declaration, 
             the compiler will not 
             know the intention of creating a partial class.
             <br></br><br></br>
             2. All the parts of a partial class needs to be contained by 
             the same namespace 
             and assembly.<br></br><br></br>
             3. All the parts must use the partial keyword in their declaration.
             <br></br><br></br>
             4. All the parts must use the same access modifier in their declaration.
             <br></br><br></br>
             5. If any of the parts is declared as abstract, the entire class will be 
             abstract (even if only a part was declared abstract).
             <br></br><br></br>
             6. If any of the parts is declared as sealed, the entire class will 
             be sealed.
             <br></br><br></br>
             7. If any of the parts is declared to be inherited from a a class, 
             the entire class will be inherited from that class. 
             <br></br><br></br>
             8. Different parts of the partial class cannot specify that they are 
             inherited from 
             different classes.
             <br></br>
             Multiple class inheritance is not allowed in C#.
             <br></br><br></br>
             9. Different parts of the partial class can specify that they inherits 
             from different interfaces, so after the compilation the partial class
             will be inherited from all the specified interfaces (even if they were 
             specified in different parts of the class).
             <br></br><br></br>
             10. The members declared to a part of the partial class are available to all 
             the part of the partial class (available in the entire class).
             
             
<code>
//Example of partial class in C#:

FILE: project47_partial_classes.cs

using System;

namespace project47_partial_classes
{
    class Program
    {
        public static void Main(string[] args)
        {
            //A partial class its used like a normal class.
            MyClass obj = new MyClass();
            obj.Age = 16;
            obj.Name = "Ellias";
            obj.PrintInfo();
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    
    //Example of partial class:
    //the partial keyword must be used for all the parts of the class
    partial class MyClass .
    {
        private string _Name;
        private int _Age;
        
        public int Age
        {
            get {
                return _Age;
            }
            set
            {
                _Age=value;
            }
        }
        
        public string Name
        {
            get {
                return _Name;
            }
            set
            {
                _Name=value;
            }
        }
        
        //THE SECOND PART OF THE CLASS IS IN THE ASSEMBLY DIRECTORY (PROJECT DIRECTORY), 
        //WITH THE NAME PartialClassPartTwo, AND CONTAINS A METHOD CALLED PrintInfo().
    }
    
}
</code>

<code>
//FILE: PartialClassPartTwo.cs

using System;

//IMPORTANT: the class parts must be in the same namespace.
namespace project47_partial_classes 
{
        /// &lt;summary&gt;
        /// Description of PartialClassPartTwo.
        /// &lt;/summary&gt;
        partial class MyClass //the partial keyword must be used for all the parts of the class.
        {
                public void PrintInfo()
                {
                        Console.WriteLine("Name: {0}         Age: {1}", _Name, _Age);
                }
        }
}
</code>
        </partial-classes>
        <decorators>*General-Programming-Knowledge*</decorators>
        <operators>
            *General-Programming-Knowledge*
<code>
//Example of using operators in C#

using System;

namespace project12_new_types_null_coalescing_operator
{
    class Program
    {
        public static void Main(string[] args)
        {
            /* Non-Nullable type: Are Value TYPES: 
             * integers, boolean, double, float, long, long long, char...etc
             * 
             * Nullable type: Are Reference TYPES: 
             * classes, interface, delegates, arrays... etc
             * 
             * A Non-Nullable type can become Nullable type by using ? in their declaration.
             * 
             * Examples:
             */
            
            bool major = false; //non-nullable value type.
            bool ?minor = null; //nullable value type. 
            
            /* A nullable boolean type can hold on to 3 values: true, false or null. */
            Console.WriteLine("Are you a minor? Press Y/N to answear or anything else to skip.");
            char answear = Convert.ToChar(Console.ReadLine());
            switch(answear)
            {
                case 'y':  minor = true; break;
                case 'Y': minor = true; break;
                case 'n':  minor = false; break;
                case 'N': minor = false; break;
                default: minor = null; break;
            }
            
            if(minor == true)
            {
                Console.WriteLine("You are minor!");
            }
            else if(minor == false)
            {
                Console.WriteLine("You are not minor!");
            }
            else
            {    
                Console.WriteLine("You did not answear the question!");
            }
            
            //NULL COALESCING OPERATOR:
            int? TicketsOnSale = 100;
            
            //if TicketsOnSale is null, availableTickets will be 0, otherwise
            //availableTickets = (int)TicketsOnSale.
            int availableTickets=TicketsOnSale??0; 

            /*Equivalent method:
             * if(TicketsOnSale == null)
             * {
             *         availableTickets=0;
             * }
             * else
             * {
             *         availableTickets = (int)TicketsOnSale; 
             *         //TicketsOnSale is a nullable int, so it must be
             *         //casted to normal int.
             *         
             *         //Other method of casting:
             *         //available Tickets = TicketsOnSale.value;
             * }
             */
            
            Console.WriteLine("Available Tickets: {0}", availableTickets);
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
</code>
        </operators>
        <pre-post-incrementation>*General-Programming-Knowledge*</pre-post-incrementation>
        <abstract-classes>
            *General-Programming-Knowledge*
            <br></br>
            <green>In C#:</green> 
            <br></br><br></br>
             An abstract class is similar to an interface, 
             dispite that it can contain 
             variable_members(field members) , and that
             an abstract class it's acting like a class when it comes to 
             inheritance.
             <br></br><br></br>
             An abstract class can have implementation
             for some or even for all its members/field, while the interface 
             cannot.
             <br></br><br></br>
             An abstract class can use the (public) 
            access modifiers whereas an interface cannot. 
            <br></br><br></br>
            An interface can be inherited only from another interface, 
            while an abstract class
            can be inherited either from an interface or abstract class. 
            <br></br><br></br>
            A class can inherit from multiple interfaces at the
            same time whereas a class cannot inherit from multiple classes.
            <br></br><br></br>
            <green>Rules for abstract classes in C#:</green>
            <br></br><br></br>
            
             1. An abstract class cannot be instanciated (an instance 
             of the class cannot be created).<br></br>
             <br></br>
             2. An abstract class can contain abstract members, and the 
             abstract members
             are not allowed to be implemented in
             that class.<br></br>
             <br></br>
             3. An abstract class can inherit (can have children classes), and every child 
             of the class must provide its
             own implementations for the abstract members of the parent class.<br></br>
             <br></br>
             4. Any class provides single inheritance (the child of the class can have 
             only one parent/base class).<br></br>
             <br></br>
             5. An abstract class can only be used as a base class. 
             So an abstract class cannot be sealed.<br></br>
             <br></br>
             6. If a class that's inherited from an abstract class 
             doesn't wish to provide implementation for the parent class
             abstract members, then that class can be also 
             set as abstract.<br></br>
             
<code>
//Example of abstract class in C#:

using System;

namespace project32_abstract_classes
{
    //A class can inherit only from a single class. 
    //(multiple class inheritance is not allowed)
    
    class Program: AbsClass 
    {
        public static void Main(string[] args)
        {
            Program p1 = new Program();
            p1.MessageShow();
            p1.Print();
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
        
        //In order to provide implementation for an abstract member of the parent 
        //class the override keyword must be used.
        protected override void Print()
        {
            Console.WriteLine("Providing implementation for the parent abstract class member.");
        }
    }
    
    //Creating an abstract class:
    public abstract class AbsClass
    {
        //this function is abstract
        protected abstract void Print(); 
        
        //this is a normal function
        public void MessageShow()
        {
            Console.WriteLine("This is not an abstract member.");
        }
    }
}
</code>
        </abstract-classes>
        <recursion>
            *General-Programming-Knowledge*
        </recursion>
        <reflection>
            *General-Programming-Knowledge*
<code>
//Example of reflection in C#:

using System;
using System.Reflection; //using this namespace for reflection

/*
In C# every object is directly or indirectly inherited from System.Object class, 
so every type and object will have access to functionalities like:
 getType(), ToString(), etc
*/

namespace project43_reflection
{
    class Program
    {
        public static void Main(string[] args)
        {
            //Getting the type:
            //T gets the type of the project43_reflection.ExampleClass.
            Type T = Type.GetType("project43_reflection.ExampleClass");
                
            //Equivalent methods to get the type: 
            //Type T = typeof (ExampleClass);
            //ExampleClass ec = new ExampleClass();
            //Type T = ec.GetType();
                
            //Getting the properties:
            //T.GetProprieties returns an array of type PropertyInfo, containing all
            //the information about the proprieties of the class.
            PropertyInfo [] proprietiesFound = T.GetProperties(); 
            
            foreach(PropertyInfo k in proprietiesFound)
            {
                Console.WriteLine("Property Name: {0}   Property type: {1}", k.Name, k.PropertyType); 
                //printing the proprieties of the class ExampleClass.
            }
                
            Console.WriteLine();        
                
            //Getting the methods:
            MethodInfo[] methodsFound = T.GetMethods();
            foreach(MethodInfo k in methodsFound)
            {
                Console.WriteLine("Method Name: {0} Method return type: {1}", k.Name, k.ReturnType);
            }
            Console.WriteLine();
                
            //Getting members:
            MemberInfo [] membersFound = T.GetMembers();
            foreach(MemberInfo k in membersFound)
            {
                Console.WriteLine("Member Name: {0} Member type: {1}", k.Name,  k.MemberType);
            }
                
            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
    
    class ExampleClass
    {
        //Variables:
        private int _age;
        private string _name;
            
        //Properties:
        public string Name 
        {
            get{
                    return this._name;
            }
            set{
                    this._name=value;
            }
        }
        public int Age
        {
            get{
                    return this._age;
            }
            set{
                    this._age=value;
            }
        }
            
        //Methods:
        public void Print()
        {
                Console.WriteLine("Name: {0}        Age: {1}", this._name, this._age);
        }
    }
}
</code>
        </reflection>
    </manifest>
    
    <manifest>
        <name>JavaScript</name>
        <description>
            JavaScript often abbreviated as JS, is a programming language and core 
            technology of the Web, alongside HTML and CSS. 99% of websites use JavaScript 
            on the client side for webpage behavior.
            <br></br><br></br>
            Web browsers have a dedicated JavaScript engine that executes the client code. 
            These engines are also utilized in some servers and a variety of apps. The most 
            popular runtime system for non-browser usage is Node.js.
            <br></br><br></br>
            JavaScript is a high-level, often just-in-time 
            compiled language that conforms 
            to the ECMAScript standard. It has dynamic typing, prototype-based
            object-orientation, and first-class functions. It is 
            multi-paradigm, 
            supporting event-driven, functional, and imperative 
            programming styles. 
            It has application programming interfaces (APIs) for working with text, dates, 
            regular expressions, standard data structures, and the Document Object Model (DOM).
            <br></br><br></br>
            
            Difference between JavaScript and PHP is that 
            JavaScript is running in the client 
            computer's browser, and its performance depends only on the client 
            computer's specifications. 
            Whereas PHP is a programming language that runs on a server so when 
            the client is using a PHP script its computer will make a request to 
            the server with the purpose of getting the compilation result and 
            transfer that information back to the client computer. 
            <br></br><br></br>
            
            This action is significantly slower than the javascript because in case that 
            the server is busy, that action might take place in a matter of seconds, or minutes. 
            While in case of JavaScript the action completes almost instantaneos.
            <br></br><br></br>
            
            PHP is a back-end development language (related to the server), JavaScript is a 
            front-end development language related to the client computer/machine.
            <br></br><br></br>
            
            <brown>Vanilla JavaScript is a synonymous with pure or plain JavaScript.</brown> 
            
            <br></br><br></br>
            JavaScript has undergone significant 
            transformations, playing an important role in the evolution of web development. 
            With these changes, an abundance 
            of tools and libraries has emerged, reshaping the way we build websites.
            <br></br><br></br>
            <green>Node.js</green>
            <br></br><br></br>
            Node.js is a cross-platform, open-source JavaScript 
            runtime environment that can run on Windows, 
            Linux, Unix, macOS, and more. Node.js runs on the V8 JavaScript engine, and executes 
            JavaScript code outside a web browser.
            <br></br><br></br>
            Node.js lets developers use JavaScript to write command line tools 
            and for server-side scripting. 
            The ability to run JavaScript code on the server is often used to generate dynamic web 
            page content before the page is sent to the user's web browser.
            <br></br><br></br>
            Consequently, Node.js represents a "JavaScript everywhere" paradigm, unifying web-application 
            development around a single programming language, as opposed to using different languages for 
            the server versus client-side programming.
            <br></br><br></br>
            <green>AngularJS</green>
            <br></br><br></br>
            AngularJS is a toolset for building the framework most suited to your application development. 
            It is fully extensible and works well with other libraries. 
            <br></br><br></br>
            AngularJS extends HTML with new attributes.
            <br></br><br></br>
            <green>React</green>
            <br></br><br></br>
            React is the library for web and native user interfaces out of 
            individual pieces called components written in JavaScript.
            <br></br><br></br>
            React's declarative syntax facilitates the creation of complex user interfaces, 
            and it provides a vast range of tools, including Redux, for state management. 
            This makes React a powerful choice for scalable and maintainable applications, 
            utilizing modular and reusable components.
            <br></br><br></br>
            React Native brings the React programming paradigm to platforms like Android and iOS.
            <br></br><br></br>
            <green>Vue.js</green>
            <br></br><br></br>
            Vue.js is a JavaScript framework known for its simplicity and flexibility. Recognized for its 
            reactive system, seamless integration with existing projects, and organized component handling.
            <br></br><br></br>
            Vue.js appeals to developers working on both small and large applications. Its incremental 
            adoption allows developers to utilize specific features as needed, making it easy to learn 
            and widely popular.
            <br></br><br></br>
            Vue.js lets you extend HTML with HTML attributes called directives.
            Vue.js directives offers functionality to HTML applications.
            Vue.js provides built-in directives and user defined directives.
            <br></br><br></br>
            <green>jQuery</green>
            <br></br><br></br>
            jQuery is a JavaScript library which greatly simplifies JavaScript programming.
            jQuery is a fast, small, and feature-rich. It makes things like HTML document 
            traversal and manipulation, event handling, animation, and Ajax much simpler with an easy-to-use 
            API that works across a multitude of browsers. 
            <br></br><br></br>
            With a combination of versatility and extensibility, 
            jQuery has changed the way that millions of people write JavaScript.
            <br></br><br></br>
            <green>AJAX</green>
            <br></br><br></br>
            Ajax short for "Asynchronous JavaScript and XML" is a set of web development techniques 
            that uses various web technologies on the client-side to create asynchronous web applications.
            <br></br><br></br>
            With Ajax, web applications can send and retrieve data from a server asynchronously 
            (in the background) without interfering with the display and behaviour of the existing page. 
            <br></br><br></br>
            <green>JSON</green>
            <br></br><br></br>
            JSON stands for JavaScript Object Notation is a lightweight format for storing and transporting 
            data.
            JSON is often used when data is sent from a server to a web page.
            JSON is "self-describing" and easy to understand.
            <br></br><br></br>
            <green>Bootstrap</green>
            <br></br><br></br>
            Bootstrap is the most popular CSS Framework for developing responsive and 
            mobile-first websites.
            <br></br><br></br>
            Bootstrap 5 is the newest version of Bootstrap.
            <br></br><br></br>
            <green>TypeScript</green>
            <br></br><br></br>
            TypeScript is a free and open-source high-level programming language developed by Microsoft 
            that adds static typing with optional type annotations to JavaScript.
            <br></br><br></br>
            TypeScript may be used to develop JavaScript applications for both client-side and 
            server-side execution.
            The TypeScript compiler is itself written in TypeScript and compiled to JavaScript.
        </description>
        <oop>
            *General-Programming-Knowledge*
            <br></br>
            <green>
            OOP in JavaScript:
            </green>
            <br></br><br></br>
            The objects can be classifed in 2 categories:<br></br>
            
            - standard built-in objects;<br></br>
            - custom objects;<br></br>
            
            <br></br>
            In Javascript the concept called of "class" is different, so objects are 
            not built based on classes alone, but also based on functions or 
            literal notations (or singletons).
            <br></br>
<code>
//Example of creating objects in JavaScript:

//Creating an object using an function as Object Constructor:

function Employee (firstName, lastName) //This will be the constructor;
{
    this.firstName = firstName;
    this.LastName = lastName;
    
    //This is an object method:
    this.getFullName = function () {
        return this.firstName + " " + this.LastName;
    }
}

//Creating an instance of the object:

var emp = new Employee("Alan", "Walker");
document.write("First Name: " + emp.firstName + "&lt;br&gt;");
document.write("Last Name: " + emp.LastName + "&lt;br&gt;");
document.write("Full Name: " + emp.getFullName() + "&lt;br&gt;");

//Creating a class with Object Constructor:
class Student
{

    constructor(firstName, lastName)
    {
        this.firstName = firstName;
        this.LastName = lastName;
    }
    getFullName() 
    {
        return this.firstName + " " + this.LastName;
    }
}

var stud = new Student("Alan", "Walker");
document.write("First Name: " + stud.firstName + "&lt;br&gt;");
document.write("Last Name: " + stud.LastName + "&lt;br&gt;");
document.write("Full Name: " + stud.getFullName() + "&lt;br&gt;");

//Creating an object using a Variable/Literal Notation or Singleton:

var objct = { //in this case we already create an object/instance.

    //Here we are now describing the functionality of the object:

    // In this case instead of equal sign for assignment 
    //we use colon operator and coma afterwards;
    
    firstName: "Alan", 
    lastName: "Walker",
    
    getFullName: function ()
    {
        return this.firstName + " " + this.lastName;
    }
} 

//Displaying the information about this objct:

document.write("&lt;br&gt;First Name: " + objct.firstName + "&lt;br&gt;");
document.write("Last Name: " + objct.lastName + "&lt;br&gt;");
document.write("Full Name: " + objct.getFullName() + "&lt;br&gt;");

</code>
            <br></br>
            <green>Differences between the Object Constructor and Object Literal/Singleton:
            </green>
            <br></br><br></br>
            In the constructor case the properties are separed by their values 
            using = operator, whereas in case of literal notation 
            we use : operator;
            <br></br><br></br>
            In case of contructor we use ; to separate the properties, in 
            literal notation we use , 
            instead.
            <br></br><br></br>
            With the constructor method, you first need to create an instance 
            in order to access its properties, but with literal notation the 
            instance is already created, so you can just access it. 
            <br></br><br></br>
            Objects created using literal notation are singletons, 
            this mean that when a value is 
            changed for an instance, it affects all the instances created. 
            <br></br><br></br>
            This is happening because all the instances created from literal notation 
            will reference the same set of values, so if any of them make a change, that change will 
            affect the whole set of instances.
            <br></br>
            Whereas this is not the case using constructor objects.
            <br></br><br></br>
            <green>
            When to use Object Constructor or Object Literal/Singleton:
            </green>
            <br></br><br></br>
            When multiple instances of an object are needed the object contructor will be used.
            <br></br>
            When single instance of an object is needed the object literal can be used.
            <br></br><br></br>
            Singleton means that the object cannot have multiple instances 
            without affecting one another. <br></br>
            That's why the object literal is a singleton.
            <br></br><br></br>
            The common way used for creating objects in all the OOP languages is by using 
            Object Constructor.
            <br></br>
        </oop>
        <reflection>
            *General-Programming-Knowledge*
            <br></br>
            Reflection allows the inspection of meta data, 
            assemblies, modules and type.
            <br></br><br></br>
            If the object is derived from a base class than
            reflection can also inspect the parent/base class data.
<code>
//Example of reflection in JavaScript

var Class = function (objName, objID, objType) {
    //These are public fields:
    this.ObjectName = objName;
    this.ObjectID= objID;
    this.ObjectType = objType;
}

//These are public methods:
Class.prototype.getObjectName = function () {
    return this.ObjectName + "&lt;br&gt;";
}

Class.prototype.getObjectID = function () {
    return this.ObjectID + "&lt;br&gt;";
}

Class.prototype.getObjectType = function () {
    return this.ObjectType + "&lt;br&gt;";
}

var Class = new Class ("Car", "2", "Base Class");

//Creating a foreach loop:
for (var property in Class)
{
    //Checking if the property is a variable:
    if(typeof Class[property] != "function")
    {
        document.write(property + " : " + Class[property] + "&lt;br&gt;");
        //A property of class can be accessed using ClassName[foreach_variable].
    }
}

document.write("&lt;br&gt;");
//Another foreach loop:
for (var p in Class)
{
    //Checking if a property is not inherited:
    if( Class.hasOwnProperty(p) )
    {
        document.write(p + " : " + Class[p] + "&lt;br&gt;");
    }
    
    //Checking if a property is inherited:
    if( !Class.hasOwnProperty(p) )
    {
        document.write(p + " : " + Class[p] + "&lt;br&gt;");
    }
}
</code>
        </reflection>
        <encapsulation>
            *General-Programming-Knowledge*
<code>
//Example of encapsulation in JavaScript:

function Car ()
{
    //Creating private fields using the naming convention.
    var _speed;
    var _acceleration;
    
    //Creating properties: getters and setters
    Object.defineProperty(this, "speed", 
    {
        get: function () 
        {
            return _speed;
        } 
        , //using the coma operator to separate between get and set properties:
        set: function (value)
        {
        
            _speed = value;
        }
    })
    
    //The second way of creating getters and setters
    
    //Private methods:
    function getAccel()
    {
        return _acceleration;
    }
    function setAccel(value)
    {
        _acceleration = value;
    }
    
    //The third way of achieving encapsulation
    
    //Privileged methods;
    this.getAcceleration = function() //this is a get function
    {
        return getAccel();
    }
    this.setAcceleration = function (value) //this is a set function
    {
        setAccel(value);
    }
    
    /*
    Privileged methods can be accessed from anywhere, and apart of public methods. 
    
    Privileged methods are the only methods that can access directly private 
    fields and functions. 
    
    In the case of public methods this is not possible.
    */
    
}

var c = new Car();

//Now we can use this syntax for initializing the private fields:
c.speed = 12; //using the set:

document.write ("The car speed is " + c.speed + "&lt;br&gt;"); //using the get;

//Using the second way of encapsulation:

c.setAcceleration(22); //using the setter
document.write ("The car acceleration is " + c.getAcceleration() + "&lt;br&gt;"); //using the getter;
</code>
        </encapsulation>
        <polymorphism>
            *General-Programming-Knowledge*
<code>
//Creating polymorphism in Javascript:

//Creating a base class;
var Shape = function() { }

//Adding a function to the class:
Shape.prototype.draw = function () 
{
    return "I am a generic shape.";
}

//Creating another class
var Circle = function () {}

//Doing the inheritance:
Circle.prototype = Object.create(Shape.prototype);

//Overriding the base class function:
Circle.prototype.draw = function ()
{
    return "I am a circle shape.";
}

//Creating another class
var Square = function () {}

//Doing the inheritance:
Square.prototype = Object.create(Shape.prototype);

//Overriding the base class function:
Square.prototype.draw = function () 
{
    return "I am a square shape.";
}

//Creating a collection of objects:
var collection = [new Shape(), new Circle(), new Square()];

//Iterating through the collection using foreach loop:
collection.forEach(function (shape) {

    document.write(shape.draw() + "&lt;br&gt;");
    
    //Expected result every object calls it's own implementation of .draw() function.
    //OUTPUT:
    //
    //I am a generic shape.
    //I am a circle shape.
    //I am a square shape.
})
</code>
        </polymorphism>
        <inheritance>
            *General-Programming-Knowledge*
            <br></br>
            In other programming languages a class inherits from 
            another class, 
            but in Javascript an object will only inherits from another 
            object (this is called prototype based inheritance).
            <br></br><br></br>
            Also it's not possible for a constructor to
            inherit from another constructor.
            <br></br><br></br>
            A constructor can inherit only from an instance 
            of another (also called object).
            <br></br>
<code>
//Example of inheritance in JavaScript:

//Creating a singleton object constructor:

var Vehicle = function (Name, Traction)
{
    this.name = Name;
    this.traction = Traction;
}

/*
Creating a function object constructor will work as well:

function Vehicle(Name, Traction)
{
    this.name = Name;
    this.traction = Traction;
}
*/

//Creating a function using the prototype object:
Vehicle.prototype.getName = function ()
{
    return this.name;
}
Vehicle.prototype.getTraction = function()
{
    return this.traction;
}

//Creating another singleton object:

//Inheritance can also be made using the first singleton object(var Vehicle), 
//as well, but the main fields should be initialized first. 
//Example:

var car = function (speed, acceleration)
{
    //this keyword refers to the current instance's field.
    this.speed = speed;
    this.acceleration = acceleration;
}

//Creating an object from the singleton constructor:
var vehicle = new Vehicle("Bike", "2 wheels");

//Creating the inheritance:
car.prototype = vehicle; 
//Now the any object of the car constructor is a child of the "vehicle" object.

//Creating an object of the constructor "car".
var c = new car(22, 109); 

document.write("The following fields are inherited: &lt;br&gt;");

//calling the functions inherited from parent object.
document.write("Name: " + c.getName() + "&lt;br&gt;"); 
document.write("Traction: " + c.getTraction() + "&lt;br&gt;"); 

/*
Adding a new method to the parent object will automatically 
make it available to the child object.

.hasOwnProperty() - this method will check whether a property/field/variable 
is defined on the actual object or prototype. 

By that it can be found all the inherited properties.
*/

document.write("Is Name a Property of c Object: " + c.hasOwnProperty("name") + "&lt;br&gt;");
document.write("Is Speed a Property of c Object: " + c.hasOwnProperty("speed") + "&lt;br&gt;");


/* Another Example: Inheritance from the first object of the singleton: */

document.write("Singleton Nume: " + Vehicle.name + "&lt;br&gt;");
Vehicle.name = "Something";
Vehicle.traction = "4 wheels";

document.write("Singleton Nume: " + Vehicle.name + "&lt;br&gt;");

function Class (num)
{
    this.number = num;
}

Class.prototype = Vehicle;
var clas = new Class(4)

document.write("Inherited From Singleton: " + clas.name + "&lt;br&gt;");

/*
Inheritance can be realized without singletons as well:

function Class (num)
{
    this.number = num;
}

var cl = new Class(7);

function B (name)
{
    this.name = name;
}
B.prototype = cl;

var bb = new B("Alan");

document.write(bb.number + " is perfectly valid" + "&lt;br&gt;");
*/
</code>
        </inheritance>
        <abstraction>
            *General-Programming-Knowledge*
            <br></br>
            Abstract object constructors are those constructors that 
            cannot be instantiated. That means that no object can be 
            created out of them. 
            The purpose of using such constructors is to provide inheritance 
            to other prototypes. 
            <br></br><br></br>
            In this way the functionality can be shared amongst the objects without 
            needing any instances.
            <br></br><br></br>
            Blocking a constructor from being instantiated will result in error.
<code>
//Example of abstraction

function House ()
{
    this.personName = "";
    
    //This will block anyone from creating an instance with this constructor.
    throw Error ("Cannot instantiate an abstract object.");
    
}

//This is a public-static method of House object;
House.prototype.printMsg = function()
{
    document.write("Printing a message!" + "&lt;br&gt;");
}

function Home(pn)
{
    //Using the base object (Home) field named personName;
    personName = pn;
    
    this.getHomeOwnerName = function ()
    {
        return personName;
    }
}

//Creating the inheritance:

//House is gonna be the base class for Home constructor

Home.prototype = Object.create(House.prototype); 

/*
Object.create - will create an object without using the constructor.
*/

//Creating an instance of the child object:
var h = new Home("Adrian");

//Using the child object method and parent object field:
document.write("Owner's name: " + h.getHomeOwnerName() + "&lt;br&gt;");
document.write("Is name owned by this class: " + h.hasOwnProperty("personName") + "&lt;br&gt;");
document.write("Is h instance of House: " + (h instanceof House) + "&lt;br&gt;")
document.write("Is h instance of Home: " + (h instanceof Home) + "&lt;br&gt;")

//Calling the base object method;
h.printMsg();
</code>
        </abstraction>
        <generic-programming>
            *General-Programming-Knowledge*
            <br></br>
            TypeScript is a syntactic superset of JavaScript which adds static typing which
            also facilitates the use of generic-programming.
            <br></br><br></br>
            This basically means that TypeScript adds syntax on top of JavaScript, 
            allowing developers to add data types.
            <br></br><br></br>
            <green>
            Why should I use TypeScript?
            </green>
            <br></br><br></br>
            JavaScript is a loosely typed language. It can be difficult to understand 
            what types of data are being passed around within the script.
            <br></br><br></br>
            In JavaScript, function parameters and variables don't have 
            any information! 
            So developers need to look at documentation, or guess based on the implementation.
            <br></br><br></br>
            TypeScript allows specifying the types of data being passed around within 
            the code, and has the ability to report errors when the types don't match.
            <br></br><br></br>
            For example, TypeScript will report an error when passing a <code>string</code> into a 
            function that expects a number. JavaScript will not do that.
            <br></br><br></br>
            TypeScript uses compile time type checking. Which means it checks if the 
            specified types match 
            before running the code, not while running the code.
            <br></br><br></br>
            Generics allow creating 'type variables' which can be used to 
            create classes, functions and 
            type aliases that don't need to explicitly define the types that they use.
            <br></br>
<code>
//Example of generic programming in JavaScript using TypeScript:

function createPair&lt;S, T&gt;(v1: S, v2: T): [S, T] 
{
  return [v1, v2];
}
console.log(createPair&lt;string, number&gt;('hello', 42)); 

//OUTPUT: ['hello', 42]
</code>

<code>
//Example of generic class implementation

class NamedValue&lt;T&gt; 
{
  private _value: T | undefined;

  constructor(private name: string) {}

  public setValue(value: T) 
  {
    this._value = value;
  }

  public getValue(): T | undefined 
  {
    return this._value;
  }

  public toString(): string 
  {
    return `${this.name}: ${this._value}`;
  }
}

let value = new NamedValue&lt;number&gt;('myNumber');
value.setValue(10);
console.log(value.toString()); // myNumber: 10
</code>
        </generic-programming>
        <variable-arguments-lists>
            *General-Programming-Knowledge*
<code>
//Example of using variable number of arguments in JavaScript:

/*
The argument object is used to store the value of arguments of a function.
Accessing the argument object outside a function will result in undefined error.
The argument object is not an array, but it only has one property of the array, 
and that is .length
*/

function Myfct(a,b,c)
{
    document.write("The function has: " + arguments.length + " arguments.&lt;br&gt;");
    
    //arguments.length will return the number of arguments that was passed to the function. 
    //Not the number of parameters that the function has. 
    
    document.write("&lt;br&gt;The arguments are: &lt;br&gt;");
    for (var i =0; i&lt;arguments.length; i++)
    {
        document.write(" " + arguments[i] + " ");
    }
    document.write("&lt;br&gt;");
    
};

/*
The Myfct(a,b,c) function has 3 parameters: a,b,c 
but it is called below using 5 arguments: 0,1,3,4,5
*/

Myfct(0,1,3,4,5); 

//In JavaScript a function can be called using any number of arguments. 
//The unnecessary ones will be ignored.

//Creating a function with various number of arguments;

function getSum() 
{
    var sum=0;
    for (var i=0; i&lt;arguments.length; i++)
    {
        sum+=arguments[i];
    }
    return sum;
    
};

//See how the getSum() function is declared without any parameters 
//but it is called with various number of arguments each time.

document.write("&lt;br&gt;The sum of all the arguments is: " + getSum(1,12,3,22,1,3,4,22) + "&lt;br&gt;");
document.write("The sum of all the arguments is: " + getSum(-2,10,4,21) + "&lt;br&gt;");

//the function was called with different number of arguments each time and 
//it worked fine every time.
</code>
        </variable-arguments-lists>
        <simple-data-types>
            Javascript is a dynamical type language this means that any variable 
            can store any data type.
            <br></br><br></br>
            <green>
            Data Values:
            </green>
            <br></br><br></br>
            Numbers: <code>22</code>, <code>22.4</code>, <code>44</code>;<br></br>
            Strings: <code>"me"</code>, <code>"you"</code>; <br></br>
            boolean: <code>true</code>, <code>false</code>; <br></br>
            <br></br>
            Strings can also be initialized using single quotes such as: <code>'me'</code>, <code>'you'</code>
            
            <br></br><br></br>
            All the variables are declared using the <code>var</code> keyword.
<code>
//Example of using JavaScript dynamical typed variables:

var A = 22;
A="My string";
//This is perfectly valid, because the var size and type 
//will be automatically converted as needed.

/*
Variables and function as in other programming languages they are case sensitive 
this means that var A is different from var a; 
and function A () {} is different from function a() {};
*/
</code>
            In order to add static typing so that JavaScript can work with 
            data types, the TypeScript was introduced. 
            <br></br><br></br>
            TypeScript is a free and open-source high-level programming language developed by 
            Microsoft that adds static typing with optional type annotations to JavaScript.
            <br></br><br></br>
            Example of using TypeScript data-types:
<code>
//String data-type:
var name:string = "John";

//Number data-type:
var score1:number = 50;
var score2:number = 42.50

//Array data-type
var alphas:string[]; 
alphas = ["1","2","3","4"] 

//Tuple data-type
var mytuple = []; 
mytuple[0] = 120 
mytuple[1] = 234

//Union data-type
var val:string|number 
val = 12 

//Interface data-type:
interface IPerson { 
   firstName:string, 
   lastName:string, 
   sayHi: ()=>string 
} 

//Classes
class Shape { 
   Area:number 
   
   constructor(a:number) { 
      this.Area = a 
   } 
} 
</code>
        </simple-data-types>
        <loops>
            *General-Programming-Knowledge*
            <br></br>
            <green>
            JavaScript also provides a forEach() function.
            </green>
            <br></br><br></br>
            The <code>forEach()</code> method of Array instances executes a provided function once 
            for each array element.
            <br></br>
<code>
//Example of foreach loop in JavaScript
const array1 = ['a', 'b', 'c'];

array1.forEach((element) => console.log(element));

// Expected output: "a"
// Expected output: "b"
// Expected output: "c"

</code>
        </loops>
        <collections>
            *General-Programming-Knowledge*
            <br></br>
            <green>In JavaScript:</green>
            <br></br><br></br>
            An array is a collection of variables which can take 
            any type of values. A JavaScript Array is much like a 
            Vector or a List, 
            being dynamic in length (resizeable).
            <br></br><br></br>
            For example: an array could store both strings and 
            integer values in it.
            <br></br>
<code>
//Example of creating an array in JavaScript:

//Creating an array without a constructor:
var arr = ["James", 10, 2];

//Another ways to create an array without a constructor:
var arr2 = []; //Creating an array (without constructor), the size is not specified.

/*
Dispite the other C-like languages, creating an array using this syntax make it resizeable.
*/

arr2[0]= 22; //the array length is now 1.
arr2[1]= 44; //the array length is now 2.

//Creating an array using the constructor

var arr3 = new Array(5); // the 5 between the parenthesis specifies the length.
//The elements of arr3 are not initialized.

//Creating an array using constructor, the elements are specified.
var arr4 = new Array(26,8,1994); 

/*
The elements can be specified while creating an array using a constructor, 
by using multiple arguments when calling it. 
So, you cannot create and initialize an array with a single element, using this syntax. 
*/

</code>
        </collections>
        <collection-methods>
            *General-Programming-Knowledge*
            The collection methods in Javascript can be divided in 2 categories:
            <br></br>
            
             - mutator methods;<br></br>
             - non-mutator methods;<br></br>
            
            <br></br>
            A mutator method is a method that change or modify the array object
            (in size or content).
            <br></br><br></br>
            The non-mutator methods are the methods that don't perform 
            any change on the array object.
<code>

//Creating an array using constructor.
var arr4 = new Array(26,8,1994); 

//.length property contains the current number of elements within the array
document.write("The length of arr4 is: " + arr4.length + "&lt;br&gt;");

//.pop() - This method removes and returns the last item from the array.
document.write("This element was returned using pop method: " + arr4.pop() + "&lt;br&gt;");

//.shift() - This method removes and returns the first element of the array.
document.write("This element was returned using shift method: " + arr4.shift() + "&lt;br&gt;");

/*
MORE METHODS:

These are Mutator methods:
.push() - This method adds a new item at the end of the array.
.pop() - This method removes and returns the last item from the array.
.unshift() - This method adds a new item at the beginning of the array.
.shift() - This method removes and returns the first element of the array.

.reverse() - This method reverse the element order of an Array Object 
(the last element becomes the first, etc).

.sort() - This method sorts the items of an array (alphabetical, descending or ascending, etc).

.slice() - This method returns a shallow copy of a portion of an array into a new array object 
selected from begin to end (end not included). 
The original array will not be modified. 
It can be used for adding or removing a group of item after the specified index. 

Non-mutator methods:
.contains() - This method returns a boolean value specifying whether the searched value 
is present in the array or not.

.lastIndexOf() - This method returns the position of the last occurrence of a specified value.
.indexOf() - This method returns the position of the first occurrence of a specified value.

*/
</code>
        </collection-methods>
        <serialization>*General-Programming-Knowledge*</serialization>
        <deserialization>*General-Programming-Knowledge*</deserialization>
        <enums>
            *General-Programming-Knowledge*
            In JavaScript enums are made available only with by the means of TypeScript.
<code>
//Example of using enums in TypeScript:

enum CardinalDirections 
{
  North,
  East,
  South,
  West
}

let currentDirection = CardinalDirections.North;
// logs 0
console.log(currentDirection);

// throws error as 'North' is not a valid enum
currentDirection = 'North'; // Error: "North" is not assignable to type 'CardinalDirections'.
</code>
        </enums>
        <constructors>
            *General-Programming-Knowledge*
            <br></br>
            A constructor is a special function that creates and initializes an 
            object instance of a class. 
            <br></br><br></br>
            In JavaScript, a constructor gets called when an object 
            is created using the <code>new</code> keyword.
<code>
//Example of constructor in JavaScript:

function User (name, age) {
    this.name = name;
    this.age = age;
}

var user1 = new User('Bob', 25);
var user2 = new User('Alice', 27);
</code>
        </constructors>
        <instantiation>
            *General-Programming-Knowledge*
<code>
//Instantiation in Javascript:

var user1 = new User('Bob', 25);
</code>
        </instantiation>
        <destructors>
            *General-Programming-Knowledge*
            <br></br>
            <brown>
            JavaScript doesn't have a concept of destructors like many OOP languages.
            </brown>
        </destructors>
        <function-overloading>
            *General-Programming-Knowledge*
            <br></br>
            <green>
                JavaScript does not support function overloading.
            </green>
            <br></br><br></br>
             When creating 2 functions with the same name and different
             number of arguments in JavaScript, the function declared later 
             will replace the function 
             declared sooner, in the global namespace. 
             <br></br><br></br>
             This process is called namespace pollution (or name collision). 
             <br></br><br></br>
             Also if the scripts are written in different files, the file 
             which is loaded last will replace the function 
             declared into the file which was loaded first.
             <br></br>
<code>
//Example of namespace pollution

function PrintSomething()
{
    alert("This is the first function.");
}

function PrintSomething(a) //this function will replace the first function declared above;
{
    alert("This is the second function.");
}

PrintSomething(5);

//OUTPUT:
//This is the second function.
</code>
        </function-overloading>
        <operator-overloading>
            *General-Programming-Knowledge*
            <br></br>
            <green>
                JavaScript doesn't support operator overloading.
            </green>
        </operator-overloading>
        <concurrent-programming>
            *General-Programming-Knowledge*
            <br></br>
            <green>Multithreading in JavaScript:</green>
            <br></br><br></br>
            JavaScript is a single-threaded language which means it does 
            not support multithreading. <br></br>
            <br></br>
            All the operations in JavaScript are non-blocking and are executed in the event loop. 
            <br></br>
            This single-threaded nature along with event loop allows 
            JavaScript to handle concurrent operations at once.
            <br></br>
        </concurrent-programming>
        <namespaces>
            *General-Programming-Knowledge*
            <br></br>
            In JavaScript: it is possible to declare 2 functions with the same name, 
            but not in the same namespace.
            <br></br><br></br>
            Similarly with creating 2 variables with the same name but in 
            different scope (global and local).
            <br></br><br></br>
            The global namespace in JavaScript can be accessed using <code>window.Object</code> 
            - where Object is an item in the global namespace "window".
<code>
//Example of creating a namespace in JavaScript:

//Create a variable named NameSpace 
//if such an object already exists, than my variable will take its value,
//otherwise my variable will be an empty object {};
var NameSpace = NameSpace || {} 

//Creating a nested namespace/object;
NameSpace.a = NameSpace.a || {} 

//Creating an object into the nested namespace:
NameSpace.a.print = function () 
{
    this.PrintMessage = function ()
    {
        alert("Message from the nested object.");
    }
}

//Creating an instance of the nested namespace object.
var a = new NameSpace.a.print;

//Setting the object method for the onclick button.
document.getElementById("but2").onclick = a.PrintMessage;

/*
Another example of creating a namespace:
    var yourNamespace = {

        foo: function() {
        },

        bar: function() {
        }
    };

    yourNamespace.foo();
*/
</code>
        </namespaces>
        <exception-handling>
            *General-Programming-Knowledge*
<code>
//Example of exception handling in JavaScript:

try
{
    //The code that can produce exception will be put here:
    document.write(sayHello()); //calling undefined function will cause an exception;
    
    document.write("This line will be skipped, once the exception was caught.&lt;br&gt;");
}
catch(e) //e is the type of exception to be caught;
{
    document.write("Error. Calling undefined function.&lt;br&gt;&lt;br&gt;");
    document.write(e.description+"&lt;br&gt;");
    document.write(e.message+"&lt;br&gt;");
    document.write(e.stack+"&lt;br&gt;");
}
finally //this will be executed no matter what.
{
    /*
    The code in this block will be executed regardless 
    if there was an exception or not.
    */
    
    document.write("&lt;br&gt;Finished. &lt;br&gt;");
}

//Throwing customized exceptions:

function Fraction(a,b)
{
    try
    {
        if (b==0)
        {
            throw 
            { 
                //creating a custom exception.
                //Completing the exception properties:
                
                error: "Divide by zero error." ,  //here is coma not semicolon
                message: "Denominator cannot be ZERO."
            }
        }
        else
        {
            return a/b;
        }
    }
    catch(e) //catching the custom exception
    {
        document.write("Exception caught. " + e.error + "&lt;br&gt;");
        document.write(e.message + "&lt;br&gt;");
    }
};

var a = parseInt(prompt("Enter a number for nominator: "));
var b = parseInt(prompt("Enter a number for denominator: "));

document.write("&lt;br&gt;The result a/b is: " + Fraction(a,b) + "&lt;br&gt;");


//Using window.onerror for handling errors:

/*
Once the window.onerror is initialized with a function which takes 3 arguments: 
msg, url, line. 

Any error that will occur will execute that code.
*/

window.onerror = function (msg, url, line)
{
    //This code will be executed each time an error occur
    //without the need of try/catch blocks.
    
    alert("Message: " + msg + "\nURL: " + url + "\nLine: " + line);
    return true;
}

//Raising window.onerror by calling undefined function:
UndefinedFunction();

/*
window.onerror is not displayed if it's places in a try/catch block, 
instead the try/catch will handle the exception it by itself.

window.onerror is raised only when there is an unhandled exception.
*/

//Handling an html element error:
function ImageErrorHandler() 
{
    //this function will be executed when the html image will have an error.
    
    alert("The image is not present.");
}
</code>
        </exception-handling>
        <bitwise-operators>
            *General-Programming-Knowledge*
<code>
//Example of working with bitwise operators in JavaScript:
let x = 5 | 1;
let x = 5 ^ 1;
let x = ~5;
let x = 5 &lt;&lt; 1;
let x = -5 &gt;&gt; 1;
</code>
        </bitwise-operators>
        <default-parameters>
            *General-Programming-Knowledge*
<code>
//Example of default arguments/parameters in JavaScript:

function myFunction(x, y) 
{
    //check whether second argument was passed to the function
    if (y === undefined) 
    {
        y = 2;
    }
}

//In JavaScript a function can be called with any number of arguments:
myFunction(2);
myFunction(2,3,4,5);
</code>
        </default-parameters>
        <interfaces>
            *General-Programming-Knowledge*
            <br></br>
            In JavaScript, an interface can be thought of as a set of 
            method signatures that a class must implement.
            <br></br><br></br>
            You can define an interface as an empty object 
            containing method names and their associated function signatures.
<code>
//Example of implementation of an interface in JavaScript:

const MyInterface = {
    method1: function () { },
    method2: function (param1, param2) { },
};

class MyClass {
    method1() {
        console.log("Method 1 called");
    }
 
    method2(param1, param2) {
        console.log(
            `Method 2 called with ${param1} and ${param2}`);
    }
}
 
function implementsInterface(obj, interfaceObj) {
    for (const method in interfaceObj) {
        if (!(method in obj) || 
            typeof obj[method] !== "function") {
            return false;
        }
    }
    return true;
}
 
const myObject = new MyClass();
 
if (implementsInterface(myObject, MyInterface)) {
    console.log(
        "myObject implements MyInterface");
} else {
    console.log(
        "myObject does not implement MyInterface");
}
</code>
        </interfaces>
        <random-generators>
            *General-Programming-Knowledge*<br></br>
            <br></br>
            Generate a random whole number between 1 and 10 (inclusive):
            <br></br><br></br>
<code>
//Example of generating random numbers in JavaScript:

let x = Math.floor((Math.random() * 10) + 1);
</code>
        </random-generators>
        <ternary-operator>
            *General-Programming-Knowledge*
<code>
//Example of working with ternary operator in JavaScript:

function Funct()
{
    var a = document.getElementById('textBox').value;
    
    //if statement is used to execute code when a particular condition is true
    if(isNaN(a))
    {
        document.getElementById('textBox').value+= " 'is not a number.'";
    }
    else //if the condition above is not true, then it will execute this code.
    {
        document.getElementById('textBox').value+= " is a number.";
    }

    //using ternary operator to change the color of the textbox:
    
    (isNaN(a)==true) ? alert("Entered ternary if.")  //this part is if condition is true
                    : alert("Entered ternary else.") //this part is executed otherwise.
                    
    /*
    Ternary operator is also called the short if, and has the same functionality 
    as an if statement, the only difference is that ternary operator sythax is shorter, 
    and yet harder to be read, in that regard it's better to use if else statements.
    */

    //using switch()
    if(isNaN(a) == false)
    {
        a = parseInt(a);
        
        //switch works only with constant values: 
        //integer, long, chars values. 
        //switch cannot be used with floats, doubles or strings
        
        switch(a)
        {
            case 1: {alert("you have entered 1."); break} 
            case 2: {alert("you have entered 2."); break}
            case 3: {alert("you have entered 3."); break}
            default : {alert("you have entered a number above 3 or below 1."); break}
            
            // the break statement will break out of the switch.
            //the default case is equivalent to else statement, 
            //it will be executed only of the cases above do not match.
        }    
    }
    
    /*
        switch is very similar to an if, else if, else block, 
        generally a switch statement it's faster in execution.
    */
}
</code>
        </ternary-operator>
        <modular-programming>*General-Programming-Knowledge*</modular-programming>
        <optional-parameters>*General-Programming-Knowledge*</optional-parameters>
        <string-methods>
            *General-Programming-Knowledge*
            <br></br>
            JavaScript provides several function that facilitate string manipulation:
            <br></br>
<code>
//Some string methods in JavaScript:

var string1 = "Blue bottle on a blue table."

var result = string1.replace(/blue/g , "green") 
//.replace() This function replaces a substring within a string and 
//returns the result.
//Result will be: Blue bottle on a green table.

result = string1.replace(/blue/gi, "green") 
//result will be: green bottle on a green table.

result = string1.substring(1, 4); 
//.substring() This function returns the part of this string from the start 
//index up to and excluding the end index

result = string1.substring(4, 1); 
//string1.substring(4, 1) will produce the same result as above, 
//because the function will swap the values 4 with 1, because the start 
//value needs to be smaller than the end value. 
//The value at the second parameter is not included in the returned result.

result = string1.substring(4); 
//will return a string containing all the character from 4th character 
//until the end of the string. 
//Result will be: "e bottle on a blue table."

result = string1.substr(1,4);
//.substr() has the same functionality .substring(), 
//But it doesn't swap the parameters, and the second parameter 
//specifies the last caracter to be returned.

result = string1.slice(1,4); 
//has the same functionality as the .substr()
//if the start is greater than the end - empty string is returned

result = string1.indexOf("B"); 
//this function will return the index of "B" which is 0;

result = string1.lastIndexOf(b); 
//this will return the last index of specified value "b" which is: 17

</code>
        </string-methods>
        <datatype-conversions>
            *General-Programming-Knowledge*
            <br></br>
            JavaScript variables can be converted to different data types by using the 
            following functions: <br></br><br></br>
            <code>Number()</code> - Returns a number, converted from its argument<br></br>
            <code>parseFloat()</code> - Parses a string and returns a floating point number<br></br>
            <code>parseInt()</code> - Parses a string and returns an integer<br></br>
            <code>String()</code>  - Converts to string<br></br>
        </datatype-conversions>
        <operators>
            *General-Programming-Knowledge*
<code>
//In JavaScript operator + can also be used for concatenation:
//In JavaScript variables are converted implicitly to facilitate the operation:

//Plus operator:
var a = 10;
var b = 20;
//a + b will result 30;

a = "10";
b = 20;
//a + b will result 1020;  
//'b' will be converted to string and then concatenated with 'a'.

//Minus operator:
a = "10";
b = 20;
//a-b will result -10; 
//because the string 'a' will be automatically converted to a number.
</code>
        </operators>
        <pre-post-incrementation>*General-Programming-Knowledge*</pre-post-incrementation>
        <minification>
            Minification of Javascript consists in reducing the amount of JavaScript 
            files used in a webpage as well as reducing the size of 
            each files, in order to optimize the server amount of requests from 
            the client machine.
            <br></br><br></br>
            Example: Instead of using 4 JavaScript files, it will be used a single file, 
            and instead of arranging the code in that file to be readable, it will be arranged in
            such a way that the size will be reduced by removing unnecessary 
            characters such used spaces, newline characters and comments.
        </minification>
        <recursion>
            *General-Programming-Knowledge*
<code>
//Example of using recursion in JavaScript

function RecursiveFunc(num)
{
    if (num &lt;= 1)
    {
        return 1;
    }
    else
    {
        return num * RecursiveFunc(num-1);
        //This will be equivalent to n* n-1* n-2* n-3* ...... *1; when it reaches 
        //1 all the functions will end
        
    }
    
    /*
        Using the loop the whole code above can be implemented as :
        var result=1;
        while(num > 1)
        {
            result*=num;
            num-=1;
        }
    */
};

document.write("This was a recursive function: " + RecursiveFunc(5) + "&lt;br&gt;");

//Comparison to loops:

document.write("&lt;br&gt;With Loops&lt;br&gt;");
var i;
for(i=0;i&lt;10;i++)
{
    document.write(i+" ");
}

//The equivalent recursive function of the for loop above is:

document.write("&lt;br&gt;With Recursion&lt;br&gt;");

function Rec(a)
{
    if(a&lt;10)
    {
        document.write(a + " ");
        Rec(a+1);
    }
};

Rec(0);
</code>
        </recursion>
        <abstract-classes>
            *General-Programming-Knowledge*
            <br></br>
            <brown>
                In Javascript, the concept of an abstract class is not natively 
                supported as it is in other languages but it is however 
                available in TypeScript.
            </brown>
<code>
//Abstract classes in TypeScript

abstract class Shape {
  name: string;
  constructor(name: string) {
     this.name = name;
  }
}

class Circle extends Shape {
  radius: number;
  constructor(name: string, radius:number){
     super(name);
     this.radius = radius;
  }
    
}

const myShape = new Shape('My shape'); // This will throw an Error 
const shortCircle = new Circle("Short Circle", 0.5); // This will work fine.
</code>
        </abstract-classes>
        <decorators>
            *General-Programming-Knowledge*
<code>
// Working with decorators in Javascript
 
// "add" function takes the function as
// a parameter for wrapping function 
// "print" is wrapped 

function add(fn) 
{
    return function(s) 
    {
        var gg = s + ' is Best';

        // By concatenating we extend
        // the function "add"
        fn(gg);
    }
}
 
// Decorated function
function print(s) 
{
    document.write(s);
}
 
// Calling "add"
var g = add(print);
g('GFG'); 
</code>
        </decorators>
    </manifest>
    
    <manifest>
        <name>Java</name>
        <description>
            Java is a high-level, class-based, object-oriented 
            programming language that is 
            designed to have as few implementation dependencies as possible.
            <br></br><br></br>
            It is a general-purpose programming language intended to let 
            programmers write once, 
            run anywhere meaning that compiled Java code can run on all platforms that support 
            Java without the need to recompile. <br></br><br></br>
            
            Java applications are typically compiled to bytecode that can run on any 
            Java virtual machine (JVM) regardless of the 
            underlying computer architecture. The syntax of Java is similar to C and C++, 
            but has fewer low-level facilities than either of them. 
            The Java runtime provides 
            dynamic capabilities (such as reflection and runtime code 
            modification) that are typically not available in traditional compiled languages.
        </description>
        <oop>
            *General-Programming-Knowledge*
            In Java each class must have its own .java file. 
            There cannot be multiple classes in the same file,
            unless some of them are inner classes 
            (class inside another class).
<code>
//Example of class definition in Java
 
class Student 
{
    // data member (also instance variable)
    int id;
    // data member (also instance variable)
    String name;

    public static void main(String args[])
    {
        // creating an object of
        // Student - process called instantiation
        Student s1 = new Student();
        System.out.println(s1.id);
        System.out.println(s1.name);
    }
}
</code>
        </oop>
        <encapsulation>
            *General-Programming-Knowledge*
            <br></br>
            <green>
            Encapsulation in Java:
            </green>
            <br></br><br></br>
            Encapsulation in Java is a mechanism of wrapping 
            the data (variables) 
            and code acting on the data (methods) 
            together as a single unit. 
            <br></br><br></br>
            In encapsulation, the variables of a class will be 
            hidden from other classes, and can be accessed only through 
            the methods of their current classes.
            <br></br><br></br>
            Therefore, it is also known as data hiding.
            <br></br>
<code>
//Example of using Encapsulation in Java
 
// Person Class
class Person 
{
    // Encapsulating the name and age
    // only approachable and used using
    // methods defined
    
    private String name;
    private int age;
 
    public String getName() { return name; }
 
    public void setName(String name) { this.name = name; }
 
    public int getAge() { return age; }
 
    public void setAge(int age) { this.age = age; }
}
 
public class Main 
{
    public static void main(String[] args)
    {
        // person object created
        Person person = new Person();
        person.setName("John");
        person.setAge(30);
 
        // Using methods to get the values from the
        // variables
        System.out.println("Name: " + person.getName());
        System.out.println("Age: " + person.getAge());
    }
}
</code>
        </encapsulation>
        <polymorphism>
            *General-Programming-Knowledge*
<code>
//Example of polymorphism in Java:

class Bike
{  
    void run(){System.out.println("running");}  
}  

class Splendor extends Bike
{  
    void run(){System.out.println("running safely with 60km");}  

    public static void main(String args[])
    {  
        //Parent datatype instantiated with child object
        Bike b = new Splendor();//upcasting  
        b.run(); 
        //even though b is Bike it's gonna act like Splendor
    }
    /*
        OUTPUT:
        running safely with 60km.
    */
}  
</code>
        </polymorphism>
        <inheritance>
            *General-Programming-Knowledge*
            <br></br>
            <green>Inheritance in Java:</green>
            <br></br><br></br>
            Java does not support multiple inheritances with classes. 
            But multiple 
            inheritances is still possible through the use of interfaces.
            <br></br>
            Any Java class can inherit from a single class 
            and/or multiple interfaces.
            <br></br><br></br>
            By inheritance the child class (class which inherits) extends 
            the functionality of the parent class.
            <br></br><br></br>
            <green>Implements vs Extends:</green>
            <br></br><br></br>
            - extends is for extending a class (class inheritance);<br></br>
            - extends can also be used for interface inheritance. 
            An interface can extend another interface.
            <br></br>
            - implements is for implementing an interface 
            (interface to class inheritance);<br></br>
            <br></br>
            Through implements the interfaces exhibit the same characteristics 
            to the classes which are implementing them.
            <br></br><br></br>
            The main difference between an interface and a class is that 
            in an interface cannot implement any 
            of the declared methods. 
            <br></br>
            Only the class that "implements" 
            the interface can implement the methods. 
            <br></br><br></br>
            Also
            an interface cannot contain instance fields/variables. 
            The only fields that can appear in an 
            interface must be declared both static and final.
            <br></br>
            A final variable, also called a "constant", is a variable 
            whose value it cannot be
            change after it's been initialized. 
            <br></br>
            A static variable is a variable 
            shared among all the instances of a class and which can be accessed
            from the class even with no instances by using: 
            <code>ClassName.variable;</code>
            <br></br><br></br>
            An interface is not extended by a class; 
            it is implemented by a class.
            <br></br><br></br>
            <green>Class to class inheritance:</green>
            <br></br>

<code>
//Example of class to class inheritance in Java:

//FILE: Product.java

package project25;

public class Product 
{
    private String name;
    private double Price;
    
    public Product(String NewName, double NewPrice)
    {
        this.name = NewName;
        this.Price = NewPrice;
    }
    
    //Getters:
    public String GetName()
    {
        return this.name;
    }
    public double GetPrice()
    {
        return this.Price;
    }
    public String GetType()
    {
        return "Product";
    }
}

</code>

<code>
//FILE: Books.java

package project25;

public class Books extends Product 
{
    private String Author;
    private int NrOfPages;
    
    public Books(String NewAuthor, int NewNrOfPages, String NewName, double NewPrice)
    {
        super(NewName, NewPrice); 
        //super refers to the parent class, so it will call the constructor of the  
        //parent class, and it will initialize the two fields Price and Name.
        this.Author = NewAuthor;
        this.NrOfPages = NewNrOfPages;
    }
    
    //Getters:
    public String GetAuthor()
    {
        return this.Author;
    }
    public int GetNrOfPages()
    {
        return this.NrOfPages;
    }
    
    //Overriding the function of the parent class
    @Override
    public String GetType()
    {
        return "Book";
    }
}
</code>
        <br></br>
        <green>Interface to class inheritance:</green>
        <br></br>
<code>
//Example of class implementing an interface in Java:
//Example of defining a nested interface in Java:

//FILE: ToDoListInterface.java

package project13;

//this is the outer interface
public interface ToDoListInterface 
{ 
    
    //this is the inner interface
    public interface Numbers
    { 
        int findMax(int a, int b, int c);
    }
    void PrintMessage(String message);
}
</code>

<code>
//FILE: Project13.java

package project13;

import java.util.Scanner;

//This class is obliged to provide implementations for: 
//ToDoListInterface and ToDoListInterface.Numbers

public class Project13 implements ToDoListInterface, ToDoListInterface.Numbers 
{
    /*
     * @param args the command line arguments
     */
     
    public static void main(String[] args) 
    {
        //Creating an object of the class:
        Project13 InstanceOfClass = new Project13();
        
        //Calling functions inherited from interface:
        InstanceOfClass.PrintMessage("This is a function that came from an interface!");
        System.out.printf("Max number is: %d\n", InstanceOfClass.findMax(12, 33, 21));
        
        Scanner myscanner = new Scanner (System.in);
        myscanner.next();
    }
    
    //If Project13 class will not provide implementations for these methods
    //the program will not compile.
    public void PrintMessage(String Message){
        System.out.println(Message);
    }
    public int findMax(int a, int b, int c)
    {
        //Using ternary operator:
        return a>b? a>c? a : c : b>c? b : c;
    }
}
</code>
        <br></br>
        <green>Interface to interface inheritance:</green>
        <br></br>
<code>
//FILE: Sports.java
public interface Sports 
{
    public void setHomeTeam(String name);
    public void setVisitingTeam(String name);
}

//FILE: Football.java
public interface Football extends Sports 
{
    public void homeTeamScored(int points);
    public void visitingTeamScored(int points);
    public void endOfQuarter(int quarter);
}

//FILE: Hockey.java
public interface Hockey extends Sports 
{
    public void homeGoalScored();
    public void visitingGoalScored();
    public void endOfPeriod(int period);
    public void overtimePeriod(int ot);
}
</code>
            <br></br>
            Whatever class will implement interface Hockey will have to 
            provide implementation to all its methods + the extended methods from Sports 
            interface.
            <br></br>
            Same goes for whatever class will implement Football.
        </inheritance>
        <abstraction>
            *General-Programming-Knowledge*
            <br></br>
            <green>Abstraction in Java:</green>
            <br></br><br></br>
            In Java, abstraction is achieved using abstract classes and 
            interfaces.
            <br></br><br></br>
            A class which contains the abstract keyword in its declaration is 
            known as abstract class.
            <br></br><br></br>
            Abstract classes may or may not contain abstract methods, 
            i.e., methods without a body.
            <br></br>
            Example: ( <code>public void get();</code> )
            <br></br><br></br>
            But, if a class has at least one abstract method, then the class 
            must be declared abstract.
            <br></br><br></br>
            If a class is declared abstract, it cannot be instantiated.
            <br></br><br></br>
            To use an abstract class, you have to inherit it from another 
            class, provide implementations to the abstract methods in it.
            <br></br><br></br>
            If you inherit an abstract class, you have to provide implementations 
            to all the abstract methods in it.
<code>
//Example of abstraction using interfaces:

//Defining an interface
interface Animal 
{
    public void animalSound(); // interface method (does not have a body)
    public void sleep(); // interface method (does not have a body)
}

// Pig "implements" the Animal interface
class Pig implements Animal 
{
    public void animalSound() 
    {
        // The body of animalSound() is provided here
        System.out.println("The pig says: wee wee");
    }
    
    public void sleep() 
    {
        // The body of sleep() is provided here
        System.out.println("Zzz");
    }
}

class Main 
{
    public static void main(String[] args) 
    {
        Pig myPig = new Pig();  // Create a Pig object
        myPig.animalSound();
        myPig.sleep();
    }
}
</code>
        </abstraction>
        <generic-programming>
            *General-Programming-Knowledge*
            <br></br>
            <green>Generic Programming in Java:</green>
            <br></br><br></br>
            <brown>Generic Classes:</brown>
            <br></br><br></br>
            In Java a generic class declaration is similar to a 
            regular non-generic class declaration, 
            except that the class name is followed by a 
            <code>&lt;type parameter&gt;</code> section.
            <br></br><br></br>
            For all generics the <code>&lt;type parameter&gt;</code> section can 
            contain one or more <code>&lt;type parameters&gt;</code> separated by commas.
            <br></br><br></br>
            Such generics are called parameterized types because they 
            accept one or more parameters.
<code>
//Example of generic class declaration in Java:

package project29;

public class GenericClass &lt;T&gt; 
{
   private T t;

   public void set(T t) 
   {
      this.t = t;
   }

   public T get() 
   {
      return t;
   }
}

</code>

        In Java each data type has an object correspondant: 
        <br></br>
        <code>int</code> (primitive) -> <code>Integer</code> (object)<br></br>
        <code>double</code> (primitive) -> <code>Double</code> (object)<br></br>
        etc...
        <br></br><br></br>
        We could use generics to wrap primitive types 
        into objects.
        <br></br><br></br>
        Example: <code>java.lang.Integer class</code>  wraps a value of the 
        primitive type <code>int</code> into an object. 
        <br></br>
        The object of type <code>Integer</code> contains a single field 
        whose type is <code>int</code>
        <br></br><br></br>
        <brown>Generic Methods:</brown>
        <br></br><br></br>
        Generic methods are methods that can be called with arguments of 
        different types.
        Based on the types of the arguments passed to the 
        generic method, the compiler handles each method 
        call appropriately.
<code>
//Example of generic class instantiation in Java:
//Example of generic method/function definition in Java:

package project29;

import java.util.Scanner;
 
public class Project29 
{
    public static void main(String[] args) 
    {
        //Instantiating the GenericClass from previous example:
        GenericClass &lt;Integer&gt; FirstGeneric_Class = new GenericClass&lt;Integer&gt;();
        FirstGeneric_Class.set(2);
        System.out.printf("Value of GenericClass object: %d\n", FirstGeneric_Class.get());
        
        //Creating some arrays:
        Integer [] myArray = new Integer[] {1,42,13,24,5};
        Character [] myCharArray = new Character[] {'D', 'N', 'C', 'A'};
        
        //Calling the generic method printArray() on 2 different arrays:
        printArray(myArray);
        printArray(myCharArray);
        
        //Keep the window opened until a key is pressed:
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
    //Creating a generic method/function:
    public static &lt; E &gt; void printArray( E[] inputArray ) 
    {
        // Display array elements
        for(E element : inputArray) 
        {
         System.out.printf("%s ", element);
        }
        System.out.println();
    }
}
/*
Another example of using generics:
public final class Integer extends Number implements Comparable&lt;Integer&gt;
*/
</code>
        </generic-programming>
        <variable-arguments-lists>
            *General-Programming-Knowledge*
<code>
// Example of variable arguments in Java
 
class Test1 
{
    // A method that takes variable 
    // number of integer arguments.
    static void fun(int... a)
    {
        System.out.println("Number of arguments: "
                           + a.length);
 
        // using for each loop to display contents of a
        for (int i : a)
            System.out.print(i + " ");
        System.out.println();
    }
 
    public static void main(String args[])
    {
        // Calling the varargs method with 
        // different number of parameters

        // one parameter
        fun(100); 

        // four parameters
        fun(1, 2, 3, 4); 

        // no parameter
        fun(); 
    }
}
</code>
        </variable-arguments-lists>
        <simple-data-types>
            *General-Programming-Knowledge*
<code>
package project2;

import java.util.Scanner;

//In Java: function definitions outside classes is not allowed
//The main function also needs to be places inside a function.

public class Project2 
{ 
    public static void main(String[] args) 
    {
        //Creating a scanner in order to take the input;
        Scanner myscanner = new Scanner(System.in);
        
        //In Java strings needs to be declared using String keyword (with capital S);
        String Name; 
        int Age;
        double height=11.1;
        
        //In Java the bool type got renamed to boolean.
        boolean IsFemale;
        
        //In Java a variable cannot be displayed if it doesn't get initialized.
        String gender;
        System.out.printf("Enter you name: ");
        
        //Creating a scanner for inputting;
        Name = myscanner.nextLine();
        
        System.out.printf("Enter you age: ");
        Age = myscanner.nextInt(); 
        //if any other data it's entered that cannot be converted into a integer
        //an exception will be thrown.
        
        System.out.printf("Enter your height: ");
        height = myscanner.nextDouble();
        //if any other type it's entered that cannot be converted into a float, 
        //an exception will be thrown.
        
        //Printing the stored information:
        System.out.printf("Are you a female? (True or False)\n");
        IsFemale = myscanner.nextBoolean();
        
        //Using the ternary operator:
        gender = IsFemale? "Female" : "Male";
        
        //Printing the information:
        System.out.printf("Hello %s. Your age is %d, and you're %f tall. \n", Name, Age, height);
        System.out.printf("%s, you are a %s!\n", Name, gender);
        
        //System.out.print(MyByte); => this code is not valid, because the 
        //variable MyByte is never initialized so it cannot be displayed.
        
        System.out.printf("Press any key to terminate!\n");
        myscanner.next();
    }   
}
</code>
        <br></br>
        <green>Default initializations in Java:</green>
        <br></br><br></br>
            <code>Data Type             Default Value (for fields)</code><br></br>
            <code>byte                     0</code><br></br>
            <code>short                    0</code><br></br>
            <code>int                      0</code><br></br>
            <code>long                     0L</code><br></br>
            <code>float                    0.0f</code><br></br>
            <code>double                   0.0d</code><br></br>
            <code>char                    '\u0000'</code><br></br>
            <code>String (or any object)   null</code><br></br>
            <code>boolean                  false</code><br></br>
        </simple-data-types>
        <complex-data-types>*General-Programming-Knowledge*</complex-data-types>
        <loops>
            *General-Programming-Knowledge*
            <brown>
            Foreach loop:
            </brown>
            <br></br><br></br>  
            Java also contains a foreach loop:
            <br></br><br></br>
            The foreach loop is used exclusively for collections such as: 
            arrays, vectors, lists, etc. 
            <br></br>
            By using a foreach loop you can iterate through all the items in that 
            collection and access their values without using indexes.
            <br></br>
<code>
//Example of foreach loop in Java:

package project7;

import java.util.Scanner;

public class Project7 
{
    public static void main(String[] args) 
    {
        int [] arrayC = {1,2,3,4,5,6,7,8,9,10};
        //Using foreach loop in Java:
        System.out.printf("Multiplication Table with 10:\n");
        for (int k : arrayC)
        {
            System.out.printf("10 * %d = %d\n", k, 10*k);
        }
        
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
}
</code>
        </loops>
        <collections>
            *General-Programming-Knowledge*
            <br></br>
            <green>Collections in Java:</green>
            <br></br><br></br>
            <brown>Arrays</brown>
            <br></br><br></br>
            An array is a collection of data of the same type, with 
            fixed size/capacity.
            <br></br>
<code>
//Example of arrays in Java:

String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
cars[0] = "Opel";
System.out.println(cars[0]);
// Now outputs Opel instead of Volvo

int[] myNum = {10, 20, 30, 40};
System.out.println(myNum[1]);
// Now outputs 20
</code>
            <br></br>
            <brown>Vectors</brown>
            <br></br><br></br>
            A Vector is a dynamic array that can change it's 
            size/capacity and is 
            capable of storing any type of data/object. Meaning that a Vector 
            of objects 
            can mix different types together such as: 
            integers and strings.
            <br></br>
            
<code>
//Example of working with Vectors in Java:

package project11;
import java.util.Scanner;
import java.util.Vector; //using this for Vector class.

public class Project11 
{
    /*
     * the parameter args will store command line arguments
     */
    
    public static void main(String[] args) 
    {
        //creating a vector (of objects by default) of size 3;
        Vector myVector = new Vector(3); 
        
        //Creating a vector of integers:
        Vector &lt;Integer&gt; Vector2 = new Vector(); 
        //using the default constructor, this vector will have the size 10

        System.out.printf("The capacity of the myVector before adding elements: %d\n", myVector.capacity());
        System.out.printf("The size of myVector before adding elements: %d\n", myVector.size());
        
        //A Vector of object can mix different types of data together.
        myVector.add(21);
        myVector.add(55);
        myVector.add(77);
        myVector.add(192);
        myVector.add("Name");
        
        System.out.printf("The capacity of the myVector after adding 5 elements: %d\n", myVector.capacity());
        System.out.printf("The size of myVector after adding 5 elements: %d\n", myVector.size());
        System.out.printf("The capacity of the Vector2 is: %d\n", Vector2.capacity());
        
        /*
        The capacity increases automatically when it exceeds its initial value.
        */
        
        System.out.printf("The index of NAME is: %d\n", myVector.indexOf("Name"));
        
        //Displaying elements:
        int i = 0;
        
        //Using foreach loop to iterate through the vector:
        for(Object k : myVector)
        {
           if(i&lt;myVector.indexOf("Name"))
           {
               System.out.printf("vector [%d] = %d\n", i, Integer.parseInt(k.toString()));
           }
           else
           {
               System.out.printf("vector [%d] = %s\n", i, k.toString());
           }
           i++;
        }
        
        //Some vector functions:
        Object [] array = myVector.toArray(); //converting vector into array;
        
        //Iterate through array:
        for(i=0;i&lt;array.length; i++)
        {
            System.out.printf("array[%d] = %s\n", i, array[i].toString());
        }
        myVector.insertElementAt("NAME2", 3); //insert element at index 3;
        myVector.removeElementAt(4); // remove element at index 4;
        i=0;
        
        //Using while to iterate through vector:
        while(i&lt;myVector.size())
        {
            System.out.printf("myVector[%d] = %s\n", i, myVector.elementAt(i).toString());
            i++;
        }
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
}
</code>
            <br></br>
            <brown>ArrayLists</brown>
            <br></br><br></br>
            The ArrayList class extends AbstractList and 
            implements the List interface. 
            ArrayList supports dynamic arrays that can grow as needed. 
            This gives us a new collection data type that can be used exactly as 
            Vectors, Lists, Stacks, Dictionaries.
            <br></br><br></br>
            ArrayLists are created with an initial size of 10 elements. 
            When this size is exceeded, the collection is automatically enlarged. 
            <br></br>
            When objects are removed, the ArrayList may be shrunk.
            <br></br><br></br>
            NOTE: ArrayLists cannot hold primitive data types such as int, 
            double, char, and long.
            <br></br><br></br>
            To create an ArrayList that store primitive values such as those mentioned
            above, the ArrayList must be created using the corresponding object 
            of these primitives.
            <br></br>
            Example: <br></br>
            - for int the corresponding class is Integer;
            <br></br>
            - for double the corresponding class is Double;
            <br></br><br></br>
            These classes wrap the primitive types into an object.
            <br></br><br></br>
            The methods available for the ArrayLists are similar to those of 
            Vector, List, Stack, Dictionary. 
            <br></br><br></br>
            So you can call methods such as: <code>Add()</code>, <code>Remove()</code>, 
            <code>RemoveAt()</code>, etc.
<code>
//Example of working with ArrayLists in Java:

package project20;

import java.util.ArrayList; //used for ArrayList Collection type.
import java.util.Scanner;

public class Project20 {
    public static void main(String[] args) 
    {
        ArrayList&lt;Integer&gt; al = new ArrayList();
        al.add(22);
        al.add(44);
        al.add(59);
        
        //Accessing the elements:
        for(int i: al)
        {
            System.out.printf("%d ", i);
        }
        
        System.out.println();
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
}
</code>
             <br></br>
            <brown>Stacks</brown>
            <br></br><br></br>
            Stack is a subclass of Vector that implements the LIFO standard 
            (last-in first-out).
            <br></br><br></br>
            Stack only defines the default constructor, which creates an 
            empty stack.
            <br></br><br></br>
            Stack includes all the methods defined by Vector, and adds several of 
            its own.
            <br></br><br></br>
            A stack has the same properties as a vector, it's 
            dynamic in size, and
            can store objects of any type.
            <br></br><br></br>
            Stacks get automatically resized to fit the objects pushed in.
            <br></br>
<code>
//Example of working with Stack.

package project16;

import java.util.Scanner; //used for Scanner class;
import java.util.Stack; //used for stack collection;

public class Project16 {

    public static void main(String[] args) 
    {
        Stack newStack = new Stack(); //Stack of objects
        Stack&lt;Integer&gt; intStack; //Stack of integers;
        
        //Adding objects to the Stack:
        newStack.add(5);
        newStack.add(5);
        newStack.add(33);
        newStack.add(135);
        newStack.add(25);
        
        //Accessing elements in the Stack:
        System.out.printf("The element on top of stack is: %d\n", newStack.peek());
        System.out.printf("The element on bottom of the stack is: %d\n", newStack.firstElement());
        //Stacks have the same methods, fields and functionalities as vectors.
        
        Scanner myscanner = new Scanner (System.in);
        myscanner.next();
    }
}
</code>
             <br></br>
            <brown>Dictionaries</brown>
            <br></br><br></br>

                The Dictionary class is an abstract class that 
                defines a data structure for mapping keys to values.
                <br></br>
                This is useful in cases where you want to be able to access data via a particular 
                key rather than an integer index.
                <br></br><br></br>
                Since the Dictionary class is abstract, it provides only the 
                framework for a 
                key-mapped data structure rather than a specific implementation.
                <br></br><br></br>
                Given a key and value, you can store the value in a 
                Dictionary object. 
                Once the value is stored, you can retrieve it by using its key. 
                Thus, like a map, a dictionary can be thought of as a 
                list of key/value pairs.
                <br></br>
                The Dictionary class is obsolete. 
                You should implement the Map interface to 
                obtain key/value storage functionality.
                <br></br>
<code>
//Example of working with dictionaries:

package project17;

import java.util.Dictionary; //used for dictionary;
import java.util.Scanner; //used for Scanner class;
import java.util.Hashtable; //used for the hashtable;
import java.util.Enumeration; //used for enumeration;

public class Project17 {

    /*
     * @param args the command line arguments
     */
     
    public static void main(String[] args) 
    {
        //It can be constructed like this also: Dictionary myDict = new Hashtable();
        Dictionary &lt;Integer, String&gt; myDict = new Hashtable(); 
        //creating a dictionary with Integer Keys, and String Content.

        myDict.put(1, "Alan Walker");
        myDict.put(2, "Adam Lambert");
        myDict.put(3, "Tokio Hotel");
        myDict.put(4, "Deryck Whibley");
        myDict.put(5, "Avril Lavigne");
        Enumeration&lt;Integer&gt; MyKeys = myDict.keys();
        Enumeration&lt;String&gt; MyNames = myDict.elements();
        System.out.printf("Size of Dictionary: %d\n", myDict.size());
        
        //Using for loop to access dictionary:
        for(int i=0; i&lt;myDict.size(); i++)
        {
            System.out.printf("Name: %s     Key: %s\n", MyNames.nextElement(), MyKeys.nextElement());
        }
        
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
    
}
</code>
        <br></br>
        <brown>Lists</brown>
        <br></br><br></br>
        The List interface extends Collection and declares the 
        behavior of a collection that stores a sequence of elements.
        <br></br><br></br>
        Elements can be inserted or accessed by their position in the List 
        by using a zero-based index.
        <br></br><br></br>
        A List may contain duplicate elements.
        <br></br><br></br>
        In addition to the methods defined by Collection, the List defines 
        some of its own.
        <br></br><br></br>
        Several of the List methods will throw an <code>UnsupportedOperationException</code> 
        if the collection cannot be modified, and a <code>ClassCastException</code> is generated 
        when one object is incompatible with the other.
        <br></br>
<code>
//Example of working with Lists/LinkedLists

package project31;
import java.util.*; //import everything in java.util; 

public class Project31 
{

    /**
     * @param args the command line arguments
     */
    
    public static void main(String[] args) 
    {
      List a1 = new ArrayList();
      //List is an interface so it cannot be instanciated, but it can be 
      //initialized with an object of type ArrayList() or LinkedList;

      a1.add("Zara");
      a1.add("Mahnaz");
      a1.add("Ayan");      
      System.out.println("ArrayList Elements:");
      System.out.print("\t" + a1);
      System.out.println();
      
      //Creating and printing a linked list.
      List l1 = new LinkedList();
      
      /*
        The LinkedList class extends AbstractSequentialList and implements
        the List interface and provides a linked-list data structure.
      */
      
      l1.add("Zara");
      l1.add("Mahnaz");
      l1.add("Ayan");
      System.out.println();
      System.out.println("LinkedList Elements:");
      System.out.print("\t" + l1);
      System.out.println();
      
      //Keep the window opened until the next button press.
      Scanner myscanner = new Scanner(System.in);
      myscanner.next();
   }
    
}
</code>
        </collections>
        <collection-methods>
            The Collection in Java is a framework that provides an architecture to 
            store and manipulate the group of objects.
            <br></br><br></br>
            There are many methods declared in the Collection interface:
            <br></br><br></br>
            <code>public boolean add(E e)</code><br></br>
            It is used to insert an element in this collection.
            <br></br><br></br>
            <code>public boolean addAll(Collection&lt;? extends E&gt; c)</code><br></br>
            It is used to insert the specified collection 
            elements in the invoking collection.
            <br></br><br></br>
            <code>public boolean remove(Object element)</code><br></br>
            It is used to delete an element from the collection.
            <br></br><br></br>
            <code>public boolean removeAll(Collection&lt;?&gt; c)</code><br></br>
            It is used to delete all the elements of the specified collection 
            from the invoking collection.
            <br></br><br></br>
            <code>default boolean removeIf(Predicate&lt;? super E&gt; filter)</code><br></br>
            It is used to delete all the elements of the collection 
            that satisfy the specified predicate.
            <br></br><br></br>
            <code>public boolean retainAll(Collection&lt;?&gt; c)</code><br></br>
            It is used to delete all the elements of invoking collection 
            except the specified collection.
            <br></br><br></br>
            <code>public int size()</code><br></br>
            It returns the total number of elements in the collection.
            <br></br><br></br>
            <code>public void clear()</code><br></br>
            It removes the total number of elements from the collection.
            <br></br><br></br>
            <code>public boolean contains(Object element)</code><br></br>
            It is used to search an element.
            <br></br><br></br>
            <code>public boolean containsAll(Collection&lt;?&gt; c)</code><br></br>
            It is used to search the specified collection in the 
            collection.
            <br></br><br></br>
            <code>public Iterator iterator()</code><br></br>
            It returns an iterator.
            <br></br><br></br>
            <code>public Object[] toArray()</code><br></br>
            It converts collection into array.
            <br></br><br></br>
            <code>public &lt;T&gt; T[] toArray(T[] a)</code><br></br>
            It converts collection into array. Here, the runtime type of the 
            returned array 
            is that of the specified array.
            <br></br><br></br>
            <code>public boolean isEmpty()</code><br></br>
            It checks if collection is empty.
            <br></br><br></br>
            <code>default Stream&lt;E&gt; parallelStream()</code><br></br>
            It returns a possibly parallel Stream with the collection as 
            its source.
            <br></br><br></br>
            <code>default Stream&lt;E&gt; stream()</code><br></br>
            It returns a sequential Stream with the collection as its source.
            <br></br><br></br>
            <code>default Spliterator&lt;E&gt; spliterator()</code><br></br>
            It generates a Spliterator over the specified elements in the 
            collection.
            <br></br><br></br>
            <code>public boolean equals(Object element)</code>
            It matches two collections.
            <br></br><br></br>
            <code>public int hashCode()</code><br></br>
            It returns the hash code number of the collection.
            <br></br><br></br>
        </collection-methods>
        <dynamic-memory-allocation>
            Heap space is used for the dynamic memory allocation of 
            Java objects and JRE (Java Runtime Environment) classes 
            at runtime. 
            <br></br><br></br>
            New objects are always created in heap space, and the 
            references to these objects are stored in stack memory. 
            <br></br>
            These objects have global access and we can access them from 
            anywhere in the application.
            <br></br><br></br>
            <green>Dynamic memory allocation in Java:</green>
            <br></br><br></br>
            All Java objects are dynamically allocated. 
            The variables used in the application are stored in stack but these variables 
            only store references to objects. 
            <br></br>
            If the variable dies the object still exists as 
            long as referenced by other variables.
            <br></br><br></br>
            This means is we always pass objects to other functions by 
            reference 
            (no copies are performed behind the scenes).
            <br></br>
        </dynamic-memory-allocation>
        <read-from-file>
            *General-Programming-Knowledge*
<code>
//Example of reading content from file in JAVA:

// Import the File class
import java.io.File;

// Import this class to handle errors
import java.io.FileNotFoundException;

// Import the Scanner class to read text files  
import java.util.Scanner; 

public class ReadFile 
{
    public static void main(String[] args) 
    {
        try 
        {
            File myObj = new File("filename.txt");
            Scanner myReader = new Scanner(myObj);
            while (myReader.hasNextLine()) 
            {
                String data = myReader.nextLine();
                System.out.println(data);
            }
            myReader.close();
        } 
        catch (FileNotFoundException e) 
        {
            System.out.println("An error occurred.");
            e.printStackTrace();
        }
    }
}
</code>
        </read-from-file>
        <write-to-file>
            *General-Programming-Knowledge*
            <br></br>
            <green>Writing to files in Java:</green>
            <br></br><br></br>
            Creating a file:
            <br></br>
<code>
//Example of creating a file in Java: 

// Import the File class
import java.io.File;

// Import the IOException class to handle errors
import java.io.IOException;

public class CreateFile 
{
    public static void main(String[] args) 
    {
        try 
        {
            File myObj = new File("filename.txt");
            if (myObj.createNewFile()) 
            {
                System.out.println("File created: " + myObj.getName());
            } 
            else 
            {
                System.out.println("File already exists.");
            }
        }
        catch (IOException e) 
        {
            System.out.println("An error occurred.");
            e.printStackTrace();
        }
    }
}
</code>
            <br></br>
            Write to a file:
            <br></br>
<code>
//Example of writing content to a file in Java:

// Import the FileWriter class
import java.io.FileWriter;

// Import the IOException class to handle errors
import java.io.IOException;  

public class WriteToFile 
{
    public static void main(String[] args) 
    {
        try 
        {
            FileWriter myWriter = new FileWriter("filename.txt");
            myWriter.write("Files in Java might be tricky, but it is fun enough!");
            myWriter.close();
            System.out.println("Successfully wrote to the file.");
        } 
        catch (IOException e)
        {
            System.out.println("An error occurred.");
            e.printStackTrace();
        }
    }
}
</code>
        </write-to-file>
        <serialization>
            *General-Programming-Knowledge*
<code>
//Example of serialization in Java:

package project23;

import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Scanner;

public class Project23 {

    /**
     * @param args the command line arguments
     */
    
    //Making main function able to throw IOException, 
    //so that we don't need to use try catch blocks.
    public static void main(String[] args) throws IOException 
    {
        //Creating a collection of HumanClass objects:
        ArrayList&lt;HumanClass&gt; myList = new ArrayList();
        myList.add(new HumanClass(22, "Adam Lambert"));
        myList.add(new HumanClass(44, "Jackie Chan"));
        
        //Creating a file to store these objects:
        File myObjectsFile = new File ("objectFile.txt");
        
        //Serializing an object:
        try
        {
            FileOutputStream fo = new FileOutputStream(myObjectsFile);
            ObjectOutputStream os = new ObjectOutputStream(fo);
            for(HumanClass s:myList)
            {
                //Writing objects to a file can be made only using binary mode. 
                //So that file will not contain readable text
                //and cannot be altered using text editors.
                os.writeObject(s);
            }
        }
        catch(FileNotFoundException e)
        {
            System.out.printf("File not found: %s", e);
        }
        
        //Keep the console opened until a key is pressed.
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
}
</code>
        </serialization>
        <deserialization>
            *General-Programming-Knowledge*
            <br></br>
<code>
//Example of deserialization in Java:

package project23;

import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Scanner;

public class Project23 
{

    /**
     * @param args the command line arguments
     */
    
    //Making main function able to throw IOException, 
    //so that we don't need to use try catch blocks.
    public static void main(String[] args) throws IOException 
    {
        //Deserializing an object from the file:
        ArrayList&lt;HumanClass&gt; ObjectRead = new ArrayList();
        FileInputStream fi = new FileInputStream(myObjectsFile);
        ObjectInputStream oi = new ObjectInputStream(fi);
        try
        {
            //the following loop will terminate when the catch block will terminate, 
            //and when the catch block will terminate then EOFException will be thrown.
            while(true) 
            {
                //this will read until the file ends.
                HumanClass e = (HumanClass) oi.readObject();  
                
                //When it cannot read any more objects from the file 
                //it will throw an EOFException that needs to be catched, and handled,
                //otherwise the program will terminate.
                ObjectRead.add(e);
            }
        }
        catch(ClassNotFoundException e)
        {
             System.out.printf("File not found: %s", e);
        }
        //Once the file was done reading, it will throw EOFException
        catch(EOFException b) 
        {
            System.out.println("\nDone reading the objects:\n");
            
            //Print the objects:
            for(HumanClass s:ObjectRead)
            {
                System.out.printf("Name: %s, Age: %d\n", s.GetName(), s.GetAge());
            }
        }
        
        //Keep the console opened until a key is pressed.
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
}
</code>
        </deserialization>
        <constructors>
            *General-Programming-Knowledge*
<code>
//Example of constructors in Java:

//Create a Main class
public class Main 
{
    //Create a class attribute
    int x;  

    //Create a class constructor for the Main class
    public Main() 
    {
        x = 5;  
        //Set the initial value for the class attribute x
    }

    public static void main(String[] args) 
    {
        Main myObj = new Main(); 
        // Create an object of class Main 
        //(This will call the constructor)
        
        System.out.println(myObj.x); 
        //Print the value of x
    }
}

// Outputs 5
</code>
        </constructors>
        <instantiation>
            *General-Programming-Knowledge*
<code>
//Example of instanciation in Java:

ClassName objName = new ClassName();  
</code>
        </instantiation>
        <destructors>
            *General-Programming-Knowledge*
            <br></br>
            <green>Destructors in Java:</green><br></br>
            <br></br>
            In Java: destructors are also known as finalizers that are 
            non-deterministic. <br></br>
            The allocation and deallocation of objects is handled by the 
            garbage collector. <br></br>
            The invocation of finalizers is not guaranteed because it 
            invokes implicitly.
            <br></br><br></br>
            <brown>Advantages of Destructor:</brown><br></br>
            
            1. It releases the resources occupied by the object.<br></br>
            2. No explicit call is required, it is automatically invoked at the end of the 
            program execution.<br></br>
            3. It does not accept any parameter and cannot be overloaded.<br></br>
            
            <br></br>
            Java <code>finalize()</code> method works the same as the destructor. 
            It is not a 
            destructor however, but it provides extra security.
            <br></br>            
            For example: It ensures the use of 
            external resources like closing the file, etc. before shutting down the 
            program.
            <br></br>
<code>
//Example of destructor in Java:

public class DestructorExample  
{  
    public static void main(String[] args)  
    {  
        DestructorExample de = new DestructorExample ();  
        de.finalize();  
        de = null;  
        System.gc();  
        System.out.println("Inside the main() method");  
    }
    
    protected void finalize()  
    {  
        System.out.println("Object is destroyed by the Garbage Collector");  
    }  
}   
</code>
        </destructors>
        <function-overloading>
            *General-Programming-Knowledge*
<code>
// Example of Method overloading in Java
// By using Different Types of Arguments
 
// Class 1
// Helper class
class Helper {
 
    // Method with 2 integer parameters
    static int Multiply(int a, int b)
    {
        // Returns product of integer numbers
        return a * b;
    }
 
    // Method 2
    // With same name but with 2 double parameters
    static double Multiply(double a, double b)
    {
        // Returns product of double numbers
        return a * b;
    }
}
 
// Class 2
// Main class
class GFG 
{
    public static void main(String[] args)
    {
        // Calling method by passing
        // input as in arguments
        System.out.println(Helper.Multiply(2, 4));
        System.out.println(Helper.Multiply(5.5, 6.3));
    }
}
</code>
        </function-overloading>
        <operator-overloading>
            *General-Programming-Knowledge*
<code>
public class Vec {
   private float x, y, z;

   public Vec(float x, float y, float z) {
       this.x = x;
       this.y = y;
       this.z = z;
   }
   //Overloading the operator +
   public Vec plus(Vec other) {
       return new Vec(x + other.x, y + other.y, z + other.z);
   }
}
</code>
        </operator-overloading>
        <enums>
            *General-Programming-Knowledge*
            <green>Enums in Java:</green>
            <br></br><br></br>
            In Java: enums can have constructors, and it needs to have 
            constructors 
            if they are provided with values. 
            <br></br><br></br>
            Enums provides both string values and 
            int values in the same patch.
            <br></br>
<code>
//Example of enums in Java:

package project18;

public enum Directions 
{
    //Defining the fields:
    South(0), West(180), North(90), East(260);
    private final int Degrees; 
    // a place to store the value for each field.
    
    //This constructor has the role of initializing 
    //the above fields with their values:
    Directions(int degreesNew)
    {
        this.Degrees = degreesNew;
    }
    public int GetDegrees()
    {
        return this.Degrees;
    }
}
</code>
            <br></br>
            <green>Enumerations in Java:</green>
            <br></br><br></br>
            The Enumeration interface defines the methods by which you can 
            enumerate 
            (obtain one at a time) the elements in a collection of objects.
            <br></br><br></br>
            Enumerations must not be confused with enums.
             They are different types, different objects, 
            with different utility.
            <br></br><br></br>
<code>
//Example of working with Enumerations in Java:

package project15;

import java.util.Enumeration; //used for enumerations;
import java.util.Scanner; // used for scanner class;
import java.util.Vector; //used for vectors;

public class Project15 {

    /**
     * @param args the command line arguments
     */
    
    public static void main(String[] args) 
    {
        //Creating an enumeration of objects;
        Enumeration Days; 
        //enumerations cannot be initialized with an object ;
        //of type enumeration because enumeration is abstract interface.
        
        Enumeration &lt;Integer&gt; intEnumeration; //enumeration of integers;
        
        //vector of objects
        Vector myVect = new Vector (3);
        myVect.add("Sunday");
        myVect.add("Monday");
        myVect.add("Friday");
        
        //the elements from vector gets transfered to enumeration.
        Days = myVect.elements(); 
        while(Days.hasMoreElements())
        {
            System.out.println(Days.nextElement());
        }
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
}
</code>
        </enums>
        <concurrent-programming>
            *General-Programming-Knowledge*
            <br></br>
            <green>Multithreading in Java:</green>
            <br></br><br></br>
            In Java: Threads can be created by using two mechanisms : 
            <br></br><br></br>
            
            1. Extending the Thread class; <br></br>
            2. Implementing the Runnable Interface;
            
            <br></br><br></br>
            <brown>Thread creation by extending the Thread class:</brown>
            <br></br><br></br>
            We create a class that extends the java.lang.Thread class. 
            This class overrides the run() method available in 
            the Thread class.
            <br></br><br></br>
            A thread begins its life inside run() method. 
            We create an object of our 
            new class and call start() method to start the 
            execution of a thread. 
            Start() invokes the run() method on the Thread object.
            <br></br>
<code>
//Example of multithreading in Java 
//by extending the Thread class:

class MultithreadingDemo extends Thread 
{
    public void run()
    {
        try 
        {
            // Displaying the thread that is running
            System.out.println(
                "Thread " + Thread.currentThread().getId()
                + " is running");
        }
        catch (Exception e) 
        {
            // Throwing an exception
            System.out.println("Exception is caught");
        }
    }
}
 
// Main Class
public class Multithread {
    public static void main(String[] args)
    {
        int n = 8; // Number of threads
        for (int i = 0; i &lt; n; i++) 
        {
            MultithreadingDemo object
                = new MultithreadingDemo();
            object.start();
        }
    }
}
</code>
        <br></br>
        <brown>Thread creation by implementing the Runnable Interface</brown>
        <br></br><br></br>
        We create a new class which implements java.lang.Runnable 
        interface and override run() 
        method. 
        <br></br>
        Then we instantiate a Thread object and call 
        start() method on this object. 
        <br></br>
<code>
//Example of multithreading in Java 
//by implementing the Runnable interface:

class MultithreadingDemo implements Runnable 
{
    public void run()
    {
        try 
        {
            // Displaying the thread that is running
            System.out.println(
                "Thread " + Thread.currentThread().getId()
                + " is running");
        }
        catch (Exception e) 
        {
            // Throwing an exception
            System.out.println("Exception is caught");
        }
    }
}
 
// Main Class
class Multithread 
{
    public static void main(String[] args)
    {
        int n = 8; // Number of threads
        for (int i = 0; i &lt; n; i++) 
        {
            Thread object
                = new Thread(new MultithreadingDemo());
            object.start();
        }
    }
}
</code>
        </concurrent-programming>
        <exception-handling>
            *General-Programming-Knowledge*
<code>
//Example of exception handling in Java:
//Example of throwing custom exceptions;

package project22;
import java.util.InputMismatchException;
import java.util.Scanner;

public class Project22 
{
    public static void main(String[] args) 
    {
        Scanner myscanner = new Scanner(System.in);
        try
        {
            //try block should contain the code that 
            //might throw an exception:
            System.out.println("Enter an integer: ");
            int number = myscanner.nextInt();
            
            //This code will run only if the line above doesn't 
            //produce an exception.
            System.out.printf("You entered: %d\n\n", number);
            
            //Throwing a Custom Exception:
            if(number>10||number&lt;0)
            {
                throw new CustomExceptionOutRange();
            }
        }
        //Handle the input mismatch exception:
        catch(InputMismatchException e)
        {
            System.out.println("You didn't entered an integer!\n");
        }
        //Handle the custom exception:
        catch(CustomExceptionOutRange r)
        {
            System.out.println("Your number is out of range!\n");
        }
        //This code gets executed anyhow.
        finally
        {
            //the finally block is not mandatory
            //It is possible to have only try and catch blocks
            
            System.out.println("Finally block reached.");
        }
        myscanner.next();
    }
}

</code>
            <br></br>
            <green>Creating Custom Exceptions classes in Java:</green>
            <br></br><br></br>
            In order to create Custom Exception classes in Java, 
            you to create a class of 
            extends the Exception class.
            <br></br>
<code>
package project22;

/*
 * Making this class inherits from Exception class.
 */

public class CustomExceptionOutRange extends Exception
{
    //custom code can be added here
}
</code>
        </exception-handling>
        <bitwise-operators>*General-Programming-Knowledge*</bitwise-operators>
        <default-parameters>
            *General-Programming-Knowledge*
<code>
public void doSomething(String name, int age, String city = "New York") {  
  // code to perform some action  
}  
</code>
        </default-parameters>
        <interfaces>
            *General-Programming-Knowledge*
            <br></br>
            <green>Interfaces in Java:</green>
            <br></br><br></br>
            An interface is a reference type in Java that 
            is similar to class.
            <br></br><br></br>
            A class implements an interface, 
            thereby inheriting the 
            abstract methods of the interface.
            <br></br><br></br>
            An interface is basically a collection of abstract methods. 
            <br></br><br></br>
            Along with the abstract methods, an interface may 
            also contain constants
            (final variables), static variables,  
            default methods, static methods, and nested types.
            <br></br><br></br>
            A nested type is a type defined within a type 
            such as: 
            a class defined within a class or an interface defined
            within an interface.
            <br></br><br></br>
            A final variable is also called a "constant". It is a variable 
            whose value cannot be
            change after it's been initialized. 
            <br></br><br></br>
            The method bodies may exist only for the default methods and/or 
            static methods.
<code>
//Example of interface with constants, 
//default and static methods:

public interface Electronic 
{

    // Constant variable
    String LED = "LED";

    // Abstract method
    int getElectricityUse();

    // Static method
    static boolean isEnergyEfficient(String electtronicType) 
    {
        if (electtronicType.equals(LED)) 
        {
            return true;
        }
        return false;
    }

    //Default method
    default void printDescription() 
    {
        System.out.println("Electronic Description");
    }
}
</code>
            <br></br>
            A static variable  or method is one which is shared 
            among all the 
            instances of a class and which can be accessed directly
            from the class even with no instances by using: 
            <code>ClassName.variable;</code>
            <br></br><br></br>
            The default methods can be defined inside the interface by using the 
            default
            keyword. These methods are non-abstract methods meaning they have an 
            implementation.
            <br></br><br></br>
            The concept of default method is used to define a method with default
            implementation. 
            The class implementing the interface can override the 
            default method also, in order
            to provide a more specific implementation for the method.
            <br></br><br></br>
            Defining an interface is similar to defining a class. 
            But a class 
            describes the attributes and behaviors of an object,
            whereas an interface contains the declaration of the behaviors 
            that a class needs to implement.
            <br></br><br></br>
            Just like classes, there can be only one interface in a .java file. 
            <br></br><br></br>
            Java does not allow that multiple interfaces and/or classes be 
            defined in the same file, unless they are nested.
            <br></br><br></br>
            The only way to have multiple classes/interfaces defined in 
            one file is by having them defined as nested types.
            <br></br><br></br>
            Once that a class implements an interface that class is 
            obliged to 
            provide implementations for all the abstract methods within 
            the interface:
            <br></br><br></br>
            <green>
            Properties of Interfaces:
            </green>
            <br></br><br></br>
            An interface is implicitly abstract. You do not need to use the abstract 
            keyword while declaring an interface.
            <br></br><br></br>
            Each method within the interface is implicitly abstract, so the 
            abstract keyword is also not needed for declaring the methods.
            <br></br><br></br>
            The methods declared within the interface are implicitly public.
            <br></br><br></br>
            <green>
            Similarities between interfaces and classes:
            </green>
            <br></br><br></br>
            An interface can contain any number of methods.
            <br></br><br></br>
            An interface is written in a file with a .java extension, with the name of 
            the 
            interface matching the name of the file.
            <br></br><br></br>
            The bytecode of an interface appears in a .class file.
            <br></br><br></br>
            The interfaces appear in packages, and their corresponding bytecode 
            file must be in a directory structure that matches the package name.
            <br></br><br></br>
            <green>
            Differences between interfaces and classes:
            </green>
            <br></br><br></br>
            You cannot instantiate an interface.
            <br></br><br></br>
            An interface does not contain any constructors.
            <br></br><br></br>
            All of the methods in an interface are abstract.
            <br></br><br></br>
            An interface cannot contain instance fields. 
            The only fields that can appear in an interface must be declared 
            both static and final.
            <br></br><br></br>
            An interface is not extended by a class, it is implemented by a 
            class.
            <br></br><br></br>
            An interface can extend multiple other interfaces.
            <br></br><br></br>
            Through implements the interfaces exhibit the same characteristics 
            to the classes which are implementing them.
            <br></br>
<code>
//Example of defining an interface in Java:
//Example of nested interfaces

package project13;

public interface ToDoListInterface 
{ 
    //this is the outer interface
    public interface Numbers
    { 
        //this is the inner interface
        int findMax(int a, int b, int c);
    }
    void PrintMessage(String message);
}
</code>

<code>
//Example of a class implementing an interface in Java:
//FILE: Project13.java

package project13;

import java.util.Scanner;

//This class is obliged to provide implementations for: 
//ToDoListInterface and ToDoListInterface.Numbers

public class Project13 implements ToDoListInterface, ToDoListInterface.Numbers 
{
    /*
     * @param args the command line arguments
     */
     
    public static void main(String[] args) 
    {
        //Creating an object of the class:
        Project13 InstanceOfClass = new Project13();
        
        //Calling functions inherited from interface:
        InstanceOfClass.PrintMessage("This is a function that came from an interface!");
        System.out.printf("Max number is: %d\n", InstanceOfClass.findMax(12, 33, 21));
        
        Scanner myscanner = new Scanner (System.in);
        myscanner.next();
    }
    
    //If Project13 class will not provide implementations for these methods
    //the program will not compile.
    public void PrintMessage(String Message){
        System.out.println(Message);
    }
    public int findMax(int a, int b, int c)
    {
        //Using ternary operator:
        return a>b? a>c? a : c : b>c? b : c;
    }
}
</code>
        </interfaces>
        <random-generators>
            *General-Programming-Knowledge*
<code>
//Example of generating random numbers in Java:

package project37;

import java.util.Random;
import java.util.Scanner;

public class Project37 {

    /**
     * @param args the command line arguments
     */
     
    public static void main(String[] args) 
    {
        Scanner myscanner = new Scanner(System.in);
        System.out.printf("Thinking of a number between 0 and 100:\n\n");
        
        //Create a random generator
        Random rand = new Random();
        
        //Generate a random number between 0-100
        int Number = rand.nextInt(101);
        
        //This variable will store user input;
        int choice = 101;
        
        //this will count how many times 
        //the user guessed wrong
        int NrOfTries=0;
        
        //Enter the loop by default:
        while(Number!=choice)
        {
            System.out.printf("What is the number?\n");
            do
            {
                System.out.printf("Number = ");
                choice = myscanner.nextInt();
                //get input from the user;
                
            }while(choice&lt;0 || choice>100);
            
            //Compare the user input with the random number;
            if(Number==choice)
            {
                System.out.printf("Congratulations, the number was: %d\n", Number);
            }
            
            else if(Number&lt;choice)
            {
               System.out.printf("Your number is too high, try a lower one!\n");
            }
            
            else
            {
                System.out.printf("Your number is too low, try a higher one!\n");
            }
            
            System.out.println();
            NrOfTries++;
        }
        
        System.out.printf("You required %d tries to guess the number!\n", NrOfTries);
        
        //Keep the console opened.
        myscanner.next();
    }
}
</code>
        </random-generators>
        <command-line-arguments>
            *General-Programming-Knowledge*
<code>
//Working with command-line arguments in Java:

package Args_main;

import java.util.Scanner;

public class Args_main
{
    //args will store the command prompt arguments - if any
    public static void main(String[] args) 
    { 
        //Supposingly we have some arguments in args[]
        
        int [] lenNrs = Args_main.NumberOrNo(args); 
        //convert them to numbers or get their string length
        
        Sorting(lenNrs, args); 
        //sort the numbers or lengths
        
        System.out.printf("Sorting by length or value: \n\n");
        for (int i=0; i&lt;args.length; i++)
        {
            //print results
            System.out.printf("%d &lt;--&gt; %s\n", lenNrs[i], args[i]); 
        }
        
        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
        //cursor to the next line.
    }
    
    //We shall return an array
    public static int[] NumberOrNo(String[] arguments) 
    {
        //Build an array of the same length as arguments array
        int[] someArray = new int[arguments.length]; 
        for (int i=0; i&lt;arguments.length; i++)
        {
            try
            {
                //try to convert to int
                someArray[i] = Integer.parseInt(arguments[i]); 
            }
            catch (Exception e)
            {
                //if not successful then we are having a letter string / word
                someArray[i] = arguments[i].length(); 
                //take out it's length
            }
        }
        return someArray;
    }
    
    //no need to return anything, lists/arrays are always passed by reference
    public static void Sorting (int[] nrsOrNo, String[] arguments) 
    {
        //Do the sorting
        for (int i=0; i &lt; nrsOrNo.length; i++)
        {
            for (int j=0; j&lt;nrsOrNo.length; j++ )
            {
                if (nrsOrNo[j] &lt; nrsOrNo[i])
                {
                    int temp = nrsOrNo[i];
                    nrsOrNo[i] = nrsOrNo[j];
                    nrsOrNo[j] = temp;
                    String argTmp = arguments[i];
                    arguments[i] = arguments [j];
                    arguments [j] = argTmp;
                }
            }
        }
    }
}

</code>
        </command-line-arguments>
        <ternary-operator>
            *General-Programming-Knowledge*
<code>
//Example of using ternary operator in Java:

import java.io.*;

class Ternary 
{
    public static void main(String[] args)
    {
        // variable declaration
        int n1 = 5, n2 = 10, max;

        System.out.println("First num: " + n1);
        System.out.println("Second num: " + n2);

        // Largest among n1 and n2
        max = (n1 > n2) ? n1 : n2;

        // Print the largest number
        System.out.println("Maximum is = " + max);
    }
}
</code>
        </ternary-operator>
        <modular-programming>
            *General-Programming-Knowledge*
            <green>Modular Programming in Java:</green>
            <br></br><br></br>
            A module in Java is typically just a .jar file that has a module-info.java 
            file at the root. 
            <br></br><br></br>
            A module is a directory containing other directories 
            called packages, 
            where every package contains classes stored in individual 
            .java files.
            <br></br><br></br>
            Java modules help encapsulating packages and managing dependencies:<br></br>
            - a class is a container of fields and methods;<br></br>
            - a package is a container of classes and interfaces;<br></br>
            - a module is a container of packages;<br></br>
            <br></br>
            In Java a module is somehow different than in C/C++.
            <br></br>            
            Since Java only allow one class/interface
            be defined per file, a module is more like a collection of files, 
            than a pair of 2 files (.c and .h) as it is in C/C++.
            <br></br><br></br>
            In Java there cannot be any functions, variable declarations or
            implementations of any sort, outside
            the class. <br></br>
            Everything has to be encapsulated within the class.
            <br></br><br></br>
            <brown>Example of modular project in Java:</brown>
            <br></br><br></br>
            1. The module exporting the implementation:
            <br></br>
<code>
//Example of modular project in Java:

//FILEPATH: Implementation_Module/classes/module-info.java

module Implementation_Module 
{
    //this module exports the package:
    exports Implementation_Package;
}
</code>

<code>
//FILEPATH: 
//Implementation_Module/classes/Implementation_Package/Implementation_Class.java

//A package is like a folder/directory
package Implementation_Package;
//This package contains the class with the implementation

public class Implementation_Class 
{
    public void PrintMessage() 
    {
        //This class contains the implementation:
        System.out.println("Hello from Implementation_Module");
    }
    
}
</code>
            <br></br>
            2. The module importing the implementation:
<code>
//FILEPATH: Main_Module/classes/module-info.java

module Main_Module 
{
    //this module requires Implementation_Module:
    requires Implementation_Module;
}
</code>

<code>
//FILEPATH: Main_Module/classes/Main_Package/Main_Class.java

//A package is like a folder/directory
package Main_Package;
//Main_Package requires the implementation

import Implementation_Package.Implementation_Class;
//Implementation is in this package.class

public class Main_Class 
{
    public static void main(String[] args) 
    {
        //Accessing the implementation:
        Implementation_Class obj = new Implementation_Class();
        obj.PrintMessage();
        
        /*
        OUTPUT:
        Hello from Implementation_Module
        */
    }
}
</code>
        </modular-programming>
        <string-methods>
            The String class in Java has a set of built-in methods that 
            can used on strings:
            <br></br><br></br>
            <code>charAt()</code><br></br>
            Returns the character at the specified index (position).
            <br></br><br></br>
            <code>compareTo()</code><br></br>
            Compares two strings lexicographically.
            <br></br><br></br>
            <code>compareToIgnoreCase()</code><br></br>
            Compares two strings lexicographically, ignoring case differences.
            <br></br><br></br>
            <code>concat()</code><br></br>
            Appends a string to the end of another string.
            <br></br><br></br>
            <code>contains()</code><br></br>
            Checks whether a string contains a sequence of characters.
            <br></br><br></br>
            <code>contentEquals()</code><br></br>
            Checks whether a string contains the exact same sequence of characters of the specified 
            CharSequence or StringBuffer.
            <br></br><br></br>
            <code>copyValueOf()</code><br></br>
            Returns a String that represents the characters of the character array.
            <br></br><br></br>
            <code>endsWith()</code><br></br>
            Checks whether a string ends with the specified character(s).
            <br></br><br></br>
            <code>equals()</code><br></br>
            Compares two strings. Returns true if the strings are equal, and false if not.
            <br></br><br></br>
            <code>equalsIgnoreCase()</code><br></br>
            Compares two strings, ignoring case considerations.
            <br></br><br></br>
            <code>format()</code><br></br>
            Returns a formatted string using the specified locale, format string, and arguments.
            <br></br><br></br>
            <code>indexOf()</code><br></br>
            Returns the position of the first found occurrence of specified characters in a string.
            <br></br><br></br>
            <code>isEmpty()</code><br></br>
            Checks whether a string is empty or not.
            <br></br><br></br>
            <code>join()</code><br></br>
            Joins one or more strings with a specified separator.
            <br></br><br></br>
            <code>lastIndexOf()</code><br></br>
            Returns the position of the last found occurrence of specified characters in a string.
            <br></br><br></br>
            <code>length()</code><br></br>
            Returns the length of a specified string.
            <br></br><br></br>
            <code>matches()</code><br></br>
            Searches a string for a match against a regular expression, and returns the matches.
            <br></br><br></br>
            <code>replace()</code><br></br>
            Searches a string for a specified value, and returns a new string where the 
            specified values are replaced.
            <br></br><br></br>
            <code>replaceAll()</code><br></br>
            Replaces each substring of this string that matches the given regular expression 
            with the given replacement.
            <br></br><br></br>
            <code>replaceFirst()</code><br></br>
            Replaces the first occurrence of a substring that matches the given regular expression 
            with the given replacement.
            <br></br><br></br>
            <code>split()</code><br></br>
            Splits a string into an array of substrings.
            <br></br><br></br>
            <code>startsWith()</code><br></br>
            Checks whether a string starts with specified characters.
            <br></br><br></br>
            <code>subSequence()</code><br></br>
            Returns a new character sequence that is a subsequence of this sequence.
            <br></br><br></br>
            <code>substring()</code><br></br>
            Returns a new string which is the substring of a specified string.
            <br></br><br></br>
            <code>toCharArray()</code><br></br>
            Converts this string to a new character array.
            <br></br><br></br>
            <code>toLowerCase()</code><br></br>
            Converts a string to lower case letters.
            <br></br><br></br>
            <code>toString()</code><br></br>
            Returns the value of a String object.
            <br></br><br></br>
            <code>toUpperCase()</code><br></br>
            Converts a string to upper case letters.
            <br></br><br></br>
            <code>trim()</code><br></br>
            Removes whitespace from both ends of a string.
            <br></br><br></br>
            <code>valueOf()</code><br></br>
            Returns the string representation of the specified value.
        </string-methods>
        <datatype-conversions>
            *General-Programming-Knowledge*
<code>
//Example of datatype conversion in Java:

package project3;
import java.util.Scanner;

public class Project3 
{
    public static void main (String[] args) 
    {
        String ValueOne = "1";
        String ValueTwo = "2";
        System.out.printf("ValueOne + ValueTwo = %s\n", ValueOne+ValueTwo);
        
        //Converting Strings to int:
        int a = Integer.parseInt(ValueOne);
        int b = Integer.parseInt(ValueTwo);
        System.out.printf("a + b = %d\n", a+b);
        float val1 = 22.1f, val2 = 25.4f;

        //TypeCasting:
        a = (int)val1; 
        //a gets the integer part of the floating number val1;

        b = (int)val2; 
        //b gets the integer part of the floating number val2;

        System.out.printf("The value of a is: %d\nThe value of b is: %d\n", a, b);

        //The implicit casting is the casting made automatically by the compiler:
        val2 = 15; 
        //so in this case the integer value 15 will be casted into a floating  
        //point value 15.00, this is done automatically by the compiler, 
        //so it's implicit casting.

        //Explicitly casting is the casting that is done by the programmer, 
        //because it cannot be done, automatically by the compiler.
        a = (int) 22.5; 
        //in this case 22.5 will became 22, only the integer part of 
        //the floating value will get stored into int a;

        //Interesting fact:
        val2 = 20 / 15; 
        //integer / integer will result an integer.

        System.out.printf("The value of division is: %f\n", val2); 
        //this will output the value: 1, 
        //even if 20/15 is 1.33333333, and even if it is stored in a float.

        //for the result of the operation to be a float at least one 
        //of those operands need to be casted to float:

        val2 = 20 / (1.0f * 15); 
        //solution one for casting (1.0 * 15 will be converted to 
        //float implicitly).

        System.out.printf("The value of division after casting is: %f\n", val2);

        val2 = 25 / (float) a; 
        //a is explicitly casted to float, so int divided by float will 
        //result in float.

        System.out.printf("The value after explicitly casting is: %f\n", val2);
        System.out.printf("Press any key to terminate!\n");

        Scanner myscanner = new Scanner(System.in);
        myscanner.next();
    }
}

</code>
        </datatype-conversions>
        <decorators>
            *General-Programming-Knowledge*
            <br></br>
            <green>Decorators in Java:</green>
            <br></br><br></br>
            In order to implement a decorator in Java, the following steps
            needs to be followed:
            <br></br><br></br>
            <indigo>1. Component Interface:</indigo>
            <br></br><br></br>
            Defining the interface or the abstract class 
            declaring the methods that will be 
            implemented. 
            <br></br>
            In this case Car will be the component interface.
            <br></br>
<code>
//the interface defining the methods 
//that will be implemented.

package com.journaldev.design.decorator;

public interface Car 
{
    public void assemble();
}
</code>
        <br></br>
        <indigo>2. Component Implementation:</indigo>
        <br></br><br></br>
        The basic implementation of the component interface. 
        We can have BasicCar class as our component implementation.
        <br></br>
<code>
//the basic implementation of 
//the Car interface

package com.journaldev.design.decorator;

public class BasicCar implements Car 
{
    @Override
    public void assemble() 
    {
        System.out.print("Basic Car.");
    }
}
</code>
        <br></br>
        <indigo>3. Decorator:</indigo> 
        <br></br><br></br>
        Defining the decorator class that implements the component 
        interface. <br></br>
        The component variable needs to be accessible to the child decorator classes, 
        so it should be defined as protected variable .
<code>
//the decorator class implementing
//Car interface

package com.journaldev.design.decorator;

public class CarDecorator implements Car 
{

    protected Car car;

    public CarDecorator(Car c)
    {
        this.car=c;
    }

    @Override
    public void assemble() 
    {
        this.car.assemble();
    }

}
</code>
        <br></br>
        <indigo>4. Concrete Decorators:</indigo>
        <br></br><br></br>
        Extending the base decorator functionality and modifying the 
        component behavior accordingly. We can have concrete decorator classes 
        as LuxuryCar and SportsCar.
        <br></br>
<code>
//a second decorator extending the
//functionality of the first decorator

package com.journaldev.design.decorator;

public class SportsCar extends CarDecorator 
{
    public SportsCar(Car c) 
    {
        super(c);
    }

    @Override
    public void assemble()
    {
        super.assemble();
        System.out.print(" Adding features of Sports Car.");
    }
}
</code>

<code>
//using the decorator to modify the 
//component behaviour

package com.journaldev.design.decorator;

public class LuxuryCar extends CarDecorator 
{
    public LuxuryCar(Car c) 
    {
        super(c);
    }

    @Override
    public void assemble()
    {
        super.assemble();
        System.out.print(" Adding features of Luxury Car.");
    }
}
</code>
        </decorators>
        <operators>*General-Programming-Knowledge*</operators>
        <pre-post-incrementation>*General-Programming-Knowledge*</pre-post-incrementation>
        <recursion>
            *General-Programming-Knowledge*
<code>
//Example of using recursion in Java:

public class Main 
{
    public static void main(String[] args) 
    {
        int result = sum(10);
        System.out.println(result);
    }
    
    //Use recursion to add all numbers up to 10:
    public static int sum(int k) 
    {
        if (k > 0) 
        {
            return k + sum(k - 1);
        } 
        else 
        {
            return 0;
        }
    }
}
</code>
        </recursion>
        <reflection>
            *General-Programming-Knowledge*
<code>
//Example of reflection in Java:

import java.lang.Class;
import java.lang.reflect.*;

class Animal {
}

//put this class in different Dog.java file
public class Dog extends Animal 
{
    public void display() 
    {
        System.out.println("I am a dog.");
    }
}

//put this in Main.java file
class Main 
{
    public static void main(String[] args) 
    {
        try 
        {
            // create an object of Dog
            Dog d1 = new Dog();

            // create an object of Class
            // using getClass()
            Class obj = d1.getClass();

            //get name of the class
            String name = obj.getName();
            System.out.println("Name: " + name);

            //get the access modifier of the class
            int modifier = obj.getModifiers();

            //convert the access modifier to string
            String mod = Modifier.toString(modifier);
            System.out.println("Modifier: " + mod);

            //get the superclass of Dog
            Class superClass = obj.getSuperclass();
            System.out.println("Superclass: " + superClass.getName());
        }

        catch (Exception e) 
        {
            e.printStackTrace();
        }
    }
}
</code>
        </reflection>
        <abstract-classes>
            *General-Programming-Knowledge*
            <br></br>
            <green>Abstract classes in Java:</green>
            <br></br><br></br>
            In Java the pure virtual functions/methods are called abstract 
            functions/methods
            due to the keyword <code>abstract</code> used for their definition.
            <br></br><br></br>
            <brown>
            Important rules for abstract methods/classes in Java:
            </brown>
            <br></br><br></br>
            
            Any class that contains one or more abstract methods
            must also be declared abstract.<br></br>
            If a class contains an abstract method it needs to be 
            abstract and vice versa is not true.<br></br>
            If a non-abstract class extends an abstract class, then the 
            class must implement all the abstract methods of the abstract 
            class else the concrete class has to be declared as 
            abstract as well.<br></br><br></br>
            
            The following combinations of modifiers used on abstract methods 
            declaration are invalid: <br></br>
            <code>final</code><br></br>
            <code>abstract native</code><br></br>
            <code>abstract synchronized</code><br></br>
            <code>abstract static</code><br></br>
            <code>abstract private</code><br></br>
            <code>abstract strictfp</code>
            <br></br>
<code>
//Example of abstract class definition:

abstract class Shape 
{
    int color;
    // An abstract function
    abstract void draw();
}
</code>

<code>
//Example of abstract class definition
//and implementation:

//Abstract class
abstract class Sunstar 
{
    abstract void printInfo();
}
 
//Abstraction performed using extends
class Employee extends Sunstar 
{
    void printInfo()
    {
        String name = "avinash";
        int age = 21;
        float salary = 222.2F;

        System.out.println(name);
        System.out.println(age);
        System.out.println(salary);
    }
}
</code>
        </abstract-classes>
        <optional-parameters>
            *General-Programming-Knowledge*
        </optional-parameters>
    </manifest>
    
    <manifest>
        <name>Python</name>
        <description>
            Python is a high-level, general-purpose programming language. 
            Its design 
            philosophy emphasizes code readability with the use of 
            significant indentation.
            <br></br><br></br>

            Python is dynamically typed and garbage-collected. 
            It supports multiple 
            programming paradigms, including structured 
            (particularly procedural), 
            object-oriented and functional programming. 
            It is often described as a 
            "batteries included" language due to its comprehensive standard library.
        </description>
        <oop>
            *General-Programming-Knowledge*
            <green>Object Oriented Programming in Python:</green>
            <br></br><br></br>
            Python uses the self keyword to refer to 
            instance variables.
            <br></br><br></br>
            In Python the variables/fields declared within a class but outside of 
            any methodred
            will become class variables/fields and will be shared amongst all instances.
            The variables/fields
            declared within the constructor will become
            instance variables/fields.
            <br></br>
<code>
#Example of class definition in Python 3:

#Creating a class:
class Employee:
    #This works like documentation of the class.
    'Common base class for all employees' 

    #This member is a class variable whose value 
    #is shared among all instances of a this class.
    empCount = 0 
    #this is similar to a static variable

    #Creating a constructor for the class:
    def __init__(self, name, salary):    
        #the name of the constructor is 
        #always the same: "__init__"
    
        #Here is the place where the members of the 
        #class gets created and initialized.
        self.name = name
        self.salary = salary
        Employee.empCount += 1
   
    #The first parameter of any function
    #in the class is always "self"
    def displayCount(self):  
        #That means that the function will display 
        #information about that instance that calls it.
        print ("Total Employee {0}" .format(Employee.empCount))

    def displayEmployee(self):
        print ("Name : {0}, Salary: {1}" .format(self.name,self.salary))

    #Implementing a destructor for the class.
    def __del__(self):
        #This code will be executed when calling 'del instance'
        class_name = self.__class__.__name__
        print ("Employee destroyed")


#Creating the instances:
"This would create first object of Employee class"
emp1 = Employee("Zara", 2000)
"This would create second object of Employee class"
emp2 = Employee("Manni", 5000)

#Calling the functions;
emp1.displayEmployee()
emp2.displayEmployee()
emp1.displayCount()

Employee.displayCount(emp2) 
#This can work like this as well. 
#But it needs to be specified an instance

Employee.displayEmployee(emp1)

#Instead of using the normal statements to access  
#attributes, you can use the following functions
#similar to getters and setters:

hasattr(emp1, 'name')
#Returns true if 'name' attribute exists

getattr(emp1, 'name')    
#Returns value of 'name' attribute

setattr(emp1, 'name', "Mark") 
#Set attribute 'name' at 8

delattr(emp1, 'name')    
# Delete attribute 'name'

#calling this method will now throw an exception
#emp1.displayEmployee()
#as emp1 has no name attribute anymore.

#Accesing build-in class attributes:
print ("Employee.__doc__: {0}" .format(Employee.__doc__))
#__doc__ is the class documentation string or none, if undefined.

print ("Employee.__name__: {0}" .format( Employee.__name__))
#__name__ is the class name

print ("Employee.__module__: {0}" .format( Employee.__module__))
#__module__ is the module name in which the class is defined.

print ("Employee.__bases__: {0}" .format( Employee.__bases__))
#__bases__ a possibly empty tuple containing the base classes
#in the order of their occurrence in the base class list.

print ("Employee.__dict__: {0}" .format( Employee.__dict__))
#__dict__ is a dictionary containing the class's namespace.

#Example:
del emp1 
#this will delete the instance callded emp1.

emp2.displayEmployee()

#emp1.displayEmployee()
#using emp1 will throw an exception
#as it doesn't exist anymore

input("\nPress any key to exit: ")
#this statement will keep the command prompt open 
#until the next button press:
</code>        
            
            Python deletes unneeded objects (built-in types or 
            class instances) automatically to free the memory space.
            <br></br><br></br>
            Python's garbage collector runs during program execution 
            and is triggered when an object's reference count reaches zero. 
            An object's reference count changes as the number of aliases 
            that point to it changes.
            <br></br><br></br>
            You normally will not notice when the garbage collector 
            destroys an orphaned instance and reclaims its space.
            <br></br><br></br>
            A class can implement the special method <code>__del__()</code>, 
            called a destructor, that is invoked when the 
            instance is about to be destroyed.
            <br></br><br></br>
            <green>Built-In Class Attributes:</green>
            <br></br><br></br>
            These built-in attributes can be accessed using dot operator(<code>.</code>) just 
            like any other class attribute.
            <br></br><br></br>
            <brown>The atttributes used in the example above are:</brown>
            <br></br><br></br>
            <code>__dict__</code> 
            The attribute contains a dictionary containing the class's namespace.
            <br></br><br></br>
            <code>__doc__</code>   
            The attribute contains the class documentation string or none, if undefined.
            <br></br><br></br>
            <code>__name__</code>  
            The attribute contains the class name.
            <br></br><br></br>
            <code>__bases__</code>  
            The attribute contains a possibly empty tuple containing the base classes, 
            in the order of their occurrence in the base class list.
            <br></br><br></br>
            <code>__module__</code>  
            The attribute contains the name of the module in which 
            the class is defined. 
            If the module is the one that is currently running then the module name will 
            be <code>__main__</code>.
            <br></br><br></br>
            This is used for modular programming:
<code>
//Check whether the python script is ran standalone
//or was imported from a different file.

if __name__ == "__main__": 
    print ("Executed when invoked directly")
else: 
    print ("Executed when imported")
</code>

            
        </oop>
        <encapsulation>
            *General-Programming-Knowledge*
<code>
#Example of encapsulation in Python 3:

class Person:

    #Static fields are declared here
    name = "name"
    __age = 0 #this is a public field
    width = 0 #this is a private
    
    #static field can become non-static field for a particular instance 
    #at a particular time when specified
    
    #Constructor:
    def __init__(self):
        #This is the constructor: Only one constructor 
        #function is allowed in Python.
        
        #Function overriding is forbidden.
        self.width = 104
        #Non-Static field get declared in the constructor
    
    #Encapsulation getters and setters:
    
    #Setters:
    def setName(self, Name): # this is a setter
        self.name = Name
    
    def setAge(self, Age):
        self.__age = Age
    
    #Getters:
    def getAge(self):
        return self.__age

class Employee(Person):
    def __init__(self):
        super().__init__()
        self.name = "Employee"

#Creating a class
person = Person ()
#seting the field of the class

person.setName("Alin Popescu")

#Accesing the public field of the class
print (person.name)

#setting the value of private field
person.setAge(22)

#getting the value of a private field
print(person.getAge())

#accessing field modified by the constructor
print(person.width)

emp = Employee()
print(emp.name)

input("\nPress ENTER to exit.")
</code>        
        </encapsulation>
        <polymorphism>
            *General-Programming-Knowledge*
            <br></br><br></br>
            <green>Polymorphism in Python:</green>
            <br></br><br></br>
            Polymorphism with built-in functions:
            <br></br>
<code>
#Example of polymorphism in Python 3
#using built-in functions:
 
# len() being used for a string
print(len("geeks"))
 
# len() being used for a list
print(len([10, 20, 30]))
</code>
            <br></br>
            Polymorphism with user-defined functions:
            <br></br>
<code>
#Example of polymorphism in Python 3
#using user-defined functions:
 
def add(x, y, z = 0): 
    return x + y+z
 
print(add(2, 3))
print(add(2, 3, 4))
</code>
            <br></br>
            Polymorphism with class methods:
            <br></br>
<code>
#Example of polymorphism in Python 3
#using class methods:

class India():
    def capital(self):
        print("New Delhi is the capital of India.")
 
    def language(self):
        print("Hindi is the most widely spoken language of India.")
 
    def type(self):
        print("India is a developing country.")
 
class USA():
    def capital(self):
        print("Washington, D.C. is the capital of USA.")
 
    def language(self):
        print("English is the primary language of USA.")
 
    def type(self):
        print("USA is a developed country.")
 
obj_ind = India()
obj_usa = USA()

for country in (obj_ind, obj_usa):
    country.capital()
    country.language()
    country.type()
</code>
        </polymorphism>
        <inheritance>
            *General-Programming-Knowledge*
            <br></br>
            <green>Inheritance in Python:</green>
            <br></br><br></br>
            Instead of starting from scratch, you can create a class by deriving 
            it from a preexisting class by listing the parent class
            between <code>()</code> parentheses, after the class name.
            <br></br><br></br>
            By inheritance: the child class inherits the attributes of 
            its parent class, 
            and those attributes can be used as if they were defined in the child class. 
            <br></br><br></br>
            A child class can also override data members and methods from the 
            parent.
            <br></br><br></br>
            In Python a child class is often refered to as subclass whereas a 
            parent class
            is refered to as superclass.
            <br></br>
<code>
#Example of inheritance in Python 3:

#Defining a parent class
class Parent:        
    #Variables declared here will be 
    shared through all the instances
    
    #Creating a public member
    parentAttr = 100 
    #This is a public member which could 
    #be accessed from anywhere.

    #Creating hidden (private) member:
   __secretCount = 0 
    #this member is only visible for this class. 
    #So child classes won't be able to access or inherit it.
    
    #To create hidden members (private members), 
    #you just need to put __ as prefix.
    
    #Private members are only visible inside the class, 
    #and can be accessed only by class instances.
    #It's not inheritable

    #Defining a constructor:
    def __init__(self):

        #Members declared here will be 
        #individually created for each instance:
        print ("Calling parent constructor")
        
        #Creating protected member(variable):
        self._protectedVar = 2 
        
        #protected variables can be accessed by parent class 
        #and child class, they are not public.
        
        #Creating hidden (private) member:
        self.__privateVar = 1

    def parentMethod(self):
        print ("Calling parent method")
      
    #Defining a setter:
    def setAttr(self, attr):
        Parent.parentAttr = attr
      
    #Defining a getter:
    def getAttr(self):
        print ("Parent attribute : {0}" .format(Parent.parentAttr))

    def myMethod(self):
        print ("Calling parent method")
    
    def printPrivate(self):
        print("Private Variable: {0}" .format(self.__privateVar))

#Defining a child class
#Child(Parent) means Child inherits Parent
class Child(Parent): 
    #Defining a contructor:
    def __init__(self):
        print ("Calling child constructor")
        
        #Calling parent constructor:
        Parent.__init__(self)
   
    def childMethod(self):
        print ("Calling child method")

    #This is an overrided function:
    def myMethod(self):
        print ("Calling the overrided method.")


c = Child()          # creating an instance of Child class
c.childMethod()      # child calls its method
c.parentMethod()     # calls parent's method
c.setAttr(200)       # again call parent's method
c.getAttr()          # again call parent's method

#You can always override your parent class methods. One reason 
#for overriding parent's methods is because you may want
#special or different functionality in your subclass.
c.myMethod()

#Trying to print a private members:
#print("Private value: {0}" .format(c.__secretCount)) 
#will result in compilation error, child has no member named like that.

#print("Private value: {0}" .format(Parent.__secretCount))
#will result incompilation error, parent has no member like that.

print("The public member: {0}" .format(Parent.parentAttr))

#Trying to print protected members:
#print("The protected member: {0}" .format(Parent._protectedVar)) 
#will result in compilation error, parent class has no member name like that.

print("The protected member: {0}" .format(c._protectedVar))
p1 = Parent()

#Accesing the private variable can only be made 
#with public accessors (Getters and Setters)
p1.printPrivate()

#print("The private member: {0}" .format(p1.__privateVar))
#this won't work.

input("\nPress any key to exit: ")
</code>
        <br></br>
        <green>Python built-in functions for classes/instances:</green>
        <br></br><br></br>
        <code>issubclass(sub, sup)</code><br></br>
        It's a boolean function that returns true 
        if the given subclass sub is indeed a subclass of the 
        superclass sup.
        <br></br><br></br>
        <code>isinstance(obj, Class)</code><br></br>
        Its a boolean function that returns true if 
        the <code>obj</code> is an instance of class Class or is an 
        instance of a subclass of Class.
        <br></br>
        </inheritance>
        <abstraction>
            *General-Programming-Knowledge*
            <br></br>
            <green>Abstraction in Python:</green>
            <br></br><br></br>
            Abstraction in Python refers to the process of creating 
            abstract 
            classes and methods that provide a blueprint for other 
            classes to inherit from.
            <br></br><br></br>
            It allows us to define common attributes and behaviors that can be shared among 
            multiple classes.
            <br></br>
<code>
#Example of abstraction in Python:

from abc import ABC, abstractmethod

#Defining abstract class:
class democlass(ABC):
    #Defining abstract method:
    @abstractmethod
    def method1(self):
        print ("abstract method")
        return
    
    #Defining concrete method:
    def method2(self):
        print ("concrete method")

#Defining concrete class:
class concreteclass(democlass):
    def method1(self):
        #Calling parent class method:
        super().method1()
        return
      
obj = concreteclass()
obj.method1()
obj.method2()
</code>
        </abstraction>
        <generic-programming>
            *General-Programming-Knowledge*
            <br></br>
            <green>Generic-Programming in Python:</green>
            <br></br><br></br>
            Python generics are like hints in Python. They came out in Python 3.5
            and newer versions. 
            <br></br>
            They let you say what type of things your variables, 
            functions, and results are. 
            <br></br>
            It helps you write down what kind of things your 
            code is dealing with, but it doesn't make the computer check it 
            while running the code.
            <br></br>
<code>
#Example of Python 3 generics with functions:

from typing import TypeVar, List

T = TypeVar('T')

def element(items: List[T]) -> T:
    return items[0]

# Usage
print(element([1, 2, 3])) 
print(element(['a', 'b', 'c']))  

# OUTPUT:
# 1
# a
</code>

<code>
#Example of Python 3 generics with classes:

from typing import TypeVar, Iterable

#Declare type variable
T = TypeVar('T')  

def process_data(data: Iterable[T]) -> None:
    for item in data:
        # Check if the object has a quack method, then call it
        if hasattr(item, 'quack') and callable(item.quack):
            item.quack()
        else:
            print(f"This object of type {type(item).__name__} doesn't quack like a duck!")

#Example class
class Duck:
    def quack(self):
        print("Quack!")

#Another class with similar behavior
class AnotherBird:
    def quack(self):
        print("Quack!")

#Using duck typing with process_data function
duck_obj = Duck()
another_bird_obj = AnotherBird()

#Both objects "quack" like a duck
duck_list = [duck_obj, another_bird_obj]  

#We can pass duck_list to process_data because 
#both objects have a quack method
process_data(duck_list)   

# OUTPUT: 
# Quack!
# Quack!
</code>
        </generic-programming>
        <variable-arguments-lists>
            *General-Programming-Knowledge*
<code>
#Example of variable arguments in Python:

def Print(*argv):
    for arg in argv:
        print(arg)

Print('Hello', 'Welcome')
</code>        
        </variable-arguments-lists>
        <simple-data-types>
            In programming, data type is an important concept.
            <br></br><br></br>
            Variables can store data of different types, and different 
            types can do different things.
            <br></br><br></br>
            <green>Data types in Python:</green>
            <br></br><br></br>
            <indigo>Python has the following built-in data types:</indigo><br></br>
            <code>Text Type:        str</code><br></br>
            <code>Numeric Types:    int, float, complex</code><br></br>
            <code>Sequence Types:   list, tuple, range</code><br></br>
            <code>Mapping Type:     dict</code><br></br>
            <code>Set Types:        set, frozenset</code><br></br>
            <code>Boolean Type:     bool</code><br></br>
            <code>Binary Types:     bytes, bytearray, memoryview</code><br></br>
            <code>None Type:        NoneType</code><br></br>
            <br></br>
<code>
#Example of data-types in Python:

#str
x = "Hello World"
print(type(x))

#int
x = 20
print(type(x))

#float
x = 20.5
print(type(x))

#complex
x = 1j
print(type(x))

#list
x = ["apple", "banana", "cherry"]
print(type(x))

#tuple
x = ("apple", "banana", "cherry")
print(type(x))

#range
x = range(6)
print(type(x))

#dict
x = {"name" : "John", "age" : 36}
print(type(x))

#set
x = {"apple", "banana", "cherry"}
print(type(x))

#frozenset
x = frozenset({"apple", "banana", "cherry"})
print(type(x))

#bool
x = True
print(type(x))

#bytes
x = b"Hello"
print(type(x))

#bytearray
x = bytearray(5)
print(type(x))

#memoryview
x = memoryview(bytes(5))
print(type(x))

#NoneType
x = None
print(type(x))
</code>        
        </simple-data-types>
        <complex-data-types>
            The complex data type in Python is used to represent numbers with both 
            real and imaginary parts. It is written in the 
            form of <code>a + bj</code>, where <code>a</code> 
            represents the real part and <code>b</code> represents the imaginary part.
        </complex-data-types>
        <loops>
            Python programming language provides two types of loops: For loop and 
            While loop
            <br></br><br></br>
            Loops in Python provides multiple ways for the execution:
            <br></br><br></br>
            <indigo>While Loop:</indigo>
<code>
#Example of while loop execution:

count = 0
while (count &lt; 3):
    count = count + 1
    print("Hello")
</code>

<code>
#Example of while-else loop execution:

count = 0
while (count &lt; 3):
    count = count + 1
    print("Hello")
else:
    print("Goodbye")
</code>

<code>
#Example of infinite while loop execution 
#using try-except blocks:

fruits = ["apple", "orange", "kiwi"]
iter_obj = iter(fruits)
while True:
    try:
        fruit = next(iter_obj)
        print(fruit)
    except StopIteration:
        break
</code>
             <br></br>
            <indigo>For Loop:</indigo>
            <br></br>
<code>
#Example of for loop execution using range:

n = 4
for i in range(0, n):
    print(i)
</code>

<code>
#Example of for loop execution using range:

list = ["items", "inside", "the", "list"]
for index in range(len(list)):
    print(list[index])
</code>

<code>
#Example of for-else loop execution using range:

list = ["items", "inside", "the", "list"]
for index in range(len(list)):
    print(list[index])
else:
    print("List ended.")
</code>

<code>
#Example of for loop execution as foreach:

fruits = ["apple", "orange", "kiwi"]

for fruit in fruits:
    print(fruit)
</code>
        </loops>
        <collections>
            *General-Programming-Knowledge*
            <br></br>
            <green>Collections in Python:</green>
            <br></br><br></br>
            <brown>Lists:</brown>
            <br></br><br></br>
            Lists are ordered and changeable collections which 
            allow duplicate values. 
            Ordered means that the items within a list have a 
            defined order, and that order will 
            not change. Changeable means that we can change, add, 
            and remove 
            items in a list after it has been created.
            <br></br><br></br>
            A list is like a vector (dynamic in length) and it can be accessed 
            in the same way, by index. The list collections are indexed 
            starting from 
            0, similar to any other collection from other programming languages.
            <br></br><br></br>
            In Python a list can be created using any type of data.
            The dynamic length of a list, allows appending new elements 
            at the end of the 
            list, so that the size would change automatically.
            <br></br>
<code>
#Example of working with lists in Python 3:

#Defining a list:
CharList = ['M','e','s','s','a','g','e']

print('The list is: {0}' .format(CharList))

#Accessing an element of the list:
print('This is the 4th element {0}' .format(CharList[4]))

#Changing an element of the list:
CharList[4] = 'O'
print("The new 4th element is: {0}" .format(CharList[4]))

#Appending elements at the end of the list.
CharList+= ['1', '2'] 
#this is used for temporarily change.
print("The list now, looks like this: {0}" .format(CharList))

CharList.append('3') 
#this is used for permanent change. 
print("The list now, looks like this: {0}" .format(CharList))

#Slicing lists:
print("The sliced list is: {0}" .format(CharList[:5])) 
#slicing a list can be done just like in case of strings.

#Changing multiple items of the list:
CharList[2:] = ['2', '3'] 
#this synthax can only be used on lists, to add multiple
#elements after a given index (will automatically erase 
#the rest of the elements after that index)

print(CharList)

#Emptying the list:
CharList[:] = []
print(CharList)

input("\nPress any key to exit: ")
</code>

<code>
#Example of unpacking lists in Python:

#Unpacking is the process in which every
#list element gets assigned to individual variable

item, name, price = ["Car", "Mustang Gt", "14000"]
#This is an unpacked list, where each element is actually a variable.

print("item: ", item, " name: ", name, " price: ", price);

#The lists that have many more elements:
print("\nThis is the second method: ")
start, *middle, end = ["element1", "element2", "element3", "element4"]

print(start) 
#this will print the first element

print(*middle) 
#this will print all the middle elements

print(end) 
#this will print the last element
</code>

<code>
#Example of zipping/combining lists together:

Lst1 = ["Dragos", "Alan", "Robin"]
Lst2 = ["Blake", "Walker", "Williams"]

names = zip(Lst1, Lst2)

#names will be a new list, a 2-dimensional list 
#containing all the elements in Lst1 and Lst2 combined.

#Iterating names:
for a,b in names:
    print("Name = ", a, b)

</code>
            <brown>Dictionaries:</brown>
            <br></br><br></br>
            Dictionaries are used to store data values in <code>key:value</code> pairs.
            A dictionary is a collection which is ordered, 
            changeable and do not allow duplicates.
            <br></br><br></br>
            Each key is separated from its value by a colon (<code>:</code>), 
            the items are separated by
            commas (<code>,</code>) and the whole thing is enclosed in curly braces <code>{}</code>. 
            <br></br>
            An empty dictionary
            without any items is declared using only two curly braces such as: <code>{}</code>.
            <br></br><br></br>
            Keys are unique within a dictionary while 
            values may not be. The values of a
            dictionary can be of any type, but the keys must be of 
            an immutable data type such as strings, numbers, 
            or tuples.
            <br></br><br></br>
            An item can be accessed only with a valid key or index, 
            trying to access an item with invalid key or index will 
            result in an error.
            <br></br><br></br>
            Dictionary values have no restrictions. 
            They can be any arbitrary Python objects,
            either standard objects or user-defined objects. 
            However, the same is not true for the keys
            <br></br><br></br>
            <indigo>Important aspect: </indigo>
            <br></br>
            More than one entry per key is not allowed. 
            Which means no duplicate key is allowed. 
            When duplicate keys are encountered during assignment, the last
            assignment wins.
            <br></br><br></br>
            Keys must be immutable. Which means you can use 
            strings, numbers or tuples as dictionary  
            keys but something like <code>['key']</code> is not allowed.
            <br></br><br></br>
            Example: <code>dict = {['Name']: 'Zara'}</code>
            <br></br>
            This case is not allowed as the key provided is of type list.
            <br></br>
<code>
#Example of working with dictionaries in Python 3:

dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}

print ("dict['Name']: {0}" .format(dict['Name']))
print ("dict['Age']: {0}" .format(dict['Age']))

#Updating the dictionary:
print("\nAfter the update:")
dict['Age'] = 8; # update existing entry
dict['Name'] = "DPS School"; # Add new entry
print ("dict['Name']: {0}" .format(dict['Name']))
print ("dict['Age']: {0}" .format(dict['Age']))

#Looping through the dictionary:
for name,key in dict.items(): 
    #treat 'name' as the Name(from dictionary)
    #and key as the Key(value from the dictionary)
    
    print("Key: ", key, "\t Name:", name)

#Deleting dictionary items:
del dict['Name']; 
#remove entry with key 'Name'
#After the deletion the item with key 'Name'
#accessing it will result and error.

dict.clear();     
#remove all entries in dict, the dictionary 
#will be empty.

del dict ;        
#delete entire dictionary, it won't exist anymore.

input("\nPress any key to exit: ")
</code>

<code>
#Example of iterating through dictionaries:
#Accessing elements of dictionary using indexes:

i=0
dict = {"name1": "John", "name2": "Allan", "name3": "Mark"}

#Iterating through dictionary using while loop (for values):
while(i&lt;len(dict)):
    print("While-loop Key: ", list(dict.keys())[i], \
                  " While-loop Value: ", list(dict.values())[i])
    i+=1
print()

#Iterating through dictionary using while loop (for values):
i=0
while(i&lt;len(dict)):
    print("While-loop Value: ", list(dict.values())[i])
    i+=1
print()

#Iterating through dictionary using while loop (for values):
i=0
while(i&lt;len(dict)):
    print("While-loop Key: ", list(dict.keys())[i])
    i+=1
print()

#Iterating through dictionary using for loop (for keys and values):
for n,k in dict.items():
    print("For-Loop key = ", n, " For-Loop Value = ", k)
print()

#Iterating through dictionary using for loop (for keys):
for k in dict:
    print("For-Loop key = ", k)
print()

#Iterating through dictionary using for loop (for values):
for k in dict.values():
    print("For-Loop Value = ", k)

#Keep the console opened until the next button pressed:
input("Enter anything to quit.")
</code>
            <br></br>
            Dictionaries can also be converted to lists as the following 
            example demonstrates:
            <br></br>
<code>
//Example of splitting dictionaries to lists:

Dict = { "GOOGLE": 53.22, "FACEBOOK": 77.22, "TUMBLR": 33.2}

#Splitting dictionary to lists:
#Dict.values() => this will return a list with all the values in dictionary
#Dict.keys() => this will return a list with all the keys in the dictionary

#Zipping a dictionary:
name = zip(Dict.values(), Dict.keys())

#The zipped dictionary will look like this:
#(33.2, 'TUMBLR'), (53.22, 'GOOGLE'), (77.22, 'FACEBOOK')
#The same would be in case of lists, 1->1, 2->2
#first element combined with first, second to second... etc

print("The original dictionary is: ", Dict)
#Sorting a zipped dictionary:
print("The sorted(by value) zipped dictionary is: ", sorted(name))

name = name = zip(Dict.keys(), Dict.values())
print("The sorted (by keys) zipped dictionary is: ", sorted(name))
</code>
            <br></br>
            <brown>Sets:</brown>
            <br></br><br></br>
            Sets are like lists that cannot contain duplicate elements.
            <br></br>
            A set is one of 4 built-in data types in Python used 
            to store collections of data, 
            the other 3 are List, Tuple, and Dictionary, 
            all with different qualities and usage.
            <br></br>
<code>
#Example of working with sets in Python 3:

SetO = {"Fruits", "Vegetables", "Meal", "Drinks"}
print("This is the set: ", SetO)

#Printing item by item:
print("\nThese are the items in the set: ")
for item in SetO:
    print(item)

print("The size of Set is: " + str(len(SetO)))

input("\nPress any key to exit: ")
</code>
            <br></br>
            <brown>Tuples:</brown>
            <br></br><br></br>
            A tuple is a sequence of immutable Python objects. 
            Tuples are 
            sequences, just like lists. 
            <br></br><br></br>
            The differences between tuples 
            and lists are:<br></br>
            - tuples cannot be changed whereas lists can be changed;<br></br>
            - tuples use parenthesis <code>()</code>, whereas lists use 
            square brackets <code>[]</code>.<br></br>
            Immutable means constant once initialized it cannot be changed, meaning
            no item can be changed, added or removed from it.
            <br></br><br></br>
            Tuples can however be reinitialized with different values.
            <br></br><br></br>
            Tuples can be sliced meaning you are able to take portions of
            existing tuples to create new tuples.
            <br></br><br></br>
            New tuples can be created by adding 2 
            existing tuples together.
            <br></br><br></br>
            Any set of multiple objects, comma-separated, declared without identifying 
            symbols are by default set to tuples.
            <br></br>
            Tuples can be accessed using indexes. 
            <br></br>
<code>
#Example of working with tuples in Python 3:

tup1 = ('physics', 'chemistry', 1997, 2000);
tup2 = (1, 2, 3, 4, 5 );
tup3 = "a", "b", "c", "d";

#An empty tuple is declared like this:
tup1 = ();

#To write a tuple containing a single value you have to 
include a comma, even though there is only one value.
tup1 = (50,); 
print("The tuple contain {0} elements: {1} " .format(len(tup1), tup1[0]))

#Tuples can be reinitialized with other values.
tup1 = (12, 34.56); 
tup2 = ('abc', 'xyz');

#Following action is not valid for tuples
#tup1[0] = 100;

#So let's create a new tuple as follows:
tup3 = tup1 + tup2;
print (tup3)

#Tuples can be DELETED as follows:
del tup3
#print(tup3) -> this will result an error, 
#tup3 won't exist anymore after its deletion

tup3 = tup1 + tup2;
#Tuples can use the same operation just as lists:
print ("\nExample: tup3[2] = {0}, tup3[-2] = {1}" .format(tup3[2], tup3[-2]))

print("Slicing tuples: {0}" .format(tup3[:2]))
print("Slicing tuples: {0}" .format(tup3[2:]))

#Any set of multiple objects, comma-separated, 
#declared without identifying symbols are by 
#default set to tuples.
#Examples:
x, y = 1, 2;

input("\nPress any key to exit: ")
</code>
        </collections>
        <collection-methods>
            <green>Collection Methods in Python:</green>
            <br></br><br></br>
            Python has a set of built-in methods that can be used on collections.
            <br></br><br></br>
            <green>List methods:</green>
            <br></br><br></br>
            <code>append()</code><br></br>
            Used for adding elements to the end of the List. 
            <br></br><br></br>
            <code>copy()</code><br></br>
            It returns a shallow copy of a list
            <br></br><br></br>
            <code>clear()</code><br></br>
            This method is used for removing all items from the list. 
            <br></br><br></br>
            <code>count()</code><br></br>
            These methods count the elements.
            <br></br><br></br>
            <code>extend()</code><br></br>
            Adds each element of an iterable to the end of the List
            <br></br><br></br>
            <code>index()</code><br></br>
            Returns the lowest index where the element appears. 
            <br></br><br></br>
            <code>insert()</code><br></br>
            Inserts a given element at a given index in a list. 
            <br></br><br></br>
            <code>pop()</code><br></br>
            Removes and returns the last value from the List or the given index value.
            <br></br><br></br>
            <code>remove()</code><br></br>
            Removes a given object from the List. 
            <br></br><br></br>
            <code>reverse()</code><br></br>
            Reverses objects of the List in place.
            <br></br><br></br>
            <code>sort()</code><br></br>
            Sort a List in ascending, descending, or user-defined order
            <br></br><br></br>
            <code>min()</code><br></br>
            Calculates the minimum of all the elements of the List
            <br></br><br></br>
            <code>max()</code><br></br>
            Calculates the maximum of all the elements of the List
            <br></br><br></br>
            <green>Dictionary methods:</green>
            <br></br><br></br>
            <code>clear()</code><br></br>
            Removes all the elements from the dictionary
            <br></br><br></br>
            <code>copy()</code><br></br>
            Returns a copy of the dictionary
            <br></br><br></br>
            <code>fromkeys()</code><br></br>
            Returns a dictionary with the specified keys and value
            <br></br><br></br>
            <code>get()</code><br></br>
            Returns the value of the specified key
            <br></br><br></br>
            <code>items()</code><br></br>
            Returns a list containing a tuple for each key value pair
            <br></br><br></br>
            <code>keys()</code><br></br>
            Returns a list containing the dictionary's keys
            <br></br><br></br>
            <code>pop()</code><br></br>
            Removes the element with the specified key
            <br></br><br></br>
            <code>popitem()</code><br></br>
            Removes the last inserted key-value pair
            <br></br><br></br>
            <code>setdefault()</code><br></br>
            Returns the value of the specified key. If the key does not exist: 
            insert the key, with the specified value
            <br></br><br></br>
            <code>update()</code><br></br>
            Updates the dictionary with the specified key-value pairs
            <br></br><br></br>
            <code>values()</code><br></br>
            Returns a list of all the values in the dictionary
            <br></br><br></br>
            <green>Set methods:</green>
            <br></br><br></br>
            <code>add()</code><br></br>
            Adds an element to the set
            <br></br><br></br>
            <code>clear()</code><br></br>
            Removes all the elements from the set
            <br></br><br></br>
            <code>copy()</code><br></br>
            Returns a copy of the set
            <br></br><br></br>
            <code>difference()</code><br></br>
            Returns a set containing the difference between two or more sets
            <br></br><br></br>
            <code>difference_update()</code><br></br>
            Removes the items in this set that are also included in another, specified set
            <br></br><br></br>
            <code>discard()</code><br></br>
            Remove the specified item
            <br></br><br></br>
            <code>intersection()</code><br></br>
            Returns a set, that is the intersection of two other sets
            <br></br><br></br>
            <code>intersection_update()</code><br></br>
            Removes the items in this set that are not present in other, 
            specified set(s)
            <br></br><br></br>
            <code>isdisjoint()</code><br></br>
            Returns whether two sets have a intersection or not
            <br></br><br></br>
            <code>issubset()</code><br></br>
            Returns whether another set contains this set or not
            <br></br><br></br>
            <code>issuperset(()</code><br></br>
            Returns whether this set contains another set or not
            <br></br><br></br>
            <code>pop()</code><br></br>
            Removes an element from the set
            <br></br><br></br>
            <code>remove()</code><br></br>
            Removes the specified element
            <br></br><br></br>
            <code>symmetric_difference()</code><br></br>
            Returns a set with the symmetric differences of two sets
            <br></br><br></br>
            <code>symmetric_difference_update()</code><br></br>
            Inserts the symmetric differences from this set and another
            <br></br><br></br>
            <code>union()</code><br></br>
            Return a set containing the union of sets
            <br></br><br></br>
            <code>update()</code><br></br>
            Update the set with the union of this set and others
            <br></br><br></br>
            <green>Tuple methods:</green>
            <br></br><br></br>
            <code>count()</code><br></br>
            Returns the number of times a specified value occurs in a tuple
            <br></br><br></br>
            <code>index()</code><br></br>
            Searches the tuple for a specified value and returns the 
            position of where it was found
            <br></br>
        </collection-methods>
        <dynamic-memory-allocation>
            <green>Dynamic memory allocation in Python:</green>
            <br></br><br></br>
            The memory is allocated to the objects at the run time. <br></br>
            The heap is used to implement dynamic memory management. 
            <br></br><br></br>
            Everything in Python is an object which means the memory is
            allocated dynamically and is managed by the 
            Python Memory Management.
            <br></br><br></br>
            Python deletes unneeded objects (built-in types or 
            class instances) automatically to free the memory space.
            <br></br><br></br>
            Python's garbage collector runs during program execution 
            and is triggered when an object's reference count reaches zero. 
            An object's reference count changes as the number of aliases 
            that point to it changes.
            <br></br>
        </dynamic-memory-allocation>
        <read-from-file>
            *General-Programming-Knowledge*
            <green>Read files in Python:</green>
            <br></br><br></br>
            The <code>read()</code> method reads a string from an opened file. 
            <br></br>
            It is important to note that Python strings can contain binary data, 
            apart from text data.
            <br></br><br></br>
            When reading/writing characters from a file the pointer/cursor 
            will move across the
            content of a file, and if it reaches the end, it will need to be reseted 
            using <code>seek()</code> function, before being able to read/write again.
            <br></br><br></br>
            The method <code>tell()</code> returns the current position of the 
            pointer/cursor within the file.
            <br></br><br></br>
            Passing an argument to the <code>read()</code> method will ensure that everything is 
            read until to the given position within the file content.
            <br></br><br></br>
            Example: <code>MyFile.read(11)</code> 
            <br></br>
            Only the first 11 characters will be extracted from the file.
            <br></br><br></br>
            The <code>close()</code> method of a file object, flushes 
            any unwritten information and closes the file object, 
            after which no more reading or writing can be done. 
            <br></br><br></br>
            Python automatically closes a file when the reference object of 
            a file is reassigned to another file.
            <br></br><br></br>
            It is a good practice to use the <code>close()</code> method to close a file 
            after finishing operating on the file.
            <br></br><br></br>
            In order to open a file the <code>open()</code> method it is used. 
            <br></br><br></br>
            The <code>open()</code> method takes 2 arguments:<br></br>
            - the filepath of the file to be opened;<br></br>
            - the mode for opening;<br></br>
            <br></br>
            Example: <code>open("file.txt", "w")</code><br></br>
            This will open a file named file.txt placed in the same 
            directory as the <code>.py</code> script.
            <br></br><br></br>
            <green>Modes for opening a file:</green>
            <br></br><br></br>
            The other available modes for opening a file are:
            <br></br><br></br>
            <code>"r"</code> - Opens a file for reading only. 
            <br></br>
            The file pointer/cursor is placed at the beginning of the file. 
            This is the default mode. It throws an error if 
            the file does not exist.
            <br></br><br></br>
            <code>"w"</code> - Opens a file for writing only. 
            <br></br>
            Overwrites the file if the file exists.
            If the file does not exist, creates a new file for writing.
            <br></br><br></br>
            <code>"rb"</code> - Opens a file for reading only in binary format. 
            <br></br>
            The file pointer/cursor is placed
            at the beginning of the file. 
            This is the default mode.
            <br></br><br></br>
            <code>"rb+"</code> - Opens a file for both reading and writing in 
            binary format. 
            <br></br>
            The file pointers placed at the beginning of the file.
            <br></br><br></br>
            <code>"wb"</code> - Opens a file for writing only in binary format. 
            <br></br>
            Overwrites the file if the file exists. 
            If the file does not exist, 
            creates a new file for writing.
            <br></br><br></br>
            <code>"w+"</code> - Opens a file for both writing and reading.
            <br></br>
            Overwrites the existing file if
            the file exists. 
            If the file does not exist, creates a new file for reading
            and writing.
            <br></br><br></br>
            <code>"wb+"</code> - Opens a file for both writing and reading in 
            binary format. 
            <br></br>
            Overwrites the existing file if 
            the file exists. 
            If the file does not exist, creates a
            new file for reading and writing.
            <br></br><br></br>
            <code>"a"</code> - Opens a file for appending. <br></br>
            The file pointer/cursor is at the end of the file
            if the file exists. 
            The file is opened in 
            the append mode. If the file does
            not exist, it creates a new file for writing.
            <br></br><br></br>
            <code>"ab"</code> - Opens a file for appending in binary format. 
            <br></br>
            The file pointer/cursor is at the
            end of the file if the file exists.
            The file is opened in the append mode.
            If the file does not exist, 
            it creates a new file for writing.
            <br></br><br></br>
            <code>"a+"</code> - Opens a file for both appending and reading.
            <br></br>
            The file pointer/cursor is at the
            end of the file if the file exists.
            The file opens in the append mode. If the
            file does not exist, it creates a new file 
            for reading and writing.
            <br></br><br></br>
            <code>"ab+"</code> - Opens a file for both appending and reading 
            in binary format. 
            <br></br>
            The pointer/cursor within the file is poiting to the end of the 
            file if the file exists. 
            If the file does not exist, it creates 
            a new file for reading and writing.
            <br></br><br></br>
            <green>File object attributes:</green>
            <br></br><br></br>
            The file object contains several attributes:
            <br></br><br></br>
            <code>file.closed</code><br></br>
            Returns <code>true</code> if file is closed, <code>false</code> 
            otherwise.
            <br></br><br></br>
            <code>file.mode</code><br></br>
            Returns the access mode with which the file was 
            opened.
            <br></br><br></br>
            <code>file.name</code><br></br> 
            Returns name of the file.
            <br></br><br></br>
            <code>file.softspace</code><br></br>
            Returns a boolean that indicates whether a space character 
            needs to be printed before another value when using the print statement.
            <br></br><br></br>
<code>
#Example of reading content from files
#in Python:

MyFile.write("This program is written in Python language.")
#The string above will be written after the files gets closed (in the next line)
MyFile.close();

MyFile = open("file.txt", "r")

Msg = MyFile.read(11) 
#Only the first 11 character will be extracted from the file.
print(Msg)

Msg = MyFile.read(11) 
#This will print the next 11 character in the file
#since the cursor wasn't restarted.

print(Msg)

#Check current position
position = MyFile.tell();
print ("Current file position : {0}"  .format(position))
position = MyFile.seek(0, 0); 
#this will restart the cursor to the beginning of the file.

Msg = MyFile.read(11)
print(Msg)

import os 
#needed for the os functions.

#Syntax: os.rename(current_file_name, new_file_name)
#This function will rename a file:

#Getting the current file name:
print("The current file name is: {0}" .format(MyFile.name))
#The attribute .name shows the name of the current file loaded.

MyFile.close() 
#closing the file

#Check if a file exists
if os.path.isfile("file1.txt"): 
    os.remove("file1.txt") 
    #remove the file

os.rename("file.txt", "file1.txt")
#renaming the file

#Renaming the file with the name of an 
#existing file (at the same path) will
#throw an exception.

MyFile = open("file1.txt", "r")
print("The current file name is: {0}" .format(MyFile.name))
#Changing the name of the file will work only 
#if the file is closed, and not being
#processed by another programs.

#Removing a directory:
os.chdir(r"C:\Users\Black2\Desktop\python") 
#Changing the current directory

#Check if a directory exists
if os.path.exists(r"C:\Users\Black2\Desktop\python\file dir"):
    os.rmdir(r"C:\Users\Black2\Desktop\python\file dir") 
    #removing the directory

#Creating a directory:
os.mkdir("file dir")

#The os.getcwd() method displays the current working directory.
print("The current working directory is: {0}" .format(os.getcwd()))

#Renaming directories:
#Check if a directory exists:
if os.path.exists(r"C:\Users\Black2\Desktop\python\directory dir2"):
    os.rmdir(r"C:\Users\Black2\Desktop\python\directory dir2") 
    #removing the directory

os.rename(r"C:\Users\Black2\Desktop\python\directory dir",
             r"C:\Users\Black2\Desktop\python\directory dir2")
#renaming the file

MyFile.close()
#closing the file

os.rmdir(r"C:\Users\Black2\Desktop\python\directory dir2")
#removing the directory

input("\nPress any key to exit: ")
</code>
        </read-from-file>
        <write-to-file>
            *General-Programming-Knowledge*
            <br></br>
            <green>Writing to files in Python:</green>
            <br></br><br></br>
            The <code>write()</code> method writes any string to an open file.
            The <code>write()</code> method does not add a newline character ('\n')
            <br></br><br></br>
            It is important to note that
            Python strings can have binary data and not just text.
            <br></br><br></br>
            When reading/writing characters from a file the pointer/cursor 
            will move across the
            content of a file, and if it reaches the end, it will need to be reseted 
            using <code>seek()</code> function, before being able to read/write again.
            <br></br><br></br>
            The <code>close()</code> method of a file object, flushes 
            any unwritten information and closes the file object, 
            after which no more reading or writing can be done. 
            <br></br><br></br>
            Python automatically closes a file when the reference object of 
            a file is reassigned to another file.
            <br></br><br></br>
            It is a good practice to use the <code>close()</code> method to close a file 
            after finishing operating on the file.
            <br></br><br></br>
            In order to open a file the open() method it is used. 
            <br></br><br></br>
            The <code>open()</code> method takes 2 arguments:<br></br>
            <br></br>
            - the filepath of the file to be opened;<br></br>
            - the mode for opening;
             <br></br><br></br>
            Example: <code>open("file.txt", "w")</code><br></br>
            This will open a file named file.txt placed in the same 
            directory as the <code>.py</code> script.
            <br></br><br></br>
            <brown>Writing to a file using TXT format:</brown>
            <br></br>
<code>
#Example of writing to a file in Python:
 
#Opening a file
file1 = open('myfile.txt', 'w')
L = ["This is Delhi \n", "This is Paris \n", "This is London \n"]
s = "Hello\n"
 
#Writing a string to file
file1.write(s)
 
#Writing multiple strings
#at a time
file1.writelines(L)
 
#Closing file
file1.close()
 
#Checking if the data is
#written to file or not
file1 = open('myfile.txt', 'r')
print(file1.read())
file1.close()
</code>
            <br></br>
            <brown>Writing to a file using XML format:</brown>
            <br></br>
<code>
#Example of writing to XML file
#in Python 3:

import os

import sys
import xml.etree.ElementTree
#import used for XML formatting

#Defining a person class:
class Person:
    def __init__(self, surname:str, firstname:str, age: int):
        self.surname = surname
        self.age = age
        self.firstname = firstname

    def __repr__(self):
        return self.surname+ " " + self.firstname + " " + str(self.age)

#Creating a list of persons:
people = [
                Person("Geere", "Richard", 64),
                Person("Walker", "Alan", 24),
                Person("Manson", "Mary", 34),
                Person("Manson", "Deny", 36),
                Person("Menance", "Denise", 54),
                Person("Reyes", "Antonio", 22),
            ]

#Define a function to write to an xml file:
def write_xml(list, filename):
    #Format the content of the list to XML format
    root  = xml.etree.ElementTree.Element("people")
    for pers in list:
        node = xml.etree.ElementTree.Element("people", age = str(pers.age))
        surname = xml.etree.ElementTree.SubElement(node, 'surname')
        firstname = xml.etree.ElementTree.SubElement(node, 'firstname')
        surname.text = pers.surname
        firstname.text = pers.firstname
        root.append(node)
    
    tree = xml.etree.ElementTree.ElementTree(root)
    
    #Writing to the file:
    try:
        tree.write(filename, "UTF-8")
    
    except EnvironmentError as err:
        print("{0}: import error: {1}".format(
            os.path.basename(sys.argv[0]), err))
        return False
    
    return True

#Calling write_xml function:
write_xml(people, "file.xml")
</code>        
        </write-to-file>
        <serialization>
            *General-Programming-Knowledge*
<code>
#Example of serialization in Python:

import pickle

#Object to serialize  
data = [1, 2, 3, 4, 5]

#Serialize object to a file  
with open('data.pkl', 'wb') as file:  
pickle.dump(data, file) 
</code>        
        </serialization>
        <deserialization>
            *General-Programming-Knowledge*
<code>
#Example of deserialization in Python:

import pickle

#Deserialize object from the file  
with open('data.pkl', 'rb') as file:  
loaded_data = pickle.load(file)

print(loaded_data)    
</code>        
        </deserialization>
        <enums>
            *General-Programming-Knowledge*
            <green>Enums in Python:</green>
            <br></br><br></br>
            Enumerations in Python are implemented by using the module named 
            "enum".
            <br></br><br></br>
            Enumerations are created using classes. 
            Enums have names and values 
            associated with them.
            <br></br><br></br>
            Enums can be displayed as string or repr.<br></br>
            Enums can be checked for their types using type().<br></br>
            The "name" keyword is used to display the name of the enum
            member.
            <br></br>
<code>
#Example of enums in Python:

from enum import Enum
 
class Season(Enum):
    SPRING = 1
    SUMMER = 2
    AUTUMN = 3
    WINTER = 4

print(Season.SPRING)
print(Season.SPRING.name)
print(Season.SPRING.value)
print(type(Season.SPRING))
print(repr(Season.SPRING))
print(list(Season))
</code>
        </enums>
        <constructors>
            *General-Programming-Knowledge*
<code>
#Example of constructor in Python:

class Employee:
 
    #Constructor definition:
    def __init__(self):
        print('Employee created.')

#Instantiation:
obj = Employee()
del obj
</code>        
        </constructors>
        <instantiation>
            *General-Programming-Knowledge*
<code>
#Example of instantiation in Python: 

class Person:
    #Defining a constructor:
    def __init__(self, name, age):
        self.name = name
        self.age = age

#Instantiation:
person1 = Person("John", 25)

print(person1.name)
print(person1.age)
</code>        
        </instantiation>
        <destructors>
            *General-Programming-Knowledge*
<code>
#Example of destructor in Python:

class Employee:
 
    #Constructor definition:
    def __init__(self):
        print('Employee created.')
 
    #Destructor definition:
    def __del__(self):
        print('Destructor called, Employee deleted.')

#Instantiation:
obj = Employee()
del obj
</code>        
        </destructors>
        <function-overloading>
            *General-Programming-Knowledge*
            <br></br>
            <green>Function overloading in Python:</green>
            <br></br><br></br>
            In Python function overloading works different as compared to other 
            OOP programming
            languages: the methods can be overloaded but only the 
            latest defined method can be used.
            <br></br>
<code>
#Example of function overloading in Python:

#First product takes 2 arguments:
def product(a, b):
    p = a * b
    print(p)
 
#Second product method 3 arguments:
def product(a, b, c):
    p = a * b*c
    print(p)
 
#Uncommenting the below line shows an error
#product(4, 5)
 
 
#This line will call the second product method
product(4, 5, 5)
</code>
            <br></br>
            <green>Overloading behaviour in a single function:</green>
            <br></br><br></br>
            A method can be implemented in such a way that it responds differently
            based on the arguments passed to it. This will result in a behaviour
            which is similarly obtained via method overloading in other programming
            languages.
            <br></br>
<code>
#Example of efficient overloading
#behavior:

#Function to take multiple arguments
def add(datatype, *args):
 
    #if datatype is int
    #initialize answer as 0
    if datatype == 'int':
        answer = 0
 
    #if datatype is str
    #initialize answer as ''
    if datatype == 'str':
        answer = ''
 
    #Traverse through the arguments
    for x in args:
 
        #This will do addition if the
        #arguments are int. Or concatenation
        #if the arguments are str
        answer = answer + x
 
    print(answer)
 
 
#Integer
add('int', 5, 6)
 
#String
add('str', 'Hello ', 'Python')
</code>
            <br></br>
            <green>Overloading via decorator:</green>
            <br></br><br></br>
            Method overloading can also be achieved by using a decorator. 
            The method everloading via decorator allows using all the 
            defined versions of the method.
            <br></br>
<code>
#Overloading via decorator:

from multipledispatch import dispatch
#import dispatch

@dispatch(int, int)
def product(first, second):
    result = first*second
    print(result)
 
@dispatch(int, int, int)
def product(first, second, third):
    result = first * second * third
    print(result)
 
@dispatch(float, float, float)
def product(first, second, third):
    result = first * second * third
    print(result)
 
 
#calling product method with 2 arguments
product(2, 3)  
#the output will be 6
 
#calling product method with 3 arguments but all int
product(2, 3, 2)  
#the output will be 12
 
#calling product method with 3 arguments but all float
product(2.2, 3.4, 2.3)  
#the output will be 17.985999999999997
</code>
        </function-overloading>
        <operator-overloading>
            *General-Programming-Knowledge*
            <br></br>
<code>
#Example of operator overloading in Python:
 
class complex:
    def __init__(self, a, b):
        self.a = a
        self.b = b
 
     #overloading the + operator for addition:
    def __add__(self, other):
        return self.a + other.a, self.b + other.b
 
Ob1 = complex(1, 2)
Ob2 = complex(2, 3)

#Using the overloaded operator we can now
#perform addition on complex objects:
Ob3 = Ob1 + Ob2
print(Ob3)
</code>
        <br></br>
        <green>Python Operators for Overloading:</green>
        <br></br><br></br>
        Operator:<code>      </code>Magic Method:<br></br>
        <code>+             __add__(self, other)</code><br></br>
        <code>–             __sub__(self, other)</code><br></br>
        <code>*             __mul__(self, other)</code><br></br>
        <code>/             __truediv__(self, other)</code><br></br>
        <code>/</code><code>/            __floordiv__(self, other)</code><br></br>
        <code>%             __mod__(self, other)</code><br></br>
        <code>**            __pow__(self, other)</code><br></br>
        <code>&gt;&gt;            __rshift__(self, other)</code><br></br>
        <code>&lt;&lt;            __lshift__(self, other)</code><br></br>
        <code>&#38;             __and__(self, other)</code><br></br>
        <code>|             __or__(self, other)</code><br></br>
        <code>^             __xor__(self, other)</code><br></br>
        </operator-overloading>
        <concurrent-programming>
            *General-Programming-Knowledge*
            <br></br>
            <green>Multithreading in Python:</green>
            <br></br><br></br>
            In Python: multithreading is the action of executing tasks simultaneously 
            (in parallel) in order to increase the speed of execution.
            <br></br><br></br>
            <green>GIL or Global Interpreter Lock:</green>
            <br></br><br></br>
            Python Global Interpreter Lock or GIL is an important 
            part of multithreading programming. 
            <br></br><br></br>
            Python Global Interpreter Lock it's a mutex or a type 
            of process lock used when working with multiple processes. 
            It allows only one thread to hold the control of 
            the Python interpreter. 
            This means that only one thread can be in a state of 
            execution at any point in time. 
            <br></br><br></br>
            The impact of the GIL isn’t visible to developers who execute 
            single-threaded programs but it can be a performance bottleneck in 
            CPU-bound and multi-threaded code.
            <br></br><br></br>
            Python uses reference counting for memory management. 
            It means that 
            objects created in Python have a reference count variable that 
            keeps track of the number of references that point to the object. 
            <br></br>
            When this count reaches zero and no variable is referencing the 
            object stored in the heap memory, 
            the heap memory occupied by the object is released 
            (deallocated).
            <br></br><br></br>
            The problem was that this reference count variable needed protection 
            from race conditions where two threads increase or decrease 
            its value 
            simultaneously. If this happens, it can cause either leaked memory that 
            is never released or, even worse, incorrectly release of the
            the memory while a reference to that object still exists. 
            This can cause crashes or other "weird" bugs within the 
            Python programs.
            <br></br><br></br>
            <brown>GIL was introduced in order to fix these issues.</brown>
            <br></br><br></br>
            Generally, Python uses a single thread to run a single process.
            We get the same performance result of the single-threaded and 
            multithreading processes using the GIL. 
            It restricts achieving multithreading in Python because it prevents 
            the threads and works as a single thread.
            <br></br><br></br>
            <green>Python-related Multithreading Drawbacks:</green>
            <br></br><br></br>
            1. One GIL is used for all threads, and threads are limited by 
            GIL;
            <br></br><br></br>
            2. Multithreading has no effect for CPU-bound tasks due to 
            the GIL, 
            meaning we'll notice no improvements in the performance when it comes to these sort 
            of tasks;
            <br></br>
            CPU-bound tasks are those that require a significant amount of computational 
            resource.
            <br></br>
<code>
#Example of multithreading in Python 3:

import threading 
#used for threading

import time 
#used for time

def calculateSquare(numberList):
    for n in numberList:
        print(str(n) + " * " + str(n) + " = " + str(n*n))
        time.sleep(0.2) #this will add a 0.2 seconds delay

def calculateCube(numberList):
    for n in numberList:
        print(str(n) + " * " + str(n) + " * " + str(n) + " = " + str(n*n*n))
        time.sleep(0.2) #this will add a 0.2 seconds delay

#Creating a list:
numberList = [2,4,5,6,12,34]

#Creating threads:
thread1 = threading.Thread(target=calculateSquare, args =(numberList,))
thread2 = threading.Thread(target=calculateCube, args =(numberList,))

t_before = time.time() 
#this will get the time before starting the threads

calculateSquare(numberList)
calculateCube(numberList)
t_after = time.time()

print("Example 1: No threading - time for execution: " 
    + str(t_after-t_before) + " seconds.\n")

#The following thread example works as calling 
#the 2 functions without threading (similar to the example above),
#because the second thread needs to wait until the first thread 
#finishes its execution just like the functions in the example 
#above do.

#Get current time:
t1_before = time.time() # this will get the time before starting the threads
thread1.start()
thread1.join() 
#wait for the thread1 to finish its work.

thread2.start()
thread2.join() 
#wait for the thread2 to finish its work.
t1_after = time.time()

print("Example 2: Inefficient threading - time for execution: " 
        + str(t1_after-t1_before) + " seconds.\n")

#The following way is faster but printing is a mess 
#(because the 2 functions are executed in parallel).

#After finishing, the thread needs to be reinitialized.
#Reinintializing threads:
thread1 = threading.Thread(target=calculateSquare, args =(numberList,))
thread2 = threading.Thread(target=calculateCube, args =(numberList,))
t2_before = time.time() 
#this will get the time before starting the threads.

thread1.start()
thread2.start()
thread1.join() 
#wait for the thread1 to finish its work.

thread2.join() 
#wait for the thread2 to finish its work.

t2_after = time.time()
print("Example 3: Good threading - time for execution: " 
    + str(t2_after-t2_before) + " seconds.")

input("\nPress any key to exit: ")
</code>
            <br></br>
            <green>Multiprocessing in Python:</green>
            <br></br><br></br>
            By using multiprocessing in Python the 
            Global Interpreter Lock limitations can be overcome.
            <br></br><br></br>
            Multiprocessing refers to the ability of a system to support more than 
            one processor at the same time. Applications in a multiprocessing system 
            are broken to smaller routines that run independently. The operating system 
            allocates these threads to the processor cores improving the performance 
            of the system.
            <br></br><br></br>
            The <code>Pool class</code> in Python's multiprocessing module provides 
            convenient means of managing a pool of worker processes. It comes with 
            built-in methods that offer structured ways to distribute tasks 
            among these processes.
            <br></br><br></br>
            The <code>Pool class</code> represents a pool of worker processes. It has 
            methods which allows 
            tasks to be offloaded/distributed to the worker cores/processes 
            in few different ways. 
            <br></br>
<code>
#Example of multiprocessing in Python 3:

import multiprocessing 
#used for multiprocessing

import time 
#used for time

def PrintHello():
    i=0
    while(i&lt;50):
        print("Hello " + str(i))
        time.sleep(0.2)
        i+=1

def PrintHi():
    i=0
    while(i&lt;50):
        print("Hi " + str(i))
        time.sleep(0.2)
        i+=1

#Functions used with ".pool and .map" needs 
#to take an extra argument

#The Python Multiprocessing Pool provides 
#reusable worker processes in Python.

def Funct(n):
    i=0
    while(i&lt;50):
        print("Hello " + str(i))
        time.sleep(0.2)
        i+=1

#If the script is being ran standalone:
if __name__ == "__main__":
    t_before = time.time()
    p1 = multiprocessing.Process(target=PrintHello, args=())
    p2 = multiprocessing.Process(target=PrintHi, args=())
    p1.start()
    p2.start()
    p1.join() 
    #wait for the process to finish
    
    p2.join() 
    #Wait for the process to finish
    t_after = time.time()
    print("Example 1. Time for execution: " + str(t_after - t_before))
    
    #Executing single process:
    t_before = time.time()
    p1 = multiprocessing.Process(target=PrintHello, args=())
    p1.start()
    p1.join() 
    #wait for the process to finish
    
    t_after = time.time()
    print("Example 2: Without Pooling and Mapping - time for execution: " 
            + str(t_after - t_before))
    
    #Pooling and mapping processes:
    #Functions used for "pooling and mapping" needs to 
    #take an extra argument for
    #iteration (how many times to run the same function).
    
    t_before = time.time()
    p1 = multiprocessing.Pool()
    p1.map(Funct, range(1)) 
    #run this function for 1 time.
    
    #The extra argument specifies how many times the 
    #function should be runned.
    t_after = time.time()
    print("Example 2: With Pooling and Mapping - time for execution: " 
        + str(t_after - t_before))
    
    input("Press any key to quit.")
</code>        
        </concurrent-programming>
        <namespaces>
            *General-Programming-Knowledge*
            <br></br>
            <green>Namespaces in Python:</green>
            <br></br><br></br>
            Python namespaces are collections of different 
            objects that are associated with 
            unique names whose lifespan depends on the scope of a variable.
            <br></br>
            A variable is only available from inside the region it is created. 
            This is called scope.
            <br></br><br></br>
            The scope is a 
            region from where we can access a particular object.
            <br></br><br></br>
            There are three levels 
            of scopes: built-in (outermost), 
            global, and local.
            <br></br><br></br>
            <brown>Built-in scope:</brown>
            <br></br><br></br>
            The built-in scope is automatically loaded by Python when you run a 
            program or script. 
            It contains names that are built into Python, such as 
            keywords, functions, exceptions, 
            and other attributes. 
            <br></br><br></br>
            <brown>Global scope:</brown>
            <br></br><br></br>
            A variable created in the main body of the Python 
            code is a global variable and belongs to the global scope.
            Global variables are available from within any scope, 
            global and local.
            The global keyword makes the variable global.
            <br></br><br></br>
            <brown>Local scope:</brown>
            <br></br><br></br>
            A variable created inside a function belongs to the local scope 
            of that function, and can only be used inside that function.
            The nonlocal keyword is used to work with variables 
            inside nested functions. A nested function is a function defined within a function.
            <br></br><br></br>
            The nonlocal keyword makes the variable belong to the outer function.
            <br></br><br></br>
            Variables are names (identifiers) that map to objects. 
            A namespace is a dictionary of variable names (keys)
            and their corresponding objects (values).
            <br></br><br></br>
            A Python statement can access variables in a 
            local namespace and in the global namespace. 
            If a local and a global variable have the same name,
            the local variable shadows the global variable.
            <br></br><br></br>
            Python makes educated guesses on whether variables are 
            local or global. It assumes that any variable assigned 
            with a value within a function is local.
            Therefore, in order to assign a value to a global variable 
            within a function, you must first use the global specifier.
            <br></br><br></br>
            Within Python namespaces and scopes are in a tight relationship. 
            For example: 
            the global namespace can be seen as a collection of global variables 
            which have 
            global scope, meaning they can be accessed from anywhere in the program. 
            The global
            namespace contains local namespaces for each function/method/loop an 
            other entities
            defining local scopes.
            <br></br><br></br>
            Scope refers to the coding region from which a particular Python object 
            is accessible. 
            <br></br>
<code>
#Example of namespace and scopes in Python:

#var1 is in the global namespace
#meaning var1 has global scope:
var1 = 5

def some_func():
 
    #var2 is in the local namespace 
    #meaning var1 has local scope:
    var2 = 6
    
    def some_inner_func():
 
        #var3 is in the nested local namespace
        #meaning var3 has nested local scope:
        var3 = 7
</code>
        </namespaces>
        <exception-handling>
            *General-Programming-Knowledge*
            <br></br>
            <green>Exception handling in Python:</green>
            <br></br><br></br>
            An exception is an event, which occurs during the execution of a program 
            that disrupts the normal flow of the program's
            instructions. In general, when a Python script encounters a situation 
            that it cannot cope with, it raises an exception.
            <br></br><br></br>
            An exception is a Python object that represents an error.
            <br></br>
<code>
#Example of exception handling 
#in Python:

#Handling exceptions:
#Example 1:
try:
    fh = open("file.txt", "a")
    fh.write("This line was added by Python Program.")
except IOError:
    print ("Error: can't find file or read \
        data from {0}" .format(fh.name))
else:
    print ("Written content in the file successfully!")
    fh.close()

#Example 2:
try:
    fh = open("file.txt", "r")
    fh.read(12)
except IOError:
    print ("Error: can\'t find file or read data \
        from {0}" .format(fh.name))
finally:
    print ("Not working!")


#Raising an exception:
level=1
if level &lt; 1:
      raise Exception('level &lt; 1')

#Creating user-defined exception:
#Example 3:
class MyError(Exception):
     def __init__(self, value):
         self.value = value
     def __str__(self):
         return repr(self.value)

#Catching user-defined exceptions:
try:
    raise MyError(2*2)
except MyError as e:
     print ("My exception occurred, value: \
        {0}" .format (e.value))

input("\nPress any key to exit: ")
</code>
            <br></br>
            <green>Python Exceptions:</green>
            <br></br><br></br>
            <code>Exception</code><br></br>
            Base class for all exceptions.
            <br></br><br></br>
            <code>StopIteration</code><br></br>
            Raised when the <code>next()</code> method of an iterator does not 
            point to any object.
            <br></br><br></br>
            <code>SystemExit</code><br></br>
            Raised by the <code>sys.exit()</code> function.
            <br></br><br></br>
            <code>StandardError</code><br></br>
            Base class for all built-in exceptions except <code>StopIteration</code> 
            and <code>SystemExit</code>.
            <br></br><br></br>
            <code>ArithmeticError</code><br></br>
            Base class for all errors that occur for numeric calculation.
            <br></br><br></br>
            <code>OverflowError</code><br></br>
            Raised when a calculation exceeds maximum limit for a numeric type.
            <br></br><br></br>
            <code>FloatingPointError</code><br></br>
            Raised when a floating point calculation fails.
            <br></br><br></br>
            <code>ZeroDivisionError</code><br></br>
            Raised when division or modulo by zero takes place for all numeric types.
            <br></br><br></br>
            <code>AssertionError</code><br></br>
            Raised in case of failure of the Assert statement.
            <br></br><br></br>
            <code>AttributeError</code><br></br>
            Raised in case of failure of attribute reference or assignment.
            <br></br><br></br>
            <code>EOFError</code><br></br>
            Raised when there is no input from either the <code>raw_input()</code> or 
            <code>input()</code> function and the end of file is reached.
            <br></br><br></br>
            <code>ImportError</code><br></br>
            Raised when an import statement fails.
            <br></br><br></br>
            <code>KeyboardInterrupt</code><br></br>
            Raised when the user interrupts program execution, usually by pressing 
            Ctrl+C.
            <br></br><br></br>
            <code>LookupError</code><br></br>
            Base class for all lookup errors.
            <br></br><br></br>
            <code>IndexError</code><br></br>
            Raised when an index is not found in a sequence.
            <br></br><br></br>
            <code>KeyError</code><br></br>
            Raised when the specified key is not found in the dictionary.
            <br></br><br></br>
            <code>NameError</code><br></br>
            Raised when an identifier is not found in the local or global namespace.
            <br></br><br></br>
            <code>UnboundLocalError</code><br></br>
            Raised when trying to access a local variable in a function or method but 
            no value has been assigned to it.
            <br></br><br></br>
            <code>EnvironmentError</code><br></br>
            Same as above
            <br></br><br></br>
            <code>IOError</code><br></br>
            Raised when an input/output operation fails, such as the print 
            statement or the <code>open()</code> function when trying to open
            a file that does not exist.
            <br></br><br></br>
            <code>IOError</code><br></br>
            Same as above.
            <br></br><br></br>
            <code>SyntaxError</code><br></br>
            Raised when there is an error in Python syntax.
            <br></br><br></br>
            <code>IndentationError</code><br></br>
            Raised when indentation is not specified properly.
            <br></br><br></br>
            <code>SystemError</code><br></br>
            Raised when the interpreter finds an internal problem, but when 
            this error is encountered the Python interpreter does not exit.
            <br></br><br></br>
            <code>SystemExit</code><br></br>
            Raised when Python interpreter is quit by using the <code>sys.exit()</code> 
            function. If not handled in the code, causes the interpreter to exit.
            <br></br><br></br>
            <code>TypeError</code><br></br>
            Raised when an operation or function is attempted that is invalid 
            for the specified data type.
            <br></br><br></br>
            <code>ValueError</code><br></br>
            Raised when the built-in function for a data type has the valid 
            type of arguments, but the arguments have invalid values specified.
            <br></br><br></br>
            <code>RuntimeError</code><br></br>
            Raised when a generated error does not fall into any category.
            <br></br><br></br>
            <code>NotImplementedError</code><br></br>
            Raised when an abstract method that needs to be implemented in an 
            inherited class is not actually implemented.
            <br></br>
        </exception-handling>
        <bitwise-operators>
            *General-Programming-Knowledge*
            <br></br>
            <brown>Python bitwise operators work only on integers.</brown>
            <br></br>
<code>
#Example of using bitwise 
#operators in Python:

a=60
b=13

print ("a:",a, "b:",b, "a&#38;b:",a&#38;b)
print ("a:",a, "b:",b, "a|b:",a|b)
print ("a:", bin(a))
print ("b:", bin(b))

#OUTPUT:
#a: 60 b: 13 a&#38;b: 12
#a: 60 b: 13 a|b: 61
#a: 0b111100
#b: 0b1101
</code>
        </bitwise-operators>
        <default-parameters>
            *General-Programming-Knowledge*
            <br></br>
<code>
#Example of default arguments/parameters
#in Python:

#Function with one default argument:
def PrintFunct (str="Default argument"):
    print(str)
    return

print("This is PrintFunct: {0}" .format(PrintFunct()))
#The function PrintFunct() from the print above 
#is called using default argument (no value is passed).


#when a function that uses more default arguments,
#the variable name can be used to specify in
#which variable the passed value should be stored.

def PrintFunct2 (str="Default argument", str2="Default argument2"):
    print("{0} + {1}" .format(str, str2))
    return

print("Calling PrintFunct2: ")
PrintFunct2(str="First String")
</code>        
        </default-parameters>
        <interfaces>
            *General-Programming-Knowledge*
<code>
#Example of interface in Python:

class PdfParser(TextExtractor):  
      
    #This PdfParser will act as an interface
    def load_data_source(self, path: str, file_name: str) -> str:  
        #pass keyword specified that the  
        #implementation will be added at later stage 
        pass  
  
    def extract_text(self, file_path):  
        #pass keyword specified that the  
        #implementation will be added at later stage
        pass  
  
class EmlParser(TextExtractor):  
     
    #This EmlParser will also act as an interface
    def load_data_source(self, path: str, file_name: str) -> str:  
        #pass keyword specified that the  
        #implementation will be added at later stage
        pass  
    
    def extract_email_text(self, file_path):  
        #pass keyword specified that the  
        #implementation will be added at later stage
        pass  

#the implementation in both interfaces will be added
#at a later stage.
</code>
        </interfaces>
        <random-generators>
            *General-Programming-Knowledge*
<code>
#Example of random generator in Python:

from random import randint

def RandomGenerator():
    #Getting a random number between 0 and 100
    choice = randint(0, 100)
    #Printing the choice:
    print("The random number is: " + str(choice))

#Calling the function:
RandomGenerator()

input("Press any key to quit.")
</code>
        </random-generators>
        <command-line-arguments>
            *General-Programming-Knowledge*
            <br></br>
            <green>Command line arguments in Python:</green>
            <br></br><br></br>
            In Python: the <code>sys</code> module provides functions and variables 
            used to manipulate different parts of the Python Runtime Environment. 
            <br></br><br></br>
            This module also provides access to some variables used or maintained by the 
            Python Interpreter that allows direct interaction with it.
            <br></br><br></br>
            One such variable is <code>sys.argv</code> which is a list
            storing the name of the script file and the command line arguments:
            <br></br>
            - <code>len(sys.argv)</code> provides the number of command line arguments.
            <br></br>
            - <code>sys.argv[0]</code> is the name of the current Python script. 
            <br></br>
<code>
#Example of working with command line
#arguments in Python:

import sys

#when the script is being ran from this file do this, 
#otherwise it means the file was imported by other 
#module and the statements in here should be ignored.

if __name__ == "__main__":
    #there is always gonna be at least one element in 
    #sys.argv array. At index 0 is always stored the name 
    #of the file.
    if len(sys.argv) > 1: 
        print ("The script has the name "  + str(sys.argv[0]))
        print ("The arguments which were passed are: " + str(sys.argv[1:]))
</code>        
        </command-line-arguments>
        <ternary-operator>
            *General-Programming-Knowledge*
            <green>Ternary operator in Python:</green>
            <br></br><br></br>
            Python modifies the syntax for using ternary operator by adding 
            keywords instead
            of operators. This increases readability:<br></br>
            <code>?</code> operator is replaced by <code>if</code> keyword;<br></br>
            <code>:</code> operator is replaced by <code>else</code> keyword;<br></br>
<code>
#Example of ternary operator in Python:

a = 10
b = 20

#ternary operator
min = "a is minimum" if a &lt; b else "b is minimum"

print(min)
</code>
        </ternary-operator>
        <modular-programming>
            *General-Programming-Knowledge*
<code>
#Example of modular programming in Python:
#FILE: module_with_functions.py

#This is a module (any .py file can be a module).

#These are the functions:
def print_func( par ):
   print ("Hello : {0} " .format(par))
   return

def CalculateSum (*Args):
    sum=0
    for item in Args:
        sum+=item
    return sum
</code>        

<code>
#Example of modular programming in Python:
#FILE: file_working.py

#The next line will set the filepath:
PYTHONPATH=r'C:\Users\Black2\Desktop\python\modular programming in python'

#The next line will import a specific module:
import module_with_functions

#Calling a function from the imported the module:
module_with_functions.print_func("Hello")

print("Sum of {0} and {1} is: {2}" .format(4,10, \
    module_with_functions.CalculateSum(4,10)))

#There is possible to import a single function 
#from the whole module by using the following syntax:
from module_with_functions import print_func

#The effect is here: the fuction can be called without 
#mentioning the module, whereas in the example above it couldn't.
print_func("Python")

#The following syntax will import anything 
#from the mentioned module:
from module_with_functions import *

print("{0}+{1}={2}" .format(3,4,CalculateSum(3,4)))
#Once again there was no need of mentioning 
#the module name when calling for CalculateSum()

input("\nPress any key to exit: ")
</code>
        </modular-programming>
        <string-methods>
            <green>String methods in Python:</green>
            <br></br><br></br>
            Python has a set of built-in methods that you can use on strings.
            <br></br><br></br>
            All string methods returns new values. They do not change
            the original string.
            <br></br><br></br>
            <code>capitalize()</code><br></br>
            Converts the first character to upper case.
            <br></br><br></br>
            <code>casefold()</code><br></br>
            Converts string into lower case.
            <br></br><br></br>
            <code>center()</code><br></br>
            Returns a centered string.
            <br></br><br></br>
            <code>count()</code><br></br>
            Returns the number of times a specified value occurs in a string.
            <br></br><br></br>
            <code>encode()</code><br></br>
            Returns an encoded version of the string.
            <br></br><br></br>
            <code>endswith()</code><br></br>
            Returns true if the string ends with the specified value.
            <br></br><br></br>
            <code>expandtabs()</code><br></br>
            Sets the tab size of the string.
            <br></br><br></br>
            <code>find()</code><br></br>
            Searches the string for a specified value and returns the position 
            of where it was found.
            <br></br><br></br>
            <code>format()</code><br></br>
            Formats specified values in a string.
            <br></br><br></br>
            <code>format_map()</code><br></br>
            Formats specified values in a string.
            <br></br><br></br>
            <code>index()</code><br></br>
            Searches the string for a specified value and returns the position 
            of where it was found.
            <br></br><br></br>
            <code>salnum()</code><br></br>
            Returns True if all characters in the string are alphanumeric.
            <br></br><br></br>
            <code>salpha()</code><br></br>
            Returns True if all characters in the string are in the alphabet.
            <br></br><br></br>
            <code>isascii()</code><br></br>
            Returns True if all characters in the string are ascii characters.
            <br></br><br></br>
            <code>isdecimal()</code><br></br>
            Returns True if all characters in the string are decimals.
            <br></br><br></br>
            <code>isdigit()</code><br></br>
            Returns True if all characters in the string are digits.
            <br></br><br></br>
            <code>isidentifier()</code><br></br>
            Returns True if the string is an identifier.
            <br></br><br></br>
            <code>islower()</code><br></br>
            Returns True if all characters in the string are lower case.
            <br></br><br></br>
            <code>isnumeric()</code><br></br>
            Returns True if all characters in the string are numeric.
            <br></br><br></br>
            <code>isprintable()</code><br></br>
            Returns True if all characters in the string are printable.
            <br></br><br></br>
            <code>isspace()</code><br></br>
            Returns True if all characters in the string are whitespaces.
            <br></br><br></br>
            <code>istitle()</code><br></br>
            Returns True if the string follows the rules of a title.
            <br></br><br></br>
            <code>isupper()</code><br></br>
            Returns True if all characters in the string are upper case.
            <br></br><br></br>
            <code>join()</code><br></br>
            Converts the elements of an iterable into a string.
            <br></br><br></br>
            <code>ljust()</code><br></br>
            Returns a left justified version of the string.
            <br></br><br></br>
            <code>lower()</code><br></br>
            Converts a string into lower case.
            <br></br><br></br>
            <code>lstrip()</code><br></br>
            Returns a left trim version of the string.
            <br></br><br></br>
            <code>maketrans()</code><br></br>
            Returns a translation table to be used in translations.
            <br></br><br></br>
            <code>partition()</code><br></br>
            Returns a tuple where the string is parted into three parts.
            <br></br><br></br>
            <code>replace()</code><br></br>
            Returns a string where a specified value is replaced with a specified value.
            <br></br><br></br>
            <code>rfind()</code><br></br>
            Searches the string for a specified value and returns the last position of 
            where it was found.
            <br></br><br></br>
            <code>rindex()</code><br></br>
            Searches the string for a specified value and returns the last 
            position of where it was found.
            <br></br><br></br>
            <code>rjust()</code><br></br>
            Returns a right justified version of the string.
            <br></br><br></br>
            <code>rpartition()</code><br></br>
            Returns a tuple where the string is parted into three parts.
            <br></br><br></br>
            <code>rsplit()</code><br></br>
            Splits the string at the specified separator, and returns a list.
            <br></br><br></br>
            <code>rstrip()</code><br></br>
            Returns a right trim version of the string.
            <br></br><br></br>
            <code>split()</code><br></br>
            Splits the string at the specified separator, and returns a list.
            <br></br><br></br>
            <code>splitlines()</code><br></br>
            Splits the string at line breaks and returns a list.
            <br></br><br></br>
            <code>startswith()</code><br></br>
            Returns true if the string starts with the specified value.
            <br></br><br></br>
            <code>strip()</code><br></br>
            Returns a trimmed version of the string.
            <br></br><br></br>
            <code>swapcase()</code><br></br>
            Swaps cases, lower case becomes upper case and vice versa.
            <br></br><br></br>
            <code>title()</code><br></br>
            Converts the first character of each word to upper case.
            <br></br><br></br>
            <code>translate()</code><br></br>
            Returns a translated string.
            <br></br><br></br>
            <code>upper()</code><br></br>
            Returns a string into upper case.
            <br></br><br></br>
            <code>zfill()</code><br></br>
            Fills the string with a specified number of 0 values at the beginning.
            <br></br>
        </string-methods>
        <datatype-conversions>
            *General-Programming-Knowledge*
<code>
#Converting integers to float:

# initializing string
s = "10010"
 
# printing string converting to int base 2
c = int(s,2)
print ("After converting to integer base 2 : ", end="")
print (c)
 
# printing string converting to float
e = float(s)
print ("After converting to float : ", end="")
print (e)
</code>

<code>
#Type conversion using hex(), ord(), orct():

#initializing integer
s = '4'

#printing character converting to integer
c = ord(s)
print ("After converting character to integer : ",end="")
print (c)

#printing integer converting to hexadecimal string
c = hex(56)
print ("After converting 56 to hexadecimal string : ",end="")
print (c)

#printing integer converting to octal string
c = oct(56)
print ("After converting 56 to octal string : ",end="")
print (c)
</code>

<code>
#Type conversion using tuple(), set(), list():

# initializing string
s = 'python'
 
# printing string converting to tuple
c = tuple(s)
print ("After converting string to tuple : ",end="")
print (c)
 
# printing string converting to set
c = set(s)
print ("After converting string to set : ",end="")
print (c)
 
# printing string converting to list
c = list(s)
print ("After converting string to list : ",end="")
print (c)
</code>
        </datatype-conversions>
        <decorators>
            *General-Programming-Knowledge*
<code>
#Example of decorators in Python:

import time

def measure_time(fct):
    if hasattr(fct, 'call_number') == False:
        fct.call_number = 1
        fct.call_time = 0
    
    print("Decorator call.")
    def proxy():
        print("Proxy call.")
        t = time.time()
        fct()
        fct.call_time += time.time() - t
        print("Function " + str(fct.__name__) + " : has executed within : " + str(time.time() - t))
        print("Function calls " + str(fct.call_number))
        print("Average duration: " + str(fct.call_time / fct.call_number))
        fct.call_number += 1
    return proxy


#measure_time it's a decorator. 

@measure_time #this is equivalent to function = measure_time(function)
def function():
    time.sleep(0.5)
    print("the function is executing.")

function()
function()
function()
function()
function()
</code>        
        </decorators>
        <optional-parameters>*General-Programming-Knowledge*</optional-parameters>
        <operators>*General-Programming-Knowledge*</operators>
        <abstract-classes>
            *General-Programming-Knowledge*
<code>
#Example of abstract classes and methods
#in Python:

#FILE: program19 abstract classes and static functions.py

from p19_abs_class import PUNCT as abstract, PUNCT

#p = PUNCT()
#instantiation cannot be done on abstract classes

class LINE(PUNCT):
    def abstract_method(self): 
        #providing definition for abstract parent method
        print("Abstract method is now redefined")

    #creating static methods:
    #the following method will be static. 
    #Static methods are shared amongst all instances.
    @staticmethod 
    def staticMe(): 
        #static methods don't take self as argument
        print("\nThis is a static method\nAll " + \
            "instances of the class share same method")

l = LINE()

l.abstract_method()
l.staticMe()
#static methods can be invoked only with the class name

LINE.staticMe()

input("\nPress ENTER to exit.")
</code>

<code>
#Example of abstract classes and methods
#in Python:

#FILE: p19_abs_class.py

from abc import abstractmethod, ABC  
#importing this to be able to create 
#abstact methods

class PUNCT(ABC): #PUNCT will be abstract
    #constructor
    def __init__(self):
        self.x=0 #non-static field
        self.y=0 #non-static field

    #the following decorator will make 
    #the following method abstract:
    @abstractmethod 
    def abstract_method(self):
        pass 
        #pass means implementation 
        #will to be provided later
</code>
        </abstract-classes>
        <pre-post-incrementation>
            In Python, the <code>++</code> increment operator does not exist.
            <br></br>
            In order to increment a variable <code>+=</code> operator is being used.
            <br></br>
<code>
#Example of incrementing in Python:

#Initializing a variable 
x = 5
  
#Incrementing the variable by 1 
#Equivalent to x = x + 1 
x += 1 
  
#Displaying the result 
print("Incremented value:", x) 
</code>
        </pre-post-incrementation>
        <regular-expressions>
            A regular expression is a special sequence of characters that helps 
            matching or finding other strings or sets of 
            strings, using a specialized syntax held in a pattern.
            <br></br><br></br>
            <green>Regular expressions in Python:</green>
            <br></br><br></br>
            The re module offers a set of functions that allow working with 
            regular expressions:
            <br></br><br></br>
            The <code>match()</code> function attempts to match RE (Regular Expression) 
            pattern to string with optional flags.
            <br></br>
            It returns a match object on success, 
            <code>None</code> on failure. 
            <br></br>
            The <code>search()</code> function searches for first occurrence of 
            RE pattern within string with optional flags.
            <br></br>
            The <code>match()</code> checks for a match only at the beginning of the string, while 
            <code>search()</code> checks for a match anywhere in the string.
            <br></br>
            The <code>sub()</code> function replaces all occurrences of the pattern in the 
            string with <code>repl</code>.
            <br></br><br></br>
            <brown>The match() function:</brown>
            <br></br><br></br>
            Syntax: <code>re.match(pattern, string, flags=0)</code> where:
            <br></br><br></br>
            <code>pattern</code><br></br>
            This is the regular expression to be matched.
            <br></br><br></br>
            <code>string</code><br></br>
            This is the string, which would be searched to match the pattern 
            at the beginning of string.
            <br></br><br></br>
            <code>flags</code><br></br>
            You can specify different flags using bitwise OR (<code>|</code>). 
            <br></br><br></br>
            <brown>The sub() function:</brown>
            <br></br><br></br>
            Syntax: <code>re.sub(pattern, repl, string, count=0, flags=0)</code> where:
            <br></br><br></br>
            <code>pattern</code><br></br>
            Denotes the string/pattern that needs to be replaced.
            <br></br><br></br>
            <code>repl</code><br></br>
            Denotes the string/pattern with which the pattern is replaced.
            <br></br><br></br>
            <code>string</code><br></br>
            Denotes the string on which the <code>re.sub()</code> operation will 
            be executed.
            <br></br><br></br>
            <code>count</code><br></br>
            Denotes the number of replacements that should occur.
            <br></br><br></br>
            <code>flags</code><br></br>
            Serves to modify the behavior of the regular expression operation.
            <br></br>
<code>
#Example of working with regular expresions
#in Python:

import re 
#This library is used for
#regular expressions (re)

line = "Cats are smarter than dogs"

matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I) 
#find something at the beginning of the string and 
#return a match object.

if matchObj:
   print ("matchObj.group() : {0}" .format(matchObj.group()))
   print ("matchObj.group(1) : {0}" .format (matchObj.group(1)))
   print ("matchObj.group(2) : {0}" .format(matchObj.group(2)))
else:
   print ("No match!!")

matchObj = re.match( "Cats", line, 0)
if matchObj:
   print ("matchObj.group() : {0}" .format(matchObj.group()))
   #print ("matchObj.group(1) : {0}" .format(matchObj.group(1)))
   #print ("matchObj.group(2) : {0}" .format(matchObj.group(2)))
else:
   print ("No match!!")

searchObj = re.search( r'dogs*', line, re.M|re.I) 
#re* -> Matches 0 or more occurrences of preceding expression.
if searchObj:
   print ("searchObj.group() : {0}" .format(searchObj.group()))
   #print ("searchObj.group(1) : {0}" .format (searchObj.group(1)))
   #print ("searchObj.group(2) : {0}" .format(searchObj.group(2)))
else:
   print ("No match!!")

phone = "2004-959-559"
#This is Phone Number"

#Delete Python-style comments
num = re.sub(r'#.*$', "", phone)
print ("Phone Num : {0}" .format(num))

#Remove anything other than digits
num = re.sub(r'\D', "", phone)    
print ("Phone Num : {0}" .format(num))

input("\nPress any key to exit: ")
</code>   
            <br></br>
            <green>Regular expressions available in Python:</green>
            <br></br><br></br>
            <code>^</code><code>           </code>
            Matches beginning of line.
            <br></br><br></br>
            <code>$</code><code>           </code>
            Matches end of line.
            <br></br><br></br>
            <code>.</code><code>           </code>
            Matches any single character except newline.
            Using <code>m</code> option allows it to match newline as well.
            <br></br><br></br>
            <code>[...]</code><code>       </code>
            Matches any single character in brackets.
            <br></br><br></br>
            <code>[^...]</code><code>      </code>
            Matches any single character not in brackets.
            <br></br><br></br>
            <code>re*</code><code>         </code>
            Matches 0 or more occurrences of preceding expression.
            <br></br><br></br>
            <code>re+</code><code>         </code>
            Matches 1 or more occurrence of preceding expression.
            <br></br><br></br>
            <code>re?</code><code>         </code>
            Matches 0 or 1 occurrence of preceding expression.
            <br></br><br></br>
            <code>re{ n}</code><code>      </code>
            Matches exactly <code>n</code> number of occurrences of preceding expression.
            <br></br><br></br>
            <code>re{ n,}</code><code>     </code>
            Matches <code>n</code> or more occurrences of preceding expression.
            <br></br><br></br>
            <code>re{ n, m}</code><code>   </code>
            Matches at least <code>n</code> and at most <code>m</code> occurrences 
            of preceding expression.
            <br></br><br></br>
            <code>a| b</code><code>        </code>
            Matches either <code>a</code> or <code>b</code>.
            <br></br><br></br>
            <code>(re)</code><code>        </code>
            Groups regular expressions and remembers matched text.
            <br></br><br></br>
            <code>(?imx)</code><code>      </code>
            Temporarily toggles on <code>i</code>, <code>m</code>, or <code>x</code> 
            options within a regular expression. 
            If in parentheses, only that area is affected.
            <br></br><br></br>
            <code>(?-imx)</code><code>     </code>
            Temporarily toggles off <code>i</code>, <code>m</code>, or <code>x</code>  options 
            within a regular expression. 
            If in parentheses, only that area is affected.
            <br></br><br></br>
            <code>(?: re)</code><code>     </code>
            Groups regular expressions without remembering matched text.
            <br></br><br></br>
            <code>(?imx: re)</code><code>  </code>
            Temporarily toggles on <code>i</code>, <code>m</code>, or <code>x</code> options 
            within parentheses.
            <br></br><br></br>
            <code>(?-imx: re)</code><code> </code>
            Temporarily toggles off <code>i</code>, <code>m</code>, or <code>x</code> options 
            within parentheses.
            <br></br><br></br>
            <code>(?</code><code>#</code><code>...)</code><code>      </code>Comment.
            <br></br><br></br>
            <code>(?= re)</code><code>     </code>
            Specifies position using a pattern. Doesn't have a range.
            <br></br><br></br>
            <code>(?! re)</code><code>     </code>
            Specifies position using pattern negation. Doesn't have a range.
            <br></br><br></br>
            <code>(?> re)</code><code>     </code>
            Matches independent pattern without backtracking.
            <br></br><br></br>
            <code>\w</code><code>          </code>
            Matches word characters.
            <br></br><br></br>
            <code>\W</code><code>          </code>
            Matches nonword characters.
            <br></br><br></br>
            <code>\s</code><code>          </code>
            Matches whitespace. Equivalent to <code>[\t\n\r\f]</code>.
            <br></br><br></br>
            <code>\S</code><code>          </code>
            Matches nonwhitespace.
            <br></br><br></br>
            <code>\d</code><code>          </code>
            Matches digits. Equivalent to <code>[0-9]</code>.
            <br></br><br></br>
            <code>\D</code><code>          </code>
            Matches nondigits.
            <br></br><br></br>
            <code>\A</code><code>          </code>
            Matches beginning of string.
            <br></br><br></br>
            <code>\Z</code><code>          </code>
            Matches end of string. If a newline exists, it matches just 
            before newline.
            <br></br><br></br>
            <code>\z</code><code>          </code>
            Matches end of string.
            <br></br><br></br>
            <code>\G</code><code>          </code>
            Matches point where last match finished.
            <br></br><br></br>
            <code>\b</code><code>          </code>
            Matches word boundaries when outside brackets. 
            Matches backspace <code>(0x08)</code> when inside brackets.
            <br></br><br></br>
            <code>\B</code><code>          </code>
            Matches nonword boundaries.
            <br></br><br></br>
            <code>\n</code>, <code>\t</code><code>       </code>
            Matches newlines, carriage returns, tabs, etc.
            <br></br><br></br>
            <code>\1...\9</code><code>     </code>
            Matches nth grouped subexpression.
            <br></br><br></br>
            <code>\10</code><code>         </code>
            Matches nth grouped subexpression if it matched already.
            Otherwise refers to the octal representation of a character code.
            <br></br><br></br>

            <brown>Option flags:</brown>
            <br></br><br></br>
            <code>re.I</code><code>      </code>
            Performs case-insensitive matching.
            <br></br><br></br>
            <code>re.L</code><code>      </code> Interprets words according to the current locale. 
            This interpretation affects the alphabetic group (<code>\w</code> and <code>\W</code>), 
            as well as word boundary behavior (<code>\b</code> and <code>\B</code>).
            <br></br><br></br>
            <code>re.M</code><code>      </code>
            Makes <code>$</code> match the end of a line (not just the end of the string).
            <br></br>
            Also makes <code>^</code> match the start of any line 
            (not just the start of the string).
            <br></br><br></br>
            <code>re.S</code><code>      </code>
            Makes a period (dot) match any character, including a newline.
            <br></br><br></br>
            <code>re.U</code><code>      </code>
            Interprets letters according to the Unicode character set. 
            This flag affects the behavior of <code>\w</code>, <code>\W</code>, 
            <code>\b</code>, <code>\B</code>.
            <br></br><br></br>
            <code>re.X</code><code>      </code>
            Permits "cuter" regular expression syntax. It ignores whitespace 
            (except inside a set <code>[]</code> or when escaped by a backslash) 
            and treats unescaped <code>#</code> as a comment marker.
            <br></br><br></br>

            <brown>Character classes:</brown>
            <br></br><br></br>
            <code>[Pp]ython</code><code>      </code>Match <code>"Python"</code> or 
            <code>"python"</code>.
            <br></br><br></br>
            <code>rub[ye]</code><code>        </code>Match <code>"ruby"</code> or 
            <code>"rube"</code>.
            <br></br><br></br>
            <code>[aeiou]</code><code>        </code>Match any one lowercase vowel.
            <br></br><br></br>
            <code>[0-9]</code><code>          </code>Match any digit - same as 
            <code>[0123456789]</code>.
            <br></br><br></br>
            <code>[a-z]</code><code>          </code>Match any lowercase ASCII letter.
            <br></br><br></br>
            <code>[A-Z]</code><code>          </code>Match any uppercase ASCII letter.
            <br></br><br></br>
            <code>[a-zA-Z0-9]</code><code>    </code>Match any of the above.
            <br></br><br></br>
            <code>[^aeiou]</code><code>       </code>Match anything other than a lowercase vowel.
            <br></br><br></br>
            <code>[^0-9]</code><code>         </code>Match anything other than a digit.
            <br></br><br></br>

            <brown>Special Character Classes:</brown>
            <br></br><br></br>
            <code>.</code><code>       </code>Match any character except newline.
            <br></br><br></br>
            <code>\d</code><code>      </code>Match a digit: <code>[0-9]</code>.
            <br></br><br></br>
            <code>\D</code><code>      </code>Match a nondigit: <code>[^0-9]</code>.
            <br></br><br></br>
            <code>\s</code><code>      </code>Match a whitespace character: <code>[ \t\r\n\f]</code>.
            <br></br><br></br>
            <code>\S</code><code>      </code>Match nonwhitespace: <code>[^ \t\r\n\f]</code>.
            <br></br><br></br>
            <code>\w</code><code>      </code>Match a single word character: <code>[A-Za-z0-9_]</code>.
            <br></br><br></br>
            <code>\W</code><code>      </code>Match a nonword character: <code>[^A-Za-z0-9_]</code>.
            <br></br><br></br>

            <brown>Repetition Cases:</brown>
            <br></br><br></br>
            <code>ruby?</code><code>      </code>Match <code>"rub"</code> or <code>"ruby"</code>: the 
            <code>y</code> is optional.
            <br></br><br></br>
            <code>ruby*</code><code>      </code>Match <code>"rub"</code> plus 0 or more 
            <code>y</code>'s.
            <br></br><br></br>
            <code>ruby+</code><code>      </code>Match <code>"rub"</code> plus 1 or more 
            <code>y</code>'s.
            <br></br><br></br>
            <code>\d{3}</code><code>      </code>Match exactly 3 digits.
            <br></br><br></br>
            <code>\d{3,}</code><code>     </code>Match 3 or more digits.
            <br></br><br></br>
            <code>\d{3,5}</code><code>    </code>Match 3, 4, or 5 digits.
            <br></br><br></br>
        </regular-expressions>
        <recursion>
            *General-Programming-Knowledge*
<code>
#Example of recursion in Python:

def try_recursion(k):
    if(k>0):
        result = k+try_recursion(k-1)
        print(result)
    
    else:
        result = 0
    return result

print("\n\nRecursion Example Results")
try_recursion(6)
</code>
        </recursion>
        <reflection>
            *General-Programming-Knowledge*
<code>
#Example of reflection in Python:

def reverse(sequence):  
    sequence_type = type(sequence)  
    empty_sequence = sequence_type()  
      
    if sequence == empty_sequence:  
        return empty_sequence  
      
    rest = reverse(sequence[1:])  
    first_sequence = sequence[0:1]  
      
    #Combine the result  
    final_result = rest + first_sequence 
      
    return final_result  
  
print(reverse([10, 20, 30, 40]))  
print(reverse("Reflection in Python"))  
</code>
        </reflection>
        <lambda-anonymous-functions>
            <green>Lambda/Anonymous Functions in Python:</green>
            <br></br><br></br>
            In Python the functions declared using the 
            lambda keyword are called anonymous 
            because they are declared with a no-name within in a single line.
            <br></br>
<code>
#Example of lambda/anonymous functions:

sum = lambda arg1, arg2: arg1 + arg2; 
</code>

        </lambda-anonymous-functions>
    </manifest>
    <manifest>
        <name>AutoSAR</name>
        <description>
            <green>What is an ECU?</green>
            <br></br><br></br>
            The ECU also known as the Electronic Control Unit or as some refer to as “Engine Control Units” (Electronic Control Unit 
            is actual correct term) is a computer within  a vehicle that controls how other components work.  In a nutshell it is a 
            computer with software installed and this software can be removed, changed, upgraded just like any other computer.
            <br></br><br></br>
            <img class="database_image" src="./website_resources/local/database/pictures/ecu.png" alt="ecu picture"></img>
            <br></br><br></br>
            It has input sensors where information about the car is sent back to the ECU and output sensors to send information 
            out to the components to tell them how to behave.  
            <br></br><br></br>
            If the car was a human, the ECU would be the brain, it has input 
            sensors (nerves) telling the brain information about where our parts of body are (for example if we are in an 
            uncomfortable position), but also has output sensors to tell the body what to do (for example moving our legs into a 
            more comfortable position). 
            <br></br><br></br>
            A concrete example of how an ECU operates in a vehicle would be controlling the fuelling into the engine.  
            The ECU would receive information about how much fuel is entering the chamber of the engine and will send out 
            instructions to reduce it or raise it if it senses it not currently at the correct flow. 
            <br></br><br></br>
            <green>What is AutoSAR?</green>
            <br></br><br></br>
            AUTOSAR is an open system architecture for automotive software development and provides standards for developing common 
            automotive software applications. It is a growing and evolving standard that defines a layered architecture for the software.
            <br></br><br></br>
            AUTOSAR (AUTomotive Open System ARchitecture) is primarily focused on the development of software architecture for 
            Electronic Control Units (ECUs),  but its applications extend beyond just ECUs. 
            <br></br><br></br>
            Here’s a breakdown of its uses:
            <br></br><br></br>
            <brown>ECUs:</brown>
            <br></br>
            The primary focus of AUTOSAR is to standardize the software architecture for ECUs, which are critical 
            components in vehicles that control various functions (like engine management, safety systems, etc).
            <br></br><br></br>
            <brown>Software Components:</brown>
            <br></br>
            AUTOSAR facilitates the development of reusable software components that can be integrated into different ECUs, 
            promoting interoperability among various manufacturers.
            <br></br><br></br>
            <brown>Vehicle Networks:</brown>
            <br></br>
            AUTOSAR also plays a role in defining communication protocols and standards for vehicle networks, allowing different 
            ECUs to communicate effectively.
            <br></br><br></br>
            <brown>Safety and Security:</brown>
            <br></br>
            It provides guidelines and frameworks for developing safety-critical systems, which are essential for modern vehicles, 
            especially with the rise of autonomous driving technologies.
            <br></br><br></br>
            <brown>Integration with Other Systems:</brown>
            <br></br>
            While its primary focus is on ECUs, AUTOSAR can also be integrated with other automotive systems, such as infotainment 
            and telematics, enhancing the overall vehicle architecture.
            <br></br><br></br>
            The classic AUTOSAR platform runs on a microcontroller and is divided into 3 main layers:
            
                <enum>Basic Software Architecture - It is common to any AUTOSAR ECU.</enum>
                <enum>AUTOSAR Runtime Environment</enum>
                <enum>Application Layer</enum>
            
            <br></br>
            <img class="database_image" src="./website_resources/local/database/pictures/autosar_architecture.png" alt="autosar_architecture"></img>
            <br></br><br></br>
            <green>Basic Software Architecture (BSW)</green>
            <br></br><br></br>
            Basic Software Architecture (BSW) is the lowest layer of 3 main layers. It is the layer in direct contact with the hardware part 
            (the microcontroller).
            <br></br><br></br>
            AUTOSAR Basic Software Architecture consists of hundreds of software modules structured in different sublayers (Services Layer, ECU Abstraction Layer, 
            Microcontroller Abstraction Layer, Complex Drivers, Operating System) and 
            it is common to any AUTOSAR ECU. This means the supplier who has designed BSW can share it with other suppliers that are 
            working on ECUs of engine, gearbox, etc.
            <br></br><br></br>
            <green>Runtime Environment Layer (RTE)</green>
            <br></br><br></br>
            AUTOSAR Runtime Environment is a middleware layer of the AUTOSAR software architecture between the BSW and the application 
            layer and provides communication services for the application software.
            <br></br><br></br>
            The purpose of RTE is to act as the middle-man between the software components. Example: if we have 2 software components 
            SWC A and SWC B, in order for SWC A to use some variables or functions from SWC B, the components SWC A it will have to connect 
            to the RTE which then will connect SWC A to SWC B through a series of interfaces for Reading/Writing.
            <br></br><br></br>
            Runtime Environment Layer (RTE) is an implementation based on the abstract concept of Virtual Function Bus (VFB).
            <br></br><br></br>
            The Virtual Function Bus (VFB) serves as a communication layer that allows different software components to 
            interact with each other 
            in a standardized way. It abstracts the underlying hardware and software complexities, enabling easier 
            integration and communication.
            <br></br><br></br>
            If SWC A and SWC B were two people trying to communicate, then RTE is their postman while VFB is their mailbox.
            This means VFB provides addresses which allows RTE to deliver the data to the right receiver. RTE handles
            sorting and routing ensuring that data travels the right way from one SWC to the other, and RTE also ensures that
            data arrives at the right time, in case of asynchronous functions. 
            <br></br><br></br>
            In case of asynchronous functions, once the function generates the data, it passes the data to the RTE, then the 
            RTE keeps the data stored until the receiver will come to collect it. 
            <br></br><br></br>
            In case of synchronous functions, once the function generates the data, it calls in for RTE API, which provides access 
            to the receiver, and the sender ensure that the receiver has the data when it becomes available.
            As an analogy, imagine that the sender calls in the RTE which is a cab, the RTE brings the sender to the receiver's destination
            then the RTE (cab) gives the key to the receivers house, and the sender enters the receivers house, and leaves the data, 
            then locks the door behind it, and it resumes its normal duties. 
            <br></br><br></br>
            The synchrounous SWCs causes blocking / delays because it has to do all this extra work. 
            <br></br><br></br>
            Several factors influence whether to use synchronous or asynchronous communication in SWCs:
            <br></br><br></br>
            <indigo>Timing Requirements:</indigo>
            <br></br>
            If the application requires immediate responses, synchronous communication is preferred.
            For less time-sensitive operations, asynchronous communication is more suitable.
            <br></br><br></br>
            <indigo>Data Dependency:</indigo>
            <br></br>
            If the sender's operation depends on the receiver's response, synchronous is necessary.
            If the operations can proceed independently, asynchronous is ideal.
            <br></br><br></br>
            <indigo>System Architecture:</indigo>
            <br></br>
            The overall design of the system and how components interact can dictate the choice.
            For example, in a multi-core environment, asynchronous communication can help manage load and improve 
            performance.
            <br></br><br></br>
            <indigo>Error Handling:</indigo>
            <br></br>
            Synchronous communication can simplify error handling since the sender waits for a response.
            Asynchronous communication may require more complex error management strategies.
            <br></br><br></br>
            <indigo>Performance Considerations:</indigo>
            <br></br>
            Synchronous calls can introduce delays, especially if the receiver is busy.
            Asynchronous calls can improve throughput by allowing multiple operations to occur simultaneously.
            <br></br><br></br>
            <green>Application Layer</green>
            <br></br><br></br>
            The application layer is the highest layer of the AUTOSAR software architecture and supports custom functionalities 
            implementation. This layer consists of the specific software components and many applications which perform specific 
            tasks as per instructions.
            <br></br><br></br>
            The AUTOSAR application layer consists of three components which are: application software components, ports of software 
            components, and port interfaces.
            <br></br><br></br>
            AUTOSAR ensures standardized interfaces for the software components within the application layer and these software 
            components help in generating simple applications to support the vehicle functions.
            <br></br><br></br>
            <brown>Virtual Function Bus (VFB)</brown>
            <br></br><br></br>
            Imagine a city with roads (VFB) connecting different buildings (SWCs). Each building has doorways (ports) that allow 
            people (data) to enter and exit. The doorways have specific rules (interfaces) about who can enter and what they can
            bring (data types). Connectors act as the pathways between doorways, allowing people to move between buildings.
            <br></br><br></br>
            The communication between the software components is enabled via specific ports using a Virtual Function Bus (VFB).
            <br></br>
            These ports facilitate communication between the software components within the Application Layer, between the 
            software components within the Basic Software Layer, and also across these 2 different layers together. This means
            you can connect from anywhere to anywhere.
            <br></br><br></br>
            The above-explained architecture of AUTOSAR is its classic platform, which supports real-time requirements and 
            safety constraints. Based on the microcontroller, the classic platform is capable of supporting applications in the 
            field of networking and security by allowing ECUs to access vehicle sensors and actuators.
        </description>
        <ecu-communication>
            ECUs are the brains behind various functions in vehicles, and they communicate through specific networks. 
            Modern vehicles can have over 100 ECUs, each responsible for different tasks, such as engine management, 
            transmission control, safety systems, and infotainment.
            <br></br><br></br>
            The communication through the ECU networks is performed primarily serial. 
            This means while 2 devices communicate, the others are waiting for the bus to get free (in recessive state).
            <br></br><br></br>
            While parallel communication can theoretically allow multiple devices to communicate simultaneously, it is less 
            common in automotive applications due to complexity and cost. Parallel communication requires more wires, 
            which can lead to increased weight and potential interference.
            <br></br><br></br>
            <indigo>Half-Duplex Communication:</indigo> Many serial communication systems, like CAN, operate in a 
            half-duplex mode, meaning that data can 
            flow in both directions, but not at the same time. This allows for efficient communication without the 
            need for multiple channels. 
            <br></br><br></br>
            This means that while one device is sending data, the other must wait until 
            the transmission is complete before it can respond or send its own data. CAN employs a unique bus arbitration 
            method to manage which device gets to send data when multiple devices want to communicate at the same time. 
            This is crucial for preventing data collisions.
            <br></br><br></br>
            <green>Broadcasting:</green>
            <br></br><br></br>
            When one ECU sends a message, all other ECUs on the bus can receive it, 
            allowing for efficient communication. Since all the data transmitted from the ECUs is available on the bus, the
            ECUs can be programmed to filter messages based on specific criteria, such as message identifiers. 
            This means they only process messages that are relevant to their function.
            <br></br><br></br>
            A PDU (Protocol Data Unit) is typically seen as a message in higher-level communication protocols, containing 
            the data and control information needed for a full communication exchange.
            In lower-level protocols like CAN, a PDU can be seen as the data part within a frame, but it’s still part of 
            the larger structure.
            <br></br><br></br>
            <green>Message Structure:</green>
            <br></br> <br></br>
            The data is transmitted by ECUs in the form of messages, which include:
            <br></br><br></br>
            <brown>Identifier:</brown> 
             <br></br>
            A message identifier is a unique identifier assigned to each message transmitted over the 
            network. It serves several important purposes:
            
            <enum><indigo>Priority Assignment:</indigo> The message identifier determines the priority of the message. 
            <br></br>
            In CAN networks, lower numerical values indicate higher priority. This means that if two messages are sent simultaneously, 
            the one with the lower identifier will take precedence.</enum>
            <enum><indigo>Message Routing:</indigo> The identifier helps in routing messages to the appropriate ECUs. 
            Each ECU can be programmed to listen for specific identifiers, ensuring that it only processes relevant messages.</enum>
            <enum><indigo>Data Association:</indigo> Each identifier is associated with specific data, source, and destination nodes. 
            This association allows ECUs to understand the context of the data being transmitted. 
            <br></br><br></br>
            The message identifier is used by ECUs to filter the messages from the bus. 
            If an ECU receives a message from the bus it will first check if the message is meant to be processed by its software or not.
            <br></br>
            If the message is not meant for the ECU which received it then it will be blocked by its network driver.
<code>
/*Example of ECU message filtering mechanism*/

#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdbool.h&gt;

// Define the CAN message structure
typedef struct 
{
    uint32_t id;      // Message ID
    uint8_t data[8];  // Data payload (data field)
} CAN_Message;

// Function to check if a message is intended for this ECU
bool isMessageForECU(CAN_Message *msg, uint32_t ecu_id) 
{
    // Check if the message ID matches the ECU's ID
    return (msg->id == ecu_id);
}

// Function to process incoming CAN messages
void processCANMessage(CAN_Message *msg, uint32_t ecu_id) 
{
    if (isMessageForECU(msg, ecu_id)) 
    {
        // Process the message
        printf("Processing message with ID: %u\n", msg->id);
        // Add your message handling logic here
    } 
    else 
    {
        // Block the message
        printf("Blocked message with ID: %u\n", msg->id);
    }
}

int main() 
{
    // Example ECU ID
    uint32_t ecu_id = 0x123;

    // Simulated incoming CAN messages
    CAN_Message incomingMessages[] = {
        {0x123, {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}},
        {0x456, {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}},
        {0x123, {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}},
    };

    // Process each incoming message
    for (int i = 0; i &lt; sizeof(incomingMessages) / sizeof(incomingMessages[0]); i++) 
    {
        processCANMessage(&#38;incomingMessages[i], ecu_id);
    }

    return 0;
}
</code>
            </enum>
            
            <br></br>
            <brown>Data Field:</brown> 
             <br></br>Contains the actual data being transmitted. It is also referred to as payload. The Data Field may contain 
             sensor data, control signals, status information, or any other type of 
             information that needs to be exchanged between ECUs. 
             <br></br><br></br>
             <indigo>Example:</indigo> within a PDU the actual data being transmitted is typically 
             given by a collection of signals.
            <br></br><br></br>
            <brown>Control Information:</brown> 
            <br></br>
            Helps manage the flow of data and ensures that messages are received correctly. 
            The control information consists of following elements:
            <br></br>
            
                <enum><indigo>Checksum/CRC:</indigo> A value used for error-checking to ensure the integrity of the data. 
                It helps verify that the message has not been corrupted during transmission.
                <br></br><br></br>
                Example of simple checksum calculation algorithm: 
                <br></br>
                <code>
/*Example 1: Simple Checksum Calculation
Here's a basic example of how to calculate a checksum for a data payload*/

#include &lt;stdint.h&gt;

uint8_t calculateChecksum(uint8_t* data, uint8_t length) 
{
    uint8_t checksum = 0;
    for (uint8_t i = 0; i &lt; length; i++) 
    {
        checksum += data[i]; // Sum all bytes
    }
    return checksum; // Return the checksum
}

//Example usage
uint8_t data[] = {0x01, 0x02, 0x03, 0x04};
uint8_t checksum = calculateChecksum(data, sizeof(data));
                </code>
                <br></br>
                <indigo>Checksum:</indigo> 
                <br></br>
                Primarily detects single-bit errors and is less effective at identifying multiple-bit errors.
                It may fail to detect errors if they cancel each other out (e.g., if two bits are flipped).
                <br></br><br></br>
                Example of simple CRC calculation algorithm: 
                <br></br>
                <code>
//Example 2: CRC Calculation
//For a more robust integrity check, you can use CRC. 
//Here’s a simple implementation of CRC-8:

#include &lt;stdint.h&gt;

uint8_t calculate_crc8(uint8_t* data, uint8_t length) 
{
    uint8_t crc = 0xFF; // Initial value 255 in decimal or 0b11111111 (8 bits of 1)
    
    //for each byte in data
    for (uint8_t i = 0; i &lt; length; i++) 
    {
        crc ^= data[i]; // XOR with the current byte
        
        //for each bit in CRC
        for (uint8_t j = 0; j &lt; 8; j++) 
        {
            //if MSB is 1
            if (crc &#38; 0b10000000) 
            {
                /*Complex calculations bit by bit for determining unique fingerprint CRC-8 for data*/
                
                crc = (crc &lt;&lt; 1) ^ 49; // CRC-8 calculation using CRC-8 polynomial
                
                //The value 0x31 (decimal 49) is crucial in CRC-8 calculations, 
                //and it represents the CRC-8 polynomial.
                
                //It processes each bit of the CRC value.
            } 
            else 
            {
                crc = crc &lt;&lt; 1;
            }
        }
    }
    
    //The CRC-8 algorithm is a mathematical process that generates a unique "fingerprint" for the data.
    //CRC-8 can be used for messages of any length.
    
    return crc; // Return the CRC value
}

// Example usage
uint8_t data[] = {(uint8_t)("H"), (uint8_t)("e"), (uint8_t)("l"), (uint8_t)("l"), (uint8_t)("o")}; //Actual message: 'Hello'

uint8_t crcValue = calculate_crc8(data, sizeof(data));
                </code>
                <br></br>
                <indigo>CRC-8 / CRC-16:</indigo> 
                <br></br>
                Can detect multiple-bit errors and is more robust against burst errors (where several bits are corrupted in a sequence).
                It can identify errors that a simple checksum might miss.
                
                    <enum><indigo>CRC-8:</indigo>  Suitable for detecting simple errors in short messages. 
                    It can handle single-bit errors and some burst errors but is less effective for longer data.
                    </enum>
                    <enum><indigo>CRC-16:</indigo> Offers a higher level of error detection, making it better for 
                    longer messages. It can detect more complex error patterns, including multiple-bit errors 
                    and longer burst errors. 
                    <br></br>
                    It takes slightly longer to compute compared to CRC-8 but provides a more robust error-checking 
                    mechanism, which is crucial for applications where data integrity is paramount.
                    </enum>
                
                <br></br>
                Example of Data Integrity Check within ECU:
                <br></br>
                <code>
#include &lt;stdint.h&gt;
#include &lt;stdbool.h&gt;

bool checkDataIntegrity(uint8_t* receivedData, uint8_t length, uint8_t expectedChecksum) 
{
    uint8_t calculatedChecksum = calculateChecksum(receivedData, length);
    return (calculatedChecksum == expectedChecksum); // Return true if valid
}

// Example usage
uint8_t receivedData[] = {0x01, 0x02, 0x03, 0x04};
uint8_t expectedChecksum = calculateChecksum(receivedData, sizeof(receivedData));
bool isDataValid = checkDataIntegrity(receivedData, sizeof(receivedData), expectedChecksum);
                </code>
                <br></br>
                <indigo>NOTE:</indigo> For ECUs (Electronic Control Units) to validate the Checksum / CRC (Cyclic Redundancy Check), 
                they need access to the same function or algorithm used for the their calculation.
                <br></br>
                Hence, In many automotive applications, CRC algorithms are standardized (like CRC-8, CRC-16, etc.), 
                ensuring that all ECUs in a system can communicate reliably. This standardization helps in maintaining 
                compatibility across different manufacturers and models.
                </enum>
                <enum><indigo>Control Flags:</indigo>
                Indicators that provide additional information about the message, such as whether it is 
                a request or a response, or if it contains critical data.
                </enum>
                <enum><indigo>Timestamp:</indigo>
                Information about when the message was sent, which can be crucial for time-sensitive operations.
                </enum>
                <enum><indigo>Sequence Number / Sequence Counter:</indigo> 
                    <enum><indigo>Sequence Counter:</indigo> This is a simple counter that increments with each message sent. 
                    It's primarily used to track the order of messages in a stream, but it doesn't necessarily 
                    guarantee that all messages are received.
                    <br></br><br></br>
                    Example of Sequence Counter Implementation:
                    <br></br>
                    <code>
#include &lt;stdint.h&gt;
#include &lt;stdbool.h&gt;

// Define CAN message structure
typedef struct 
{
    uint8_t id;  // Message ID
    uint8_t data[8]; // Data payload
    uint16_t sequenceNumber; // Sequence number
} CANMessage;

// Global variable for the sequence counter
uint16_t sequenceCounter = 0;

// Function to get the next sequence number
uint16_t getNextSequenceNumber() 
{
    return sequenceCounter++;
}

// Function to send a CAN message
void sendCANMessage(CANMessage message) 
{
    // Replace this with your actual CAN bus sending function
    // ... send message using CAN bus API ...
}

// Function to receive a CAN message
void receiveCANMessage() 
{
    // Replace this with your actual CAN bus receiving function
    // ... receive message using CAN bus API ...
}

// Function to validate the received sequence number
bool validateSequenceNumber(uint16_t receivedSequenceNumber) 
{
    if (receivedSequenceNumber == sequenceCounter) 
    {
        sequenceCounter++; // Increment for next message
        return true; // Valid sequence number
    } 
    else 
    {
        return false; // Invalid sequence number
    }
}

// Example usage
int main() 
{
    CANMessage message;
    message.id = 0x123; // Example message ID
    message.data[0] = 0x01; // Example data
    message.sequenceNumber = getNextSequenceNumber();

    // Send the message
    sendCANMessage(message);

    // Receive a message (replace with your actual CAN bus receiving function)
    CANMessage receivedMessage = receiveCANMessage();
    // ... receive message using CAN bus API ...

    // Validate the received sequence number
    bool isValid = validateSequenceNumber(receivedMessage.sequenceNumber);

    if (isValid) 
    {
        // Process the message
        // ... 
    } 
    else 
    {
        // Handle the error (e.g., resend request)
        // ...
    }

    return 0;
}
                    </code>
                    
                    </enum>
                    <enum>
                    <indigo>Sequence Number:</indigo> This is a more robust identifier that often incorporates additional 
                    logic to ensure the integrity of message order. It might use a combination of counter 
                    and other information to detect lost or out-of-order messages.
                    <br></br><br></br>
                    Example of Sequence Number with Validation
                    <br></br>
                    <code>
#include &lt;stdint.h&gt;
#include &lt;stdbool.h&gt;

// Global variable to store the expected sequence number
uint16_t expectedSequenceNumber = 0;

// Function to validate the received sequence number
bool validateSequenceNumber(uint16_t receivedSequenceNumber) 
{
    if (receivedSequenceNumber == expectedSequenceNumber) 
    {
        expectedSequenceNumber++; // Increment for next message
        return true; // Valid sequence number
    } 
    else 
    {
        return false; // Invalid sequence number
    }
}

// Example usage
uint16_t receivedSequenceNumber = 10; // Example received sequence number

bool isValid = validateSequenceNumber(receivedSequenceNumber);
if (isValid) 
{
    // Process the message
} 
else 
{
    // Handle the error (e.g., resend request)
}
                    </code>
                    </enum>
                
                </enum>
                <enum><indigo>Status Information:</indigo> Data that indicates the current state of the ECU or the system it controls, 
                such as error codes or operational status.
                </enum>
                <enum><indigo>Priority Level:</indigo> Some messages may include a priority level to determine the urgency of the message, 
                which can affect how it is processed in a multi-ECU environment.
                </enum>
            
            <br></br>
        </ecu-communication>
        <ecu-networks>
            In a network: ECUs are connected through various data buses, allowing them to send and receive messages. 
            Each ECU can read data from the bus and respond accordingly. 
            <br></br><br></br>
            Various Sensors and Actuators are also connected 
            within the ECU Networks. The data can be transmitted and received amongst multiple ECUs or between an ECU and 
            various Sensors / Actuators. 
            <br></br><br></br>
            <indigo>Difference between Sensors and Actuators:</indigo>
            <br></br>
            Sensors are like the "eyes and ears" of a system. They detect and measure physical quantities from the environment.
            <br></br>
            Actuators are like the "muscles" of a system. They respond to signals from a control system by 
            producing physical motion or changing a physical state.
            <br></br><br></br>
            <green>Components of ECU Networks:</green>
            <br></br><br></br>
            <brown>Electronic Control Units (ECUs)</brown>
            <br></br>
            These are specialized computers that control different functions in a vehicle, such as engine management, transmission, 
            and safety systems.
            <br></br><br></br>
            <brown>Communication Protocols</brown>
            <br></br>
            ECUs communicate using various protocols, which define how data is transmitted. The most common protocols include:
            
                <enum><indigo>Controller Area Network (CAN):</indigo> A robust vehicle bus standard that allows ECUs to 
                communicate with each other without a host computer. It is designed for real-time applications where low latency is crucial.
                <br></br>
                CAN typically supports speeds up to 1 Mbps. 
                It is used for: fuel injection system, ignition system, emissions control, breaking system etc. 
                <br></br><br></br>
                The CAN bus enables quick and reliable sharing of information between the car's brakes and engine. 
                For instance, in anti-lock braking systems (ABS), the CAN protocol helps in coordinating 
                the braking force applied to each wheel.
                <br></br>
                CAN FD (Flexible Data-rate) enhances the capabilities of the traditional CAN protocol by allowing for 
                higher data rates and larger payloads.
                </enum>
                <enum><indigo>Ethernet:</indigo> supports much higher speeds, ranging from 100 Mbps to 10 Gbps and beyond, 
                making it suitable for high-bandwidth applications. Ethernet generally uses a star topology 
                and can support a more complex network structure with switches and routers.</enum>
                <enum><indigo>FlexRay:</indigo> A high-speed bus that supports time-triggered communication, often used in safety-critical applications. 
                Supports data rates of up to 10 Mbps. It utilizes a time-triggered communication method, allowing for deterministic 
                data transmission. This means that messages are sent at predefined times, ensuring reliability and synchronization.</enum>
                <enum><indigo>Local Interconnect Network (LIN):</indigo> A simpler, lower-cost network used for less critical functions. 
                <br></br>
                LIN, typically supports data rates up to 20 Kbps, 
                making it suitable for simpler applications where high speed is not critical such as: window lifts, seat adjustments, 
                and interior lighting. </enum>
                <enum><indigo>Media Oriented Systems Transport (MOST):</indigo> Primarily used for multimedia applications in vehicles, enabling high-speed data 
                transmission for audio, video, and other media content. It operates on a peer-to-peer basis, allowing multiple devices to 
                communicate simultaneously</enum>
            
            <br></br>
            <brown>Data Buses</brown>
            <br></br>
            All ECUs are connected to a single data line, known as a bus. This bus allows information to be transmitted between 
            ECUs. 
            <br></br>
            For example:
            In a CAN bus, messages are sent as packets, and each ECU can listen to the bus and respond to messages relevant to 
            its application.
            <br></br><br></br>
            <green>How Communication Works:</green>
            <br></br><br></br>
            <indigo>Message Transmission</indigo>
            <br></br>
            When an ECU needs to send data (like engine temperature), it creates a message and places it on the bus.
            Other ECUs on the network can read this message and respond accordingly.
            <br></br><br></br>
            <indigo>Priority and Arbitration</indigo>
            <br></br>
            In a CAN network, messages have different priorities. If two messages are sent simultaneously, 
            the one with the higher priority will be transmitted first.
            <br></br><br></br>
            <indigo>Error Handling</indigo>
            <br></br>
            ECU networks are designed with error detection and correction mechanisms to ensure reliable communication. 
            If a message is corrupted, the receiving ECU can request a retransmission.
            <br></br><br></br>
            <brown>Transmission of messages:</brown>
            <br></br><br></br>
            A message can also be formed from multiple frames, when the transmission of whole message is not possible. 
            <br></br>
            Example: In CAN (Controller Area Network), the standard frame format allows for a Data Field of only up to 8 bytes. 
            <br></br><br></br>
            A CAN Frame is an actual PDU/message for CAN protocol in AUTOSAR which consists of following:
            <br></br><br></br>
            <indigo>Identifier:</indigo> 11-bit or 29-bit ID (depending on standard or extended format).<br></br>
            <indigo>Control Field:</indigo> Data length code (DLC), which specifies the length of the Data Field.<br></br>
            <indigo>Data Field:</indigo> This can contain up to 8 bytes of actual data being transferred.<br></br>
            <indigo> CRC:</indigo> For error checking.<br></br>
            <indigo>Acknowledgment:</indigo> A signal confirming successful reception of the frame.
            <br></br><br></br>
            In this case: to send larger messages (i.e., PDUs larger than 8 bytes), the CAN protocol uses a mechanism known as 
            segmentation and reassembly. 
            <br></br><br></br>
            Larger PDUs (such as those needed for diagnostic messages or large data transfers) 
            can be sent by breaking the data into smaller chunks. These chunks are sent across multiple frames, 
            and the receiving ECU must reassemble the data back into the original message.
            <br></br><br></br>
            This segmentation and reassembly is typically done using higher-layer protocols like ISO-TP (ISO 15765-2) or 
            UDS (Unified Diagnostic Services), which define how the data is split into multiple frames.
            <br></br><br></br>
            <brown>Steps for Segmentation and Reassembly:</brown>
            <br></br><br></br>
            <indigo>Segmentation:</indigo>
            <br></br>
            The PDU is split into smaller pieces, each fitting within the 8-byte data field limit of the CAN frame.
            Each segment is sent as a separate CAN frame, and these frames are linked using specific identifiers (such as a 
            Sequence Number and a Unique Message Identifier).
            <br></br><br></br>
            <indigo>Transmission of Multiple Frames:</indigo>
            <br></br>
            The first CAN frame will carry the initial part of the data, while the subsequent frames carry the remaining chunks.
            A special control byte (such as a Sequence Number) is included in the header of each frame to help the receiving ECU 
            reassemble the full message.
            <br></br><br></br>
            <indigo>Reassembly:</indigo>
            <br></br>
            The receiving ECU listens for each frame, identifies the Sequence using the Control Information, and reassembles the data 
            into the original PDU once all the frames are received.
            <br></br>
            The receiving ECU may also check for any errors or missing frames.
            <br></br><br></br>
            <brown>Example of Multi-Frame Transmission:</brown>
            <br></br><br></br>
            Suppose a diagnostic message requires 20 bytes of data.
            <br></br>
            This data would be split into 3 frames:
            <br></br><br></br>
            The first frame would carry the first 8 bytes.<br></br>
            The second frame would carry the next 8 bytes.<br></br>
            The third frame would carry the remaining 4 bytes.
            <br></br><br></br>
            Each of these frames would have identifiers or Sequence Numbers that allow the receiving ECU to know how to 
            reassemble the data.
            <br></br><br></br>
            PDUs larger than 8 bytes can be transmitted in a single frame through CAN FD 
            (Flexible Data-rate) protocol, which allows for larger data payloads and higher data 
            transfer rates with a Data Field size of up to 64 bytes.
            <br></br>
        </ecu-networks>
        <can-protocol>
            The CAN (Controller Area Network) protocol is a robust vehicle bus standard designed to 
            facilitate efficient communication primarily between Electronic Control Units (ECUs) in 
            automotive and industrial applications.
            <br></br><br></br>
            A simple CAN (Controller Area Network) typically consists of two wires. 
            CAN High (CANH) - the wire which carries the high voltage level of the signal and CAN Low (CANL) - the wire which 
            carries the low voltage level of the signal.
            
                <enum>The two wires are essential for proper 
                communication between devices on the network.</enum>
                <enum>Often, these wires are twisted together to reduce electromagnetic 
                interference, which helps maintain signal integrity.</enum>
                <enum>At each end of the CAN bus, termination resistors are 
                usually added to prevent signal reflections.</enum>
                <enum>
                In some cases, a four-wire configuration might be used to include additional wires for power and ground.
                </enum>
            
            <img class="database_image" src="./website_resources/local/database/pictures/simple_can_network.png" alt="autosar architecture"></img>
            <br></br><br></br>
            You can think of the schematic above as this: 
            <br></br><br></br>
            The Microcontroller is the brain, it has the CPU which runs the Operating System controlling every function of 
            the ECU. The CAN Controller is the communication specialist, it encodes inner-thoughts to sentences, 
            and the CAN Transceiver is the translator (the vocal cord) which provides the means for
            the brain to communicate effectively with the outside world (the CAN bus). 
            <br></br><br></br>
            <green>Information Transmission in CAN:</green>
            <br></br><br></br>
            The transmission of information through the CAN (Controller Area Network) utilizes a differential signaling 
            method between the CAN High (CANH) and CAN Low (CANL) wires.
            
                <enum><indigo>Differential Signaling:</indigo>
                The CAN bus uses a differential wired-AND signaling technique. This means that the information is transmitted as a 
                difference in voltage between the two wires.
                When data is sent, one wire (CANH) carries a higher voltage, while the other wire (CANL) carries a lower voltage.
                </enum>
                <enum><indigo>Dominant and Recessive States:</indigo>
                When a dominant bit is transmitted, CANH rises to approximately 3.5V, and CANL drops to about 1.5V. 
                This creates a differential voltage of 2 volts (3.5V - 1.5V).
                <br></br>
                In the recessive state, both wires are at the same voltage level, typically around 2.5V. 
                This indicates that no data is being transmitted.
                </enum>
                <enum><indigo>Bit Transmission:</indigo>
                The bits are sent as high/low signals, which can be visualized as pulses or waves traveling down the wires. 
                The transition between dominant and recessive states encodes the data being transmitted.
                </enum>
                <enum><indigo>Error Detection:</indigo>
                The differential nature of the signaling helps in error detection. If there is a fault in one of the wires, 
                the system can still interpret the data correctly by comparing the voltage levels of CANH and CANL.
                </enum>
               <enum><indigo>Robustness:</indigo>
                This method of transmission is highly robust against electromagnetic interference, making it ideal for automotive and 
                industrial applications where reliability is crucial.
                </enum>
            
            <br></br>
            CAN uses a bit-oriented protocol: Instead of sending 8 bytes at once, CAN transmits data bit by bit. 
            So, for an 8-byte message, you'd be sending 64 individual bits (8 bytes * 8 bits/byte).
            <br></br>
            <br></br>
            In other words we send out 64 pairs of CANH and CANL.
            <br></br><br></br>
            
            The time needed to send the 8-byte message through the bus can be calculated as follows:
            
                <enum>The speed of the CAN bus can vary, but a common speed is 500 kbps (kilobits per second).</enum>
                <enum>
                At 500 kbps, the time to transmit a single bit is calculated as 1/speed:
                <br></br>
                1/500 000 = 2 microseconds
                </enum>
                <enum>
                Time needed to transmit the whole message would be: 
                <br></br>
                    2 microseconds * 64 = 128 microseconds.
                </enum>
            
            <br></br>
            <green>Key Features of the CAN Protocol:</green>
            <br></br><br></br>
            <brown>Multi-Master Configuration:</brown>
            <br></br><br></br>
            All nodes (ECUs) on the network can send and receive messages, allowing for a decentralized communication system.
            <br></br><br></br>
            <brown>Carrier-Sense Multiple Access with Collision Detection (CSMA/CD):</brown>
            <br></br><br></br>
            CAN uses a method to manage access to the bus, ensuring that if two nodes (ECUs) attempt to send messages 
            simultaneously, the one with the higher priority will continue while the other will back off.
            <br></br><br></br>
            <brown>Message Prioritization:</brown>
            <br></br><br></br>
            Each message has a unique identifier that determines its priority. Lower numerical values indicate higher 
            priority, allowing critical messages to be transmitted first.
            <br></br><br></br>
            <brown>Error Detection and Handling:</brown>
            <br></br><br></br>
            CAN includes several mechanisms for error detection, such as Checksums / CRC and Acknowledgment (ACK) bits, ensuring 
            reliable communication. If an error is detected, the message is retransmitted.
            <br></br><br></br>
            The acknowledgement (ACK) bit is used to confirm the reception of the message. 
            So the ECU receiving the message sends out a reply that the reception was successful.
            <br></br><br></br>
            <indigo>How does Acknowledgement (ACK) Bit work?</indigo>
            <br></br>
            
                <enum>When a sender transmits a data frame, it includes an Acknowledgement (ACK) bit at the end of the frame. 
                </enum>
                <enum>Each ECU that successfully receives the data frame checks for errors. If the frame is received without errors, 
                the receiving ECU sets the Acknowledgement (ACK) bit to a dominant state (logic 0). 
                </enum>
                <enum>The ACK bit is dominant, meaning that if at least one ECU acknowledges 
                the message, the ACK bit will be recognized as dominant. 
                </enum>
                <enum>If no ECU acknowledges the message (i.e., all nodes (ECUs) detect an error), 
                the ACK bit remains in a recessive state (logic 1).
                </enum>
                <enum>The sender monitors the bus for the ACK bit. If it detects the dominant 
                state, it knows that at least one ECU has successfully received the message. If it does not detect the dominant state, 
                it assumes that there was an error in transmission. 
                </enum>
                <enum>If the sender does not receive an acknowledgment, it may retransmit the message, depending on the 
                error handling strategy implemented.
                </enum>
            
            <br></br>
            <indigo>Importance of the Acknowledgement (ACK) Bit</indigo>
            <br></br>
            The ACK bit ensures that messages are acknowledged, which is vital for maintaining the integrity of 
            communication in a network with multiple nodes. It helps in identifying transmission errors, allowing 
            for corrective actions to be taken.
            <br></br><br></br>
            These basic errors get detected by CAN Controller, but alongside these features more complex mechanisms such as: 
            E2E Protection 
            can be layered on top in order to enhance safety. Mechanisms such as: E2E (End to End) Protection are implemented 
            and handled within the higher Basic Software Layers.
            <br></br><br></br>
            <green>Broadcast Communication:</green>
            <br></br><br></br>
            Messages are broadcasted to all nodes (ECUs) on the network, meaning that every ECU can "hear" all transmissions. 
            This is efficient for applications where multiple devices need to respond to the same data.
            <br></br><br></br>
            If the information that the ECU "hears" on the bus is not meant for its functioning, then the messages will be blocked by its 
            CAN Controller / CAN Driver and it will not reach the upper software layers.
            This filtering is performed using the Unique Identifiers from the PDU / Frame.
            <br></br><br></br>
            <brown>Difference between Message/PDU and Frame</brown>
            <br></br><br></br>
            Both Frames and Message/PDUs can be used to reffer to the same thing.
            <br></br><br></br>
            In a CAN network, messages transferred across the network are referred to as frames. 
            Each frame contains essential information that allows ECUs to communicate effectively. 
            <br></br><br></br>
            When the transmission of a Message/PDU within a single frame is not possible due to the size limitations 
            (8 bytes for Data Field), 
            the Message/PDU can be transmitted across multiple frames, in segmented parts. This process is called 
            "Segmentation and Reassembly".
            <br></br><br></br>
            A Protocol Data Unit (PDU) is a generic term used to describe a unit of data specified in a protocol at any layer of 
            the OSI model. It represents the data that is transmitted over a network and can vary in structure depending on the 
            protocol being used.
            <br></br><br></br>
            A frame is a specific type of PDU used at the data link layer of the OSI model. It is a structured unit of 
            data that includes not only 
            the payload (the actual data) but also control information necessary for data transmission.
            <br></br><br></br>
            In other words: A Message/PDU is a term used to reffer to the packed data within the ECU, where as the Frame is term used 
            to reffer to the packed data travelling through the bus from one ECU to another. So once a transmitted PDU has left the ECU 
            it turns into a Frame, then the Frame is read by the recipient ECU and turns back into a Message/PDU.
            <br></br><br></br>
            If the Message/PDU was receiving across multiple frames, it will be reassembled back together into a single 
            unit once all the frames carrying the segmented parts of the Message/PDU were received.
            <br></br><br></br>
            <brown>Data Rates:</brown>
            <br></br><br></br>
            CAN supports data rates up to 1 Mbps, making it efficient for many applications.  
            A rate of 1 megabit per second (Mbps) means that the network can send 1 million bits of data every second.
            <br></br><br></br>
            At 1 Mbps, the CAN protocol can transfer up to 8 bytes of data per frame. This is the maximum payload size for a standard CAN frame, 
            which is suitable for many automotive and industrial applications. 
            <br></br><br></br>
            While 1 Mbps is effective for many applications, 
            it can be a limiting factor for systems that require higher data throughput. This is where CAN FD (Flexible Data-rate) 
            comes into play, allowing for higher speeds (up to 5 Mbps) and larger data payloads.
            <br></br><br></br>
            <brown>Bus Speed:</brown>
            <br></br><br></br>
            Bus speed, often referred to as the baud rate, is the rate at which the bus can transmit bits. 
            It is closely related to the Data Rate but can differ due to protocol overhead.
            <br></br><br></br>
            The bus speed is generally aligned with the data rate, but the effective data 
            transfer can be lower due to factors like:
            <br></br><br></br>
            <indigo>Protocol Overhead:</indigo> refers to the extra data that is transmitted alongside the actual user data 
            in a network communication. In our case: The additional bits used for error checking and message framing are sent within
            the same frame alongside the Data Field.
            <br></br><br></br>
            <indigo>Network Length:</indigo> Longer bus lengths can reduce the effective speed due to signal degradation. 
            While signal degradation doesn't directly slow down the speed of light at which the signal travels through the 
            cable, it does effectively reduce the data transfer rate, making it appear as if the signal is moving slower.
            <br></br><br></br>
            Baud rate represents the number of symbols (like 0s and 1s) that can be transmitted per second over the bus.
            <br></br>
            Bus speed describes the overall transmission capability of the bus, which is directly related to the baud rate.
            <br></br><br></br>
            <green>Types of CAN Frames</green>
            <br></br><br></br>
            <indigo>Data Frame:</indigo>
            <br></br>
            The most common type, used to transmit data from one ECU to another.
            <br></br><br></br>
            <indigo>Remote Frame:</indigo>
            <br></br>
            Requests data from another ECU without carrying any data itself. 
            
                <enum>When an ECU needs data from another ECU, it sends a Remote Frame. 
                This remote frame includes the identifier of the data frame it wants to receive. 
                </enum>
                <enum>Upon receiving the Remote Frame, 
                the targeted ECU recognizes the request and prepares to send the corresponding Data Frame.
                The Data Frame will then be transmitted back to the requesting ECU, containing the requested information.
                </enum>
            
            <br></br>
            <indigo>Error Frame:</indigo>
            <br></br>
            Indicates that an error has occurred in the transmission, prompting corrective actions. The Error Frame consists of 
            a 6-bit field that indicates the presence of an error. It is transmitted as a series of dominant bits (0s) or 
            recessive bits (1s), depending on the type of error detected and a delimiter that indicates the end of the Error Frame.
            
                <enum>Each node (ECU) on the CAN bus continuously monitors the messages being transmitted. If a node detects an error 
                (such as a bit error, format error, or acknowledgment error), it triggers the transmission of an Error Frame.
                </enum>
                <enum>
                Once an Error Frame is generated, it is immediately sent onto the CAN bus. All other nodes on the network 
                recognize this frame and take appropriate action, such as stopping their current transmission and preparing 
                to retransmit the message that caused the error.
                </enum>
                <enum>
                After the Error Frame is sent, the node (ECU) that detected the error will enter an error state. There are different 
                error states (active, passive, and bus-off) that determine how the node (ECU) will behave in future communications.
                </enum>
            
            <br></br>
            <indigo>Overload Frame:</indigo>
            <br></br>
            Used to signal that a node (ECU) is temporarily unable to process incoming messages. 
            An Overload Frame is transmitted when a node (ECU) needs more time to process incoming messages. 
            This can occur if:
            
                <enum>The node (ECU) is busy processing previous messages.</enum>
                <enum>The node's buffer is full, and it cannot accept new messages at that moment.</enum>
            
        </can-protocol>
        <can-transceiver>
            The CAN Transceiver acts as a bridge between the CAN bus and the Microcontroller (MCU). 
            It converts the differential voltage signals on the CAN High (CANH) and CAN Low (CANL) lines into a 
            single-ended digital signal that the Microcontroller (MCU) can understand.
            <br></br><br></br>
            <brown>Differential Signal Interpretation:</brown>
            <br></br>
            The transceiver interprets the voltage levels as follows:
            
            <enum>Dominant State: When the voltage difference indicates a dominant bit (e.g., CANH at approximately 3.5V and CANL at about 
            1.5V), the transceiver recognizes this as a binary 0. This state indicates an active transmission from a node (ECU) so the communication
            is going through the bus.
            </enum>
            <enum>Recessive State: When both wires are at the same voltage level (around 2.5V), it is interpreted as a 
            binary 1. When no node (ECU) is actively sending data, the bus remains in the recessive state meaning No Communication is
            going through the bus.
            </enum>
            <enum>
            Bus Idle State: When there is no communication, the bus is in an idle state, which is characterized by 
            the recessive state (higher voltage on the bus). The transceiver continuously monitors the bus for 
            any changes in voltage.
            </enum>
            
            On the dominant state, both bit 0 and bit 1 can be transmitted. This is where things get a little tricky in 
            CAN communication. The dominant state (lower voltage) represents a bit 0. This is straightforward.
            <br></br><br></br>
            In order to transmit a bit 1, a node (ECU) doesn't actively pull the bus voltage down to the dominant state. 
            Instead, it allows the voltage to remain in the recessive state (higher voltage).
            <br></br><br></br>
            Think of it like this:
            <br></br>
            Imagine a group of people shouting. When someone wants to say "yes" (bit 0), they shout loudly. 
            When they want to say "no" (bit 1), they don't shout. They simply remain silent, allowing the 
            background noise (recessive state) to continue.
            <br></br><br></br>
            <brown>Difference between Recessive State and a consecutive group of bits of value 1</brown>
            <br></br><br></br>
            If you send 111111111 on the bus, the CAN Transceiver will definitely know there's communication happening. 
            Here's why:
            
                <enum>The CAN protocol is designed to recognize patterns of bits. It's not just about individual bits; 
                it's about how they are arranged and timed.</enum>
                <enum>The CAN Transceiver is constantly monitoring the bus. It's looking for specific patterns of bits that signal 
                the start of a message, the data bits within the message, and the end of the message.
                </enum>
                <enum>
                A string of 1s, even if it's just a series of recessive states, is still a pattern that the CAN 
                Transceiver will recognize. It will know that a node (ECU) is actively holding the bus in the recessive 
                state for the duration of those bit times.
                </enum>
            
            So basically, whenever a node (ECU) sends a message on the CAN it starts transmitting with a distinguishable 
            binary sequence (SOF bit) and it ends the transmission with a different distinguishable binary sequence (EOF bit).

                <enum><indigo>Start of Frame (SOF):</indigo> This is a single dominant bit (0) that marks the beginning of a message. 
                Think of it like a "Hey, everyone, listen up!" signal.</enum>
                <enum><indigo>Data:</indigo> This is the actual message content, consisting of a series of bits representing the data 
                being transmitted.</enum>
                <enum><indigo>End of Frame (EOF):</indigo> This is a sequence of seven dominant bits (0s) followed by a recessive bit (1). 
                It's like a "That's all, folks!" signal.</enum>
            
            <brown>Digital Signal Outputting:</brown>
            <br></br>
            The transceiver outputs a digital signal (high or low) to the Microcontroller (MCU) based on the interpreted 
            voltage levels. This digital signal can then be processed by the Microcontroller (MCU) for further actions, 
            such as data logging, control commands, or communication with other devices.
            <br></br><br></br>
            <brown>Error Detection Scenario in CAN Transceiver:</brown>
            <br></br>
            Imagine a CAN bus with two wires, CANH and CANL, transmitting a dominant bit (1). 
            This means CANH should be at a higher voltage (around 3.5V) than CANL (around 1.5V).
            <br></br><br></br>
            <indigo>Fault:</indigo> Let's say there's a fault in the CANH wire, causing it to short-circuit to ground. 
            This would drop the voltage on CANH to 0V.
            <br></br><br></br>
            <indigo>With Differential Signaling:</indigo>
            <br></br>
            The CAN transceiver compares the voltage levels of CANH and CANL. It sees that CANH is at 0V, and CANL is still at 1.5V.
            <br></br>
            The transceiver recognizes this voltage difference as an error. It knows that the intended signal was a dominant bit (1), 
            even though the CANH wire is faulty.
            <br></br><br></br>
            This allows the transceiver to flag the error and potentially request a retransmission of the message.
            <br></br><br></br>
            <indigo>Without Differential Signaling:</indigo>
            <br></br>
            A standard single-ended system would only see the voltage on CANH as 0V. It would incorrectly 
            interpret this as a recessive bit (0), even though the intended signal was a dominant bit (1).
            <br></br><br></br>
        </can-transceiver>
        <can-controller-driver>
            <brown>CAN Controller and CAN Driver</brown>
            <br></br><br></br>
            The CAN Controller is usually integrated within a Microcontroller Unit (MCU). This integration allows 
            the MCU to manage communication without needing additional hardware. Even if an MCU has an integrated 
            CAN Controller, it will still require an external CAN Transceiver to connect to the CAN bus.
            <br></br><br></br>
            <indigo>Serial Peripheral Interface (SPI)</indigo>
            <br></br><br></br>
            In case of ECUs which use external Controllers (which are not part of the Microcontroller), these controllers
            are usually connected using the SPI (Serial Peripheral Interface).
            <br></br><br></br>
            The number of SPI (Serial Peripheral Interface) pins on a microcontroller can vary depending on 
            the specific microcontroller model and its architecture. However, here are the typical 
            pins associated with SPI communication:
            <br></br><br></br>
            <brown>Common SPI Pins:</brown>
            
                <enum><indigo>MOSI (Master Out Slave In):</indigo> Carries data from the master to the slave.</enum>
                <enum><indigo>MISO (Master In Slave Out):</indigo> Carries data from the slave back to the master.</enum>
                <enum><indigo>SCK (Serial Clock):</indigo> Synchronizes data transmission between master and slave.</enum>
                <enum><indigo>SS (Slave Select):</indigo> Used by the master to select which slave device to communicate with.</enum>
            
            At least 4 pins are required for basic SPI communication (MOSI, MISO, SCK, and one SS pin).
            <br></br><br></br>
            If you have multiple slave devices, you will need an additional SS pin for each slave, which can 
            increase the total number of pins used.
            <br></br><br></br>
            For instance, a microcontroller with 3 slave devices would require:
            <br></br>
            4 pins (MOSI, MISO, SCK, and one SS) + 3 additional SS pins = 7 pins in total.
            <br></br><br></br>
            Some microcontrollers may allow you to configure SPI using different pins, and some might have 
            dedicated hardware support for SPI, which can simplify the pin usage.
            <br></br><br></br>
            <brown>External CAN Controller connection through SPI:</brown>
            <br></br><br></br>
            <img class="database_image" src="./website_resources/local/database/pictures/external_can_controller.png" alt="external_can_controller"></img>
            <br></br><br></br>
            Connecting an external CAN Controller to the Microcontroller using SPI instead of dedicated CAN Hardware Interface is 
            a choice based on the specifics of the project. Sometimes the built-in CAN Hardware Interface does not satisfy the project's specifics.
            <br></br><br></br>
            SPI can provide higher data rates compared to some built-in interfaces, which can be crucial for applications requiring fast communication.
            <br></br>
            If the built-in CAN interface is complex or lacks certain functionalities, using an external CAN controller with SPI can simplify your design.
            <br></br><br></br>
            <green>CAN Driver</green>
            <br></br><br></br>
            Regardless if the CAN controller is built-in the microcontroller or external to the microcontroller, the CAN Driver controlling it will always 
            be part of the microcontroller.
            <br></br><br></br>
            The CAN Controller is controlled by a CAN Driver. The CAN Driver acts as an interface between the 
            Operating System (RTOS) (or Application Layer) and the CAN Controller. 
            <br></br><br></br>
            The CAN Driver may include functions through which the CAN Transceiver can be configured. For instance 
            the CAN Driver might be able to: 
            
                <enum>to adjust the baud rate used by CAN Transceiver;</enum>
                <enum>to enable or disable the Transceiver. This controls whether the transceiver is actively 
                listening for data or transmitting data. </enum>
                <enum>to set the transceiver's operating mode: This might include different modes for normal 
                operation, sleep mode, or a low-power mode.</enum>
                <enum>to configure the filters used by the Transceiver. These filters allow the transceiver to 
                selectively accept or reject incoming messages based on their ID.</enum> 
                <enum>to manage the errors handling for the Transceiver. The CAN Driver might provide functions to 
                check for errors, 
                report them to the RTOS, and potentially take corrective actions.</enum>
            
            <br></br>
            The CAN Driver also provides the necessary functions to send and receive messages over the CAN network. These 
            functions may be used directly by the RTOS or may be called by RTOS through interfaces defined by CANIF module. 
            <br></br>
            For example, the RTOS might call functions like 
            <code>CAN_Send(message)</code> to transmit messages or 
            <code>CAN_Receive()</code> to handle incoming messages.
            <br></br><br></br>
            
            The RTOS utilizes functions from the CAN Driver to handle errors reported on the CAN Controller, allowing for robust 
            error management in the system.
            <br></br><br></br>
            The CAN Controller can report several types of errors that are crucial for maintaining the integrity 
            of communication on the CAN bus. Some of the errors reported by CAN Controller are:
            
                <enum><indigo>Bit Error:</indigo> This occurs when the bit received does not match the bit transmitted. 
                It can happen 
                due to noise or interference on the bus.
                </enum>
                <enum><indigo>Form Error:</indigo> This error is detected when the format of a received frame is incorrect. 
                For example, if the 
                frame does not adhere to the expected structure, a form error is triggered.
                </enum>
                <enum><indigo>Stuff Error:</indigo> This happens when the bit stuffing rule is violated. In CAN, after five 
                consecutive bits of the 
                same value, a complementary bit is inserted. If this rule is not followed, a stuff error is reported.
                <br></br><br></br>
                Bit Stuffing Process: In CAN communication, if there are five consecutive bits of the same value (either all 0s or all 1s), 
                a stuff bit (the opposite value) is inserted to break the sequence.  
                If the receiver detects that a stuff bit was added incorrectly (i.e., it does not match the expected value), 
                it registers a stuff error.
                <br></br>
                This means the receiver does not expect more 5 bits of same value in a row. If it detects such a sequence 
                it will raise an Stuff Error.
                <br></br><br></br>
                Example: A sequence such as: 10111111000 will raise a Stuff error. Because there are 6 bits of 1 in a row.
                <br></br><br></br>
                Without this Stuffing Bit mechanism the receiver will not be sure if the number of bits it read 
                from the communication is exactly the same number of bits sent by the source.
                <br></br><br></br>
                The stuffing bits are part of the Frames but NOT part of the PDUs.
                <br></br><br></br>
                It's the CANIF's job to decode the information, and turn it back into a PDU, hence removing the 
                stuffing bits.
                </enum>
                <enum><indigo>CRC Error:</indigo> The Cyclic Redundancy Check (CRC) is used to detect errors in the 
                transmitted data. If the CRC 
                calculated by the receiver does not match the CRC sent with the message, a CRC error is reported.
                </enum>
                <enum><indigo>Acknowledgment Error:</indigo> This error occurs when a transmitted message is not acknowledged 
                by any node on the bus. 
                Each node is expected to send an acknowledgment bit after receiving a message, and if this does not happen, 
                an acknowledgment error is flagged.</enum>
            
            <br></br>
            The CAN Driver often uses mechanisms like semaphores or queues to synchronize access to the CAN bus, ensuring that 
            tasks do not interfere with each other during message transmission or reception.
            <br></br><br></br>
            <brown>How does the CAN Controller interract with the outside world?</brown>
            
                <enum>The CAN Controller can start a transmission when it detects an idle bus. This means that the bus is not 
                currently being used by any other node (ECU).</enum>
                <enum>If the bus is currently used by a different ECU. Our ECU can attempt to take over the bus
                by broadcasting our CAN ID. If we have higher priority (lower CAN ID) the ECU using the bus will have
                to abort its transmission, and free the bus for our ECU.
                </enum>
                <enum>When a node (ECU) wants to send a message, the CAN Controller encodes the message according to the 
                CAN protocol, which includes the Identifier, Data, and Control Information.</enum>
                <enum>The CAN Controller continuously monitors the bus for incoming messages. When it detects a message, 
                it decodes it and processes the data. It also checks for errors during transmission, ensuring that 
                the data received is valid. If an error is detected, the CAN Controller will signal this by sending an 
                error frame onto the bus. 
                <br></br><br></br>
                The CAN Controller maintains error counters to track the number of errors encountered. If the error 
                count exceeds a certain threshold, the controller may enter a bus-off state, where it temporarily 
                stops transmitting to prevent further issues on the bus.
                <br></br><br></br>
                In the event of a bus-off state, the CAN Controller will eventually attempt to recover by reinitializing 
                itself and resuming normal operation once the bus is clear and stable.
                </enum>
                <enum>
                In cases where multiple nodes (ECUs) attempt to transmit simultaneously, the CAN protocol uses a method called 
                arbitration. The CAN Controller uses the message identifier to determine which message has the highest 
                priority and allows that message to proceed while others wait.
                </enum>
                <enum>
                The CAN Controller can operate in different modes, such as normal mode, listen-only mode, and loopback 
                mode, depending on the application requirements.
                </enum>
            
            <br></br>
        </can-controller-driver>
        <can-interface>
            <brown>CAN Interface (CanIf)</brown>
            <br></br><br></br>
            The RTOS manages multiple tasks that may need to send or receive CAN messages. When a task wants to send a 
            message over the CAN network, it calls directly or indirectly the appropriate function from CanIf module 
            which builds reliable interfaces by calling functions defined within the CAN Driver. 
            <br></br><br></br>
            <indigo>Concrete Example of Communication between ECUs:</indigo>
                <enum>SWC generates data that needs to be sent to external world through the CAN network.</enum>
                <enum>SWC passed the data to RTE, which based on the system description knows in which 
                    signal the data will end up. 
                    <br></br><br></br>
                    If the signal in which the data will be stored is meant to be sent to an external ECU, 
                    and if the external ECU receiving it is of different architecture, then 
                    RTE may convert the data (Ex: from Little Endian to Big Endian) to match 
                    the receiver ECU's architecture.
                </enum>
                <enum>Once data is converted, RTE maps the data to an RTOS Scheduling Task, 
                    which is responsible for managing the CAN communication.
                </enum>
                <enum>RTOS Task passes the data to a Communication Stack module which will map it to a Signal.</enum>
                <enum>CanIf interface as part of Communication Stack, takes over the updated Signal which 
                    may or may not be part of a Signal Group and packs it into a PDU.
                    <br></br><br></br>
                    Based on the size of the PDU / Message, the CanIf 
                    will determine if the segmentation is needed. On CAN bus we are only allowed to send messages up to 8 bytes. 
                    If the message to be sent is bigger than 8 bytes, it needs to be sliced into multiple Frames. 
                    <br></br><br></br>
                    Each Frame will contain the same message ID, CAN ID and CRC, a sequential SQC / SQN (Sequence Counter or 
                    Sequence Number) and only a portion of the actual data
                </enum>
                <enum>In order to perform segmentation CanIf will call a specific function from CanTp module to inform that 
                     a new CAN N-PDU frame has been received.
                     <br></br><br></br>
                     This is done through a reception indication function, which informs the CanTp module that it needs to 
                     handle the segmentation of the incoming data.
                     <br></br><br></br>
                     CanTp module will then break down the larger message into smaller frames that fit within the 8-byte limit.
                </enum>
                <enum>CanIf then receives the frames from CanTp, and notifies the CAN Driver that everything is 
                    set for transmission.
                </enum>
                <enum>CAN Driver monitors the activity on the bus.
                    <br></br><br></br>
                    Only if the bus is busy, the CAN Driver participates in the arbitration process to determine if 
                    it can send its message. 
                    <br></br><br></br>
                    This happens before the actual frame data is transmitted.                
                    <br></br><br></br>
                    Once CAN Driver wins the Arbitration Phase or once the bus gets freed, CAN Driver
                    will inform the CanIf, that the transmission can begin.
                </enum>
                <enum>CanIf receives the notification from CAN Driver, and passes the first frame to the CAN Driver.</enum>
                <enum>CAN Driver takes the frame, and informs the CAN Transceiver that data will be coming.</enum>
                <enum>CAN Transceiver sends a distinguishable binary sequence (SOF bit) on the bus, which would 
                    reserve a slot for message transmission.
                </enum>
                <enum>CAN Driver sends each bit within the frame, individually, to the CAN Transceiver.</enum>
                <enum>CAN Transceiver receives the bit and turns it into voltage. 
                    A bit 0 is equivalent to a voltage difference greater than 0V between CANH and CANL 
                    This typically means having 4.5V on CANH, and 1.5V on CANL. 
                    <br></br><br></br>
                    A bit 1 is equivalent to a voltage difference near 0V. 
                    This typically means having 2.5V on each wire: CANH and CANL.
                    <br></br><br></br>
                    The transceivers use the voltage difference between the CANH and CANL to determine the bit value.
                    <br></br><br></br>
                    The transceiver might add staffing bits in their transmission if the same 5 bits are sent in a row.
                    This means that the CAN Transceiver will add an extra bit of opposite value after every 5 bits of 
                    the same value.
                </enum>
                <enum>While we are sending the message on the bus, bit by bit, frame by frame. All other ECUs listen, 
                    and wait for their 
                    turn to reach for the bus and send their messages.
                </enum>
                <enum>The listening ECUs will read our binary data and 
                     they will begin to write down every bit we send within that transmission.
                </enum>
                <enum>In case any other ECU with higher priority (lower CAN Id) 
                    within the network will request communication,
                    our message will be intrerrupted. 
                    <br></br><br></br>
                    Within a network: ECUs have static priority. Meaning that the priority 
                    it's pre-defined in the network design and doesn't change during communication.
                    <br></br><br></br>
                    Also the priority an ECU has in one network for instance CAN may be bigger than the same ECU has on 
                    a different network, for instance: LIN. This happens because on some network ECUs may transmit more important
                    PDUs or communicate with more important ECUs than on other networks.
                    <br></br><br></br>
                    While our ECU is transmitting, it continuously monitors the bus. If it detects a dominant level 
                    (a logical '0') when we are actually sending a recessive level (a logical '1'), 
                    this will indicate to us that another node (ECU) is trying to send a message. 
                    This is part of the CAN protocol's collision detection mechanism.
                    <br></br><br></br>
                    The bus will enter Arbitration Phase: meaning the ECU is both transmitting its own 
                    CAN ID and monitoring the bus for any dominant levels (logical '0').
                    <br></br><br></br>
                    As each bit of the CAN ID is transmitted by the other ECU, our ECU compares its own bit 
                    with the bit travelling through the bus.
                    <br></br><br></br>
                    This comparison starts from the most significant bit (MSB) of the CAN ID and proceeds 
                    towards the least significant bit (LSB).
                    <br></br><br></br>
                    The first bit where the IDs differ determines the priority. The ECU with the dominant bit 
                    (logical '0') in that position wins the arbitration and gets to continue transmitting. 
                    The ECU with the recessive bit (logical '1') loses the arbitration and stops transmitting.
                    <br></br><br></br>
                    The ECU transmitting bit 0 wins because lower CAN ID means higher priority.  This happens also 
                    because a dominant state overrides a recessive state (bit 1).
                </enum>
                <enum>
                    We will stop the transmission and free the bus.
                    Meaning, we read the intent of an ECU with higher priority (lower CAN Id) for transmission 
                    and now the bus will be reserved by that ECU.
                    
                    </enum>
                    <enum>
                    We will enter a wait state.
                    The ECU with which we were communicating will discard the received data since it's incomplete transmission.
                    <br></br>
                    We will attempt to retransmit the data after a short delay.
                </enum>
                <enum>
                    The other ECU sends its message and frees the bus.
                </enum>
                <enum>
                    Once the bus gets free, we will restart our communication.
                </enum>
                <enum>
                    Once all the frames were sent, the CAN Transceiver will send a distinguishable binary sequence (EOF bit) 
                    which will notify the receipient ECU that the message is complete, and the bus will become free again.
                </enum>
                <enum>
                    On the receipient ECU, the CAN Transceiver translates the last bit for the CAN Driver. The CAN Driver 
                    now has all the data buffered and knows that the transmission has ended, and it will notify the CanIf.
                </enum>
                <enum>
                    CanIf will request each frames from the CAN Driver and will attempt to decode/assemble all pieces 
                    together. 
                    <br></br><br></br>
                    Decoding is the process of turning individual frames into a single PDU Unit. During decoding the CanIf
                    will remove Staffing bits, and CAN ID from each frame, as they are not supposed to be part of the PDU.
                    Also for each frame CanIf will check for SQC / SQN in order to determine the order in which to assemble
                    the frames into a single PDU. 
                    <br></br><br></br>
                    Based on the SQC / SQN the frames are put together and a PDU / Message is formed.
                </enum>
                <enum>
                    CanIf will attempt to validate the PDU/Message, by calculating the CRC for the message.
                    <br></br><br></br>
                    The CRC calculation is performed on the entire message data, including the CAN ID and 
                    other control fields.
                    <br></br><br></br>
                    The calculated CRC is then compared with the CRC received from our ECU. 
                    If the CRCs are identical, the message is valid.
                </enum>
                <enum>
                    If the CRCs are not identical. The other ECU will reserve the bus, and will send out an 
                    Error Frame meant for our ECU. We will receive
                    the Error Frame, and we will know the message intrerruption caused a problem in our transmission, 
                    and the message that reached the destination
                    is different from what we meant to send.
                    <br></br><br></br>
                    The Error Frame triggers error recovery mechanisms. The transmitting ECU might retry the 
                    transmission, or other ECUs might try to avoid sending messages to the problematic node.
                </enum>
                <enum>
                    Our ECU will retransmit the message. If the same scenario repeats multiple times, and we are unable 
                    to send the message properly, based on the requirement we might decide restart the 
                    CAN Transceiver, CAN Controller, or even 
                    the ECU, and same thing might happen with the receipient ECU. We will try again after that.
                </enum>
                <enum>
                    If the CRCs are identical, and the message is valid. CanIF will pass the PDU to PduR which
                    will decide upon its configuration whether the PDU needs to be routed to a different ECU (process 
                    known as gatewaying). 
                    <br></br><br></br>
                    If the PduR is not configured to route the received PDU, then the PDU is gonna be passed to COM module,
                    which will apply its acceptance criteria.
                    <br></br><br></br>
                    Meaning if the Unique Message ID of the PDU is within the predefined range that the 
                    Com module is configured to accept, then the PDU processing within the ECU continues, 
                    and the PDU is unpacked into signals and signal groups, and passed to the appropriate Software Components.
                    <br></br><br></br>
                    Otherwise the message will be blocked, as it's not meant for the receiving ECU.
                </enum>
            <br></br>
            The same steps are taken in case of message reception. 
            <br></br>
            When a message is received, the CAN Driver notifies CanIf which assembles the message and informs 
            directly or indirectly the RTOS, which can then pass the message to the appropriate task for processing.
            <br></br><br></br>
            <img class="database_image" src="./website_resources/local/database/pictures/ecu_communication.png" alt="autosar_architecture_ecus_communicating"></img>
            <br></br>
            Each Transport Protocol implemented within the ECU has it's own BusIF module. The BusIF module would interface
            all the existing communication channels within its topology.
            <br></br><br></br>
            This means CanIF can interface multiple CAN Controllers, each controlled by its own 
            CAN Driver and every Controller/Driver pair would be operating individually as separate communication channel.
            <br></br><br></br>
            So regardless of how many CAN communication channels are implemented, there should only be one CanIF module interfacing them.
            <br></br>
            <img class="database_image" src="./website_resources/local/database/pictures/canif_mutiple_can_controllers.png" alt="canif_multiple_can_channels"></img>
        </can-interface>
        <can-collision-detection>
            CAN protocol's collision detection mechanism enables a node (ECU) which is transmitting data to detect 
            if another node is trying to send data while the bus is already in use. The collision detection on CAN network
            happens through the Arbitration. 
            <br></br><br></br>
            Arbitration is the process by which multiple ECUs on the CAN bus compete to transmit a 
            message. It's a bit like a traffic light where only one car can go through at a time.
            <br></br><br></br>
            Before our ECU begins to transmit, it sends a distinguishable binary sequence (SOF bit), notifying all 
            other nodes, that we are going to communicate, and the bus will become busy.
            <br></br><br></br>
            While we are transmitting, we are constantly monitoring the bus. We will be able to detect a collision 
            only when the value we are transmitting on the bus, is different than the value going through the bus. 
            This would mean that some other node, has interfered with our communication and has overwrite what we were sending.
            But this detection is done only when the value we are sending is different that the value transmitted by the 
            other node. 
            <br></br><br></br>
            This means if our ECU and the other ECU send same values, we won't detect any collision, 
            and neither will the other ECU.
            <br></br><br></br>
            If both ECUs are sending the same data, there's no need for a collision resolution process. The CAN protocol 
            avoids unnecessary delays and ensures smooth data transmission.
            <br></br><br></br>
            This scenario often occurs when ECUs are broadcasting messages that contain information that's relevant to 
            all nodes on the bus. For example, a message containing the current speed of the vehicle might be sent by 
            multiple ECUs, and it's important that all nodes receive this information.
            <br></br><br></br>
            The Collision Resolution Process is the process of handling collisions. 
            It includes the arbitration phase (for determining priority) 
            and the actions taken by the ECUs that lose the arbitration (waiting for a random time before retransmitting).
            <br></br><br></br>
            <green>Detecting a collision:</green>
            <br></br><br></br>
            Let's say, we are transmitting a bit 0, the other ECU transmits a bit 0 as Most Significant Bit (MSB) 
            from its CAN ID. We won't detect a collision. Then our ECU sends a bit 1, 
            but we are reading on the bus a bit 0, which overwritten what we sent. 
            Now we know there's a collision in progress. 
            But we lost the first bit from the CAN ID of the other ECU colliding to our transmission.
            <br></br><br></br>
            The arbitration process continues with the next bit. 
            Our ECU will now enter a listening mode, comparing its remaining CAN ID bits 
            with the bits being transmitted on the bus.
            <br></br><br></br>
            If the other ECU's remaining CAN ID bits are all recessive states (bit 1), 
            our ECU will win the arbitration for the remaining bits and be able to continue transmitting its message.
            <br></br><br></br>
            If the other ECU's remaining CAN ID bits contain any dominant states (bit 0), 
            our ECU will lose the arbitration, and the other ECU will take on the bus to transmit its message.
            <br></br><br></br>
            So, even though you lost the first bit of the other ECU's CAN ID, the arbitration process 
            continues, and the outcome depends on the remaining bits of both CAN IDs.
            <br></br><br></br>
            <brown>Edge Case:</brown>
            <br></br><br></br>
            <code>Our ECU's CANID:         </code><red>0</red>001001<azure>0</azure><br></br>
            <code>Other ECU's CANID:      </code><purple>0</purple><red>0</red>001001<br></br>
            <code>OUR Transmitted data:   </code><purple>0</purple><red>1</red>011110<br></br>
            <br></br>
            <indigo>Legend of bit comparison:</indigo><br></br>
            <purple>Purple</purple> - is where masking of Other ECU's CANID happens because of Our Transmitted data.<br></br>
            <red>Red</red> - is where the collision is detected because the 2nd bit from the Other ECU's CANID overwrote 
            the value of the data we were transmitting
            <br></br>
            <azure>Azure</azure> - is Our ECU's CANID LSB (Least Significant Bit) which will NOT be compared as part of 
            Arbitration Phase.
            <br></br>
            <br></br>
            <indigo>Scenario:</indigo><br></br>
            Taking under consideration the CANID and Transmitted data from above, we notice that the collision will
            be detected stating with second bit from the left. While we were transmitting bit 0, we couldn't detect 
            a collision because the Other ECU's CANID is also 0, so no value will be overwriten on the bus. 
            <br></br><br></br>
            When the collision is detected we begin to compare the bits read from the bus with Our ECU's CANID.
            This process is known as Arbitration Phase or Arbitration Process and it happens at the beggining of a 
            CAN message transmission. 
            Our ECU's CANID will win the Arbitration Phase even though Our ECU's CANID is slightly bigger, 
            because we only get to 
            compare only a partial part of the other ECU's CANID.
            <br></br><br></br>
            This is a fascinating example of how the CAN protocol's design can lead to unexpected behaviors:
            like 1000100 compared to 10001000. We win but Our CAN ID is greater than the other ECU's CAN ID. 
            <br></br><br></br>
            While the data we're transmitting isn't directly compared during Arbitration Phase, it can indirectly 
            influence the outcome by masking parts of the other ECU's CAN ID.
            <br></br><br></br>
            <green>What if multiple ECUs transmit the same data?</green>
            <br></br><br></br>
            If multiple ECUs transmit the same date, the collision detection would still work based on the ECU-Id, 
            which will be unique. So when the ECUs are trying to send their ID's through the bus, they will most likely
            raise a conflict, and they will detect the collision because the values on the bus will be overwrite from 
            multiple sources.
            <br></br><br></br>
            <brown>What if multiple ECUs with same IDs would be connected to the same network?</brown>
            <br></br><br></br>
            This scenario would most like raises serious security concerns. A malicious actor could potentially exploit 
            this situation to inject false information into the network or disrupt the normal operation of the system.
            <br></br><br></br>
            While there might not be a collision in the strict sense if multiple ECUs are sending the same ID and same date, 
            the bus would become busier as all ECUs try to transmit their messages. This could lead to delays in other 
            messages being sent, as the bus becomes saturated.
            <br></br><br></br>
            If two ECUs have the same ID, it's like one is trying to impersonate the other. This could lead to confusion 
            and potentially disrupt the communication flow.
            <br></br><br></br>
            <brown>Detection of ECU replicas within the network:</brown>
            <br></br><br></br>
            A practical way to detect a duplicated ECU within the network would be by disconnecting 
            ECUs one by one and observing the Main ECU's reaction.
            
            
                <enum><indigo>Baseline:</indigo> First, we would establish a baseline by monitoring the Main ECU's 
                behavior with all ECUs connected. This would provide a reference point for comparison.</enum>
                <enum><indigo>Disconnect and Observe:</indigo> We would then disconnect each ECU individually and observe the Main ECU's behavior.</enum>
                <enum><indigo>Duplicate Detection:</indigo> If the Main ECU doesn't register the absence of a specific ECU (i.e., 
                its behavior remains unchanged), it indicates that there might be a duplicate ID.</enum>
                <enum><indigo>Isolate and Verify:</indigo> We could then disconnect the suspect ECU and reconnect 
                the previously disconnected one to confirm the duplicate ID.</enum>
            
            <br></br>
            By leveraging network management capabilities we would have a new set of possibilities for detecting 
            duplicate ECU IDs.
            
                <enum><indigo>Wake-up Cycle:</indigo> The Main ECU could initiate a wake-up cycle, bringing each 
                ECU online one by one. This would allow for a controlled and isolated test environment.</enum>
                <enum><indigo>Message Exchange:</indigo> During the wake-up cycle, the Main ECU could send a series of test 
                messages to each ECU. These messages could be specifically designed to test communication 
                latency and bus load.</enum>
                <enum><indigo>Data Analysis:</indigo> The Main ECU would carefully analyze the time it takes for messages to 
                reach their destination and the overall bus load during each test.</enum>
                <enum><indigo>Duplicate Detection:</indigo> If the Main ECU detects a significant increase in bus load or 
                communication latency when a particular ECU is woken up, it could indicate a duplicate 
                ID situation. The duplicate ECU might be interfering with message transmission, causing 
                delays and increased bus traffic.</enum>
            
        </can-collision-detection>
        <can-tp-module>
            CAN Transport Protocol (CanTp) Module is essential for efficient communication in automotive systems, especially 
            when dealing 
            with larger data packets. It has the ability to segment, reassemble, and manage flow control of PDUs / Messages.
            <br></br><br></br>
            The CanTp module is designed to handle the transport of larger data packets over the CAN bus, 
            which has a maximum payload size of 8 bytes. When data exceeds this limit, CanTp comes into play to 
            ensure that the data is transmitted efficiently and reliably.
            <br></br><br></br>
            <green>Key Functions of CanTp:</green>
            <br></br><br></br>
            <indigo>Segmentation:</indigo>
            <br></br>
            CanTp segments larger data packets into smaller frames that fit within the 8-byte limit of CAN messages.
            This process ensures that data can be transmitted without loss or corruption.
            <br></br><br></br>
            <indigo>Reassembly:</indigo>
            <br></br>
            Once the segmented frames are received by the destination, CanTp is responsible for reassembling them 
            into the original data packet.
            This is crucial for maintaining data integrity.
            <br></br><br></br>
            <indigo>Flow Control:</indigo>
            <br></br>
            CanTp manages flow control to prevent data overflow. It ensures that the sender does not overwhelm the 
            receiver with too many messages at once.
            This is particularly important in scenarios where the receiver may take time to process incoming data.
            <br></br><br></br>
            It uses a "Flow Control Frame" to signal the sender to pause or continue sending data based on the receiver's 
            readiness.
            <br></br><br></br>
            <indigo>State Management:</indigo>
            <br></br>
            The CanTp module operates in different states (e.g., CANTP_ON), and it performs segmentation and reassembly 
            tasks only when in the appropriate state.
            This state management helps maintain the protocol's integrity and functionality.
            <br></br><br></br>
            <indigo>Error Handling:</indigo>
            <br></br>
            CanTp includes mechanisms for error detection and handling. If a transmission error occurs, it can initiate 
            retransmission of the affected frames, ensuring reliable communication.
            <br></br><br></br>
            <indigo>Configuration Parameters:</indigo>
            <br></br>
            The CanTp module can be configured with various parameters, such as maximum transmission unit 
            (MTU) size, timeout values, and flow control settings. These configurations can be tailored to meet 
            the specific needs of the application.
            <br></br><br></br>
            <indigo>Integration with Other Modules:</indigo>
            <br></br>
            CanTp sits between the PDU Router (PDUR) and the rest of the CAN stack, facilitating communication between 
            different software components.
            It interacts with other modules to ensure smooth data transmission across the system.
            <br></br><br></br>
            <indigo>Use Cases:</indigo>
            <br></br>
            CanTp is widely used in diagnostic communication, where larger data sets need to be 
            transmitted for vehicle diagnostics and maintenance.
            <br></br><br></br>
            CanTp ensures that all data is transmitted 
            without loss, maintaining the integrity of the information which is particulary important in applications 
            requiring extensive data logging.
        </can-tp-module>
        <pdur-module>
            The PduR module is primarily responsible for routing Protocol Data Units (PDUs) to the appropriate 
            bus-specific interface modules. This ensures that data is transmitted correctly between different 
            components of the vehicle's electronic systems.
            <br></br><br></br>
            The PduR module manages the transmission of data from the PDU transmit buffer to the designated interface 
            module.<br></br>
            The PduR module handles the reception of PDUs and routes them to the correct destination based on the 
            configuration.
            <br></br><br></br>
            PduR operates above the lower layers of the communication stack, allowing it to interact with various 
            communication protocols and services.
            <br></br><br></br>
            <img class="database_image" src="./website_resources/local/database/pictures/communication_stack.png" alt="autosar_comstack"></img>
            <br></br><br></br>
            The PduR module is also responsible for reporting errors related to PDU transmission, ensuring that any 
            issues are communicated to the Diagnostic Event Tracker (DET) module.
            <br></br><br></br>
            The behavior of the PduR can be configured based on the specific requirements of the vehicle's architecture, 
            making it flexible for different applications. This means PduR can be configured to route specific messages, 
            or messages within specified range of Message Ids to a specific bus.
            <br></br><br></br>
            Via PduR the ECU can redirect messages within the network. Allowing for bus traffic management over 
            Network Segments. This function is also known as gatewaying.
            <br></br><br></br>
            <img class="database_image" src="./website_resources/local/database/pictures/routing_ecus.png" alt="routing_pdus_through_gateway"></img>
            <br></br><br></br>
            <green>Use Case for PduR:</green>
            <br></br><br></br>
            ECUs within the network might be split into sectors, this would enable parallel trafic on the bus, meaning that ECUs within
            a sector could only monitor the traffic on their sector, and only communicate to their neighbors. With this approach, when there
            is traffic within the network but not in their sectors the ECUs could still communicate. This is reffer to as <indigo>network 
            segmentation</indigo>.
            <br></br><br></br>
            <brown>Network Segmentation:</brown>
            <br></br><br></br>
            Within the picture above, there is a basic representation of a segmented network, with 2 sectors: Sector A and Sector B. 
            The sender ECU from sector A cannot monitor the traffic within sector B, and in order to avoid jamming other ECUs 
            communicating through sector B, it will communicate with it's neighbor the Gateway ECU, which will receive the Message
            from the sender ECU, it will store it, and once the bus within sector B become available it will redirect the message to 
            receiver ECU from sector B.
            <br></br><br></br>
            This workflow involves PduR, as PduR is the main responsible for routing messages within the network. 
            The PduR has access to all buses through which an node (ECU) is connected. Meaning we could receive a message 
            through LIN and route it further through CAN.
            <br></br><br></br>
            <img class="database_image" src="./website_resources/local/database/pictures/routing_pdu_lin_can.png" alt="routing_pdus_from_lin_to_can"></img>
            <br></br><br></br>
            The PduR can handle payload-dependent routing. This means that the routing decisions can be influenced by the content 
            of the PDU payload, allowing for more intelligent data handling based on the actual data being transmitted.
            <br></br><br></br>
            In many cases, the PduR simply acts as a data forwarder. It receives a PDU on one bus, translates it to the 
            format required by the target bus (if necessary), and forwards it without any modification to the data 
            content. In such scenarios, the Application SW doesn't need to be involved.
            <br></br><br></br>
            But, if the gatewaying process involves specific application logic (e.g., filtering, validation, or encryption),
            the Application 
            SW will be responsible for implementing this logic.
            <br></br><br></br>
            The goal of a gateway is often to make communication between different bus segments appear seamless to the application layer. 
            The PduR handles the technical details of the bus protocol translation and routing, allowing the Application SW to focus on 
            its specific tasks.
            <br></br><br></br>
            <brown>PDU Processing:</brown>
            <br></br><br></br>
            When a PDU is received from an external ECU, the processing flow proceeds as follows:
            <br></br><br></br>
            <indigo>Bus Driver:</indigo> The physical reception of the PDU happens at the lowest level, the Bus Driver. 
            This layer handles the low-level details of the communication bus (CAN, LIN, etc.).
            <br></br><br></br>
            <indigo>Bus Interface (Bus IF):</indigo> The Bus IF layer receives the raw data from the Bus Driver 
            and performs any necessary initial processing, such as error detection and frame extraction.
            <br></br><br></br>
            <indigo>Bus TP (Transport Protocol):</indigo> If a transport protocol is used (e.g., CAN TP for segmented 
            messages), 
            the Bus TP layer reassembles the PDU from potentially fragmented parts.
            <br></br><br></br>
            <indigo>PDU Router (PduR):</indigo> The PduR is the next layer. It receives the complete PDU and determines the 
            destination based on its routing table. This is where routing decisions are made.
            <br></br><br></br>
            <indigo>Communication Manager (ComM):</indigo> If the PDU is destined for an internal SWC, ComM handles the 
            internal transfer of the PDU.
            <br></br><br></br>
            <indigo>RTE (Runtime Environment):</indigo> Finally, the PDU is passed to the RTE, which acts as an intermediary 
            between the AUTOSAR basic software modules and the application software components (SWCs). 
            The RTE delivers the PDU to the appropriate SWC based on the configured communication interfaces. 
            The SWC then processes the received data.
            <br></br><br></br>
            <indigo>Application Software:</indigo> Applies specific application logic (e.g., filtering, validation, or 
            encryption) based on the requirements.
            <br></br><br></br>
            <brown>PduR as PDU Collector</brown>
            <br></br><br></br>
            The PduR is important even if routing/gatewaying would not be implemented because PduR acts as a PDU collector.
            This means all the PDUs received by our ECU regardless of the network (CAN, LIN, Ethernet, Flexray) get collected by 
            PduR and passed to the COM module where they are unpacked into Signals and SignalGroups. 
            <br></br><br></br>
            Similarly, all the signals collected by COM module are packed into PDUs and passed to the PduR, and the PduR based on
            its configuration it decides on which network to sent them.
            <br></br><br></br>
            <img class="database_image" src="./website_resources/local/database/pictures/pdur_as_collector.png" alt="pdur_as_collector"></img>
            <br></br><br></br>
            <brown>PduR in error detection/handling:</brown>
            <br></br><br></br>
             The PduR can detect and/or handle errors related to PDU transmission. For instance: if there's an issue at the 
             interface level, the PduR simply forwards the error to the upper layer without intervention.
             <br></br><br></br>
             The PduR focuses on routing and managing PDUs without getting involved in the error correction process.
             <br></br>
             While the PduR does not handle errors directly, it does pass along the return values from lower layers. This means 
             that any status or error codes generated by the lower layers are communicated to the upper layers through the PduR.
             <br></br><br></br>
             <brown>PduR data validation:</brown>
             <br></br><br></br>
             The PduR primarily validates the format and structure of the PDUs it receives. This means it checks that:
            <enum>The PDU conforms to the expected layout and data types defined in the AUTOSAR configuration.</enum>
            <enum>The PDU contains the correct number of bytes and fields. (No missing or invalid fields and no out-of-bounds values).</enum>
            <enum>The data types within the PDU are consistent with the defined specifications. (No incorrect data types).</enum>
            <br></br>
            The PduR can also perform validation based on the content of the PDU payload. This means that it can:
            <enum>Check if the PDU payload matches certain predefined patterns or conditions.</enum>
            <enum>Use the payload to determine the appropriate routing path for the PDU.</enum>
            <br></br><br></br>
            <indigo>Example of data validation:</indigo>
            <br></br>
            Imagine a PDU that carries information about a vehicle's speed. The PduR would check that:
            <br></br>
            <enum>The PDU is formatted correctly and contains the expected fields for speed data.</enum>
            <enum>The data type for speed is defined as an integer.</enum>
            <enum>The speed value falls within a reasonable range (e.g., not exceeding the maximum speed limit).</enum>
            <br></br>
        </pdur-module>
        <com-module>
            The Communication Module (COM) in AUTOSAR is a fundamental component responsible for packing and unpacking signals 
            into or from Protocol Data Units (PDUs) during transmission and reception. This ensures that data is formatted 
            correctly for communication.
            <br></br><br></br>
            A PDU is a collection/group of signals of different values and different data types. These PDUs are also reffered 
            to as Messages. They act as an abstraction layer that facilitates the transfer of data 
            between different software components. 
            <br></br><br></br>
            PDUs are used to encapsulate data for transmission, allowing for efficient 
            routing and handling of information across various communication protocols.
            <br></br><br></br>
            <indigo>Communication Services:</indigo>
            <br></br>
            The COM module provides essential communication services to other modules, facilitating the exchange of information 
            between different software components within the vehicle. 
            <br></br><br></br>
            <indigo>Filtering Algorithms:</indigo>
            <br></br>
            The COM module supports various ComFilterAlgorithms, which help in filtering messages based on specific criteria, 
            enhancing the efficiency of data transmission.
            <br></br><br></br>
             The COM module is configured with specific filtering settings that define which PDUs are relevant for a 
             particular ECU. These settings can be based on various criteria, such as:
             <br></br>
            <enum>PDU Identifier (ID): The unique identifier of the PDU.</enum>
            <enum>Signal IDs: The specific signals contained within the PDU.</enum>
            <enum>ECU Addresses: The source or destination addresses of the PDU.</enum>
            <enum>Protocol Type: The communication protocol used for the PDU.</enum>
            <br></br>
            When an ECU receives a PDU, the COM module checks its contents against the configured filtering settings.
            <br></br><br></br>
            If the PDU matches the filtering criteria, it is considered relevant and passed on to the appropriate 
            application layer module.
            <br></br><br></br>
            If the PDU does not match the filtering criteria, it is discarded, preventing unnecessary processing 
            and saving valuable resources.
             <br></br><br></br>
             This filtering mechanism ensures that only relevant PDUs are processed by the ECU, improving communication 
             efficiency and reducing the workload on the system. This is particularly important in automotive systems 
             where real-time performance and resource constraints are critical.
            <br></br><br></br>
            
            Example: Imagine a scenario where an ECU is responsible for controlling the engine. The COM module could be 
            configured to filter out all PDUs except those related to engine parameters like speed, temperature, and fuel 
            pressure. This ensures that the ECU only receives and processes data that is relevant to its specific task.
            <br></br><br></br>
            <indigo>Protocol Independence:</indigo>
            <br></br>
            Similar to the PDU Router, the COM module operates in a protocol-independent manner, allowing it to work seamlessly with 
            different communication protocols like CAN, LIN, and Ethernet. This means, regardless of how many Transfer Protocols are
            used / implemented within an ECU, there should be only one PduR module and only one COM module.
            <br></br><br></br>
            <indigo>Configuration Flexibility:</indigo>
            <br></br>
            The COM module can be configured to meet the specific needs of different vehicle architectures, making it adaptable to 
            various communication scenarios.
            <br></br><br></br>
            <indigo>Integration with Other Modules:</indigo>
            <br></br>
            The COM module interacts closely with other AUTOSAR modules, such as the PDU Router and the Network Management module, 
            ensuring a cohesive communication framework.
            <br></br><br></br>
            <img class="database_image" src="./website_resources/local/database/pictures/com_module_operation.png" alt="com_module_operation"></img>
        </com-module>
        <error-detection>
                CAN communication relies on a combination of techniques to ensure reliable data transmission. 
                Stuffing bits, CRC codes, and timing considerations all work together to help the receiver interpret 
                the data accurately, even in challenging communication environments.
                <br></br><br></br>
                <green>Bit Stuffing</green>
                <br></br><br></br>
                Bit Stuffing Process: In CAN communication, if there are five consecutive bits of the same value 
                (either all 0s or all 1s), a stuff bit (the opposite value) is inserted to break the sequence.  
                <br></br>
                This means the receiver does not expect more 5 bits of same value in a row. If it detects such a sequence 
                it will raise an Stuff Error.
                <br></br><br></br>
                Example: A sequence such as: 10111111000 will raise a Stuff error. Because there are 6 bits of 1 in a row.
                <br></br><br></br>
                Without this Stuffing Bit mechanism the receiver will not be sure if the number of bits it read 
                from the communication is exactly the same number of bits sent by the source.
                <br></br><br></br>
                The stuffing bits are part of the Frames but NOT part of the PDUs.
                <br></br>
                
                    <enum><indigo>Frame:</indigo> Contains the raw data, including stuffing bits.<br></br></enum>
                    <enum><indigo>PDU:</indigo> Contains the actual data intended for the receiver, without 
                    the stuffing bits.</enum>
                
                <br></br>
                It's the CanIf's job to decode the information, and turn it back into a PDU, hence removing the 
                stuffing bits.
                <br></br><br></br>
                <brown>Why using Stuffing Bits: </brown>
                <br></br><br></br>
                By using stuffing bits the receiver will not get confused whether he read 5 bits of 1 or he read 4 
                bits of one but the reception was slow.
                <br></br><br></br>
                Let's imagine a sender sending 8 bits, but the communication is slow, and the receiver read the 11 bits. 
                Since the communication was slow, the receiver happened to read the same bit multiple times, because the 
                information was not updated on the bus. 
                <br></br><br></br>
                The receiver will have to figure out how many bits were actually transmitted,
                in order to properly interpret the information. This is done by calculating the variation of the 
                information on the bus. So internally the ECU is counting how many times the voltages have varried.
        </error-detection>
    </manifest>
    
</content>
